/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualStyles;
        (function (visualStyles) {
            function create(dataColors) {
                if (dataColors === undefined)
                    dataColors = new visuals.DataColorPalette();
                return {
                    titleText: {
                        color: { value: 'rgba(51,51,51,1)' }
                    },
                    subTitleText: {
                        color: { value: 'rgba(145,145,145,1)' }
                    },
                    colorPalette: {
                        dataColors: dataColors,
                    },
                    labelText: {
                        color: {
                            value: 'rgba(51,51,51,1)',
                        },
                        fontSize: '11px'
                    },
                    isHighContrast: false,
                };
            }
            visualStyles.create = create;
        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../typedefs/d3/d3.d.ts"/>
///<reference path="../../Data/obj/data.d.ts"/>
///<reference path="../../typedefs/jquery-visible/jquery-visible.d.ts"/>
///<reference path="../../typedefs/jQuery/jQuery.d.ts"/>
///<reference path="../../typedefs/microsoftMaps/Microsoft.Maps.d.ts" />
///<reference path="../../typedefs/moment/moment.d.ts"/>
///<reference path="../../JsCommon/obj/utility.d.ts"/>
///<reference path="../../typedefs/velocity/velocity-animate.d.ts"/>
///<reference path="../../typedefs/lodash/lodash.d.ts"/>
///<reference path="../../typedefs/quill/quill.d.ts"/> 
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AnimatorCommon;
        (function (AnimatorCommon) {
            AnimatorCommon.MinervaAnimationDuration = 250;
        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        /** We just need to have a non-null animator to allow axis animations in cartesianChart .
          * Use this temporarily for Line/Scatter until we add more animations (MinervaPlugins only).
          */
        var NullAnimator = (function () {
            function NullAnimator() {
            }
            NullAnimator.prototype.animate = function (options) {
                return null;
            };
            return NullAnimator;
        })();
        visuals.NullAnimator = NullAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebColumnChartAnimator = (function () {
            function WebColumnChartAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebColumnChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebColumnChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasHighlights = data.hasHighlights;
                shapes.enter().append('rect').attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); }).attr(options.layout.shapeLayoutWithoutHighlights); // Start out at the non-highlight layout
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var endStyleApplied = false;
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                shapes.enter().append('rect').attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected); }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights).each("end", function () {
                    if (!endStyleApplied) {
                        shapes.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                        endStyleApplied = true;
                    }
                }).remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebColumnChartAnimator.prototype.animateDefaultShapes = function (data, series, layout, itemCS) {
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                shapes.enter().append('rect').attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, data.hasHighlights); }).transition().duration(this.animationDuration).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebColumnChartAnimator.prototype.animateDefaultDataLabels = function (options) {
                var dataLabels;
                if (options.viewModel.labelSettings.show) {
                    dataLabels = visuals.ColumnUtil.drawDefaultLabels(options.series, options.labelGraphicsContext, options.labelLayout, options.viewPort, true, this.animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            return WebColumnChartAnimator;
        })();
        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebDonutChartAnimator = (function () {
            function WebDonutChartAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebDonutChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebDonutChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = options.graphicsContext.select('.slices').selectAll('path.slice-highlight').data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter().insert('path').classed('slice-highlight', true).each(function (d) {
                    this._current = d;
                });
                highlightShapes.style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); }).attr(options.layout.shapeLayout).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = this.animateDefaultHighlightShapes(options);
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                var endStylesApplied = false;
                var shapes = options.graphicsContext.select('.slices').selectAll('path.slice').data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter().insert('path').classed('slice', true).each(function (d) {
                    this._current = d;
                });
                // For any slice that is selected we want to keep showing it as dimmed (partially highlighted). After the highlight animation
                // finishes we will set the opacity based on the selection state.
                shapes.style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, d.data.selected, !d.data.selected); }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                var highlightShapes = options.graphicsContext.select('.slices').selectAll('path.slice-highlight').data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter().insert('path').classed('slice-highlight', true).each(function (d) {
                    this._current = d;
                });
                highlightShapes.style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(false, true, false, true); }).transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).each("end", function (d) {
                    if (!endStylesApplied) {
                        shapes.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); });
                        highlightShapes.remove(); // Then remove highlight shapes and set normal shapes to non-highlighted opacities.
                        endStylesApplied = true;
                    }
                });
                highlightShapes.exit().remove();
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateDefaultShapes = function (options) {
                var shapes = options.graphicsContext.select('.slices').selectAll('path.slice').data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter().insert('path').classed('slice', true).each(function (d) {
                    this._current = d;
                });
                shapes.style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, options.viewModel.hasHighlights); }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function (options) {
                var highlightShapes = options.graphicsContext.select('.slices').selectAll('path.slice-highlight').data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter().insert('path').classed('slice-highlight', true).each(function (d) {
                    this._current = d;
                });
                highlightShapes.style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            return WebDonutChartAnimator;
        })();
        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebFunnelAnimator = (function () {
            function WebFunnelAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebFunnelAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebFunnelAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                var shapes = options.shapeGraphicsContext.selectAll('rect').data(data.slices, function (d) { return d.key; });
                shapes.enter().append('rect').attr("class", function (d) { return d.highlight ? "funnelBar highlight" : "funnelBar"; }).attr(layout.shapeLayoutWithoutHighlights); // Start by laying out all rectangles ignoring highlights
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); }).transition().duration(this.animationDuration).attr(layout.shapeLayout); // Then transition to the layout that uses highlights
                shapes.exit().remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                // Simply animate to the new shapes.
                var shapes = this.animateDefaultShapes(data, data.slices, options.shapeGraphicsContext, layout);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToNormal = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                var shapes = options.shapeGraphicsContext.selectAll('rect').data(data.slices, function (d) { return d.key; });
                var endStyleApplied = false;
                shapes.enter().append('rect').attr("class", function (d) { return d.highlight ? "funnelBar highlight" : "funnelBar"; });
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }).transition().duration(this.animationDuration).attr(layout.shapeLayoutWithoutHighlights); // Transition to layout without highlights
                var exitShapes = shapes.exit();
                exitShapes.transition().duration(this.animationDuration).attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights).each("end", function (d, i) {
                    if (!endStyleApplied) {
                        shapes.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                        endStyleApplied = true;
                    }
                }).remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateDefaultAxis = function (graphicsContext, axisOptions) {
                var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio);
                var xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right");
                graphicsContext.classed('axis', true).transition().duration(this.animationDuration).attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
            };
            WebFunnelAnimator.prototype.animateDefaultShapes = function (data, slices, graphicsContext, layout) {
                var hasHighlights = data.hasHighlights;
                var shapes = graphicsContext.selectAll('rect').data(slices, function (d) { return d.key; });
                shapes.enter().append('rect').attr("class", function (d) { return d.highlight ? "funnelBar highlight" : "funnelBar"; });
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }; }).transition().duration(this.animationDuration).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebFunnelAnimator.prototype.animateDefaultDataLabels = function (options) {
                var dataLabels;
                if (options.viewModel.dataLabelsSettings.show) {
                    dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(options.slicesWithoutHighlights, options.labelGraphicsContext, options.labelLayout, true, this.animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            return WebFunnelAnimator;
        })();
        visuals.WebFunnelAnimator = WebFunnelAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebTreemapAnimator = (function () {
            function WebTreemapAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebTreemapAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                    labels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebTreemapAnimator.prototype.animateNormalToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights);
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect').attr('class', visuals.Treemap.layout.highlightShapeClass).attr(visuals.Treemap.layout.shapeLayout); // Start using the normal shape layout
                highlightShapes.style("fill", function (d) { return visuals.Treemap.getFill(d, true); }).style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, true); }).transition().duration(this.animationDuration).attr(visuals.Treemap.layout.highlightShapeLayout); // Animate to the highlighted positions
                highlightShapes.exit().remove();
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights);
                options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights);
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                var shapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.TreemapNodeClassName).data(options.nodes, function (d) { return d.key; });
                shapes.enter().append('rect').attr('class', visuals.Treemap.layout.shapeClass);
                shapes.transition().duration(this.animationDuration).style("fill", function (d) { return visuals.Treemap.getFill(d, false); }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, d.selected, !d.selected); }).attr(visuals.Treemap.layout.shapeLayout);
                shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName).data(options.nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect').attr('class', visuals.Treemap.layout.highlightShapeClass);
                highlightShapes.style("fill", function (d) { return visuals.Treemap.getFill(d, true); }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, true, d.selected, !d.selected); }).transition().duration(this.animationDuration).attr(hasSelection ? visuals.Treemap.layout.zeroShapeLayout : visuals.Treemap.layout.shapeLayout).each("end", function (d, i) {
                    if (i === 0) {
                        shapes.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                        highlightShapes.remove(); // Then remove highlight shapes and set normal shapes to non-highlighted opacities.
                    }
                });
                highlightShapes.exit().remove();
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebTreemapAnimator.prototype.animateDefaultShapes = function (context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + visuals.Treemap.TreemapNodeClassName).data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect').attr('class', visuals.Treemap.layout.shapeClass);
                shapes.transition().duration(this.animationDuration).style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); }).style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); }).attr(visuals.Treemap.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + visuals.Treemap.HighlightNodeClassName).data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect').attr('class', visuals.Treemap.layout.highlightShapeClass);
                highlightShapes.transition().duration(this.animationDuration).style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); }).style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); }).attr(visuals.Treemap.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            WebTreemapAnimator.prototype.animateDefaultLabels = function (context, nodes) {
                var labels = context.selectAll('text').data(nodes, function (d) { return d.key; });
                labels.enter().append('text').attr('class', visuals.Treemap.layout.labelClass);
                labels.transition().duration(this.animationDuration).attr(visuals.Treemap.layout.labelLayout).text(visuals.Treemap.layout.labelText);
                labels.exit().remove();
                return labels;
            };
            return WebTreemapAnimator;
        })();
        visuals.WebTreemapAnimator = WebTreemapAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ColumnChartWebBehavior = (function () {
            function ColumnChartWebBehavior() {
            }
            ColumnChartWebBehavior.prototype.select = function (hasSelection, selection, labels, hasHighlights) {
                selection.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
                visuals.dataLabelUtils.setHighlightedLabelsOpacity(labels, hasSelection, hasHighlights);
            };
            return ColumnChartWebBehavior;
        })();
        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataDotChartWebBehavior = (function () {
            function DataDotChartWebBehavior() {
            }
            DataDotChartWebBehavior.prototype.select = function (hasSelection, selection) {
                selection.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return DataDotChartWebBehavior;
        })();
        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DonutChartWebBehavior = (function () {
            function DonutChartWebBehavior(options) {
                this.allowDrilldown = options.allowDrilldown;
                this.visual = options.visual;
                this.svg = options.clearCatcher;
                this.isDrilled = false;
            }
            DonutChartWebBehavior.prototype.select = function (hasSelection, selection, highlighted, hasHighlights, data) {
                if (hasSelection && this.allowDrilldown) {
                    // If we are not already drilled down then drill down into this data
                    var dataToShow = !this.isDrilled ? data : undefined;
                    this.visual.setDrilldown(dataToShow);
                    this.isDrilled = !this.isDrilled;
                }
                else {
                    selection.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, highlighted, !highlighted && hasSelection, !d.data.selected && hasHighlights); });
                }
            };
            DonutChartWebBehavior.prototype.mouseOver = function (data) {
                this.setDataLabelStyle(data, false);
            };
            DonutChartWebBehavior.prototype.mouseOut = function (data) {
                this.setDataLabelStyle(data, true);
            };
            DonutChartWebBehavior.prototype.setDataLabelStyle = function (data, dimmed) {
                var text = this.svg.selectAll('text').filter(function (d) { return d.data.identity.getKey() === data.identity.getKey(); });
                var polyline = this.svg.selectAll('polyline').filter(function (d) { return d.data.identity.getKey() === data.identity.getKey(); });
                // Hide the label if it is dimmed and overlapping another slice label
                text.style('opacity', function (d) { return (dimmed && d.data.isLabelOverlapping) ? 0 : 1; });
                polyline.style('opacity', function (d) { return (dimmed && d.data.isLabelOverlapping) ? 0 : visuals.DonutChart.PolylineOpacity; });
            };
            return DonutChartWebBehavior;
        })();
        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var FunnelWebBehavior = (function () {
            function FunnelWebBehavior() {
            }
            FunnelWebBehavior.prototype.select = function (hasSelection, selection, hasHighlights) {
                selection.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
            };
            return FunnelWebBehavior;
        })();
        visuals.FunnelWebBehavior = FunnelWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LineChartWebBehavior = (function () {
            function LineChartWebBehavior() {
            }
            LineChartWebBehavior.prototype.select = function (hasSelection, lines, dots, areas) {
                lines.style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                if (areas)
                    areas.style("fill-opacity", function (d) { return (hasSelection && !d.selected) ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity; });
            };
            return LineChartWebBehavior;
        })();
        visuals.LineChartWebBehavior = LineChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MapBehavior = (function () {
            function MapBehavior() {
            }
            MapBehavior.prototype.select = function (hasSelection, bubbles, slices, shapes) {
                if (bubbles) {
                    bubbles.style({
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        'stroke-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
                if (slices) {
                    slices.style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                    });
                }
                if (shapes) {
                    shapes.style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
            };
            return MapBehavior;
        })();
        visuals.MapBehavior = MapBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        (function (DragType) {
            DragType[DragType["Drag"] = 0] = "Drag";
            DragType[DragType["DragEnd"] = 1] = "DragEnd";
        })(visuals.DragType || (visuals.DragType = {}));
        var DragType = visuals.DragType;
        var ScatterChartWebBehavior = (function () {
            function ScatterChartWebBehavior() {
            }
            ScatterChartWebBehavior.prototype.select = function (hasSelection, datapoints) {
                datapoints.style("fill-opacity", function (d) { return d.size != null ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0; });
                datapoints.style("stroke-opacity", function (d) { return visuals.ScatterChart.getBubbleOpacity(d, hasSelection); });
            };
            return ScatterChartWebBehavior;
        })();
        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
        var ScatterChartMobileBehavior = (function () {
            function ScatterChartMobileBehavior() {
            }
            ScatterChartMobileBehavior.prototype.setOptions = function (options) {
                this.data = options.data;
                this.mainGraphicsContext = options.mainContext;
                this.xAxisProperties = options.xAxisProperties;
                this.yAxisProperties = options.yAxisProperties;
                this.host = options.host;
            };
            ScatterChartMobileBehavior.prototype.select = function (hasSelection, datapoints, dataPoint, index) {
                this.selectDotByIndex(index);
            };
            ScatterChartMobileBehavior.prototype.selectRoot = function () {
                var marker = jsCommon.PerformanceUtil.create('selectRoot');
                this.onClick();
                marker.end();
            };
            ScatterChartMobileBehavior.prototype.drag = function (t) {
                switch (t) {
                    case 0 /* Drag */:
                        this.onDrag();
                        break;
                    case 1 /* DragEnd */:
                        this.onClick();
                        break;
                    default:
                        debug.assertFail('Unknown Drag Type');
                }
            };
            ScatterChartMobileBehavior.prototype.onDrag = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                //move the crosshair to the current position
                this.moveCrosshairToXY(xy.x, xy.y);
                //update the style and the legend of the dots
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDot(selectedIndex);
                this.updateLegend(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.onClick = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDotByIndex(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.getMouseCoordinates = function () {
                var mainGfxContext = this.mainGraphicsContext;
                // select (0,0) in cartesian coordinates
                var x = 0;
                var y = parseInt(mainGfxContext.attr('height'), 10);
                y = y || 0;
                try {
                    var mouse = d3.mouse(mainGfxContext.node());
                    x = mouse[0];
                    y = mouse[1];
                }
                catch (e) {
                }
                return { x: x, y: y, };
            };
            ScatterChartMobileBehavior.prototype.selectDotByIndex = function (index) {
                this.selectDot(index);
                this.moveCrosshairToIndexDot(index);
                this.updateLegend(index);
            };
            ScatterChartMobileBehavior.prototype.selectDot = function (dotIndex) {
                var _this = this;
                var root = this.mainGraphicsContext;
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({ selected: false, notSelected: true });
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function (d, i) {
                    var dataPoints = _this.data.dataPoints;
                    debug.assert(dataPoints.length > dotIndex, "dataPoints length:" + dataPoints.length + "is smaller than index:" + dotIndex);
                    var currentPoint = dataPoints[dotIndex];
                    return (d.x === currentPoint.x) && (d.y === currentPoint.y);
                }).classed({ selected: true, notSelected: false });
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function (index) {
                var dataPoints = this.data.dataPoints;
                var root = this.mainGraphicsContext;
                debug.assert(dataPoints.length > index, "dataPoints length:" + dataPoints.length + "is smaller than index:" + index);
                var x = this.xAxisProperties.scale(dataPoints[index].x);
                var y = this.yAxisProperties.scale(dataPoints[index].y);
                if (this.crosshair == null) {
                    var width = +root.attr('width');
                    var height = +root.attr('height');
                    this.crosshair = this.drawCrosshair(root, x, y, width, height);
                    this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector);
                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                }
                else {
                    this.moveCrosshairToXY(x, y);
                }
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function (x, y) {
                this.crosshairHorizontal.attr({ y1: y, y2: y });
                this.crosshairVertical.attr({ x1: x, x2: x });
            };
            ScatterChartMobileBehavior.prototype.drawCrosshair = function (addTo, x, y, width, height) {
                var crosshair = addTo.append("g");
                crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, true);
                crosshair.append('line').classed(ScatterChartMobileBehavior.Horizontal.class, true).attr({ x1: 0, x2: width, y1: y, y2: y });
                crosshair.append('line').classed(ScatterChartMobileBehavior.Vertical.class, true).attr({ x1: x, x2: x, y1: height, y2: 0 });
                return crosshair;
            };
            ScatterChartMobileBehavior.prototype.findClosestDotIndex = function (x, y) {
                var selectedIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var dataPoints = this.data.dataPoints;
                var xAxisPropertiesScale = this.xAxisProperties.scale;
                var yAxisPropertiesScale = this.yAxisProperties.scale;
                for (var i in dataPoints) {
                    var currentPoint = dataPoints[i];
                    var circleX = xAxisPropertiesScale(currentPoint.x);
                    var circleY = yAxisPropertiesScale(currentPoint.y);
                    var horizontalDistance = circleX - x;
                    var verticalDistance = circleY - y;
                    var distanceSqrd = (horizontalDistance * horizontalDistance) + (verticalDistance * verticalDistance);
                    if (minDistance === Number.MAX_VALUE) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                    else if (minDistance && minDistance > distanceSqrd) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                }
                return selectedIndex;
            };
            ScatterChartMobileBehavior.prototype.updateLegend = function (dotIndex) {
                if (this.lastDotIndex == null || this.lastDotIndex !== dotIndex) {
                    var legendItems = this.createLegendDataPoints(dotIndex);
                    this.host.updateLegend(legendItems);
                    this.lastDotIndex = dotIndex;
                }
            };
            ScatterChartMobileBehavior.prototype.createLegendDataPoints = function (dotIndex) {
                var formatStringProp = visuals.scatterChartProps.general.formatString;
                var legendItems = [];
                var data = this.data;
                debug.assert(data.dataPoints.length > dotIndex, "dataPoints length:" + data.dataPoints.length + "is smaller than index:" + dotIndex);
                var point = data.dataPoints[dotIndex];
                //set the title of the legend to be the category or radius or group or blank
                var blank = visuals.valueFormatter.format(null);
                var title = blank;
                var legendData = data.legendData;
                debug.assertValue(legendData, "legendData");
                debug.assertValue(legendData.dataPoints, "legendData");
                var legendDataPoints = legendData.dataPoints;
                if (point.category !== blank) {
                    title = point.category;
                }
                else if (point.radius.sizeMeasure != null) {
                    title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
                }
                else if (legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank) {
                    title = legendDataPoints[dotIndex].label;
                }
                if (data.xCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0 /* Box */,
                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                if (data.yCol !== undefined && data.yCol !== null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0 /* Box */,
                        label: visuals.valueFormatter.format(data.axesLabels.y),
                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                if (data.size !== undefined && data.size !== null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0 /* Box */,
                        label: visuals.valueFormatter.format(data.size.displayName),
                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                return { dataPoints: legendItems };
            };
            ScatterChartMobileBehavior.CrosshairClassName = 'crosshair';
            ScatterChartMobileBehavior.ScatterChartCircleTagName = 'circle';
            ScatterChartMobileBehavior.DotClassName = 'dot';
            ScatterChartMobileBehavior.DotClassSelector = '.' + ScatterChartMobileBehavior.DotClassName;
            ScatterChartMobileBehavior.Horizontal = {
                class: 'horizontal',
                selector: '.horizontal'
            };
            ScatterChartMobileBehavior.Vertical = {
                class: 'vertical',
                selector: '.vertical'
            };
            return ScatterChartMobileBehavior;
        })();
        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SlicerWebBehavior = (function () {
            function SlicerWebBehavior() {
            }
            SlicerWebBehavior.prototype.select = function (selectionLabels) {
                selectionLabels.style({
                    'color': function (d) {
                        if (d.selected)
                            return visuals.Slicer.DefaultStyleProperties.slicerText.selectionColor;
                        else
                            return visuals.Slicer.DefaultStyleProperties.slicerText.color;
                    }
                });
            };
            SlicerWebBehavior.prototype.mouseInteractions = function (selectionLabels) {
                selectionLabels.style({
                    'color': function (d) {
                        if (d.mouseOver)
                            return visuals.Slicer.DefaultStyleProperties.slicerText.hoverColor;
                        if (d.mouseOut) {
                            if (d.selected)
                                return visuals.Slicer.DefaultStyleProperties.slicerText.selectionColor;
                            else
                                return visuals.Slicer.DefaultStyleProperties.slicerText.color;
                        }
                    }
                });
            };
            SlicerWebBehavior.prototype.clearSlicers = function (selectionLabels, slicerItemInputs) {
                slicerItemInputs.selectAll('input').property('checked', false);
                selectionLabels.style('color', visuals.Slicer.DefaultStyleProperties.slicerText.color);
            };
            return SlicerWebBehavior;
        })();
        visuals.SlicerWebBehavior = SlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LegendWebBehavior = (function () {
            function LegendWebBehavior() {
            }
            LegendWebBehavior.prototype.select = function (hasSelection, legendIcons) {
                if (hasSelection) {
                    legendIcons.style({
                        'fill': function (d) {
                            if (!d.selected)
                                return LegendWebBehavior.selectedLegendColor;
                            else
                                return d.color;
                        }
                    });
                }
                else {
                    legendIcons.style({
                        'fill': function (d) {
                            return d.color;
                        }
                    });
                }
            };
            LegendWebBehavior.selectedLegendColor = '#A6A6A6';
            return LegendWebBehavior;
        })();
        visuals.LegendWebBehavior = LegendWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TreemapWebBehavior = (function () {
            function TreemapWebBehavior() {
            }
            TreemapWebBehavior.prototype.select = function (hasSelection, datapoints, hasHighlights) {
                datapoints.style("fill", function (d) { return visuals.Treemap.getFill(d, false); }).style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, false); });
            };
            return TreemapWebBehavior;
        })();
        visuals.TreemapWebBehavior = TreemapWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WaterfallChartWebBehavior = (function () {
            function WaterfallChartWebBehavior() {
            }
            WaterfallChartWebBehavior.prototype.select = function (hasSelection, selection) {
                selection.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return WaterfallChartWebBehavior;
        })();
        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        // default ranges are for when we have a field chosen for the axis, but no values are returned by the query
        var fallBackDomain = [0, 10];
        var fallbackDateDomain = [new Date(2014, 1, 1).getTime(), new Date(2015, 1, 1).getTime()];
        var AxisHelper;
        (function (AxisHelper) {
            var XLabelOffsetForOrdinal = 25;
            var XLabelOffsetForNonOrdinal = 10;
            var TextHeightConstant = 10;
            var MinTickCount = 2;
            var DefaultBestTickCount = 3;
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                if (availableWidth < 250)
                    return 3;
                return 6;
            }
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                if (availableWidth < 150)
                    return 3;
                return 6;
            }
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
            /** Get the best number of ticks based on minimum value, maximum value, measure metadata and max tick count.
              * @min - The minimum of the data domain.
              * @max - The maximum of the data domain.
              * @valuesMetadata - The measure metadata array.
              * @maxTickCount - The max count of intervals.
              * @is100Pct - Whether this is 100 percent chart.
              */
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
                if (isNaN(min) || isNaN(max))
                    return DefaultBestTickCount;
                debug.assert(min <= max, "min value needs to be less or equal to max value");
                if (maxTickCount <= 1 || (max <= 1 && min >= -1))
                    return maxTickCount;
                if (min === max) {
                    // datetime needs to only show one tick value in this case so formatting works correctly
                    if (!!isDateTime)
                        return 1;
                    return DefaultBestTickCount;
                }
                if (hasNonIntegerData(valuesMetadata))
                    return maxTickCount;
                // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
                return Math.min(max - min + 1, maxTickCount);
            }
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
                        return true;
                    }
                }
                return false;
            }
            AxisHelper.hasNonIntegerData = hasNonIntegerData;
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar) {
                if (!isScalar || isOrdinalScale(scale)) {
                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
                }
                else if (isDateTime(axisType)) {
                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
                }
                return getRecommendedTickValuesForALinearRange(maxTicks, scale);
            }
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                // return no ticks in this case
                if (maxTicks <= 0)
                    return tickLabels;
                var len = labels.length;
                if (maxTicks > len)
                    return labels;
                for (var i = 0, step = Math.floor(len / maxTicks); i < len; i += step) {
                    tickLabels.push(labels[i]);
                }
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
            function getRecommendedTickValuesForALinearRange(maxTicks, scale) {
                var tickLabels = [];
                //if maxticks is zero return none
                if (maxTicks === 0)
                    return tickLabels;
                var linearScale = scale;
                if (linearScale.ticks) {
                    tickLabels = linearScale.ticks(maxTicks);
                    if (tickLabels.length > maxTicks && maxTicks > 1)
                        tickLabels = linearScale.ticks(maxTicks - 1);
                    if (tickLabels.length < MinTickCount) {
                        tickLabels = linearScale.ticks(maxTicks + 1);
                    }
                    return tickLabels;
                }
                debug.assertFail('must pass a linear scale to this method');
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForALinearRange = getRecommendedTickValuesForALinearRange;
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                tickLabels = dateTimeTickLabels.map(function (d) { return d.getTime(); });
                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                return tickLabels;
            }
            function normalizeLinearDomain(domain) {
                if (isNaN(domain.min) || isNaN(domain.max)) {
                    domain.min = fallBackDomain[0];
                    domain.max = fallBackDomain[1];
                }
                else if (domain.min === 0 && domain.max === 0) {
                    domain.max = fallBackDomain[1]; // default
                }
                else if (domain.min === domain.max) {
                    // d3 linear scale will give zero tickValues if max === min, so extend a little
                    domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
                    domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
                }
                else {
                    // Check that min is very small and is a negligable portion of the whole domain.
                    // (fix floating pt precision bugs)
                    // sometimes highlight value math causes small negative numbers which makes the axis add
                    // a large tick interval instead of just rendering at zero.
                    if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
                        domain.min = 0;
                    }
                }
                return domain;
            }
            AxisHelper.normalizeLinearDomain = normalizeLinearDomain;
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0 || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
                    return {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    };
                }
                return {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            AxisHelper.getMargin = getMargin;
            function getTickLabelMargins(//todo: Put the parameters into one object
                viewport, leftMarginLimit, textMeasurer, xAxisProperties, y1AxisProperties, rotateX, maxHeight, properties, y2AxisProperties, scrollbarVisible, showOnRight, renderXAxis, renderYAxes, renderY2Axis) {
                debug.assertValue(viewport, 'viewport');
                debug.assertValue(textMeasurer, 'textMeasurer');
                debug.assertValue(xAxisProperties, 'xAxis');
                debug.assertValue(y1AxisProperties, 'yAxis');
                var xLabels = xAxisProperties.values;
                var yLeftLabels = y1AxisProperties.values;
                var xAxisType = xAxisProperties.axisType;
                var maxLeft = 0;
                var maxRight = 0;
                var xMax = 0;
                var labelOffset = isOrdinal(xAxisType) ? XLabelOffsetForOrdinal : XLabelOffsetForNonOrdinal;
                var xLabelPadding = 0;
                if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                if (getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0 || getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
                    var rotation;
                    if (scrollbarVisible)
                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        rotation = LabelLayoutStrategy.DefaultRotation;
                    for (var i = 0, len = yLeftLabels.length; i < len; i++) {
                        properties.text = yLeftLabels[i];
                        maxLeft = Math.max(maxLeft, textMeasurer(properties));
                    }
                    if (y2AxisProperties) {
                        var yRightLabels = y2AxisProperties.values;
                        for (var i = 0, len = yRightLabels.length; i < len; i++) {
                            properties.text = yRightLabels[i];
                            maxRight = Math.max(maxRight, textMeasurer(properties));
                        }
                    }
                    for (var i = 0, len = xLabels.length; i < len; i++) {
                        var height;
                        properties.text = xLabels[i];
                        var size = textMeasurer(properties);
                        if (rotateX) {
                            height = size * rotation.sine;
                        }
                        else {
                            height = TextHeightConstant;
                            // Account for wide X label
                            if (i === 0) {
                                var width = (size / 2) - labelOffset - xLabelPadding;
                                maxLeft = Math.max(maxLeft, width);
                            }
                            else if (i === len - 1) {
                                var width = (size / 2);
                                maxRight = Math.max(maxRight, width);
                            }
                        }
                        xMax = Math.max(xMax, height);
                    }
                    ;
                }
                if (showOnRight) {
                    var temp = maxLeft;
                    maxLeft = maxRight;
                    maxRight = temp;
                }
                var calulatedMargins = {
                    xMax: Math.min(maxHeight, Math.ceil(xMax)),
                    yLeft: Math.min(Math.ceil(maxLeft), leftMarginLimit),
                    yRight: Math.ceil(maxRight),
                };
                //*******Adjust the axes based on if it's turn on or not
                if (!renderYAxes) {
                    calulatedMargins.yLeft = 0;
                    calulatedMargins.yRight = 0;
                }
                if (!renderY2Axis && showOnRight) {
                    calulatedMargins.yLeft = 0;
                }
                if (!renderY2Axis && !showOnRight) {
                    calulatedMargins.yRight = 0;
                }
                if (!renderXAxis) {
                    calulatedMargins.xMax = 0;
                }
                //*******
                return calulatedMargins;
            }
            AxisHelper.getTickLabelMargins = getTickLabelMargins;
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.createOrdinalType = createOrdinalType;
            function isOrdinal(type) {
                return !!(type && (type.text || type.bool));
            }
            AxisHelper.isOrdinal = isOrdinal;
            function isOrdinalScale(scale) {
                return typeof scale.invert === 'undefined';
            }
            AxisHelper.isOrdinalScale = isOrdinalScale;
            function isDateTime(type) {
                return !!(type && type.dateTime);
            }
            AxisHelper.isDateTime = isDateTime;
            function invertScale(scale, x) {
                if (isOrdinalScale(scale)) {
                    return invertOrdinalScale(scale, x);
                }
                return scale.invert(x);
            }
            AxisHelper.invertScale = invertScale;
            function extent(scale) {
                if (isOrdinalScale(scale)) {
                    return scale.rangeExtent();
                }
                return scale.range();
            }
            AxisHelper.extent = extent;
            function invertOrdinalScale(scale, x) {
                var leftEdges = scale.range();
                var width = scale.rangeBand();
                var j;
                for (j = 0; x > (leftEdges[j] + width) && (leftEdges.length - 1) > j; j++)
                    ;
                return scale.domain()[j];
            }
            AxisHelper.invertOrdinalScale = invertOrdinalScale;
            function getOrdinalScaleClosestDataPointIndex(scale, x) {
                var index = 0;
                var range = scale.range();
                var distance = Math.abs(x - range[0]);
                for (var j = 1; j < range.length; j++) {
                    var currentDistance = Math.abs(x - range[j]);
                    if (distance > currentDistance) {
                        distance = currentDistance;
                        index = j;
                    }
                }
                return index;
            }
            AxisHelper.getOrdinalScaleClosestDataPointIndex = getOrdinalScaleClosestDataPointIndex;
            function diffScaled(scale, value1, value2) {
                debug.assertValue(scale, 'scale');
                var value = scale(value1) - scale(value2);
                if (value === 0)
                    return 0;
                if (value < 0)
                    return Math.min(value, -1);
                return Math.max(value, 1);
            }
            AxisHelper.diffScaled = diffScaled;
            function createDomain(data, axisType, isScalar, forcedScalarDomain) {
                var userMin, userMax;
                if (forcedScalarDomain && forcedScalarDomain.length === 2) {
                    userMin = forcedScalarDomain[0];
                    userMax = forcedScalarDomain[1];
                }
                if (isScalar && !isOrdinal(axisType))
                    return createScalarDomain(data, userMin, userMax, axisType);
                return createOrdinalDomain(data);
            }
            AxisHelper.createDomain = createDomain;
            function ensureValuesInRange(values, min, max) {
                debug.assert(min <= max, "min must be less or equal to max");
                var filteredValues = values.filter(function (v) { return v >= min && v <= max; });
                if (filteredValues.length < 2)
                    filteredValues = [min, max];
                return filteredValues;
            }
            AxisHelper.ensureValuesInRange = ensureValuesInRange;
            /** Gets the ValueType of a category column, defaults to Text if the type is not present. */
            function getCategoryValueType(metadataColumn) {
                return metadataColumn && columnDataTypeHasValue(metadataColumn.type) ? metadataColumn.type : powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.getCategoryValueType = getCategoryValueType;
            /**
             * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
             * @param {CreateAxisOptions} options the properties used to create the axis
             */
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;
                var formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp);
                var dataType = this.getCategoryValueType(metaDataColumn);
                // Create the Scale
                var scaleResult = this.createScale(options);
                var scale = scaleResult.scale;
                var bestTickCount = scaleResult.bestTickCount;
                var scaleDomain = scale.domain();
                // fix categoryThickness if scalar and the domain was adjusted
                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
                    var oldSpan = dataDomain[1] - dataDomain[0];
                    var newSpan = scaleDomain[1] - scaleDomain[0];
                    if (oldSpan > 0 && newSpan > 0) {
                        categoryThickness = categoryThickness * oldSpan / newSpan;
                    }
                }
                // Prepare Tick Values for formatting
                var tickValues;
                if (isScalar && bestTickCount === 1) {
                    tickValues = [dataDomain[0]];
                }
                else {
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar);
                }
                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);
                // sets default orientation only, cartesianChart will fix y2 for comboChart
                // tickSize(pixelSpan) is used to create gridLines
                var axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? 'left' : 'bottom').ticks(bestTickCount).tickValues(tickValues);
                var formattedTickValues = [];
                if (metaDataColumn)
                    formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);
                // Use category layout of labels if specified, otherwise use scalar layout of labels
                if (!isScalar && categoryThickness) {
                    xLabelMaxWidth = categoryThickness;
                }
                else {
                    // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan       
                    // When there is > 1 ticks then we need to +1 so that their widths don't overlap
                    // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.
                    var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                    var xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;
                }
                return {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: null,
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding,
                };
            }
            AxisHelper.createAxis = createAxis;
            function createScale(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness;
                var dataType = this.getCategoryValueType(metaDataColumn);
                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                var scalarDomain = dataDomain.slice();
                var bestTickCount = maxTicks;
                var scale;
                // using double-equals null intentionally, also checks undefined.
                if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null)) {
                    dataDomain = fallBackDomain;
                    dataType = powerbi.ValueType.fromDescriptor({ numeric: true });
                    scale = createLinearScale(pixelSpan, dataDomain, outerPadding, bestTickCount);
                }
                else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = forcedTickCount !== undefined ? (maxTicks !== 0 ? forcedTickCount : 0) : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [metaDataColumn], maxTicks, dataType.dateTime);
                        var normalizedRange = AxisHelper.normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] });
                        scalarDomain = [normalizedRange.min, normalizedRange.max];
                    }
                    if (isScalar && dataType.numeric && !dataType.dateTime) {
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, bestTickCount);
                    }
                    else if (isScalar && dataType.dateTime) {
                        // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
                        // to control the formatting of the time values, since d3's implementation isn't
                        // in accordance to our design.
                        //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null); // DO NOT PASS TICKCOUNT
                    }
                    else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                        bestTickCount = maxTicks === 0 ? 0 : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianChart.MinOrdinalRectThickness);
                    }
                    else {
                        debug.assertFail('unsupported dataType, something other than text or numeric');
                    }
                }
                // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
                if (isVertical && isScalar) {
                    scale.range(scale.range().reverse());
                }
                visuals.ColumnUtil.normalizeInfinityInScale(scale);
                return {
                    scale: scale,
                    bestTickCount: bestTickCount,
                };
            }
            AxisHelper.createScale = createScale;
            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
                var formatter;
                if (dataType.dateTime) {
                    if (isScalar) {
                        var value = new Date(scaleDomain[0]);
                        var value2 = new Date(scaleDomain[1]);
                        // datetime with only one value needs to pass the same value
                        // (from the original dataDomain value, not the adjusted scaleDomain)
                        // so formatting works correctly.
                        if (bestTickCount === 1)
                            value = value2 = new Date(dataDomain[0]);
                        formatter = visuals.valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });
                    }
                    else {
                        if (getValueFn == null) {
                            debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');
                        }
                        var minDate = getValueFn(0, dataType);
                        var maxDate = getValueFn(scaleDomain.length - 1, dataType);
                        formatter = visuals.valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });
                    }
                }
                else {
                    if (getValueFn == null && !isScalar) {
                        debug.assertFail('getValueFn must be supplied for ordinal tickValues');
                    }
                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var domainMin = tickValues[tickValues.length - 1] - tickValues[0];
                        var domainMax = 0; //force tickInterval to be used with display units
                        formatter = visuals.valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });
                    }
                    else {
                        // do not use display units, just the basic value formatter
                        // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                return formatter;
            }
            // format the linear tick labels or the category labels
            function formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                var formattedTickValues = [];
                if (formatter) {
                    // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.
                    if (getValueFn && !(dataType.numeric && isScalar)) {
                        axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
                        formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
                    }
                    else {
                        axis.tickFormat(function (d) { return formatter.format(d); });
                        formattedTickValues = tickValues.map(function (d) { return formatter.format(d); });
                    }
                }
                else {
                    formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
                }
                return formattedTickValues;
            }
            AxisHelper.formatAxisTickValues = formatAxisTickValues;
            function createScalarDomain(data, userMin, userMax, axisType) {
                debug.assertValue(data, 'data');
                if (data.length === 0) {
                    if (axisType.dateTime)
                        return fallbackDateDomain;
                    else
                        return fallBackDomain;
                }
                var defaultMinX = d3.min(data, function (kv) {
                    return d3.min(kv.data, function (d) {
                        return d.categoryValue;
                    });
                });
                var defaultMaxX = d3.max(data, function (kv) {
                    return d3.max(kv.data, function (d) {
                        return d.categoryValue;
                    });
                });
                var minX, maxX;
                if (typeof userMin === 'number') {
                    minX = userMin;
                }
                else {
                    minX = defaultMinX;
                }
                if (typeof userMax === 'number') {
                    maxX = userMax;
                }
                else {
                    maxX = defaultMaxX;
                }
                //edge case
                if (minX > maxX) {
                    //take the default, only adjust when it makes sense
                    minX = defaultMinX;
                    maxX = defaultMaxX;
                }
                return [minX, maxX];
            }
            /**
             * createValueDomain - creates a [min,max] from your Cartiesian data values
             * @param {CartesianSeries[]} data the series array of CartesianDataPoints
             * @param {boolean} includeZero columns and bars includeZero, line and scatter do not.
             */
            function createValueDomain(data, includeZero) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return fallBackDomain;
                var minY = d3.min(data, function (kv) {
                    return d3.min(kv.data, function (d) {
                        return d.value;
                    });
                });
                var maxY = d3.max(data, function (kv) {
                    return d3.max(kv.data, function (d) {
                        return d.value;
                    });
                });
                if (includeZero)
                    return [Math.min(minY, 0), Math.max(maxY, 0)];
                return [minY, maxY];
            }
            AxisHelper.createValueDomain = createValueDomain;
            function createOrdinalDomain(data) {
                if (ArrayExtensions.isUndefinedOrEmpty(data))
                    return [];
                return data[0].data.map(function (d) { return d.categoryIndex; });
            }
            var LabelLayoutStrategy;
            (function (LabelLayoutStrategy) {
                function willRotate(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (labels.length === 0)
                        return false;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined ? axisProperties.xLabelMaxWidth : availableWidth / labels.length;
                    return labels.some(function (d) {
                        properties.text = d;
                        return textMeasurer(properties) > labelMaxWidth;
                    });
                }
                LabelLayoutStrategy.willRotate = willRotate;
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: 'rotate(-35)',
                    dy: '-0.5em',
                };
                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(Math.PI * (90 / 180)),
                    cosine: Math.cos(Math.PI * (90 / 180)),
                    tangent: Math.tan(Math.PI * (90 / 180)),
                    transform: 'rotate(-90)',
                    dy: '-0.8em',
                };
                function rotate(text, availableWidth, maxBottomMargin, svgEllipsis, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var rotatedLength;
                    var defaultRotation;
                    if (scrollbarVisible)
                        defaultRotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        defaultRotation = LabelLayoutStrategy.DefaultRotation;
                    if (needRotate) {
                        rotatedLength = maxBottomMargin / defaultRotation.sine;
                    }
                    text.each(function () {
                        var text = d3.select(this);
                        if (needRotate) {
                            var textContentIndex = axisProperties.values.indexOf(this.textContent);
                            var allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (textContentIndex + 0.5);
                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                            if (needEllipsis || (allowedLength < rotatedLength)) {
                                svgEllipsis(text[0][0], Math.min(allowedLength, rotatedLength));
                            }
                            text.style('text-anchor', 'end').attr({
                                'dx': '-0.5em',
                                'dy': defaultRotation.dy,
                                'transform': defaultRotation.transform
                            });
                        }
                        else {
                            text.style('text-anchor', 'middle').attr({
                                'dx': '0em',
                                'dy': '1em',
                                'transform': 'rotate(0)'
                            });
                        }
                    });
                }
                LabelLayoutStrategy.rotate = rotate;
                function clip(text, availableWidth, svgEllipsis) {
                    if (text.size() === 0)
                        return;
                    text.each(function () {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    });
                }
                LabelLayoutStrategy.clip = clip;
            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
            var ToolTip;
            (function (ToolTip) {
                var calloutHtml = '<div class="callout triangle-border ms-font-mi">' + '<div class="textArea"/>' + '</div>';
                function createCallout() {
                    return $(calloutHtml);
                }
                ToolTip.createCallout = createCallout;
                function clearCallout(callout) {
                    callout.find('.destroyme').remove();
                }
                ToolTip.clearCallout = clearCallout;
                function renderCallout(callout, x, rangeEnd, leftMargin) {
                    var calloutBleed = 0;
                    var calloutWidth = callout.width();
                    var calloutHalfWidth = calloutWidth / 2;
                    var xOffset = (leftMargin - calloutHalfWidth) - 10;
                    var innerTriangleOffset = 2;
                    var left;
                    var triangleLeftBefore;
                    var triangleLeftAfter;
                    if (x + (calloutHalfWidth - calloutBleed) > rangeEnd) {
                        left = (rangeEnd + xOffset - (calloutHalfWidth - calloutBleed));
                        triangleLeftBefore = ((calloutWidth - innerTriangleOffset - calloutBleed) - (rangeEnd - x));
                        triangleLeftAfter = ((calloutWidth - calloutBleed) - (rangeEnd - x));
                    }
                    else if (x > (calloutHalfWidth - calloutBleed)) {
                        left = (x + xOffset);
                        triangleLeftBefore = (calloutHalfWidth - innerTriangleOffset);
                        triangleLeftAfter = (calloutHalfWidth);
                    }
                    else {
                        left = (calloutHalfWidth - calloutBleed) + xOffset;
                        triangleLeftBefore = (x + calloutBleed - innerTriangleOffset);
                        triangleLeftAfter = (x + calloutBleed);
                    }
                    renderCalloutImpl(callout, left, triangleLeftBefore, triangleLeftAfter);
                }
                ToolTip.renderCallout = renderCallout;
                function renderCalloutImpl(callout, left, triangleLeftBefore, triangleLeftAfter) {
                    callout.css('left', left + 'px');
                    callout.find('.destroyme').remove();
                    callout.append('<style class="destroyme">.triangle-border:before{left:' + triangleLeftBefore + 'px;}</style>');
                    callout.append('<style class="destroyme">.triangle-border:after{left:' + triangleLeftAfter + 'px;}</style>');
                }
            })(ToolTip = AxisHelper.ToolTip || (AxisHelper.ToolTip = {}));
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                if (outerPaddingRatio === void 0) { outerPaddingRatio = 0; }
                var scale = d3.scale.ordinal().rangeBands([0, pixelSpan], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio).domain(dataDomain);
                return scale;
            }
            AxisHelper.createOrdinalScale = createOrdinalScale;
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                if (outerPadding === void 0) { outerPadding = 0; }
                var scale = d3.scale.linear().range([outerPadding, pixelSpan - outerPadding]).domain([dataDomain[0], dataDomain[1]]);
                // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
                // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            AxisHelper.createLinearScale = createLinearScale;
            function getRangeForColumn(sizeColumn) {
                var result = {};
                if (sizeColumn) {
                    result.min = sizeColumn.min == null ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal : sizeColumn.min;
                    result.max = sizeColumn.max == null ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal : sizeColumn.max;
                }
                return result;
            }
            AxisHelper.getRangeForColumn = getRangeForColumn;
            //combine the forced domain with the actual domain if one of the values was set
            function combineDomain(forcedDomain, domain) {
                var combinedDomain = [domain[0], domain[1]];
                if (forcedDomain && forcedDomain.length === 2) {
                    if (forcedDomain[0] != null) {
                        combinedDomain[0] = forcedDomain[0];
                    }
                    if (forcedDomain[1] != null) {
                        combinedDomain[1] = forcedDomain[1];
                    }
                    if (combinedDomain[0] > combinedDomain[1]) {
                        combinedDomain = domain; //this is invalid, so take the original domain
                    }
                }
                return combinedDomain;
            }
            AxisHelper.combineDomain = combineDomain;
            function scaleShouldClamp(combinedDomain, domain) {
                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1]; //when the start or end is different, clamp it
            }
            AxisHelper.scaleShouldClamp = scaleShouldClamp;
            function normalizeNonFiniteNumber(value) {
                if (isNaN(value))
                    return null;
                else if (value === Number.POSITIVE_INFINITY)
                    return Number.MAX_VALUE;
                else if (value === Number.NEGATIVE_INFINITY)
                    return -Number.MAX_VALUE;
                return value;
            }
            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianHelper;
        (function (CartesianHelper) {
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects['categoryAxis'];
                    if (categoryAxisObject) {
                        toReturn = {
                            show: categoryAxisObject['show'],
                            axisType: categoryAxisObject['axisType'],
                            start: categoryAxisObject['start'],
                            end: categoryAxisObject['end'],
                            showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
                            axisStyle: categoryAxisObject['axisStyle']
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects['valueAxis'];
                    if (valueAxisObject) {
                        toReturn = {
                            show: valueAxisObject['show'],
                            position: valueAxisObject['position'],
                            start: valueAxisObject['start'],
                            end: valueAxisObject['end'],
                            showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
                            axisStyle: valueAxisObject['axisStyle'],
                            secShow: valueAxisObject['secShow'],
                            secPosition: valueAxisObject['secPosition'],
                            secStart: valueAxisObject['secStart'],
                            secEnd: valueAxisObject['secEnd'],
                            secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
                            secAxisStyle: valueAxisObject['secAxisStyle']
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
            function forceValueDomainToZero(valueAxisProperties) {
                if (valueAxisProperties['start'] == null) {
                    valueAxisProperties['start'] = 0;
                }
                if (valueAxisProperties['secStart'] == null) {
                    valueAxisProperties['secStart'] = 0;
                }
            }
            CartesianHelper.forceValueDomainToZero = forceValueDomainToZero;
            function isScalar(isScalar, xAxisCardProperties) {
                if (isScalar) {
                    //now check what the user wants
                    isScalar = xAxisCardProperties && xAxisCardProperties['axisType'] ? xAxisCardProperties['axisType'] === powerbi.axisType.scalar : true;
                }
                return isScalar;
            }
            CartesianHelper.isScalar = isScalar;
        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
        var ColorHelper = (function () {
            function ColorHelper(colors, fillProp, defaultDataPointColor) {
                this.colors = colors;
                this.fillProp = fillProp;
                this.defaultDataPointColor = defaultDataPointColor;
            }
            /**
             * Gets the color for the given series value. If no explicit color or default color has been set then the color is
             */
            ColorHelper.prototype.getColorForSeriesValue = function (objects, fieldIds, value) {
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp)) || this.defaultDataPointColor || this.colors.getColorByScale(SQExprShortSerializer.serializeArray(fieldIds || []), value).value;
            };
            /** Gets the color for the given measure. */
            ColorHelper.prototype.getColorForMeasure = function (objects, queryName) {
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp)) || this.defaultDataPointColor || this.colors.getColor(queryName).value;
            };
            ColorHelper.normalizeSelector = function (selector, isSingleSeries) {
                debug.assertAnyValue(selector, 'selector');
                // For dynamic series charts, colors are set per category.  So, exclude any measure (metadata repetition) from the selector.
                if (selector && (isSingleSeries || selector.data))
                    return { data: selector.data };
                return selector;
            };
            return ColorHelper;
        })();
        visuals.ColorHelper = ColorHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var rectName = 'rect';
        var ColumnUtil;
        (function (ColumnUtil) {
            ColumnUtil.DimmedOpacity = 0.4;
            ColumnUtil.DefaultOpacity = 1.0;
            function getTickCount(min, max, valuesMetadata, maxTickCount, is100Pct, forcedTickCount) {
                return forcedTickCount !== undefined ? (maxTickCount !== 0 ? forcedTickCount : 0) : visuals.AxisHelper.getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount);
            }
            ColumnUtil.getTickCount = getTickCount;
            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                if (isScalar) {
                    var min = xAxisCardProperties['start'];
                    var max = xAxisCardProperties['end'];
                    return ColumnUtil.transformDomain(dataView, min, max);
                }
                return dataView;
            }
            ColumnUtil.applyUserMinMax = applyUserMinMax;
            function transformDomain(dataView, min, max) {
                if (!dataView.categories || dataView.categories.length === 0)
                    return dataView; // no need to do something when there are no categories  
                if (typeof min !== "number" && typeof max !== "number")
                    return dataView; //user did not set min max, nothing to do here        
                var category = dataView.categories[0]; //at the moment we only support one category
                var categoryValues = category.values;
                var categoryObjects = category.objects;
                var newcategoryValues = [];
                var newValues = [];
                var newObjects = [];
                //get new min max
                if (typeof min !== "number") {
                    min = categoryValues[0];
                }
                if (typeof max !== "number") {
                    max = categoryValues[categoryValues.length - 1];
                }
                //don't allow this
                if (min > max)
                    return dataView;
                for (var j = 0, len = dataView.values.length; j < len; j++) {
                    newValues.push([]);
                }
                for (var t = 0, len = categoryValues.length; t < len; t++) {
                    if (categoryValues[t] >= min && categoryValues[t] <= max) {
                        newcategoryValues.push(categoryValues[t]);
                        if (categoryObjects) {
                            newObjects.push(categoryObjects[t]);
                        }
                        //on each measure set the new range
                        if (dataView.values) {
                            for (var k = 0; k < dataView.values.length; k++) {
                                newValues[k].push(dataView.values[k].values[t]);
                            }
                        }
                    }
                }
                //don't write directly to dataview
                var resultDataView = powerbi.Prototype.inherit(dataView);
                var resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values);
                var resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories);
                var resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                resultDataViewCategories0.values = newcategoryValues;
                //only if we had objects, then you set the new objects
                if (resultDataViewCategories0.objects) {
                    resultDataViewCategories0.objects = newObjects;
                }
                for (var t = 0, len = dataView.values.length; t < len; t++) {
                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                    measureArray.values = newValues[t];
                }
                return resultDataView;
            }
            ColumnUtil.transformDomain = transformDomain;
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax) {
                var categoryThickness = layout.categoryThickness;
                var isScalar = layout.isScalar;
                var outerPaddingRatio = layout.outerPaddingRatio;
                var dw = new DataWrapper(data, isScalar);
                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({ text: true }), isScalar, [forcedXMin, forcedXMax]);
                var axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatStringProp: visuals.columnChartProps.general.formatString,
                    outerPadding: categoryThickness * outerPaddingRatio,
                    isCategoryAxis: true,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return dw.lookupXValue(index, type); }
                });
                // intentionally updating the input layout by ref
                layout.categoryThickness = axisProperties.categoryThickness;
                return axisProperties;
            }
            ColumnUtil.getCategoryAxis = getCategoryAxis;
            function applyInteractivity(columns, onDragStart) {
                debug.assertValue(columns, 'columns');
                if (onDragStart) {
                    columns.attr('draggable', 'true').on('dragstart', onDragStart);
                }
            }
            ColumnUtil.applyInteractivity = applyInteractivity;
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
                    return ColumnUtil.DimmedOpacity;
                return ColumnUtil.DefaultOpacity;
            }
            ColumnUtil.getFillOpacity = getFillOpacity;
            function getClosestColumnIndex(coordinate, columnsCenters) {
                var currentIndex = 0;
                var distance = Number.MAX_VALUE;
                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    if (currentDistance < distance) {
                        distance = currentDistance;
                        currentIndex = i;
                    }
                }
                return currentIndex;
            }
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var lastColumnUndefined = typeof lastColumnIndex === 'undefined';
                // find all columns that do not belong to the selected column and set a dimmed opacity with a smooth animation to those columns
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return (d.categoryIndex !== selectedColumnIndex) && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                }).transition().style('fill-opacity', ColumnUtil.DimmedOpacity);
                // set the default opacity for the selected column
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return d.categoryIndex === selectedColumnIndex;
                }).style('fill-opacity', ColumnUtil.DefaultOpacity);
            }
            ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity;
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var series = colGroupSelection.data(data.series, function (d) { return d.key; });
                series.enter().append('g').classed(visuals.ColumnChart.SeriesClasses.class, true);
                series.exit().remove();
                return series;
            }
            ColumnUtil.drawSeries = drawSeries;
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros) {
                // We filter out invisible (0, null, etc.) values from the dataset
                // based on whether animations are enabled or not, Dashboard and
                // Exploration mode, respectively.
                var dataSelector;
                if (filterZeros) {
                    dataSelector = function (d) {
                        var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
                        return filteredData;
                    };
                }
                else {
                    dataSelector = function (d) { return d.data; };
                }
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
                var hasSelection = data.hasSelection;
                shapes.enter().append(rectName).attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes.style("fill", function (d) { return d.color; }).style("fill-opacity", function (d) { return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); }).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            }
            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                if (series && series.data().length > 0) {
                    var seriesData = series.data();
                    var dataPoints = [];
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    }
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
            }
            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
            function normalizeInfinityInScale(scale) {
                // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
                // results in infinite values being included in the domain. To correct for that, we need to
                // re-normalize the domain now to not include infinities.
                var scaledDomain = scale.domain();
                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
                    if (scaledDomain[i] === Number.POSITIVE_INFINITY)
                        scaledDomain[i] = Number.MAX_VALUE;
                    else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
                        scaledDomain[i] = -Number.MAX_VALUE;
                }
                scale.domain(scaledDomain);
            }
            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        (function (ClusteredUtil) {
            function createValueFormatter(valuesMetadata, interval) {
                return StackedUtil.createValueFormatter(valuesMetadata, false, interval);
            }
            ClusteredUtil.createValueFormatter = createValueFormatter;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var cols = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        (function (StackedUtil) {
            var constants = {
                percentFormat: '0%',
                roundingError: 0.0001,
            };
            function getSize(scale, size) {
                return visuals.AxisHelper.diffScaled(scale, 0, size);
            }
            StackedUtil.getSize = getSize;
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (data.length === 0)
                    return defaultNumberRange;
                // Can't use AxisHelper because Stacked layout has a slightly different calc, (position - valueAbs)
                var min = d3.min(data, function (d) { return d3.min(d.data, function (e) { return e.position - e.valueAbsolute; }); });
                var max = d3.max(data, function (d) { return d3.max(d.data, function (e) { return e.position; }); });
                if (is100pct) {
                    min = powerbi.Double.roundToPrecision(min, constants.roundingError);
                    max = powerbi.Double.roundToPrecision(max, constants.roundingError);
                }
                return {
                    min: min,
                    max: max,
                };
            }
            StackedUtil.calcValueDomain = calcValueDomain;
            function getValueAxis(data, is100Pct, size, scaleRange, forcedTickCount, forcedYDomain) {
                var valueDomain = calcValueDomain(data.series, is100Pct), min = valueDomain.min, max = valueDomain.max;
                var maxTickCount = visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(size);
                var bestTickCount = ColumnUtil.getTickCount(min, max, data.valuesMetadata, maxTickCount, is100Pct, forcedTickCount);
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({ min: min, max: max });
                var valueDomainNorm = [normalizedRange.min, normalizedRange.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainNorm);
                var scale = d3.scale.linear().range(scaleRange).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainNorm));
                ColumnUtil.normalizeInfinityInScale(scale);
                var yTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, scale);
                var d3Axis = d3.svg.axis().scale(scale).tickValues(yTickValues);
                var yInterval = visuals.ColumnChart.getTickInterval(yTickValues);
                var yFormatter = StackedUtil.createValueFormatter(data.valuesMetadata, is100Pct, yInterval);
                d3Axis.tickFormat(yFormatter.format);
                var values = yTickValues.map(function (d) { return yFormatter.format(d); });
                return {
                    axis: d3Axis,
                    scale: scale,
                    formatter: yFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({ numeric: true }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
            }
            StackedUtil.getValueAxis = getValueAxis;
            function createValueFormatter(valuesMetadata, is100Pct, interval) {
                // TODO: Passing 0 in createFormatter below is a temporary workaround. As long as we fix createFormatter
                // to pass scaleInterval parameter instead min and max, we can remove it.
                if (is100Pct)
                    return visuals.valueFormatter.create({ format: constants.percentFormat, value: interval, value2: 0, allowFormatBeautification: true });
                // Default to apply formatting from the first measure.
                return visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    value: interval,
                    value2: 0,
                    allowFormatBeautification: true
                });
            }
            StackedUtil.createValueFormatter = createValueFormatter;
            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(rowIdx, 'rowIdx');
                var pos = 0, neg = 0;
                for (var i = 0; i < seriesCount; i++) {
                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                    if (value > 0)
                        pos += value;
                    else if (value < 0)
                        neg -= value;
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? (pos / absTotal) / pos : 1,
                    neg: neg ? (neg / absTotal) / neg : 1,
                };
            }
            StackedUtil.getStackedMultiplier = getStackedMultiplier;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var bars = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                bars.exit().remove();
            }
            StackedUtil.clearColumns = clearColumns;
        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
        var DataWrapper = (function () {
            function DataWrapper(columnChartData, isScalar) {
                this.data = columnChartData;
                this.isScalar = isScalar;
            }
            DataWrapper.prototype.lookupXValue = function (index, type) {
                debug.assertValue(this.data, 'this.data');
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime && this.isScalar)
                    return new Date(index);
                var data = this.data;
                if (type.text) {
                    debug.assert(index < data.categories.length, 'category index out of range');
                    return data.categories[index];
                }
                else {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            if (this.data.hasHighlights)
                                index = index * 2;
                            var dataPoint = seriesValues[index];
                            if (dataPoint) {
                                if (isDateTime)
                                    return new Date(dataPoint.categoryValue);
                                return dataPoint.categoryValue;
                            }
                        }
                    }
                }
                return index;
            };
            return DataWrapper;
        })();
        visuals.DataWrapper = DataWrapper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var converterHelper;
        (function (converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    // Need to pivot data if our category soure is a series role
                    var category = dataView.categories[0];
                    return category.source && visuals.DataRoleHelper.hasRole(category.source, seriesRoleName) && visuals.DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return false;
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    var categoryValues = category.values;
                    return category.values.length > 0 ? {
                        categories: categoryValues,
                        categoryFormatter: visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                            value: categoryValues[0],
                            value2: categoryValues[categoryValues.length - 1],
                            // Do not use display units such as K/M/bn etc. on the x-axis.
                            // PowerView does not use units either as large ranges will make the x-axis indecipherable.
                            displayUnitSystemType: 1 /* Verbose */,
                        }),
                        categoryIdentities: category.identity,
                        categoryObjects: category.objects,
                    } : {
                        categories: [],
                        categoryFormatter: { format: visuals.valueFormatter.format },
                    };
                }
                // For cases where the category source is just a series role, we are pivoting the data on the role which means we
                // will have no categories.
                return defaultCategories();
            }
            converterHelper.getPivotedCategories = getPivotedCategories;
            function getSeriesName(source) {
                debug.assertValue(source, 'source');
                return (source.groupName !== undefined) ? source.groupName : source.queryName;
            }
            converterHelper.getSeriesName = getSeriesName;
            function getFormattedLegendLabel(source, values, formatStringProp) {
                debug.assertValue(source, 'source');
                debug.assertValue(values, 'values');
                var sourceForFormat = source;
                var nameForFormat = source.displayName;
                if (source.groupName !== undefined) {
                    sourceForFormat = values.source;
                    nameForFormat = source.groupName;
                }
                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
            function defaultCategories() {
                return {
                    categories: [null],
                    categoryFormatter: { format: visuals.valueFormatter.format },
                };
            }
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null;
                var yAxisLabel = null;
                if (categoryAxisProperties) {
                    // Take the value only if it's there
                    if (category && category.displayName) {
                        xAxisLabel = category.displayName;
                    }
                }
                if (valueAxisProperties) {
                    var valuesNames = [];
                    if (values) {
                        // Take the name from the values, and make it unique because there are sometimes duplications
                        valuesNames = values.map(function (v) { return v ? v.displayName : ''; }).filter(function (value, index, self) { return value !== '' && self.indexOf(value) === index; });
                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
                    }
                }
                return { xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel };
            }
            converterHelper.createAxesLabels = createAxesLabels;
        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        (function (PointLabelPosition) {
            PointLabelPosition[PointLabelPosition["Above"] = 0] = "Above";
            PointLabelPosition[PointLabelPosition["Bellow"] = 1] = "Bellow";
        })(visuals.PointLabelPosition || (visuals.PointLabelPosition = {}));
        var PointLabelPosition = visuals.PointLabelPosition;
        var dataLabelUtils;
        (function (dataLabelUtils) {
            dataLabelUtils.labelMargin = 8;
            dataLabelUtils.maxLabelWidth = 50;
            dataLabelUtils.defaultColumnLabelMargin = 5;
            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
            dataLabelUtils.LabelTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: '12px',
                fontWeight: 'bold',
            };
            dataLabelUtils.defaultLabelColor = "#696969"; //dim grey
            dataLabelUtils.defaultInsideLabelColor = "#fff"; //white
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
            var defaultLabelPrecision = 2;
            var labelsClass = {
                class: 'data-labels',
                selector: '.data-labels',
            };
            function getDefaultLabelSettings(show, labelColor) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultTreemapLabelSettings() {
                return getDefaultLabelSettings(true, '#fff');
            }
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(false);
                labelSettings.position = null;
                labelSettings.labelColor = (isLabelPositionInside) ? dataLabelUtils.defaultInsideLabelColor : null;
                return labelSettings;
            }
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null
                };
            }
            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function getDefaultDonutLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: true,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data could not be null or undefined');
                // Hide and reposition labels that overlap
                var dataLabelManager = new powerbi.DataLabelManager();
                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
                var labels = context.selectAll(labelsClass.selector).data(filteredData);
                labels.enter().append('text').classed(labelsClass.class, true);
                labels.attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } }).text(function (d) { return d.labeltext; }).style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels.exit().remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            // Funnel chart uses animation and does not use collision detection
            function drawDefaultLabelsForFunnelChart(data, context, layout, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data could not be null or undefined');
                var filteredData = data.filter(layout.filter);
                var labels = context.selectAll(labelsClass.selector).data(filteredData);
                labels.enter().append('text').classed(labelsClass.class, true);
                labels.attr(layout.labelLayout).text(layout.labelText).style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels.exit().remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForFunnelChart = drawDefaultLabelsForFunnelChart;
            function cleanDataLabels(context) {
                var empty = [];
                var labels = context.selectAll(labelsClass.selector).data(empty);
                labels.exit().remove();
            }
            dataLabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", function (d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                });
            }
            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(label, maxWidth, format) {
                var properties = {
                    text: powerbi.formattingService.formatValue(label, format),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                maxWidth = maxWidth ? maxWidth : dataLabelUtils.maxLabelWidth;
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxWidth);
            }
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText(d.labeltext);
                    },
                    labelLayout: {
                        x: function (d) { return d.x; },
                        y: function (d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? d.y - margin : d.y + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.labeltext != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                    },
                };
            }
            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions) {
                var value2 = null;
                if (data.labelSettings.displayUnits === 0 && axisFormatter && axisFormatter.displayUnit)
                    value2 = axisFormatter.displayUnit.value;
                var formatOverride = (isHundredPercent) ? dataLabelUtils.hundredPercentFormat : null;
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(data.labelSettings, formatOverride, value2));
                var hasSelection = false;
                for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                    var dataPoints = data.series[i].data;
                    if (visuals.dataHasSelection(dataPoints))
                        hasSelection = true;
                }
                return {
                    labelText: function (d) {
                        return getLabelFormattedText(formatter.format(d.value), dataLabelUtils.maxLabelWidth);
                    },
                    labelLayout: labelLayoutXY,
                    filter: function (d) {
                        return (d != null && d.value != null && d.value !== 0 && validateLabelsSize(d, axisOptions));
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'text-anchor': isColumn ? 'middle' : 'start',
                        'fill-opacity': function (d) {
                            //if bar's opacity is DimmedOpacity (less than 1) labels opacity swap to 0
                            var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights) < 1 ? 0 : 1;
                            return labelOpacity;
                        }
                    },
                };
            }
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            //valide for stacked column/bar chart and 100% stacked column/bar chart,
            // that labels that should to be inside the shape aren't bigger then shapes,
            function validateLabelsSize(d, axisOptions) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var columnWidth = axisOptions.columnWidth;
                var properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.measureSvgTextHeight(properties);
                var shapeWidth, shapeHeight;
                var inside = false;
                switch (d.chartType) {
                    case visuals.ColumnChartType.stackedBar:
                        shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                        shapeHeight = columnWidth;
                        inside = d.lastSeries ? false : true;
                        break;
                    case visuals.ColumnChartType.hundredPercentStackedBar:
                        shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                        shapeHeight = columnWidth;
                        inside = true;
                        break;
                    case visuals.ColumnChartType.stackedColumn:
                        shapeWidth = columnWidth;
                        shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                        inside = d.lastSeries ? false : true;
                        break;
                    case visuals.ColumnChartType.hundredPercentStackedColumn:
                        shapeWidth = columnWidth;
                        shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                        inside = true;
                        break;
                    default:
                        return true;
                }
                //checking that labels aren't greater than shape
                if (inside && ((textWidth > shapeWidth) || textHeight > shapeHeight))
                    return false;
                return true;
            }
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText(d.category);
                    },
                    labelLayout: {
                        x: function (d) { return xScale(d.x); },
                        y: function (d) {
                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.category != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'fill-opacity': function (d) { return visuals.ScatterChart.getBubbleOpacity(d, false); },
                        'font-family': dataLabelUtils.LabelTextProperties.fontFamily,
                        'font-size': dataLabelUtils.LabelTextProperties.fontSize,
                        'font-weight': dataLabelUtils.LabelTextProperties.fontWeight,
                    },
                };
            }
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar) {
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(labelSettings));
                return {
                    labelText: function (d) {
                        return getLabelFormattedText(formatter.format(d.value));
                    },
                    labelLayout: {
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex); },
                        y: function (d) {
                            return labelSettings.position === 0 /* Above */ ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.value != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'fill-opacity': 1,
                        'font-family': dataLabelUtils.LabelTextProperties.fontFamily,
                        'font-size': dataLabelUtils.LabelTextProperties.fontSize,
                        'font-weight': dataLabelUtils.LabelTextProperties.fontWeight,
                    },
                };
            }
            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            function getFunnelChartLabelLayout(data, axisOptions, innerTextHeightDelta, textMinimumPadding, labelSettings, currentViewport) {
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var marginLeft = axisOptions.margin.left;
                //the bars are tranform, verticalRange mean horizontal range, xScale is y, yscale is x
                var halfRangeBandPlusDelta = axisOptions.xScale.rangeBand() / 2 + innerTextHeightDelta;
                var pixelSpan = axisOptions.verticalRange / 2;
                var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString);
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(labelSettings, formatString));
                return {
                    labelText: function (d) {
                        var barWidth = Math.abs(yScale(d.value) - yScale(0));
                        var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                        var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                        var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                        return getLabelFormattedText(formatter.format(d.value), maximumTextSize);
                    },
                    labelLayout: {
                        y: function (d, i) {
                            return xScale(i) + halfRangeBandPlusDelta;
                        },
                        x: function (d) {
                            var barWidth = Math.abs(yScale(d.value) - yScale(0));
                            var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                            var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                            var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                            var properties = {
                                text: getLabelFormattedText(formatter.format(d.value), maximumTextSize),
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            var textLength = textMeasurer(properties);
                            // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                            var labelPosition = labelSettings.position;
                            if (labelPosition === powerbi.labelPosition.outsideEnd && outsideAvailableSpace < textLength)
                                labelPosition = powerbi.labelPosition.insideCenter;
                            else if (labelPosition === powerbi.labelPosition.insideCenter && insideAvailableSpace < textLength) {
                                labelPosition = powerbi.labelPosition.outsideEnd;
                            }
                            switch (labelPosition) {
                                case powerbi.labelPosition.outsideEnd:
                                    d.labelFill = d.labelFill === '#FFFFFF' ? d.color : d.labelFill;
                                    return marginLeft + pixelSpan + (barWidth / 2) + textMinimumPadding + (textLength / 2);
                                default:
                                    // Inside position, if color didn't override, then the color is white
                                    d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : '#FFFFFF';
                                    return marginLeft + pixelSpan;
                            }
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.value != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, false, false); },
                    },
                };
            }
            dataLabelUtils.getFunnelChartLabelLayout = getFunnelChartLabelLayout;
            function enumerateDataLabels(dataLabelsSettings, withPosition, withPrecision, withDisplayUnit, labelPositionObjects) {
                if (withPrecision === void 0) { withPrecision = false; }
                if (withDisplayUnit === void 0) { withDisplayUnit = false; }
                if (!dataLabelsSettings)
                    return [];
                var instance = {
                    objectName: 'labels',
                    selector: null,
                    properties: {
                        show: dataLabelsSettings.show,
                        color: dataLabelsSettings.labelColor,
                    },
                    validValues: labelPositionObjects,
                };
                //TODO: enable that when descriptor is ready for all visuals
                if (withDisplayUnit) {
                    instance.properties['labelDisplayUnits'] = dataLabelsSettings.displayUnits;
                }
                //TODO: enable that when descriptor is ready for all visuals
                if (withPrecision) {
                    instance.properties['labelPrecision'] = dataLabelsSettings.precision;
                }
                //TODO: enable that when descriptor is ready
                if (withPosition) {
                    instance.properties['labelPosition'] = dataLabelsSettings.position;
                }
                return [instance];
            }
            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(dataLabelsSettings, withFill, isDonutChart) {
                if (isDonutChart === void 0) { isDonutChart = false; }
                var labelSettings = (dataLabelsSettings) ? dataLabelsSettings : (isDonutChart) ? getDefaultDonutLabelSettings() : getDefaultPointLabelSettings();
                var instance = {
                    objectName: 'categoryLabels',
                    selector: null,
                    properties: {
                        show: isDonutChart ? labelSettings.showCategory : labelSettings.show,
                    },
                };
                if (withFill) {
                    instance.properties['color'] = labelSettings.labelColor;
                }
                return [instance];
            }
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function getDefaultFunnelLabelSettings(defaultColor) {
                return {
                    show: true,
                    position: powerbi.labelPosition.insideCenter,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: defaultColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultFunnelLabelSettings = getDefaultFunnelLabelSettings;
            function getLabelFormatterOptions(labelSetting, formatOverride, value2) {
                //displayUnitSystem avoid scaling for year values (1000 to 3000), set value to bigger than Year.Max
                var displayUnits = (labelSetting.displayUnits === 1000) ? 10000 : labelSetting.displayUnits;
                if (formatOverride) {
                    return {
                        format: formatOverride,
                        precision: labelSetting.precision,
                        value: displayUnits,
                        value2: value2,
                        allowFormatBeautification: true,
                    };
                }
                return {
                    format: (labelSetting && labelSetting.formatterOptions) ? labelSetting.formatterOptions.format : null,
                    precision: labelSetting.precision,
                    value: displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            dataLabelUtils.getLabelFormatterOptions = getLabelFormatterOptions;
            function getFormatterOptionsColumn(columns) {
                if (columns) {
                    return _.find(columns, function (col) { return col.format != null; });
                }
                return null;
            }
            dataLabelUtils.getFormatterOptionsColumn = getFormatterOptionsColumn;
        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper;
        (function (DataRoleHelper) {
            function getMeasureIndexOfRole(grouped, roleName, defaultIndexIfNoRole) {
                if (grouped && grouped.length > 0) {
                    var firstGroup = grouped[0];
                    if (firstGroup.values && firstGroup.values.length > 0) {
                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {
                            var value = firstGroup.values[i];
                            if (value && value.source) {
                                if (hasRole(value.source, roleName))
                                    return i;
                                if (len > defaultIndexIfNoRole)
                                    return defaultIndexIfNoRole;
                            }
                        }
                    }
                }
                return -1;
            }
            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;
            function hasRole(column, name) {
                var roles = column.roles;
                return roles && roles[name];
            }
            DataRoleHelper.hasRole = hasRole;
            function hasRoleInDataView(dataView, name) {
                return dataView != null && dataView.metadata != null && dataView.metadata.columns && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });
            }
            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;
        })(DataRoleHelper = visuals.DataRoleHelper || (visuals.DataRoleHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var VisualInteractivityFactory;
        (function (VisualInteractivityFactory) {
            function buildInteractivityService(options) {
                if (options.interactivity && options.interactivity.selection) {
                    return visuals.createInteractivityService(options.host);
                }
                else if (options.interactivity && options.interactivity.isInteractiveLegend) {
                    return new visuals.MobileInteractivityService();
                }
                // For hosts that don't have interactivity like the dashboard
                return null;
            }
            VisualInteractivityFactory.buildInteractivityService = buildInteractivityService;
        })(VisualInteractivityFactory = visuals.VisualInteractivityFactory || (visuals.VisualInteractivityFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
            var checker = new InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity);
            // Show a warning if necessary.
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = (function () {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                this.supportsNaN = supportsNaN;
                this.supportsNegativeInfinity = supportsNegativeInfinity;
                this.supportsPositiveInfinity = supportsPositiveInfinity;
            }
            InvalidDataValuesChecker.prototype.getWarningMessages = function (dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                if (this.hasNaN && !this.supportsNaN) {
                    warnings.push(new visuals.NaNNotSupportedWarning());
                }
                if ((this.hasNegativeInfinity && !this.supportsNegativeInfinity) || (this.hasPositiveInfinity && !this.supportsPositiveInfinity)) {
                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
                }
                if (this.hasOutOfRange) {
                    warnings.push(new visuals.ValuesOutOfRangeWarning());
                }
                return warnings;
            };
            InvalidDataValuesChecker.prototype.loadWarningStatus = function (dataViews) {
                this.hasNaN = false;
                this.hasNegativeInfinity = false;
                this.hasOutOfRange = false;
                this.hasPositiveInfinity = false;
                for (var k = 0; k < dataViews.length; k++) {
                    var dataView = dataViews[k];
                    var values = dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values : null;
                    if (!values)
                        return;
                    var valueLength = values.length;
                    for (var i = 0; i < valueLength; i++) {
                        var value = values[i];
                        if (value.values) {
                            var valueValueLength = value.values.length;
                            for (var j = 0; j < valueValueLength; j++) {
                                var v = value.values[j];
                                if (isNaN(v))
                                    this.hasNaN = true;
                                else if (v === Number.POSITIVE_INFINITY)
                                    this.hasPositiveInfinity = true;
                                else if (v === Number.NEGATIVE_INFINITY)
                                    this.hasNegativeInfinity = true;
                                else if (v < -1e300 || v > 1e300)
                                    this.hasOutOfRange = true;
                            }
                        }
                    }
                }
            };
            return InvalidDataValuesChecker;
        })();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ListViewFactory;
        (function (ListViewFactory) {
            function createHTMLListView(options) {
                return new ListView(options, 1 /* HTML */);
            }
            ListViewFactory.createHTMLListView = createHTMLListView;
            function createSVGListView(options) {
                return new ListView(options, 0 /* SVG */);
            }
            ListViewFactory.createSVGListView = createSVGListView;
        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        var ListViewMode;
        (function (ListViewMode) {
            ListViewMode[ListViewMode["SVG"] = 0] = "SVG";
            ListViewMode[ListViewMode["HTML"] = 1] = "HTML";
        })(ListViewMode || (ListViewMode = {}));
        /**
         * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
         * It can create lists containing either HTML or SVG elements
         */
        var ListView = (function () {
            function ListView(options, mode) {
                var _this = this;
                this.options = options;
                this.mode = mode;
                this.options.baseContainer.style('overflow-y', 'auto').on('scroll', function () { return _this.render(false); });
                this.scrollContainer = options.baseContainer.append(mode === 0 /* SVG */ ? 'svg' : 'div').attr('class', 'scrollRegion');
                this.visibleGroupContainer = this.scrollContainer.append(mode === 0 /* SVG */ ? 'g' : 'div').attr('class', 'visibleGroup');
                ListView.SetDefaultOptions(options);
                this.position = 0;
            }
            ListView.SetDefaultOptions = function (options) {
                options.rowHeight = options.rowHeight || 1;
            };
            ListView.prototype.rowHeight = function (rowHeight) {
                this.options.rowHeight = rowHeight;
                return this;
            };
            ListView.prototype.data = function (data, dataIdFunction) {
                this._data = data;
                this._dataIdFunction = dataIdFunction;
                this._totalRows = data ? data.length : 0;
                return this;
            };
            ListView.prototype.viewport = function (viewport) {
                this.options.viewport = viewport;
                return this;
            };
            ListView.prototype.empty = function () {
                this._data = [];
                this.render(false, true);
            };
            ListView.prototype.render = function (sizeChanged, resetScrollbarPosition) {
                if (sizeChanged === void 0) { sizeChanged = false; }
                if (resetScrollbarPosition === void 0) { resetScrollbarPosition = false; }
                if (!(this._data && this.options))
                    return;
                var scrollTop;
                var options = this.options;
                var rowHeight = options.rowHeight;
                debug.assertValue(rowHeight, 'rowHeight');
                debug.assert(rowHeight > 0, 'rowHeight should be more than 0');
                if (resetScrollbarPosition) {
                    this.position = 0;
                    scrollTop = 0;
                    $(options.baseContainer.node()).scrollTop(scrollTop);
                }
                else
                    scrollTop = options.baseContainer.node().scrollTop;
                if (sizeChanged) {
                    var height = options.viewport.height;
                    this.visibleRows = Math.ceil(height / rowHeight) + 1;
                }
                var totalHeight = Math.max(0, (this._totalRows * rowHeight));
                this.scrollContainer.style('height', totalHeight + "px").attr('height', totalHeight);
                var lastPosition = this.position;
                var position = this.position = Math.floor(scrollTop / rowHeight);
                this.delta = position - lastPosition;
                this.scrollToFrame(position);
            };
            ListView.prototype.scrollToFrame = function (scrollPosition) {
                var options = this.options;
                var visibleGroupContainer = this.visibleGroupContainer;
                var totalRows = this._totalRows;
                var rowHeight = options.rowHeight;
                var visibleRows = this.visibleRows;
                var translateY = scrollPosition * rowHeight;
                visibleGroupContainer.attr('transform', function (d) { return visuals.SVGUtil.translate(0, translateY); }).style('transform', function (d) { return visuals.SVGUtil.translateWithPixels(0, translateY); });
                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows;
                var rowSelection = visibleGroupContainer.selectAll(".row").data(this._data.slice(position0, Math.min(position1, totalRows)), this._dataIdFunction);
                rowSelection.enter().append('g').classed('row', true).call(function (d) { return options.enter(d); });
                rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll('.row:not(.transitioning)');
                rowUpdateSelection.call(function (d) { return options.update(d); });
                if (this.mode === 0 /* SVG */) {
                    rowUpdateSelection.each(function (d, i) {
                        var translate = visuals.SVGUtil.translate(0, i * rowHeight);
                        d3.select(this).attr('transform', function (d) { return translate; }).style('transform', function (d) { return translate; });
                    });
                }
                rowSelection.exit().call(function (d) { return options.exit(d); }).remove();
                if (position1 >= totalRows * ListView.loadMoreDataThreshold)
                    options.loadMoreData();
            };
            /* The value indicates the percentage of data already shown
               in the list view that triggers a loadMoreData call. */
            ListView.loadMoreDataThreshold = 0.8;
            return ListView;
        })();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A combination of identifiers used to uniquely identify
         * data points and their bound geometry.
         */
        var SelectionId = (function () {
            function SelectionId(selector, highlight) {
                this.selector = selector;
                this.highlight = highlight;
                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });
            }
            SelectionId.prototype.equals = function (other) {
                if (!this.selector || !other.selector) {
                    return (!this.selector === !other.selector) && this.highlight === other.highlight;
                }
                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);
            };
            /** Checks equality against other for all identifiers existing in this */
            SelectionId.prototype.includes = function (other, ignoreHighlight) {
                if (ignoreHighlight === void 0) { ignoreHighlight = false; }
                var thisSelector = this.selector;
                var otherSelector = other.selector;
                if (!thisSelector || !otherSelector) {
                    return false;
                }
                var thisData = thisSelector.data;
                var otherData = otherSelector.data;
                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))
                    return false;
                if (!ignoreHighlight && this.highlight !== other.highlight)
                    return false;
                if (thisData) {
                    if (!otherData)
                        return false;
                    if (thisData.length > 0) {
                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {
                            var thisValue = thisData[i];
                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))
                                return false;
                        }
                    }
                }
                return true;
            };
            SelectionId.prototype.getKey = function () {
                return this.key;
            };
            /** Temporary workaround since a few things currently rely on this, but won't need to. */
            SelectionId.prototype.hasIdentity = function () {
                return (this.selector && !!this.selector.data);
            };
            SelectionId.prototype.getSelector = function () {
                return this.selector;
            };
            SelectionId.createNull = function (highlight) {
                if (highlight === void 0) { highlight = false; }
                return new SelectionId(null, highlight);
            };
            SelectionId.createWithId = function (id, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                if (id) {
                    selector = {
                        data: [id]
                    };
                }
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithMeasure = function (measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                if (measureId)
                    selector.metadata = measureId;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                if (id) {
                    selector.data = [id];
                }
                if (measureId)
                    selector.metadata = measureId;
                if (!id && !measureId)
                    selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIds = function (id1, id2, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector = { data: selectorData };
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector.data = selectorData;
                if (measureId)
                    selector.metadata = measureId;
                if (!id1 && !id2 && !measureId)
                    selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithHighlight = function (original) {
                debug.assertValue(original, 'original');
                debug.assert(!original.highlight, '!original.highlight');
                return new SelectionId(original.getSelector(), true);
            };
            SelectionId.idArray = function (id1, id2) {
                if (id1 || id2) {
                    var data = [];
                    if (id1)
                        data.push(id1);
                    if (id2 && id2 !== id1)
                        data.push(id2);
                    return data;
                }
            };
            return SelectionId;
        })();
        visuals.SelectionId = SelectionId;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        "use strict";
        var shapes;
        (function (shapes) {
            var Utility = jsCommon.Utility;
            var Point;
            (function (Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = ((point.x + offsetX) >= 0) ? (point.x + offsetX) : 0;
                    var newPointY = ((point.y + offsetY) >= 0) ? (point.y + offsetY) : 0;
                    return { x: newPointX, y: newPointY };
                }
                Point.offset = offset;
                function equals(point, other) {
                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
                }
                Point.equals = equals;
                function clone(point) {
                    return (point !== null) ? { x: point.x, y: point.y } : null;
                }
                Point.clone = clone;
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                Point.toString = toString;
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                Point.serialize = serialize;
                function getDistance(point, other) {
                    if ((point === null) || (other) === null) {
                        return null;
                    }
                    var diffX = other.x - point.x;
                    var diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                Point.getDistance = getDistance;
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 || (point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y));
                }
                Point.equalWithPrecision = equalWithPrecision;
                function parsePoint(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { x: Utility.parseNumber(value[0]), y: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { x: Utility.parseNumber(parts[0]), y: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { x: Utility.parseNumber(value.x), y: Utility.parseNumber(value.y) };
                        }
                    }
                }
                Point.parsePoint = parsePoint;
            })(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            (function (Size) {
                function isEmpty(size) {
                    return size.width === 0 && size.height === 0;
                }
                Size.isEmpty = isEmpty;
                function equals(size, other) {
                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
                }
                Size.equals = equals;
                function clone(size) {
                    return (size !== null) ? { width: size.width, height: size.height } : null;
                }
                Size.clone = clone;
                function inflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Size.inflate = inflate;
                function deflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width = result.width - padding.left - padding.right;
                        if (result.width < 0) {
                            result.width = 0;
                        }
                        result.height = result.height - padding.top - padding.bottom;
                        if (result.height < 0) {
                            result.height = 0;
                        }
                    }
                    return result;
                }
                Size.deflate = deflate;
                function combine(size, other) {
                    if (other) {
                        size.width = Math.max(size.width, other.width);
                        size.height = Math.max(size.height, other.height);
                    }
                    return size;
                }
                Size.combine = combine;
                function toRect(size) {
                    return { left: 0, top: 0, width: size.width, height: size.height };
                }
                Size.toRect = toRect;
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                Size.toString = toString;
                function equal(size1, size2) {
                    return size1 === size2 || (size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height);
                }
                Size.equal = equal;
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 || (size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height));
                }
                Size.equalWithPrecision = equalWithPrecision;
                function parseSize(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { width: Utility.parseNumber(value[0]), height: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { width: Utility.parseNumber(parts[0]), height: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Size.parseSize = parseSize;
            })(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            (function (Rect) {
                function getOffset(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.getOffset = getOffset;
                function getSize(rect) {
                    return { width: rect.width, height: rect.height };
                }
                Rect.getSize = getSize;
                function setSize(rect, value) {
                    rect.width = value.width;
                    rect.height = value.height;
                }
                Rect.setSize = setSize;
                function right(rect) {
                    return rect.left + rect.width;
                }
                Rect.right = right;
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                Rect.bottom = bottom;
                function topLeft(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.topLeft = topLeft;
                function topRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top };
                }
                Rect.topRight = topRight;
                function bottomLeft(rect) {
                    return { x: rect.left, y: rect.top + rect.height };
                }
                Rect.bottomLeft = bottomLeft;
                function bottomRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top + rect.height };
                }
                Rect.bottomRight = bottomRight;
                function equals(rect, other) {
                    return other !== undefined && other !== null && rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                Rect.equals = equals;
                function clone(rect) {
                    return (rect !== null) ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null;
                }
                Rect.clone = clone;
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                Rect.toString = toString;
                function offset(rect, offsetX, offsetY) {
                    var newLeft = ((rect.left + offsetX) >= 0) ? rect.left + offsetX : 0;
                    var newTop = ((rect.top + offsetY) >= 0) ? rect.top + offsetY : 0;
                    return { left: newLeft, top: newTop, width: rect.width, height: rect.height };
                }
                Rect.offset = offset;
                function inflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left -= padding.left;
                        result.top -= padding.top;
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.inflate = inflate;
                function deflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left += padding.left;
                        result.top += padding.top;
                        result.width -= padding.left + padding.right;
                        result.height -= padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.deflate = deflate;
                function inflateBy(rect, padding) {
                    return { left: rect.left - padding, top: rect.top - padding, width: rect.width + padding + padding, height: rect.height + padding + padding };
                }
                Rect.inflateBy = inflateBy;
                function deflateBy(rect, padding) {
                    return { left: rect.left + padding, top: rect.top + padding, width: rect.width - padding - padding, height: rect.height - padding - padding };
                }
                Rect.deflateBy = deflateBy;
                // @return the closest point on the rect to the (x,y) point given.
                // in case the (x,y) given is inside the rect, (x,y) will be returned. otherwise, a point on a border will be returned.
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                Rect.getClosestPoint = getClosestPoint;
                function equal(rect1, rect2) {
                    return rect1 === rect2 || (rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height);
                }
                Rect.equal = equal;
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 || (rect1 !== undefined && rect2 !== undefined && powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) && powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height));
                }
                Rect.equalWithPrecision = equalWithPrecision;
                function isEmpty(rect) {
                    return rect === undefined || rect === null || (rect.width === 0 && rect.height === 0);
                }
                Rect.isEmpty = isEmpty;
                function containsPoint(rect, point) {
                    if ((rect === null) || (point === null)) {
                        return false;
                    }
                    return rect.left <= point.x && point.x <= rect.left + rect.width && rect.top <= point.y && point.y <= rect.top + rect.height;
                }
                Rect.containsPoint = containsPoint;
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) {
                        return false;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    if (left > right) {
                        return false;
                    }
                    var top = Math.max(rect1.top, rect2.top);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return top <= bottom;
                }
                Rect.isIntersecting = isIntersecting;
                function intersect(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var top = Math.max(rect1.top, rect2.top);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    if (left <= right && top <= bottom) {
                        return { left: left, top: top, width: right - left, height: bottom - top };
                    }
                    else {
                        return { left: 0, top: 0, width: 0, height: 0 };
                    }
                }
                Rect.intersect = intersect;
                function combine(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.min(rect1.left, rect2.left);
                    var top = Math.min(rect1.top, rect2.top);
                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return { left: left, top: top, width: right - left, height: bottom - top };
                }
                Rect.combine = combine;
                function parseRect(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), width: Utility.parseNumber(value[2]), height: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]),
                                top: Utility.parseNumber(parts[1]),
                                width: Utility.parseNumber(parts[2]),
                                height: Utility.parseNumber(parts[3])
                            };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Rect.parseRect = parseRect;
            })(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            (function (Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    if (other) {
                        result.left = thickness.left + other.left;
                        result.right = thickness.right + other.right;
                        result.bottom = thickness.bottom + other.bottom;
                        result.top = thickness.top + other.top;
                    }
                    return result;
                }
                Thickness.inflate = inflate;
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                Thickness.getWidth = getWidth;
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                Thickness.getHeight = getHeight;
                function clone(thickness) {
                    return (thickness !== null) ? { left: thickness.left, top: thickness.top, right: thickness.right, bottom: thickness.bottom } : null;
                }
                Thickness.clone = clone;
                function equals(thickness, other) {
                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                Thickness.equals = equals;
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left;
                    thickness.left = temp;
                }
                Thickness.flipHorizontal = flipHorizontal;
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom;
                    thickness.bottom = top;
                }
                Thickness.flipVertical = flipVertical;
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                Thickness.toString = toString;
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                Thickness.toCssString = toCssString;
                function isEmpty(thickness) {
                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
                }
                Thickness.isEmpty = isEmpty;
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 || (thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom);
                }
                Thickness.equal = equal;
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 || (thickness1 !== undefined && thickness2 !== undefined && powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) && powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom));
                }
                Thickness.equalWithPrecision = equalWithPrecision;
                function parseThickness(value, defaultValue, resetValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), right: Utility.parseNumber(value[2]), bottom: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), right: Utility.parseNumber(parts[2]), bottom: Utility.parseNumber(parts[3]) };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), right: Utility.parseNumber(value.right), bottom: Utility.parseNumber(value.bottom) };
                        }
                    }
                }
                Thickness.parseThickness = parseThickness;
            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            (function (Vector) {
                function isEmpty(vector) {
                    return vector.x === 0 && vector.y === 0;
                }
                Vector.isEmpty = isEmpty;
                function equals(vector, other) {
                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
                }
                Vector.equals = equals;
                function clone(vector) {
                    return (vector !== null) ? { x: vector.x, y: vector.y } : null;
                }
                Vector.clone = clone;
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                Vector.toString = toString;
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                Vector.getLength = getLength;
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                Vector.getLengthSqr = getLengthSqr;
                function scale(vector, scalar) {
                    return { x: vector.x * scalar, y: vector.y * scalar };
                }
                Vector.scale = scale;
                function normalize(vector) {
                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
                }
                Vector.normalize = normalize;
                function rotate90DegCW(vector) {
                    return { x: vector.y, y: -vector.x };
                }
                Vector.rotate90DegCW = rotate90DegCW;
                function rotate90DegCCW(vector) {
                    return { x: -vector.y, y: vector.x };
                }
                Vector.rotate90DegCCW = rotate90DegCCW;
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return { x: newX, y: newY };
                }
                Vector.rotate = rotate;
                function equal(vector1, vector2) {
                    return vector1 === vector2 || (vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y);
                }
                Vector.equal = equal;
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 || (vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y));
                }
                Vector.equalWithPrecision = equalWithPrecision;
                function add(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x + vect2.x, y: vect1.y + vect2.y };
                }
                Vector.add = add;
                function subtract(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x - vect2.x, y: vect1.y - vect2.y };
                }
                Vector.subtract = subtract;
                function dotProduct(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return vect1.x * vect2.x + vect1.y * vect2.y;
                }
                Vector.dotProduct = dotProduct;
                function getDeltaVector(p0, p1) {
                    if (!p0 || !p1) {
                        return undefined;
                    }
                    return { x: p1.x - p0.x, y: p1.y - p0.y };
                }
                Vector.getDeltaVector = getDeltaVector;
            })(Vector = shapes.Vector || (shapes.Vector = {}));
        })(shapes = visuals.shapes || (visuals.shapes = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in SVG manupilation.
        */
        var SVGUtil;
        (function (SVGUtil) {
            /**
             * very small values, when stringified, may be converted to scientific notation and cause a temporarily
             * invalid attribute or style property value. For example, the number 0.0000001 is converted to the string "1e-7".
             * This is particularly noticeable when interpolating opacity values. To avoid scientific notation,
             * start or end the transition at 1e-6, which is the smallest value that is not stringified in exponential notation.
            */
            SVGUtil.AlmostZero = 1e-6;
            /**
             * Creates a translate string for use with the SVG transform call.
            */
            function translate(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + ',' + y + ')';
            }
            SVGUtil.translate = translate;
            /**
             * Creates a translateX string for use with the SVG transform call.
            */
            function translateXWithPixels(x) {
                debug.assertValue(x, 'x');
                return 'translateX(' + x + 'px)';
            }
            SVGUtil.translateXWithPixels = translateXWithPixels;
            function translateWithPixels(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + 'px,' + y + 'px)';
            }
            SVGUtil.translateWithPixels = translateWithPixels;
            /**
             * Creates a translate + rotate string for use with the SVG transform call.
            */
            function translateAndRotate(x, y, px, py, angle) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(px, 'px');
                debug.assertValue(py, 'py');
                debug.assertValue(angle, 'angle');
                return 'transform', "translate(" + x + "," + y + ")" + " rotate(" + angle + "," + px + "," + py + ")";
            }
            SVGUtil.translateAndRotate = translateAndRotate;
            /**
             * Forces all D3 transitions to complete.
             * Normally, zero-delay transitions are executed after an instantaneous delay (<10ms).
             * This can cause a brief flicker if the browser renders the page twice: once at the end of the first event loop,
             * then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop,
             * you can run any zero-delay transitions immediately and avoid the flicker.
             *
             * These flickers are noticable on IE, and with a large number of webviews(not recommend you ever do this) on iOS.
             */
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function () {
                    return Infinity;
                };
                d3.timer.flush();
                Date.now = now;
            }
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
            /**
             * Wrapper for flushAllD3Transitions.
             */
            function flushAllD3TransitionsIfNeeded(options) {
                if (!options)
                    return;
                var animationOptions = options;
                var asVisualInitOptions = options;
                if (asVisualInitOptions.animation)
                    animationOptions = asVisualInitOptions.animation;
                if (animationOptions && animationOptions.transitionImmediate) {
                    flushAllD3Transitions();
                }
            }
            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
            /**
             * There is a known bug in IE10 that causes cryptic crashes for SVG elements with a null 'd' attribute:
             * https://github.com/mbostock/d3/issues/1737
            */
            function ensureDAttribute(pathElement) {
                if (!pathElement.getAttribute('d')) {
                    pathElement.setAttribute('d', '');
                }
            }
            SVGUtil.ensureDAttribute = ensureDAttribute;
            /**
             * In IE10, it is possible to return SVGPoints with NaN members
            */
            function ensureValidSVGPoint(point) {
                if (isNaN(point.x)) {
                    point.x = 0;
                }
                if (isNaN(point.y)) {
                    point.y = 0;
                }
            }
            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
            /**
             * Parse the Transform string with value 'translate(x,y)'
             * In Chrome for the translate(position) string the delimiter is a comma and in IE it is a space so checking for both
            */
            function parseTranslateTransform(input) {
                if (!input || input.length === 0) {
                    return {
                        x: "0",
                        y: "0",
                    };
                }
                var translateCoordinates = input.split(/[\s,]+/);
                debug.assertValue(translateCoordinates, 'translateCoordinates');
                debug.assert(translateCoordinates.length > 0, 'translate array must atleast have one value');
                var yValue = '0';
                var xValue;
                var xCoord = translateCoordinates[0];
                // Y coordinate is ommited in I.E if it is 0, so need to check against that
                if (translateCoordinates.length === 1) {
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length - 1);
                }
                else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1);
                    // 10 refers to the length of 'translate('
                    var xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            SVGUtil.parseTranslateTransform = parseTranslateTransform;
            /**
             * Appends 'px' to the end of number value for use as pixel string in styles
            */
            function convertToPixelString(value) {
                return value + "px";
            }
            SVGUtil.convertToPixelString = convertToPixelString;
        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in text manupilation.
        */
        var TextUtil;
        (function (TextUtil) {
            /**
             * remove breaking spaces from given string and replace by none breaking space (&nbsp)
            */
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(' ', 'g'), '&nbsp');
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Utility = jsCommon.Utility;
        var UrlHelper;
        (function (UrlHelper) {
            function isValidUrl(columnItem, value) {
                return columnItem != null && columnItem.type != null && columnItem.type.misc != null && columnItem.type.misc.webUrl != null && columnItem.type.misc.webUrl && value != null && Utility.isValidUrl(value);
            }
            UrlHelper.isValidUrl = isValidUrl;
        })(UrlHelper = visuals.UrlHelper || (visuals.UrlHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        ;
        var GradientUtils;
        (function (GradientUtils) {
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var DefaultMidColor = "#ffffff";
            function getFillRuleRole(objectDescs) {
                if (!objectDescs)
                    return;
                for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type['fillRule']) {
                            return propertyDesc.rule.inputRole;
                        }
                    }
                }
            }
            GradientUtils.getFillRuleRole = getFillRuleRole;
            function shouldShowGradient(visualConfig) {
                var isShowGradienCard = visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections['Gradient'] ? true : false;
                return isShowGradienCard;
            }
            GradientUtils.shouldShowGradient = shouldShowGradient;
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            if (value && value.solid && value.solid.color) {
                                value = value.solid.color;
                            }
                            gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values) {
                    var grouped = dataViewCategorical.values.grouped();
                    return visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                }
                return -1;
            }
            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRole = hasGradientRole;
            function getDefaultGradientSettings() {
                var colors = getDefaultColors();
                var gradientSettings = {
                    diverging: false,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: undefined,
                    midValue: undefined,
                    maxValue: undefined,
                };
                return gradientSettings;
            }
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
            function getDefaultFillRuleDefinition() {
                return getLinearGradien2FillRuleDefinition();
            }
            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
            function updateFillRule(propertyName, propertyValue, definitions) {
                var dataPointProperties = definitions["dataPoint"][0].properties;
                var fillRule = dataPointProperties.fillRule;
                var numericValueExpr;
                if (!fillRule) {
                    return;
                }
                if ($.isNumeric(propertyValue)) {
                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
                    ;
                }
                if (propertyName === "minColor") {
                    updateMinColor(fillRule, propertyValue);
                }
                else if (propertyName === "midColor") {
                    updateMidColor(fillRule, propertyValue);
                }
                else if (propertyName === "maxColor") {
                    updateMaxColor(fillRule, propertyValue);
                }
                else if (propertyName === "minValue") {
                    updateMinValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "midValue") {
                    updateMidValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "maxValue") {
                    updateMaxValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "diverging") {
                    if (propertyValue) {
                        fillRule = getLinearGradien3FillRuleDefinition(fillRule);
                    }
                    else {
                        fillRule = getLinearGradien2FillRuleDefinition(fillRule);
                    }
                    dataPointProperties.fillRule = fillRule;
                }
                else if (propertyName === "revertToDefault") {
                    fillRule = this.getDefaultFillRuleDefinition();
                    dataPointProperties.fillRule = fillRule;
                }
            }
            GradientUtils.updateFillRule = updateFillRule;
            function getGradientSettings(baseFillRule) {
                if (baseFillRule) {
                    return getGradientSettingsFromRule(baseFillRule);
                }
                else {
                    return getDefaultGradientSettings();
                }
            }
            GradientUtils.getGradientSettings = getGradientSettings;
            function getFillRule(objectDefinitions) {
                if (objectDefinitions && objectDefinitions["dataPoint"] && objectDefinitions["dataPoint"].length > 0 && objectDefinitions["dataPoint"][0].properties) {
                    return objectDefinitions["dataPoint"][0].properties['fillRule'];
                }
                return null;
            }
            GradientUtils.getFillRule = getFillRule;
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette();
                var maxColorInfo = dataColors.getColor(0);
                var colors = d3.scale.linear().domain([0, 100]).range(["#ffffff", maxColorInfo.value]);
                var maxColor = maxColorInfo.value;
                var minColor = colors(20);
                var midColor = DefaultMidColor;
                return {
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor;
                var minColor;
                var midColor = DefaultMidColor;
                var maxValue;
                var midValue;
                var minValue;
                var diverging = fillRule.linearGradient3 !== undefined;
                if (fillRule.linearGradient2) {
                    var maxColorExpr = fillRule.linearGradient2.max.color;
                    var minColorExpr = fillRule.linearGradient2.min.color;
                    var maxValueExpr = fillRule.linearGradient2.max.value;
                    var minValueExpr = fillRule.linearGradient2.min.value;
                    maxColor = maxColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                else if (fillRule.linearGradient3) {
                    var maxColorExpr = fillRule.linearGradient3.max.color;
                    var midColorExpr = fillRule.linearGradient3.mid.color;
                    var minColorExpr = fillRule.linearGradient3.min.color;
                    var maxValueExpr = fillRule.linearGradient3.max.value;
                    var midValueExpr = fillRule.linearGradient3.mid.value;
                    var minValueExpr = fillRule.linearGradient3.min.value;
                    maxColor = maxColorExpr.value;
                    midColor = midColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (midValueExpr) {
                        midValue = midValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                return {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    minValue: minValue,
                    midValue: midValue,
                    maxValue: maxValue,
                };
            }
            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
            function getLinearGradien2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient2: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function getLinearGradien3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient3: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        mid: { color: SQExprBuilder.text(gradientSettings.midColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function updateMinColor(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.color = SQExprBuilder.text(value);
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.color = SQExprBuilder.text(value);
                }
            }
            function updateMidColor(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.color = SQExprBuilder.text(value);
                }
            }
            function updateMaxColor(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.color = SQExprBuilder.text(value);
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.color = SQExprBuilder.text(value);
                }
            }
            function updateMinValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.value = value;
                }
            }
            function updateMidValue(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.value = value;
                }
            }
            function updateMaxValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.value = value;
                }
            }
        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
        ;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualBackgroundHelper;
        (function (visualBackgroundHelper) {
            function getDefaultColor() {
                return '#FFF';
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultTransparency() {
                return 50;
            }
            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
            function getDefaultShow() {
                return true;
            }
            visualBackgroundHelper.getDefaultShow = getDefaultShow;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            visualBackgroundHelper.getDefaultValues = getDefaultValues;
        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var shapes = powerbi.visuals.shapes;
    /** Defines possible content positions.  */
    (function (ContentPositions) {
        /** Content position is not defined. */
        ContentPositions[ContentPositions["None"] = 0] = "None";
        /** Content aligned top left. */
        ContentPositions[ContentPositions["TopLeft"] = 1] = "TopLeft";
        /** Content aligned top center. */
        ContentPositions[ContentPositions["TopCenter"] = 2] = "TopCenter";
        /** Content aligned top right. */
        ContentPositions[ContentPositions["TopRight"] = 4] = "TopRight";
        /** Content aligned middle left. */
        ContentPositions[ContentPositions["MiddleLeft"] = 8] = "MiddleLeft";
        /** Content aligned middle center. */
        ContentPositions[ContentPositions["MiddleCenter"] = 16] = "MiddleCenter";
        /** Content aligned middle right. */
        ContentPositions[ContentPositions["MiddleRight"] = 32] = "MiddleRight";
        /** Content aligned bottom left. */
        ContentPositions[ContentPositions["BottomLeft"] = 64] = "BottomLeft";
        /** Content aligned bottom center. */
        ContentPositions[ContentPositions["BottomCenter"] = 128] = "BottomCenter";
        /** Content aligned bottom right. */
        ContentPositions[ContentPositions["BottomRight"] = 256] = "BottomRight";
        /** Content is placed inside the bounding rectangle in the center. */
        ContentPositions[ContentPositions["InsideCenter"] = 512] = "InsideCenter";
        /** Content is placed inside the bounding rectangle at the base. */
        ContentPositions[ContentPositions["InsideBase"] = 1024] = "InsideBase";
        /** Content is placed inside the bounding rectangle at the end. */
        ContentPositions[ContentPositions["InsideEnd"] = 2048] = "InsideEnd";
        /** Content is placed outside the bounding rectangle at the base. */
        ContentPositions[ContentPositions["OutsideBase"] = 4096] = "OutsideBase";
        /** Content is placed outside the bounding rectangle at the end. */
        ContentPositions[ContentPositions["OutsideEnd"] = 8192] = "OutsideEnd";
        /** Content supports all possible positions. */
        ContentPositions[ContentPositions["All"] = ContentPositions.TopLeft | ContentPositions.TopCenter | ContentPositions.TopRight | ContentPositions.MiddleLeft | ContentPositions.MiddleCenter | ContentPositions.MiddleRight | ContentPositions.BottomLeft | ContentPositions.BottomCenter | ContentPositions.BottomRight | ContentPositions.InsideCenter | ContentPositions.InsideBase | ContentPositions.InsideEnd | ContentPositions.OutsideBase | ContentPositions.OutsideEnd] = "All";
    })(powerbi.ContentPositions || (powerbi.ContentPositions = {}));
    var ContentPositions = powerbi.ContentPositions;
    /**
    * Rectangle orientation. Rectangle orientation is used to define vertical or horizontal orientation
    * and starting/ending side of the rectangle.
    */
    (function (RectOrientation) {
        /** Rectangle with no specific orientation. */
        RectOrientation[RectOrientation["None"] = 0] = "None";
        /** Vertical rectangle with base at the bottom. */
        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
        /** Vertical rectangle with base at the top. */
        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
        /** Horizontal rectangle with base at the left. */
        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
        /** Horizontal rectangle with base at the right. */
        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
    })(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    var RectOrientation = powerbi.RectOrientation;
    /**
    * Defines if panel elements are allowed to be positioned
    * outside of the panel boundaries.
    */
    (function (OutsidePlacement) {
        /** Elements can be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
        /** Elements can not be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
        /** Elements can be partially outside of the panel. */
        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
    })(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    var OutsidePlacement = powerbi.OutsidePlacement;
    /**
    * Arranges label elements using the anchor point or rectangle. Collisions
    * between elements can be automatically detected and as a result elements
    * can be repositioned or get hidden.
    */
    var DataLabelManager = (function () {
        /**
        * Initializes a new instance of the DataLabelsPanel class.
        * @constructor
        */
        function DataLabelManager() {
            this.movingStep = 3;
            this.hideOverlapped = true;
            // The global settings for all labels. 
            // They can be oweridden by each label we add into the panel, because contains same properties.
            this._defaultSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: 0 /* None */,
                contentPosition: 128 /* BottomCenter */,
                outsidePlacement: 1 /* Disallowed */,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128 /* BottomCenter */,
                opacity: 1
            };
        }
        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function () {
                return this._defaultSettings;
            },
            enumerable: true,
            configurable: true
        });
        /** Arranges the lables position and visibility*/
        DataLabelManager.prototype.hideCollidedLabels = function (viewport, data, layout) {
            this._size = { width: viewport.width, height: viewport.height };
            // Split size into a grid
            var arrangeGrid = new DataLabelArrangeGrid(this._size, data, layout);
            var filteredData = [];
            for (var i = 0, len = data.length; i < len; i++) {
                // Filter unwanted data points
                if (!layout.filter(data[i]))
                    continue;
                // Set default values where properties values are undefined
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]),
                    y: layout.labelLayout.y(data[i])
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, this._size)) {
                    data[i].labelX = position.left;
                    data[i].labelY = position.top;
                    // Keep track of all panel elements positions.
                    arrangeGrid.add(info, position);
                    // Save all data points to display
                    filteredData.push(data[i]);
                }
            }
            return filteredData;
        };
        /**
        * Merges the label element info with the panel element info and returns correct label info.
        * @param {ILabelElementInfo} source The label info.
        * @return {ILabelElementInfo}
        */
        DataLabelManager.prototype.getLabelInfo = function (source) {
            var settings = this._defaultSettings;
            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
            source.maximumMovingDistance += source.anchorMargin;
            return source;
        };
        /**
        * (Private) Calculates element position using anchor point..
        */
        DataLabelManager.prototype.calculateContentPositionFromPoint = function (anchorPoint, contentPosition, contentSize, offset) {
            var position = { x: 0, y: 0 };
            if (anchorPoint) {
                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
                    position.x = anchorPoint.x;
                    switch (contentPosition) {
                        case 1 /* TopLeft */:
                        case 8 /* MiddleLeft */:
                        case 64 /* BottomLeft */:
                            position.x -= contentSize.width / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 32 /* MiddleRight */:
                        case 256 /* BottomRight */:
                            position.x += contentSize.width / 2.0;
                            break;
                    }
                }
                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
                    position.y = anchorPoint.y;
                    switch (contentPosition) {
                        case 8 /* MiddleLeft */:
                        case 16 /* MiddleCenter */:
                        case 32 /* MiddleRight */:
                            position.y -= contentSize.height / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 1 /* TopLeft */:
                        case 2 /* TopCenter */:
                            position.y -= contentSize.height;
                            break;
                    }
                }
                if (offset !== undefined && isFinite(offset)) {
                    switch (contentPosition) {
                        case 1 /* TopLeft */:
                            position.x -= offset;
                            position.y -= offset;
                            break;
                        case 8 /* MiddleLeft */:
                            position.x -= offset;
                            break;
                        case 64 /* BottomLeft */:
                            position.x -= offset;
                            position.y += offset;
                            break;
                        case 2 /* TopCenter */:
                            position.y -= offset;
                            break;
                        case 16 /* MiddleCenter */:
                            break;
                        case 128 /* BottomCenter */:
                            position.y += offset;
                            break;
                        case 4 /* TopRight */:
                            position.x += offset;
                            position.y -= offset;
                            break;
                        case 32 /* MiddleRight */:
                            position.x += offset;
                            break;
                        case 256 /* BottomRight */:
                            position.x += offset;
                            position.y += offset;
                            break;
                        default:
                            debug.assertFail("Unsupported content position.");
                            break;
                    }
                }
            }
            return { left: position.x, top: position.y, width: contentSize.width, height: contentSize.height };
        };
        /** (Private) Calculates element position using anchor rect. */
        DataLabelManager.prototype.calculateContentPositionFromRect = function (anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
                case 512 /* InsideCenter */:
                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 2048 /* InsideEnd */:
                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 1024 /* InsideBase */:
                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 8192 /* OutsideEnd */:
                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 4096 /* OutsideBase */:
                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                default:
                    debug.assertFail("Unsupported ContentPosition.");
            }
            return { left: 0, top: 0, width: -1, height: -1 };
        };
        /** (Private) Calculates element inside center position using anchor rect. */
        DataLabelManager.prototype.handleInsideCenterPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case 1 /* VerticalBottomTop */:
                case 2 /* VerticalTopBottom */:
                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);
                case 3 /* HorizontalLeftRight */:
                case 4 /* HorizontalRightLeft */:
                default:
                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside end position using anchor rect. */
        DataLabelManager.prototype.handleInsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case 1 /* VerticalBottomTop */:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case 2 /* VerticalTopBottom */:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case 4 /* HorizontalRightLeft */:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
                case 3 /* HorizontalLeftRight */:
                default:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside base position using anchor rect. */
        DataLabelManager.prototype.handleInsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case 1 /* VerticalBottomTop */:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case 2 /* VerticalTopBottom */:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case 4 /* HorizontalRightLeft */:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
                case 3 /* HorizontalLeftRight */:
                default:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside end position using anchor rect. */
        DataLabelManager.prototype.handleOutsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case 1 /* VerticalBottomTop */:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case 2 /* VerticalTopBottom */:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case 4 /* HorizontalRightLeft */:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
                case 3 /* HorizontalLeftRight */:
                default:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside base position using anchor rect. */
        DataLabelManager.prototype.handleOutsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case 1 /* VerticalBottomTop */:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case 2 /* VerticalTopBottom */:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case 4 /* HorizontalRightLeft */:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
                case 3 /* HorizontalLeftRight */:
                default:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        };
        /**  (Private) Calculates element position. */
        DataLabelManager.prototype.calculateContentPosition = function (anchoredElementInfo, contentPosition, contentSize, offset) {
            if (contentPosition !== 2048 /* InsideEnd */ && contentPosition !== 512 /* InsideCenter */ && contentPosition !== 1024 /* InsideBase */ && contentPosition !== 4096 /* OutsideBase */ && contentPosition !== 8192 /* OutsideEnd */) {
                // Determine position using anchor point.
                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
            }
            // Determine position using anchor rectangle.
            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        };
        /** (Private) Check for collisions. */
        DataLabelManager.prototype.hasCollisions = function (arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) {
                return true;
            }
            // Since we divide the height by 2 we add it back to the top of the view port so labels won't be cut off
            var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
            intersection = rect.inflate(intersection, { left: DataLabelManager.InflateAmount, top: 0, right: DataLabelManager.InflateAmount, bottom: 0 });
            intersection = rect.intersect(intersection, position);
            if (rect.isEmpty(intersection))
                // Empty rectangle means there is a collision
                return true;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
                case 1 /* Disallowed */:
                    return lessWithPrecision(intersection.width, position.width) || lessWithPrecision(intersection.height, position.height / 2);
                case 2 /* Partial */:
                    return lessWithPrecision(intersection.width, position.width / 2) || lessWithPrecision(intersection.height, position.height / 4);
            }
            return false;
        };
        DataLabelManager.isValid = function (rect) {
            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
        };
        DataLabelManager.DefaultAnchorMargin = 0; // For future use
        DataLabelManager.DefaultMaximumMovingDistance = 12;
        DataLabelManager.DefaultMinimumMovingDistance = 3;
        DataLabelManager.InflateAmount = 5;
        return DataLabelManager;
    })();
    powerbi.DataLabelManager = DataLabelManager;
    /**
    * Utility class to speed up the conflict detection by collecting the arranged items in the DataLabelsPanel.
    */
    var DataLabelArrangeGrid = (function () {
        /**
        * Creates new ArrangeGrid.
        * @param {DataLabelManager} manager The owner data labels.
        * @param {shapes.ISize} size The available size
        */
        function DataLabelArrangeGrid(size, elements, layout) {
            this._grid = [];
            if (size.width === 0 || size.height === 0) {
                this._cellSize = size;
                this._rowCount = this._colCount = 0;
            }
            //sets the _cell size to be twice of the Max with and Max height of the elements 
            this._cellSize = { width: 0, height: 0 };
            for (var i = 0, len = elements.length; i < len; i++) {
                var child = elements[i];
                // Fill label field
                child.labeltext = layout.labelText(child);
                var properties = {
                    fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                    text: child.labeltext,
                };
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.measureSvgTextHeight(properties),
                };
                var w = child.size.width * 2;
                var h = child.size.height * 2;
                if (w > this._cellSize.width)
                    this._cellSize.width = w;
                if (h > this._cellSize.height)
                    this._cellSize.height = h;
            }
            if (this._cellSize.width === 0)
                this._cellSize.width = size.width;
            if (this._cellSize.height === 0)
                this._cellSize.height = size.height;
            this._colCount = this.getGridRowColCount(this._cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this._rowCount = this.getGridRowColCount(this._cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this._cellSize.width = size.width / this._colCount;
            this._cellSize.height = size.height / this._rowCount;
            var grid = this._grid;
            for (var x = 0; x < this._colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this._rowCount; y++) {
                    grid[x][y] = [];
                }
            }
        }
        /**
        * Register a new label element.
        * @param {ILabelElement} element The label element to register.
        * @param {shapes.IRect} rect The label element position rectangle.
        */
        DataLabelArrangeGrid.prototype.add = function (element, rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this._grid;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    grid[x][y].push({ element: element, rect: rect });
                }
            }
        };
        /**
        * Checks for conflict of given rectangle in registered elements.
        * @param {shapes.IRect} rect The rectengle to check.
        * @return {Boolean} True if conflict is detected.
        */
        DataLabelArrangeGrid.prototype.hasConflict = function (rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this._grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    for (var z = 0; z < grid[x][y].length; z++) {
                        var item = grid[x][y][z];
                        if (isIntersecting(item.rect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
        * Calculates the number of rows or columns in a grid
        * @param {number} step is the largest label size (width or height)
        * @param {number} length is the grid size (width or height)
        * @param {number} minCount is the minimum allowed size
        * @param {number} maxCount is the maximum allowed size
        * @return {number} the number of grid rows or columns
        */
        DataLabelArrangeGrid.prototype.getGridRowColCount = function (step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        };
        /**
        * Returns the grid index of a given recangle
        * @param {shapes.IRect} rect The rectengle to check.
        * @return {shapes.IThickness} grid index as a thickness object.
        */
        DataLabelArrangeGrid.prototype.getGridIndexRect = function (rect) {
            var restrict = function (n, min, max) { return Math.min(Math.max(n, min), max); };
            return {
                left: restrict(Math.floor(rect.left / this._cellSize.width), 0, this._colCount),
                top: restrict(Math.floor(rect.top / this._cellSize.height), 0, this._rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this._cellSize.width), 0, this._colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this._cellSize.height), 0, this._rowCount)
            };
        };
        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
        return DataLabelArrangeGrid;
    })();
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    /**
    * (Private) Contains methods for calculating the top-left coordinate of rectangle based on content size and anchor rect.
    */
    var LocationConverter;
    (function (LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside;
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomInside = bottomInside;
        function rightInside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightInside = rightInside;
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftInside = leftInside;
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topOutside = topOutside;
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomOutside = bottomOutside;
        function rightOutside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightOutside = rightOutside;
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftOutside = leftOutside;
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0 + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleHorizontal = middleHorizontal;
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + rect.height / 2.0 - size.height / 2.0 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleVertical = middleVertical;
    })(LocationConverter || (LocationConverter = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Repreasents the sequence of the dates/times */
    var DateTimeSequence = (function () {
        // Constructors
        /** Creates new instance of the DateTimeSequence */
        function DateTimeSequence(unit) {
            this.unit = unit;
            this.sequence = [];
            this.min = new Date("9999-12-31T23:59:59.999");
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        // Methods
        /** Add a new Date to a sequence.
          * @param x - date to add
          */
        DateTimeSequence.prototype.add = function (date) {
            if (date < this.min) {
                this.min = date;
            }
            if (date > this.max) {
                this.max = date;
            }
            this.sequence.push(date);
        };
        // Methods
        /** Extends the sequence to cover new date range
          * @param min - new min to be covered by sequence
          * @param max - new max to be covered by sequence
          */
        DateTimeSequence.prototype.extendToCover = function (min, max) {
            var x = this.min;
            while (min < x) {
                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);
                this.sequence.splice(0, 0, x);
            }
            this.min = x;
            x = this.max;
            while (x < max) {
                x = DateTimeSequence.addInterval(x, this.interval, this.unit);
                this.sequence.push(x);
            }
            this.max = x;
        };
        /** Move the sequence to cover new date range
          * @param min - new min to be covered by sequence
          * @param max - new max to be covered by sequence
          */
        DateTimeSequence.prototype.moveToCover = function (min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit);
            var count = Math.floor(delta / this.interval);
            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);
            this.sequence = [];
            this.sequence.push(this.min);
            this.max = this.min;
            while (this.max < max) {
                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);
                this.sequence.push(this.max);
            }
        };
        // Static
        /** Calculate a new DateTimeSequence
          * @param dataMin - Date representing min of the data range
          * @param dataMax - Date representing max of the data range
          * @param expectedCount - expected number of intervals in the sequence
          * @param unit - of the intervals in the sequence
          */
        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {
            if (!unit) {
                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);
            }
            switch (unit) {
                case 0 /* Year */:
                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);
                case 1 /* Month */:
                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);
                case 2 /* Week */:
                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);
                case 3 /* Day */:
                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);
                case 4 /* Hour */:
                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);
                case 5 /* Minute */:
                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);
                case 6 /* Second */:
                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);
                case 7 /* Millisecond */:
                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);
                default:
                    debug.assertFail("Unsupported DateTimeUnit");
            }
        };
        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "Expected count is out of range");
            // Calculate range and sequence
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);
            var yearsSequence = powerbi.NumericSequence.calculate(yearsRange, expectedCount, 0);
            var years = yearsSequence.sequence;
            // Convert to date sequence
            var result = new DateTimeSequence(0 /* Year */);
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                if (year) {
                    result.add(new Date(year, 0, 1));
                }
            }
            result.interval = yearsSequence.interval;
            result.intervalOffset = yearsSequence.intervalOffset;
            return result;
        };
        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var minYear = dataMin.getFullYear();
            var maxYear = dataMax.getFullYear();
            var minMonth = dataMin.getMonth();
            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();
            var date = new Date(minYear, 0, 1);
            // Calculate month sequence 
            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 1 /* Month */);
            return result;
        };
        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            var firstDayOfWeek = 0;
            var minDayOfWeek = dataMin.getDay();
            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;
            var minDay = dataMin.getDate() - dayOffset;
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 2 /* Week */));
            // Calculate week sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 2 /* Week */);
            return result;
        };
        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, 3 /* Day */));
            // Calculate day sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 3 /* Day */);
            return result;
        };
        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 4 /* Hour */));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 4 /* Hour */));
            // Calculate hour sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 4 /* Hour */);
            return result;
        };
        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 5 /* Minute */));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 5 /* Minute */));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 5 /* Minute */);
            return result;
        };
        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 6 /* Second */));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 6 /* Second */));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 6 /* Second */);
            return result;
        };
        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());
            var min = DateTimeSequence.getDelta(date, dataMin, 7 /* Millisecond */);
            var max = DateTimeSequence.getDelta(date, dataMax, 7 /* Millisecond */);
            // Calculate milliseconds numeric sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 7 /* Millisecond */);
            return result;
        };
        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {
            var result = new DateTimeSequence(unit);
            for (var i = 0; i < sequence.sequence.length; i++) {
                var x = sequence.sequence[i];
                var d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            result.interval = sequence.interval;
            result.intervalOffset = sequence.intervalOffset;
            return result;
        };
        DateTimeSequence.addInterval = function (value, interval, unit) {
            interval = Math.round(interval);
            switch (unit) {
                case 0 /* Year */:
                    return DateUtils.addYears(value, interval);
                case 1 /* Month */:
                    return DateUtils.addMonths(value, interval);
                case 2 /* Week */:
                    return DateUtils.addWeeks(value, interval);
                case 3 /* Day */:
                    return DateUtils.addDays(value, interval);
                case 4 /* Hour */:
                    return DateUtils.addHours(value, interval);
                case 5 /* Minute */:
                    return DateUtils.addMinutes(value, interval);
                case 6 /* Second */:
                    return DateUtils.addSeconds(value, interval);
                case 7 /* Millisecond */:
                    return DateUtils.addMilliseconds(value, interval);
            }
        };
        DateTimeSequence.getDelta = function (min, max, unit) {
            var delta = 0;
            switch (unit) {
                case 0 /* Year */:
                    delta = max.getFullYear() - min.getFullYear();
                    break;
                case 1 /* Month */:
                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();
                    break;
                case 2 /* Week */:
                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);
                    break;
                case 3 /* Day */:
                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);
                    break;
                case 4 /* Hour */:
                    delta = (max.getTime() - min.getTime()) / 3600000;
                    break;
                case 5 /* Minute */:
                    delta = (max.getTime() - min.getTime()) / 60000;
                    break;
                case 6 /* Second */:
                    delta = (max.getTime() - min.getTime()) / 1000;
                    break;
                case 7 /* Millisecond */:
                    delta = max.getTime() - min.getTime();
                    break;
            }
            return delta;
        };
        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, 3 /* Day */);
            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)
                return 0 /* Year */;
            if (totalDays > 60 && totalDays > 7 * maxCount)
                return 1 /* Month */;
            if (totalDays > 14 && totalDays > 2 * maxCount)
                return 2 /* Week */;
            var totalHours = DateTimeSequence.getDelta(min, max, 4 /* Hour */);
            if (totalDays > 2 && totalHours > 12 * maxCount)
                return 3 /* Day */;
            if (totalHours >= 24 && totalHours >= maxCount)
                return 4 /* Hour */;
            var totalMinutes = DateTimeSequence.getDelta(min, max, 5 /* Minute */);
            if (totalMinutes > 2 && totalMinutes >= maxCount)
                return 5 /* Minute */;
            var totalSeconds = DateTimeSequence.getDelta(min, max, 6 /* Second */);
            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)
                return 6 /* Second */;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, 7 /* Millisecond */);
            if (totalMilliseconds > 0)
                return 7 /* Millisecond */;
            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds
            var date = min;
            if (date.getMilliseconds() !== 0)
                return 7 /* Millisecond */;
            if (date.getSeconds() !== 0)
                return 6 /* Second */;
            if (date.getMinutes() !== 0)
                return 5 /* Minute */;
            if (date.getHours() !== 0)
                return 4 /* Hour */;
            if (date.getDate() !== 1)
                return 3 /* Day */;
            if (date.getMonth() !== 0)
                return 1 /* Month */;
            return 0 /* Year */;
        };
        // Constants
        DateTimeSequence.MIN_COUNT = 1;
        DateTimeSequence.MAX_COUNT = 1000;
        return DateTimeSequence;
    })();
    powerbi.DateTimeSequence = DateTimeSequence;
    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */
    var DateUtils;
    (function (DateUtils) {
        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        /** Returns bool indicating weither the provided year is a leap year.
          * @param year - year value
          */
        function isLeap(year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        }
        /** Returns number of days in the provided year/month.
          * @param year - year value
          * @param month - month value
          */
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        /** Adds a specified number of years to the provided date.
          * @param date - date value
          * @param yearDelta - number of years to add
          */
        function addYears(date, yearDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var isLeapDay = month === 2 && day === 29;
            var result = new Date(date.getTime());
            var year = year + yearDelta;
            if (isLeapDay && !isLeap(year)) {
                day = 28;
            }
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addYears = addYears;
        /** Adds a specified number of months to the provided date.
          * @param date - date value
          * @param monthDelta - number of months to add
          */
        function addMonths(date, monthDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            year += (monthDelta - (monthDelta % 12)) / 12;
            month += monthDelta % 12;
            // VSTS 1325771: Certain column charts don't display any data
            // Wrap arround the month if is after december (value 11)
            if (month > 11) {
                month = month % 12;
                year++;
            }
            day = Math.min(day, getMonthDays(year, month));
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addMonths = addMonths;
        /** Adds a specified number of weeks to the provided date.
          * @param date - date value
          * @param weekDelta - number of weeks to add
          */
        function addWeeks(date, weeks) {
            return addDays(date, weeks * 7);
        }
        DateUtils.addWeeks = addWeeks;
        /** Adds a specified number of days to the provided date.
          * @param date - date value
          * @param dayDelta - number of days to add
          */
        function addDays(date, days) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            result.setFullYear(year, month, day + days);
            return result;
        }
        DateUtils.addDays = addDays;
        /** Adds a specified number of hours to the provided date.
          * @param date - date value
          * @param hours - number of hours to add
          */
        function addHours(date, hours) {
            return new Date(date.getTime() + hours * 3600000);
        }
        DateUtils.addHours = addHours;
        /** Adds a specified number of minutes to the provided date.
          * @param date - date value
          * @param minutes - number of minutes to add
          */
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }
        DateUtils.addMinutes = addMinutes;
        /** Adds a specified number of seconds to the provided date.
          * @param date - date value
          * @param seconds - number of seconds to add
          */
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + seconds * 1000);
        }
        DateUtils.addSeconds = addSeconds;
        /** Adds a specified number of milliseconds to the provided date.
          * @param date - date value
          * @param milliseconds - number of milliseconds to add
          */
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        DateUtils.addMilliseconds = addMilliseconds;
    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var powerbi;
(function (powerbi) {
    var maxExponent = 24;
    var defaultScientificBigNumbersBoundary = 1E14;
    var scientificSmallNumbersBoundary = 1E-4;
    var DisplayUnit = (function () {
        function DisplayUnit() {
        }
        // Methods
        DisplayUnit.prototype.project = function (value) {
            if (this.value) {
                return value / this.value;
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.reverseProject = function (value) {
            if (this.value) {
                return value * this.value;
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.isApplicableTo = function (value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        };
        return DisplayUnit;
    })();
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = (function () {
        // Constructor
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            // Properties
            get: function () {
                return this.displayUnit ? this.displayUnit.title : undefined;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        DisplayUnitSystem.prototype.update = function (value) {
            if (value === undefined)
                return;
            this._unitBaseValue = value;
            this.displayUnit = this.findApplicableDisplayUnit(value);
        };
        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {
            var count = this.units.length;
            for (var i = 0; i < count; i++) {
                var unit = this.units[i];
                if (unit.isApplicableTo(value)) {
                    return unit;
                }
            }
            return undefined;
        };
        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {
            if (!DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format)) {
                if (this.displayUnit) {
                    var projectedValue = this.displayUnit.project(value);
                    var nonScientificFormat = (trailingZeros) ? DisplayUnitSystem.getNonScientificFormatWithPrecision(this.displayUnit.labelFormat, decimals) : this.displayUnit.labelFormat;
                    return this.formatHelper(value, projectedValue, nonScientificFormat, format, decimals, trailingZeros);
                }
                if (decimals != null) {
                    if (trailingZeros && format && DisplayUnitSystem.NUMBER_FORMAT.test(format)) {
                        var formatWithPrecision = DisplayUnitSystem.getFormatWithPrecision(decimals);
                        format = format.replace(/0\.0*/g, formatWithPrecision);
                        return this.formatHelper(value, value, '', format, decimals, trailingZeros);
                    }
                    if (trailingZeros) {
                        var nonScientificFormat = DisplayUnitSystem.getNonScientificFormatWithPrecision('{0}', decimals);
                        return this.formatHelper(value, value, nonScientificFormat, format, decimals, trailingZeros);
                    }
                    return this.formatHelper(value, value, '', format, decimals, trailingZeros);
                }
            }
            format = this.removeFractionIfNecessary(format);
            return powerbi.formattingService.formatValue(value, format);
        };
        DisplayUnitSystem.prototype.formatHelper = function (value, projectedValue, nonScientificFormat, format, decimals, trailingZeros) {
            var precision = (decimals != null) ? powerbi.Double.pow10(decimals) : powerbi.Double.getPrecision(value);
            var x = powerbi.Double.roundToPrecision(projectedValue, precision);
            if (format && !powerbi.formattingService.isStandardNumberFormat(format))
                return powerbi.formattingService.formatNumberWithCustomOverride(x, format, nonScientificFormat);
            var textFormat = trailingZeros ? DisplayUnitSystem.getFormatWithPrecision(decimals) : 'G';
            var text = powerbi.formattingService.formatValue(x, textFormat);
            return powerbi.formattingService.format(nonScientificFormat, [text]);
        };
        DisplayUnitSystem.getNonScientificFormatWithPrecision = function (baseFormat, decimals) {
            if (!decimals || baseFormat === undefined)
                return baseFormat;
            var newFormat = "{0:" + DisplayUnitSystem.getFormatWithPrecision(decimals) + "}";
            return baseFormat.replace("{0}", newFormat);
        };
        DisplayUnitSystem.getFormatWithPrecision = function (decimals) {
            if (decimals == null)
                return 'G';
            return "0." + jsCommon.StringExtensions.repeat('0', Math.abs(decimals));
        };
        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */
        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals) {
            // Change unit base to a value appropriate for this value
            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);
            return this.format(value, format, decimals);
        };
        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {
            if (this.units.length === 0)
                return true;
            // Check if the value is big enough to have a valid unit by checking against the smallest unit.
            return Math.abs(value) < this.units[0].applicableRangeMin;
        };
        DisplayUnitSystem.prototype.removeFractionIfNecessary = function (formatString) {
            if (formatString) {
                if (Math.abs(this._unitBaseValue) >= 0.01) {
                    formatString = formatString.replace(/^(p\d*)$/i, "p0");
                }
                if (Math.abs(this._unitBaseValue) >= 1.0) {
                    formatString = formatString.replace(/[#0]\.[#0]+$/, "0"); // Custom number format with hash/zero fraction
                    formatString = formatString.replace(/^(n\d*)$/i, "n0");
                    formatString = formatString.replace(/^(f\d*)$/i, "f0");
                    formatString = formatString.replace(/^(c\d*)$/i, "c0");
                }
            }
            return formatString;
        };
        // Constants
        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(.*\%)|(e\d*)$/i;
        DisplayUnitSystem.NUMBER_FORMAT = /#|0/;
        return DisplayUnitSystem;
    })();
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */
    var NoDisplayUnitSystem = (function (_super) {
        __extends(NoDisplayUnitSystem, _super);
        // Constructor
        function NoDisplayUnitSystem() {
            _super.call(this, []);
        }
        return NoDisplayUnitSystem;
    })(DisplayUnitSystem);
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where
        we are showing values (chart axes) and as such it is the default unit system. */
    var DefaultDisplayUnitSystem = (function (_super) {
        __extends(DefaultDisplayUnitSystem, _super);
        // Constructor
        function DefaultDisplayUnitSystem(unitLookup) {
            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));
        }
        // Methods
        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            // Use scientific format outside of the range
            if (!this.displayUnit && this.isScientific(data)) {
                if (!format || format.toUpperCase().indexOf("E") < 0) {
                    format = "0.######E+0";
                }
            }
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        DefaultDisplayUnitSystem.prototype.isScientific = function (value) {
            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary || (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);
        };
        DefaultDisplayUnitSystem.reset = function () {
            DefaultDisplayUnitSystem._units = null;
        };
        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DefaultDisplayUnitSystem._units) {
                DefaultDisplayUnitSystem._units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {
                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc
                    if (value - previousUnitValue >= 1000) {
                        return value / 10;
                    }
                    return min;
                });
                // Set scientific value boundary
                DefaultDisplayUnitSystem._scientificBigNumbersBoundary = defaultScientificBigNumbersBoundary;
                for (var i = 0, len = DefaultDisplayUnitSystem._units.length; i < len; ++i) {
                    var unit = DefaultDisplayUnitSystem._units[i];
                    if (unit.applicableRangeMax > DefaultDisplayUnitSystem._scientificBigNumbersBoundary) {
                        DefaultDisplayUnitSystem._scientificBigNumbersBoundary = unit.applicableRangeMax;
                    }
                }
            }
            return DefaultDisplayUnitSystem._units;
        };
        return DefaultDisplayUnitSystem;
    })(DisplayUnitSystem);
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least
        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles
        where we have restricted space but do not want to show partial units. */
    var WholeUnitsDisplayUnitSystem = (function (_super) {
        __extends(WholeUnitsDisplayUnitSystem, _super);
        // Constructor
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));
        }
        WholeUnitsDisplayUnitSystem.reset = function () {
            WholeUnitsDisplayUnitSystem._units = null;
        };
        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!WholeUnitsDisplayUnitSystem._units) {
                WholeUnitsDisplayUnitSystem._units = createDisplayUnits(unitLookup);
            }
            return WholeUnitsDisplayUnitSystem._units;
        };
        return WholeUnitsDisplayUnitSystem;
    })(DisplayUnitSystem);
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        var units = [];
        for (var i = 3; i < maxExponent; i++) {
            var names = unitLookup(i);
            if (names)
                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                if (adjustMinBasedOnPreviousUnit)
                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value;
            unit.applicableRangeMin = min;
            unit.applicableRangeMax = min * 1000;
            unit.title = title;
            unit.labelFormat = labelFormat;
            units.push(unit);
        }
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequence = (function () {
        function NumericSequence() {
        }
        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            debug.assertValue(range, "range");
            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), "expectedCount");
            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), "minPower");
            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), "maxAllowedMargin");
            var result = new NumericSequence();
            if (expectedCount === undefined)
                expectedCount = 10;
            else
                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (minPower === undefined)
                minPower = powerbi.Double.MIN_EXP;
            if (useZeroRefPoint === undefined)
                useZeroRefPoint = false;
            if (maxAllowedMargin === undefined)
                maxAllowedMargin = 1;
            if (steps === undefined)
                steps = [1, 2, 5];
            // Handle single stop case
            if (range.forcedSingleStop) {
                result.interval = range.getSize();
                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);
                result.min = range.min;
                result.max = range.max;
                result.sequence = [range.forcedSingleStop];
                return result;
            }
            var interval = 0;
            var min = 0;
            var max = 9;
            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;
            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;
            var size = range.getSize();
            var exp = powerbi.Double.log10(size);
            // Account for Exp of steps
            var stepExp = powerbi.Double.log10(steps[0]);
            exp = exp - stepExp;
            // Account for MaxCount
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp = exp - expectedCountExp;
            // Account for MinPower
            exp = Math.max(exp, minPower - stepExp + 1);
            // Create array of "good looking" numbers
            if (interval !== 0) {
                // If explicit interval is defined - use it instead of the steps array.
                var power = powerbi.Double.pow10(exp);
                var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval);
                min = roundRange.min;
                max = roundRange.max;
                var count = Math.floor(roundRange.getSize() / interval);
            }
            else {
                // No interval defined -> find optimal interval
                var dexp;
                for (dexp = 0; dexp < 3; dexp++) {
                    var e = exp + dexp;
                    var power = powerbi.Double.pow10(e);
                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                    // Go throught the steps array looking for the smallest step that produces the right interval count.
                    var stepsCount = steps.length;
                    var stepPower = powerbi.Double.pow10(e - 1);
                    for (var i = 0; i < stepsCount; i++) {
                        var step = steps[i] * stepPower;
                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        roundRange.shrinkByStep(range, step);
                        // If the range is based on Data we might need to extend it to provide nice data margins.
                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)
                            roundRange.min -= step;
                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)
                            roundRange.max += step;
                        // Count the intervals
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);
                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {
                            interval = step;
                            min = roundRange.min;
                            max = roundRange.max;
                            break;
                        }
                    }
                    // Increase the scale power until the interval is found
                    if (interval !== 0)
                        break;
                }
            }
            // Avoid extreme count cases (>1000 ticks)
            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {
                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);
                interval = (max - min) / count;
            }
            result.min = min;
            result.max = max;
            result.interval = interval;
            result.intervalOffset = min - range.min;
            result._maxAllowedMargin = maxAllowedMargin;
            result._canExtendMin = canExtendMin;
            result._canExtendMax = canExtendMax;
            // Fill in the Sequence
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [];
            var x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; i < count; i++) {
                x = powerbi.Double.roundToPrecision(x + interval, precision);
                sequence.push(x);
            }
            result.sequence = sequence;
            result.trimMinMax(range.min, range.max);
            return result;
        };
        /** Calculates the sequence of int numbers which are mapped to the multiples of the units grid.
          * @min - The minimum of the range.
          * @max - The maximum of the range.
          * @maxCount - The max count of intervals.
          * @steps - array of intervals.
          */
        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {
            // Initialization actions
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (min === max) {
                max = min + 1;
            }
            var stepCount = 0;
            var step = 0;
            for (var i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);
                var minStepCount = powerbi.Double.floorWithPrecision(min / step);
                stepCount = maxStepCount - minStepCount;
                if (stepCount <= maxCount) {
                    break;
                }
            }
            // Calculate the offset
            var offset = -min;
            offset = offset % step;
            // Create sequence
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset;; x += step) {
                result.sequence.push(x);
                if (x >= max)
                    break;
            }
            result.interval = step;
            result.intervalOffset = offset;
            result.min = result.sequence[0];
            result.max = result.sequence[result.sequence.length - 1];
            return result;
        };
        NumericSequence.prototype.trimMinMax = function (min, max) {
            var minMargin = (min - this.min) / this.interval;
            var maxMargin = (this.max - max) / this.interval;
            var marginPrecision = 0.001;
            if (!this._canExtendMin || (minMargin > this._maxAllowedMargin && minMargin > marginPrecision)) {
                this.min = min;
            }
            if (!this._canExtendMax || (maxMargin > this._maxAllowedMargin && maxMargin > marginPrecision)) {
                this.max = max;
            }
        };
        NumericSequence.MIN_COUNT = 1;
        NumericSequence.MAX_COUNT = 1000;
        return NumericSequence;
    })();
    powerbi.NumericSequence = NumericSequence;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequenceRange = (function () {
        function NumericSequenceRange() {
        }
        NumericSequenceRange.prototype._ensureIncludeZero = function () {
            if (this.includeZero) {
                // fixed min and max has higher priority than includeZero
                if (this.min > 0 && !this.hasFixedMin) {
                    this.min = 0;
                }
                if (this.max < 0 && !this.hasFixedMax) {
                    this.max = 0;
                }
            }
        };
        NumericSequenceRange.prototype._ensureNotEmpty = function () {
            if (this.min === this.max) {
                if (!this.min) {
                    this.min = 0;
                    this.max = NumericSequenceRange.DEFAULT_MAX;
                    this.hasFixedMin = true;
                    this.hasFixedMax = true;
                }
                else {
                    // We are dealing with a single data value (includeZero is not set)
                    // In order to fix the range we need to extend it in both directions by half of the interval.
                    // Interval is calculated based on the number:
                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006
                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.
                    var value = this.min;
                    var exp = powerbi.Double.log10(Math.abs(value));
                    var step;
                    if (exp >= 0 && exp < 4) {
                        step = 0.5;
                        this.forcedSingleStop = value;
                    }
                    else {
                        step = powerbi.Double.pow10(exp) / 2;
                        this.forcedSingleStop = null;
                    }
                    this.min = value - step;
                    this.max = value + step;
                }
            }
        };
        NumericSequenceRange.prototype._ensureDirection = function () {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max;
                this.max = temp;
            }
        };
        NumericSequenceRange.prototype.getSize = function () {
            return this.max - this.min;
        };
        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {
            debug.assertValue(range, "range");
            debug.assert(step > 0, "step");
            var oldCount = this.min / step;
            var newCount = range.min / step;
            var deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step;
            oldCount = this.max / step;
            newCount = range.max / step;
            deltaCount = Math.ceil(newCount - oldCount);
            this.max += deltaCount * step;
        };
        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            debug.assert(dataMin <= dataMax, "dataMin should be less or equal to dataMax.");
            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, "fixedMin should be less or equal to fixedMax.");
            var result = new NumericSequenceRange();
            result.includeZero = includeZero ? true : false;
            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);
            result.hasFixedMin = ValueUtil.hasValue(fixedMin);
            result.hasFixedMax = ValueUtil.hasValue(fixedMax);
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            // Calculate the range using the min, max, dataRange
            if (result.hasFixedMin && result.hasFixedMax) {
                result.min = fixedMin;
                result.max = fixedMax;
            }
            else if (result.hasFixedMin) {
                result.min = fixedMin;
                result.max = dataMax > fixedMin ? dataMax : fixedMin;
            }
            else if (result.hasFixedMax) {
                result.min = dataMin < fixedMax ? dataMin : fixedMax;
                result.max = fixedMax;
            }
            else if (result.hasDataRange) {
                result.min = dataMin;
                result.max = dataMax;
            }
            else {
                result.min = 0;
                result.max = 0;
            }
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            if (result.min === 0) {
                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range
            }
            else if (result.max === 0) {
                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range
            }
            return result;
        };
        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {
            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {
                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
            }
            else {
                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);
            }
        };
        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {
            debug.assertValue(fixedMin, "fixedMin");
            debug.assertValue(fixedMax, "fixedMax");
            var result = new NumericSequenceRange();
            result.hasDataRange = false;
            result.includeZero = includeZero;
            result.min = fixedMin;
            result.max = fixedMax;
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            result.hasFixedMin = true;
            result.hasFixedMax = true;
            return result;
        };
        NumericSequenceRange.DEFAULT_MAX = 10;
        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;
        return NumericSequenceRange;
    })();
    powerbi.NumericSequenceRange = NumericSequenceRange;
    // Exported for testability
    var ValueUtil;
    (function (ValueUtil) {
        function hasValue(value) {
            return value !== undefined && value !== null;
        }
        ValueUtil.hasValue = hasValue;
    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var valueFormatter;
        (function (valueFormatter) {
            var StringExtensions = jsCommon.StringExtensions;
            var BeautifiedFormat = {
                '0.00 %;-0.00 %;0.00 %': 'Percentage',
                '0.0 %;-0.0 %;0.0 %': 'Percentage1',
            };
            var defaultLocalizedStrings = {
                'NullValue': '(Blank)',
                'BooleanTrue': 'True',
                'BooleanFalse': 'False',
                'NaNValue': 'NaN',
                'InfinityValue': '+Infinity',
                'NegativeInfinityValue': '-Infinity',
                'RestatementComma': '{0}, {1}',
                'RestatementCompoundAnd': '{0} and {1}',
                'RestatementCompoundOr': '{0} or {1}',
                'DisplayUnitSystem_E3_LabelFormat': '{0}K',
                'DisplayUnitSystem_E3_Title': 'Thousands',
                'DisplayUnitSystem_E6_LabelFormat': '{0}M',
                'DisplayUnitSystem_E6_Title': 'Millions',
                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
                'DisplayUnitSystem_E9_Title': 'Billions',
                'DisplayUnitSystem_E12_LabelFormat': '{0}T',
                'DisplayUnitSystem_E12_Title': 'Trillions',
                'Percentage': '#,0.##%',
                'Percentage1': '#,0.#%',
                'TableTotalLabel': 'Total',
                'Tooltip_HighlightedValueDisplayName': 'Highlighted',
                // Geotagging strings
                'GeotaggingString_Continent': 'continent',
                'GeotaggingString_Continents': 'continents',
                'GeotaggingString_Country': 'country',
                'GeotaggingString_Countries': 'countries',
                'GeotaggingString_State': 'state',
                'GeotaggingString_States': 'states',
                'GeotaggingString_City': 'city',
                'GeotaggingString_Cities': 'cities',
                'GeotaggingString_Town': 'town',
                'GeotaggingString_Towns': 'towns',
                'GeotaggingString_Province': 'province',
                'GeotaggingString_Provinces': 'provinces',
                'GeotaggingString_County': 'county',
                'GeotaggingString_Counties': 'counties',
                'GeotaggingString_Village': 'village',
                'GeotaggingString_Villages': 'villages',
                'GeotaggingString_Post': 'post',
                'GeotaggingString_Zip': 'zip',
                'GeotaggingString_Code': 'code',
                'GeotaggingString_Place': 'place',
                'GeotaggingString_Places': 'places',
                'GeotaggingString_Address': 'address',
                'GeotaggingString_Addresses': 'addresses',
                'GeotaggingString_Street': 'street',
                'GeotaggingString_Streets': 'streets',
                'GeotaggingString_Longitude': 'longitude',
                'GeotaggingString_Longitude_Short': 'lon',
                'GeotaggingString_Latitude': 'latitude',
                'GeotaggingString_Latitude_Short': 'lat',
                'GeotaggingString_PostalCode': 'postal code',
                'GeotaggingString_PostalCodes': 'postal codes',
                'GeotaggingString_ZipCode': 'zip code',
                'GeotaggingString_ZipCodes': 'zip codes',
                'GeotaggingString_Territory': 'territory',
                'GeotaggingString_Territories': 'territories',
            };
            function beautify(format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            }
            function describeUnit(exponent) {
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_Title"];
                var format = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            valueFormatter.getLocalizedString = getLocalizedString;
            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.
            var locale = {
                null: defaultLocalizedStrings['NullValue'],
                true: defaultLocalizedStrings['BooleanTrue'],
                false: defaultLocalizedStrings['BooleanFalse'],
                NaN: defaultLocalizedStrings['NaNValue'],
                infinity: defaultLocalizedStrings['InfinityValue'],
                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                beautify: function (format) { return beautify(format); },
                describe: function (exponent) { return describeUnit(exponent); },
                restatementComma: defaultLocalizedStrings['RestatementComma'],
                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],
                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],
            };
            var MaxScaledDecimalPlaces = 2;
            var MaxValueForDisplayUnitRounding = 1000;
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            valueFormatter.getFormatMetadata = getFormatMetadata;
            function setLocaleOptions(options) {
                debug.assertValue(options, 'options');
                locale = options;
                powerbi.DefaultDisplayUnitSystem.reset();
                powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            valueFormatter.setLocaleOptions = setLocaleOptions;
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function (value) {
                        if (value == null)
                            return locale.null;
                        return formatCore(value, formatBeaut);
                    }
                };
            }
            valueFormatter.createDefaultFormatter = createDefaultFormatter;
            /** Creates an IValueFormatter to be used for a range of values. */
            function create(options) {
                debug.assertValue(options, 'options');
                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);
                    var singleValueFormattingMode = !!options.formatSingleValues;
                    displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var forcePrecision = options.precision != null;
                    var decimals;
                    if (forcePrecision) {
                        decimals = -options.precision;
                    }
                    else if (displayUnitSystem.displayUnit)
                        decimals = -MaxScaledDecimalPlaces;
                    return {
                        format: function (value) {
                            var formattedValue = getStringFormat(value, true);
                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                                return formattedValue;
                            if (value && !displayUnitSystem.displayUnit && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)
                                value = powerbi.Double.roundToPrecision(value, powerbi.Double.pow10(powerbi.Double.getPrecision(value)));
                            return singleValueFormattingMode ? displayUnitSystem.formatSingleValue(value, format, decimals) : displayUnitSystem.format(value, format, decimals, forcePrecision);
                        },
                        displayUnit: displayUnitSystem.displayUnit
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit = powerbi.DateTimeSequence.getIntervalUnit(options.value, options.value2, options.tickCount);
                    return {
                        format: function (value) {
                            if (value == null)
                                return locale.null;
                            var formatString = powerbi.formattingService.dateFormatString(unit);
                            return formatCore(value, formatString);
                        }
                    };
                }
                return createDefaultFormatter(format);
            }
            valueFormatter.create = create;
            function format(value, format, allowFormatBeautification) {
                if (value == null)
                    return locale.null;
                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);
            }
            valueFormatter.format = format;
            function formatRaw(value, format) {
                return formatCore(value, format);
            }
            valueFormatter.formatRaw = formatRaw;
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (displayUnitSystemType == null)
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                    case 0 /* Default */:
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                    case 2 /* WholeUnits */:
                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);
                    case 1 /* Verbose */:
                        return new powerbi.NoDisplayUnitSystem();
                    default:
                        debug.assertFail('Unknown display unit system type');
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value;
                var value2 = options.value2;
                if ((typeof value === 'number') || (typeof value2 === 'number')) {
                    return true;
                }
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                // must check both value and value2 because we'll need to get an interval for date units
                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);
            }
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue)
                            return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime)
                                return 'd';
                            if (columnType.integer)
                                return 'g';
                            if (columnType.numeric)
                                return '#,0.00';
                        }
                    }
                }
            }
            valueFormatter.getFormatString = getFormatString;
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) {
                    return null;
                }
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    var lastIndex = length - 1;
                    for (var i = 1, len = lastIndex; i < len; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                }
                else {
                    result = null;
                }
                return result;
            }
            // The returned string will look like 'A, B, ..., and C' 
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            valueFormatter.formatListAnd = formatListAnd;
            // The returned string will look like 'A, B, ..., or C' 
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            valueFormatter.formatListOr = formatListOr;
            function formatCore(value, format) {
                var formattedValue = getStringFormat(value, false);
                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                    return formattedValue;
                return powerbi.formattingService.formatValue(value, format);
            }
            function getStringFormat(value, nullsAreBlank) {
                if (value == null && nullsAreBlank)
                    return locale.null;
                if (value === true)
                    return locale.true;
                if (value === false)
                    return locale.false;
                if (typeof value === 'number' && isNaN(value))
                    return locale.NaN;
                if (value === Number.NEGATIVE_INFINITY)
                    return locale.negativeInfinity;
                if (value === Number.POSITIVE_INFINITY)
                    return locale.infinity;
                return '';
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            valueFormatter.getDisplayUnits = getDisplayUnits;
        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = (function () {
            function ColorAllocatorFactory() {
            }
            ColorAllocatorFactory.prototype.linearGradient2 = function (options) {
                return new LinearGradient2Allocator(options);
            };
            ColorAllocatorFactory.prototype.linearGradient3 = function (options) {
                return new LinearGradient3Allocator(options);
            };
            return ColorAllocatorFactory;
        })();
        var LinearGradient2Allocator = (function () {
            function LinearGradient2Allocator(options) {
                debug.assertValue(options, 'options');
                var min = options.min, max = options.max;
                this.scale = d3.scale.linear().domain([min.value, max.value]).range([min.color, max.color]).clamp(true); // process a value outside of the domain - set to extremum values
            }
            LinearGradient2Allocator.prototype.color = function (value) {
                return this.scale(value);
            };
            return LinearGradient2Allocator;
        })();
        var LinearGradient3Allocator = (function () {
            function LinearGradient3Allocator(options) {
                debug.assertValue(options, 'options');
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = d3.scale.linear().domain([min.value, mid.value, max.value]).range([min.color, mid.color, max.color]).clamp(true); // process a value outside of the domain- set to extremum values
            }
            LinearGradient3Allocator.prototype.color = function (value) {
                return this.scale(value);
            };
            return LinearGradient3Allocator;
        })();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BeautifiedFormat = {
            '0.00 %;-0.00 %;0.00 %': 'Percentage',
            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
        };
        var defaultLocalizedStrings = {
            'NullValue': '(Blank)',
            'BooleanTrue': 'True',
            'BooleanFalse': 'False',
            'NaNValue': 'NaN',
            'InfinityValue': '+Infinity',
            'NegativeInfinityValue': '-Infinity',
            'Restatement_Comma': '{0}, {1}',
            'Restatement_CompoundAnd': '{0} and {1}',
            'DisplayUnitSystem_E3_LabelFormat': '{0}K',
            'DisplayUnitSystem_E3_Title': 'Thousands',
            'DisplayUnitSystem_E6_LabelFormat': '{0}M',
            'DisplayUnitSystem_E6_Title': 'Millions',
            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
            'DisplayUnitSystem_E9_Title': 'Billions',
            'DisplayUnitSystem_E12_LabelFormat': '{0}T',
            'DisplayUnitSystem_E12_Title': 'Trillions',
            'Percentage': '#,0.##%',
            'Percentage1': '#,0.#%',
            'TableTotalLabel': 'Total',
            'Tooltip_HighlightedValueDisplayName': 'Highlighted',
            // Geotagging strings
            'GeotaggingString_Continent': 'continent',
            'GeotaggingString_Continents': 'continents',
            'GeotaggingString_Country': 'country',
            'GeotaggingString_Countries': 'countries',
            'GeotaggingString_State': 'state',
            'GeotaggingString_States': 'states',
            'GeotaggingString_City': 'city',
            'GeotaggingString_Cities': 'cities',
            'GeotaggingString_Town': 'town',
            'GeotaggingString_Towns': 'towns',
            'GeotaggingString_Province': 'province',
            'GeotaggingString_Provinces': 'provinces',
            'GeotaggingString_County': 'county',
            'GeotaggingString_Counties': 'counties',
            'GeotaggingString_Village': 'village',
            'GeotaggingString_Villages': 'villages',
            'GeotaggingString_Post': 'post',
            'GeotaggingString_Zip': 'zip',
            'GeotaggingString_Code': 'code',
            'GeotaggingString_Place': 'place',
            'GeotaggingString_Places': 'places',
            'GeotaggingString_Address': 'address',
            'GeotaggingString_Addresses': 'addresses',
            'GeotaggingString_Street': 'street',
            'GeotaggingString_Streets': 'streets',
            'GeotaggingString_Longitude': 'longitude',
            'GeotaggingString_Longitude_Short': 'lon',
            'GeotaggingString_Latitude': 'latitude',
            'GeotaggingString_Latitude_Short': 'lat',
            'GeotaggingString_PostalCode': 'postal code',
            'GeotaggingString_PostalCodes': 'postal codes',
            'GeotaggingString_ZipCode': 'zip code',
            'GeotaggingString_ZipCodes': 'zip codes',
            'GeotaggingString_Territory': 'territory',
            'GeotaggingString_Territories': 'territories',
        };
        var DefaultVisualHostServices = (function () {
            function DefaultVisualHostServices() {
            }
            // TODO: Add locale-awareness to this host service. Currently default/english functionality only.
            DefaultVisualHostServices.initialize = function () {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
            };
            // Public for testability
            DefaultVisualHostServices.createLocaleOptions = function () {
                return {
                    null: defaultLocalizedStrings['NullValue'],
                    true: defaultLocalizedStrings['BooleanTrue'],
                    false: defaultLocalizedStrings['BooleanFalse'],
                    NaN: defaultLocalizedStrings['NaNValue'],
                    infinity: defaultLocalizedStrings['InfinityValue'],
                    negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                    beautify: function (format) { return DefaultVisualHostServices.beautify(format); },
                    describe: function (exponent) { return DefaultVisualHostServices.describeUnit(exponent); },
                    restatementComma: defaultLocalizedStrings['Restatement_Comma'],
                    restatementCompoundAnd: defaultLocalizedStrings['Restatement_CompoundAnd'],
                    restatementCompoundOr: defaultLocalizedStrings['Restatement_CompoundOr']
                };
            };
            DefaultVisualHostServices.createTooltipLocaleOptions = function () {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings['Tooltip_HighlightedValueDisplayName']
                };
            };
            DefaultVisualHostServices.prototype.getLocalizedString = function (stringId) {
                return defaultLocalizedStrings[stringId];
            };
            // NO-OP IHostServices methods
            DefaultVisualHostServices.prototype.onDragStart = function () {
            };
            DefaultVisualHostServices.prototype.canSelect = function () {
                return false;
            };
            DefaultVisualHostServices.prototype.onSelect = function () {
            };
            DefaultVisualHostServices.prototype.loadMoreData = function () {
            };
            DefaultVisualHostServices.prototype.persistProperties = function (changes) {
            };
            DefaultVisualHostServices.prototype.onCustomSort = function (args) {
            };
            DefaultVisualHostServices.prototype.getViewMode = function () {
                return 0 /* View */;
            };
            DefaultVisualHostServices.prototype.setWarnings = function (warnings) {
            };
            DefaultVisualHostServices.prototype.setToolbar = function ($toolbar) {
            };
            DefaultVisualHostServices.beautify = function (format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            };
            DefaultVisualHostServices.describeUnit = function (exponent) {
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_Title"];
                var format = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            };
            return DefaultVisualHostServices;
        })();
        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /** Factory method to create an IInteractivityService instance. */
        function createInteractivityService(hostServices) {
            return new WebInteractivityService(hostServices);
        }
        visuals.createInteractivityService = createInteractivityService;
        /** Creates a clear an svg rect to catch clear clicks  */
        function appendClearCatcher(selection) {
            return selection.append("rect").classed("clearCatcher", true).attr({ width: "100%", height: "100%" });
        }
        visuals.appendClearCatcher = appendClearCatcher;
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; i < ilen; i++) {
                if (data[i].selected)
                    return true;
            }
            return false;
        }
        visuals.dataHasSelection = dataHasSelection;
        var WebInteractivityService = (function () {
            function WebInteractivityService(hostServices) {
                this.sendSelectionToVisual = function () {
                };
                this.sendSelectionToLegend = function () {
                };
                this.sendSelectionToSecondVisual = function () {
                };
                // Selection state
                this.selectedIds = [];
                this.hasColumnChart = false;
                debug.assertValue(hostServices, 'hostServices');
                this.hostService = hostServices;
            }
            /** Sets the selected state of all selectable data points to false and invokes the behavior's select command. */
            WebInteractivityService.prototype.clearSelection = function () {
                this.clearSelectionInternal();
                this.sendSelectionToVisual();
                this.sendSelectionToLegend();
                this.sendSelectionToSecondVisual();
            };
            /** Checks whether there is at least one item selected */
            WebInteractivityService.prototype.hasSelection = function () {
                return this.selectedIds.length > 0;
            };
            WebInteractivityService.prototype.legendHasSelection = function () {
                return dataHasSelection(this.selectableLegendDataPoints);
            };
            /** Marks a data point as selected and syncs selection with the host. */
            WebInteractivityService.prototype.select = function (d, multiselect) {
                if (multiselect === undefined)
                    multiselect = d3.event.ctrlKey;
                // For highlight data points we actually want to select the non-highlight data point
                if (d.identity.highlight) {
                    d = _.find(this.selectableDataPoints, function (dp) { return !dp.identity.highlight && d.identity.includes(dp.identity, true); });
                    debug.assertValue(d, 'Expected to find a non-highlight data point');
                }
                var id = d.identity;
                if (!id)
                    return;
                var selected = !d.selected || (!multiselect && this.selectedIds.length > 1);
                // If we have a multiselect flag, we attempt a multiselect
                if (multiselect) {
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                    else {
                        d.selected = false;
                        this.removeId(id);
                    }
                }
                // We do a single select if we didn't do a multiselect or if we find out that the multiselect is invalid.
                if (!multiselect || !this.hostService.canSelect({ data: this.selectedIds.map(function (value) { return value.getSelector(); }) })) {
                    this.clearSelectionInternal();
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                }
                this.syncSelectionState();
            };
            WebInteractivityService.prototype.removeId = function (toRemove) {
                var selectedIds = this.selectedIds;
                for (var i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    if (toRemove.includes(currentId))
                        selectedIds.splice(i, 1);
                }
            };
            WebInteractivityService.isSelected = function (propertyId, categories, idx) {
                return categories.objects != null && categories.objects[idx] && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
            };
            /** Public for UnitTesting */
            WebInteractivityService.prototype.createPropertiesToHost = function (filterPropertyIdentifier) {
                var properties = {};
                if (this.selectedIds.length > 0) {
                    // Set the property if there is any selection
                    var filter = powerbi.data.Selector.filterFromSelector(this.selectedIds.map(function (value) { return value.getSelector(); }), false);
                    properties[filterPropertyIdentifier.propertyName] = filter;
                }
                return [{
                    objectName: filterPropertyIdentifier.objectName,
                    selector: undefined,
                    properties: properties
                }];
            };
            WebInteractivityService.prototype.sendPersistPropertiesToHost = function (filterPropertyIdentifier) {
                this.hostService.persistProperties(this.createPropertiesToHost(filterPropertyIdentifier));
            };
            WebInteractivityService.prototype.sendSelectToHost = function () {
                var host = this.hostService;
                if (host.onSelect) {
                    host.onSelect({ data: this.selectedIds.filter(function (value) { return value.hasIdentity(); }).map(function (value) { return value.getSelector(); }) });
                }
            };
            WebInteractivityService.prototype.sendSelectionToHost = function (filterPropertyIdentifier) {
                // First set the selection, then fire the change.  This way cross-affecting changes can be applied in the correct order.
                if (filterPropertyIdentifier)
                    this.sendPersistPropertiesToHost(filterPropertyIdentifier);
                this.sendSelectToHost();
            };
            WebInteractivityService.prototype.clearSelectionInternal = function () {
                ArrayExtensions.clear(this.selectedIds);
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                if (selectableDataPoints) {
                    for (var i = selectableDataPoints.length - 1; i > -1; i--) {
                        selectableDataPoints[i].selected = false;
                    }
                }
                if (secondSelectableDataPoints) {
                    for (var i = secondSelectableDataPoints.length - 1; i > -1; i--) {
                        secondSelectableDataPoints[i].selected = false;
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var i = selectableLegendDataPoints.length - 1; i > -1; i--) {
                        selectableLegendDataPoints[i].selected = false;
                    }
                }
            };
            WebInteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
                var hasSelection = false;
                for (var i = 0, len = dataPoints.length; i < len; i++) {
                    var dataPoint = dataPoints[i];
                    dataPoint.selected = this.selectedIds.some(function (selectedId) { return selectedId.includes(dataPoint.identity); });
                    if (dataPoint.selected)
                        hasSelection = true;
                }
                return hasSelection;
            };
            /**
             * Initialize the selection state based on the selection from the source.
             */
            WebInteractivityService.prototype.initAndSyncSelectionState = function (filterPropertyId) {
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                var selectedIds = this.selectedIds;
                // If there are selectableDataPoints and the current state of the InteractivityService doesn't have anything selected, look for selectded values in the data
                if (selectableDataPoints && selectedIds.length === 0) {
                    if (selectableDataPoints) {
                        for (var i = 0, len = selectableDataPoints.length; i < len; i++) {
                            if (selectableDataPoints[i].selected) {
                                selectedIds.push(selectableDataPoints[i].identity);
                            }
                        }
                    }
                    if (secondSelectableDataPoints) {
                        for (var i = 0, len = secondSelectableDataPoints.length; i < len; i++) {
                            if (secondSelectableDataPoints[i].selected) {
                                selectedIds.push(secondSelectableDataPoints[i].identity);
                            }
                        }
                    }
                    if (selectableLegendDataPoints) {
                        for (var i = 0, len = selectableLegendDataPoints.length; i < len; i++) {
                            if (selectableLegendDataPoints[i].selected) {
                                selectedIds.push(selectableLegendDataPoints[i].identity);
                            }
                        }
                    }
                }
                this.syncSelectionState(filterPropertyId);
            };
            /**
             * Syncs the selection state for all data points that have the same category. Returns
             * true if the selection state was out of sync and corrections were made; false if
             * the data is already in sync with the service.
             *
             * If the data is not compatible with the current service's current selection state,
             * the state is cleared and the cleared selection is sent to the host.
             *
             * Ignores series for now, since we don't support series selection at the moment.
             */
            WebInteractivityService.prototype.syncSelectionState = function (filterPropertyId) {
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                var foundMatchingId = false; // Checked only against the visual's data points; it's possible to have stuff selected in the visual that's not in the legend, but not vice-verse
                if (!selectableDataPoints)
                    return;
                for (var i = 0, ilen = selectableDataPoints.length; i < ilen; i++) {
                    var dataPoint = selectableDataPoints[i];
                    if (selectedIds.some(function (value) { return value.includes(dataPoint.identity); })) {
                        if (!dataPoint.selected) {
                            dataPoint.selected = true;
                        }
                        foundMatchingId = true;
                    }
                    else if (dataPoint.selected) {
                        dataPoint.selected = false;
                    }
                }
                if (secondSelectableDataPoints) {
                    for (var i = 0, ilen = secondSelectableDataPoints.length; i < ilen; i++) {
                        var dataPoint = secondSelectableDataPoints[i];
                        if (selectedIds.some(function (value) { return value.includes(dataPoint.identity); })) {
                            if (!dataPoint.selected) {
                                dataPoint.selected = true;
                            }
                            foundMatchingId = true;
                        }
                        else if (dataPoint.selected) {
                            dataPoint.selected = false;
                        }
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var i = 0, ilen = selectableLegendDataPoints.length; i < ilen; i++) {
                        var legendDataPoint = selectableLegendDataPoints[i];
                        if (selectedIds.some(function (value) { return value.includes(legendDataPoint.identity); })) {
                            legendDataPoint.selected = true;
                        }
                        else if (legendDataPoint.selected) {
                            legendDataPoint.selected = false;
                        }
                    }
                }
                if (!foundMatchingId && selectedIds.length > 0) {
                    this.clearSelectionInternal();
                    this.sendSelectionToHost(filterPropertyId);
                }
            };
            WebInteractivityService.prototype.apply = function (visual, options) {
                visual.accept(this, options);
            };
            WebInteractivityService.prototype.visitColumnChart = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.ColumnChartWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                var graphicsContext = options.mainGraphicsContext;
                bars.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars, graphicsContext, hasHighlights);
                    _this.sendSelectionToHost();
                    if (_this.sendSelectionToLegend)
                        _this.sendSelectionToLegend();
                    _this.sendSelectionToSecondVisual();
                });
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), bars, graphicsContext, hasHighlights);
                };
                this.hasColumnChart = true;
            };
            WebInteractivityService.prototype.visitLineChart = function (options) {
                if (this.hasColumnChart) {
                    this.visitLineChartCombo(options);
                }
                else {
                    this.visitLineChartNoCombo(options);
                }
            };
            WebInteractivityService.prototype.visitLineChartNoCombo = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.LineChartWebBehavior();
                }
                this.selectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = options.dots;
                var clearCatcher = options.clearCatcher;
                var areas = options.areas;
                var clickHandler = function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                interactivityLines.on('click', clickHandler);
                dots.on('click', clickHandler);
                if (areas)
                    areas.on('click', clickHandler);
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    behavior.select(false, lines, dots, areas);
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                };
            };
            WebInteractivityService.prototype.visitLineChartCombo = function (options) {
                var _this = this;
                var behavior = this.secondBehavior;
                if (!behavior) {
                    behavior = this.secondBehavior = new visuals.LineChartWebBehavior();
                }
                this.secondSelectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = options.dots;
                var areas = options.areas;
                var clickHandler = function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                    _this.sendSelectionToHost();
                    if (_this.sendSelectionToLegend)
                        _this.sendSelectionToLegend();
                    if (_this.sendSelectionToVisual)
                        _this.sendSelectionToVisual();
                };
                interactivityLines.on('click', clickHandler);
                dots.on('click', clickHandler);
                if (areas)
                    areas.on('click', clickHandler);
                this.sendSelectionToSecondVisual = function () {
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                };
            };
            WebInteractivityService.prototype.visitDataDotChart = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.DataDotChartWebBehavior();
                }
                // TODO: share this logic with column chart?
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var dots = options.dots;
                var clearCatcher = options.clearCatcher;
                dots.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), dots);
                    _this.sendSelectionToHost();
                });
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    behavior.select(false, dots);
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), dots);
                };
            };
            WebInteractivityService.prototype.visitDonutChart = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.DonutChartWebBehavior(options);
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var slices = options.slices;
                var highlightSlices = options.highlightSlices;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                var clickHandler = function (d) {
                    _this.select(d.data);
                    behavior.select(_this.hasSelection(), slices, false, hasHighlights, d.data);
                    behavior.select(_this.hasSelection(), highlightSlices, true, hasHighlights, d.data);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                slices.on('click', clickHandler);
                highlightSlices.on('click', clickHandler);
                slices.on('mouseover', function (d) { return behavior.mouseOver(d.data); });
                highlightSlices.on('mouseover', function (d) { return behavior.mouseOver(d.data); });
                slices.on('mouseout', function (d) { return behavior.mouseOut(d.data); });
                highlightSlices.on('mouseout', function (d) { return behavior.mouseOut(d.data); });
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), slices, false, hasHighlights);
                    behavior.select(_this.hasSelection(), highlightSlices, true, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitFunnel = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.FunnelWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var labels = options.labels;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                bars.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars, hasHighlights);
                    _this.sendSelectionToHost();
                });
                if (labels) {
                    labels.on('click', function (d, i) {
                        _this.select(d);
                        behavior.select(_this.hasSelection(), bars, hasHighlights);
                        _this.sendSelectionToHost();
                    });
                }
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), bars, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitScatterChart = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.ScatterChartWebBehavior();
                }
                this.selectableDataPoints = options.data.dataPoints;
                this.initAndSyncSelectionState();
                var selection = options.dataPointsSelection;
                var clearCatcher = options.clearCatcher;
                selection.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), selection);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), options.dataPointsSelection);
                };
            };
            WebInteractivityService.prototype.visitTreemap = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.TreemapWebBehavior();
                }
                this.selectableDataPoints = options.nodes;
                this.initAndSyncSelectionState();
                var shapes = options.shapes;
                var highlightShapes = options.highlightShapes;
                var labels = options.labels;
                var hasHighlights = options.hasHighlights;
                var clickHandler = function (d) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), shapes, false);
                    behavior.select(_this.hasSelection(), highlightShapes, true);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                shapes.on('click', clickHandler);
                highlightShapes.on('click', clickHandler);
                labels.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), shapes, hasHighlights);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), shapes, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitSlicer = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.SlicerWebBehavior();
                }
                var filterPropertyId = visuals.slicerProps.filterPropertyIdentifier;
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState(filterPropertyId);
                var slicers = options.slicerItemContainers;
                var slicerItemLabels = options.slicerItemLabels;
                var slicerItemInputs = options.slicerItemInputs;
                var slicerClear = options.slicerClear;
                slicers.on("mouseover", function (d) {
                    d.mouseOver = true;
                    d.mouseOut = false;
                    behavior.mouseInteractions(slicerItemLabels);
                });
                slicers.on("mouseout", function (d) {
                    d.mouseOver = false;
                    d.mouseOut = true;
                    behavior.mouseInteractions(slicerItemLabels);
                });
                slicerItemLabels.on("click", function (d) {
                    _this.select(d, _this.hasSelection());
                    behavior.select(slicerItemLabels);
                    _this.sendSelectionToHost(filterPropertyId);
                });
                slicerClear.on("click", function (d) {
                    _this.clearSelection();
                    behavior.clearSlicers(slicerItemLabels, slicerItemInputs);
                    _this.sendSelectionToHost(filterPropertyId);
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(slicerItemLabels);
                };
                // Always update the Slicer as it's fully repainting
                this.sendSelectionToVisual();
            };
            WebInteractivityService.prototype.visitWaterfallChart = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.WaterfallChartWebBehavior();
                }
                // TODO: share this logic with column chart?
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var clearCatcher = options.clearCatcher;
                bars.on('click', function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars);
                    _this.sendSelectionToHost();
                });
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), bars);
                };
            };
            WebInteractivityService.prototype.visitMap = function (options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.MapBehavior();
                }
                // TODO: share this logic with column chart?
                this.selectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var bubbles = options.bubbles;
                var slices = options.slices;
                var shapes = options.shapes;
                var clearCatcher = options.clearCatcher;
                var clickHandler = function (d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                    _this.sendSelectionToHost();
                };
                if (bubbles) {
                    bubbles.on('click', clickHandler);
                }
                if (slices) {
                    slices.on('click', function (d, i) {
                        _this.select(d.data);
                        behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                        _this.sendSelectionToHost();
                    });
                }
                if (shapes) {
                    shapes.on('click', clickHandler);
                }
                clearCatcher.on('click', function () {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function () {
                    behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                };
            };
            WebInteractivityService.prototype.visitLegend = function (options) {
                var _this = this;
                var behavior = new visuals.LegendWebBehavior();
                this.selectableLegendDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var legendItems = options.legendItems;
                var legendIcons = options.legendIcons;
                var clearCatcher = options.clearCatcher;
                legendItems.on('click', function (d) {
                    _this.select(d);
                    behavior.select(_this.legendHasSelection(), legendIcons);
                    _this.sendSelectionToVisual();
                    _this.sendSelectionToSecondVisual();
                    _this.sendSelectionToHost();
                });
                clearCatcher.on('click', function () {
                    clearLegendSelection(true);
                    _this.sendSelectionToVisual();
                    _this.sendSelectionToSecondVisual();
                });
                this.sendSelectionToLegend = function () {
                    behavior.select(_this.legendHasSelection(), legendIcons);
                };
                this.sendSelectionToLegend();
                var clearLegendSelection = function (sendToHost) {
                    _this.clearSelection();
                    behavior.select(_this.legendHasSelection(), legendIcons);
                    if (sendToHost)
                        _this.sendSelectionToHost();
                };
            };
            return WebInteractivityService;
        })();
        visuals.WebInteractivityService = WebInteractivityService;
        ;
        /** A service for the mobile client to enable & route interactions */
        var MobileInteractivityService = (function () {
            function MobileInteractivityService() {
            }
            MobileInteractivityService.prototype.apply = function (visual, options) {
                visual.accept(this, options);
            };
            MobileInteractivityService.prototype.makeDataPointsSelectable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    sel.on('click', function (d, i) {
                        _this.behavior.select(true, sel, d, i);
                    });
                }
                return this;
            };
            MobileInteractivityService.prototype.makeRootSelectable = function (selection) {
                var _this = this;
                selection.on('click', function (d, i) {
                    _this.behavior.selectRoot();
                });
                return this;
            };
            MobileInteractivityService.prototype.makeDragable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    var drag = d3.behavior.drag().on('drag', function (d) {
                        _this.behavior.drag(0 /* Drag */);
                    }).on('dragend', function (d) {
                        _this.behavior.drag(1 /* DragEnd */);
                    });
                    sel.call(drag);
                }
                return this;
            };
            MobileInteractivityService.prototype.clearSelection = function () {
            };
            MobileInteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
                return false;
            };
            MobileInteractivityService.prototype.visitColumnChart = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitLineChart = function (options) {
                // Todo
            };
            MobileInteractivityService.prototype.visitDataDotChart = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitDonutChart = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitFunnel = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitScatterChart = function (options) {
                var behavior = this.behavior;
                if (options.data.dataPoints.length > 0) {
                    if (!behavior) {
                        behavior = this.behavior = new visuals.ScatterChartMobileBehavior();
                    }
                    behavior.setOptions(options);
                    this.makeDataPointsSelectable(options.dataPointsSelection).makeRootSelectable(options.root).makeDragable(options.root).makeDragable(options.background);
                    behavior.selectRoot();
                }
            };
            MobileInteractivityService.prototype.visitTreemap = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitSlicer = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitWaterfallChart = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitMap = function (options) {
                // No mobile interactions declared.
            };
            MobileInteractivityService.prototype.visitLegend = function (options) {
                // No mobile interactions declared.
            };
            return MobileInteractivityService;
        })();
        visuals.MobileInteractivityService = MobileInteractivityService;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BI;
        (function (BI) {
            var Services;
            (function (Services) {
                function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                    return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow);
                }
                Services.createGeocodingCache = createGeocodingCache;
                var GeocodingCache = (function () {
                    function GeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                        this.geocodeCache = {};
                        this.maxCacheSize = maxCacheSize;
                        this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                    }
                    /** Retrieves the coordinate for the key from the cache, returning undefined on a cache miss */
                    GeocodingCache.prototype.getCoordinates = function (query) {
                        // Check in-memory cache
                        var pair = this.geocodeCache[query.key];
                        if (pair) {
                            pair.query.incrementCacheHit();
                            return pair.coordinate;
                        }
                        // Check local storage cache
                        pair = powerbi.localStorageService.getData(query.key);
                        if (pair) {
                            this.registerInMemory(query, pair.coordinate);
                            return pair.coordinate;
                        }
                        return undefined;
                    };
                    /** Registers the query and coordinate to the cache */
                    GeocodingCache.prototype.registerCoordinates = function (query, coordinate) {
                        this.registerInMemory(query, coordinate);
                        this.registerInStorage(query, coordinate);
                    };
                    GeocodingCache.prototype.registerInMemory = function (query, coordinate) {
                        var geocodeCache = this.geocodeCache;
                        var keys = Object.keys(geocodeCache);
                        var cacheSize = keys.length;
                        var maxCacheSize = this.maxCacheSize;
                        if (keys.length > (maxCacheSize + this.maxCacheSizeOverflow)) {
                            var sortedKeys = keys.sort(function (a, b) {
                                var ca = geocodeCache[a].query.getCacheHits();
                                var cb = geocodeCache[b].query.getCacheHits();
                                return ca < cb ? -1 : (ca > cb ? 1 : 0);
                            });
                            for (var i = 0; i < (cacheSize - maxCacheSize); i++) {
                                geocodeCache[sortedKeys[i]] = undefined;
                            }
                        }
                        geocodeCache[query.key] = { query: query, coordinate: coordinate };
                    };
                    GeocodingCache.prototype.registerInStorage = function (query, coordinate) {
                        powerbi.localStorageService.setData(query.key, { query: query, coordinate: coordinate });
                    };
                    return GeocodingCache;
                })();
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualPluginFactory;
        (function (visualPluginFactory) {
            var VisualPluginService = (function () {
                function VisualPluginService() {
                    this._plugins = powerbi.visuals.plugins;
                }
                /** Gets metadata for all registered. */
                VisualPluginService.prototype.getVisuals = function () {
                    var registry = this._plugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                VisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this._plugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                VisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin)
                        return plugin.capabilities;
                };
                return VisualPluginService;
            })();
            visualPluginFactory.VisualPluginService = VisualPluginService;
            function createPlugin(visualPlugins, base, create) {
                var visualPlugin = powerbi.Prototype.inherit(base);
                visualPlugin.create = create;
                visualPlugins[base.name] = visualPlugin;
            }
            var MinervaVisualPluginService = (function (_super) {
                __extends(MinervaVisualPluginService, _super);
                function MinervaVisualPluginService(featureSwitches) {
                    _super.call(this);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.featureSwitches = featureSwitches;
                    this.visualPlugins = {};
                    if (this.featureSwitches.devToolsEnabled) {
                        this.addCustomVisualizations([]);
                    }
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({ chartType: 5 /* StackedBar */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.card, function () { return new visuals.Card({ isScrollable: true }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({ chartType: 4 /* ClusteredBar */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({ chartType: 2 /* ClusteredColumn */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({ chartType: 3 /* StackedColumn */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 14 /* DataDotClusteredColumnCombo */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 15 /* DataDotStackedColumnCombo */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({ animator: new visuals.WebDonutChartAnimator(), isScrollable: true }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({ animator: new visuals.WebFunnelAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({ chartType: 6 /* HundredPercentStackedBar */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({ chartType: 7 /* HundredPercentStackedColumn */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({ chartType: 0 /* Line */, isScrollable: true, animator: new visuals.NullAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({ chartType: 1 /* Area */, isScrollable: true, animator: new visuals.NullAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 12 /* LineClusteredColumnCombo */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 13 /* LineStackedColumnCombo */, isScrollable: true, animator: new visuals.WebColumnChartAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({ sliceWidthRatio: 0, animator: new visuals.WebDonutChartAnimator(), isScrollable: true }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({ chartType: 8 /* Scatter */, isScrollable: true, animator: new visuals.NullAnimator() }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.treemap, function () { return new visuals.Treemap({ animator: new visuals.WebTreemapAnimator, isScrollable: true }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({ chartType: 11 /* Waterfall */, isScrollable: true }); });
                }
                MinervaVisualPluginService.prototype.getVisuals = function () {
                    // Current visual types that supports visual conversion. Please don't change the orders
                    // CAUTION: If you are adding new visual types, please check if you need to update the height of
                    // the visual convertion pane in visualization pane as well.
                    var convertibleVisualTypes = [
                        powerbi.visuals.plugins.barChart,
                        powerbi.visuals.plugins.columnChart,
                        powerbi.visuals.plugins.clusteredBarChart,
                        powerbi.visuals.plugins.clusteredColumnChart,
                        powerbi.visuals.plugins.hundredPercentStackedBarChart,
                        powerbi.visuals.plugins.hundredPercentStackedColumnChart,
                        powerbi.visuals.plugins.lineChart,
                        powerbi.visuals.plugins.areaChart,
                        powerbi.visuals.plugins.lineStackedColumnComboChart,
                        powerbi.visuals.plugins.lineClusteredColumnComboChart,
                        powerbi.visuals.plugins.waterfallChart,
                        powerbi.visuals.plugins.scatterChart,
                        powerbi.visuals.plugins.pieChart,
                        powerbi.visuals.plugins.treemap,
                        powerbi.visuals.plugins.map,
                        powerbi.visuals.plugins.table,
                        powerbi.visuals.plugins.matrix,
                        powerbi.visuals.plugins.filledMap,
                        powerbi.visuals.plugins.funnel,
                        powerbi.visuals.plugins.gauge,
                        powerbi.visuals.plugins.multiRowCard,
                        powerbi.visuals.plugins.card,
                        powerbi.visuals.plugins.slicer,
                        powerbi.visuals.plugins.donutChart,
                    ];
                    if (this.featureSwitches.devToolsEnabled) {
                        this.addCustomVisualizations(convertibleVisualTypes);
                    }
                    if (this.featureSwitches.dataDotChartEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotClusteredColumnComboChart);
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotStackedColumnComboChart);
                    }
                    return convertibleVisualTypes;
                };
                MinervaVisualPluginService.prototype.addCustomVisualizations = function (convertibleVisualTypes) {
                    // Read new visual from localstorage
                    var customVisualizationList = powerbi.localStorageService.getData('customVisualizations');
                    if (customVisualizationList) {
                        var len = customVisualizationList.length;
                        for (var i = 0; i < len; i++) {
                            var pluginName = customVisualizationList[i].pluginName;
                            var plugin = this.getPlugin(pluginName);
                            // If the browser session got restarted or its a new window the plugin wont be available, so we need to add it
                            if (!plugin) {
                                var jsCode = customVisualizationList[i].javaScriptCode;
                                var script = $("<script/>", {
                                    html: jsCode + '//# sourceURL=' + pluginName + '.js\n' + '//# sourceMappingURL=' + pluginName + '.js.map'
                                });
                                script.attr('pluginName', pluginName);
                                $('body').append(script);
                                var style = $("<style/>", {
                                    html: customVisualizationList[i].cssCode
                                });
                                style.attr('pluginName', pluginName);
                                $('head').append(style);
                                plugin = this.getPlugin(pluginName);
                            }
                            convertibleVisualTypes.push(plugin);
                        }
                    }
                };
                MinervaVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                return MinervaVisualPluginService;
            })(VisualPluginService);
            visualPluginFactory.MinervaVisualPluginService = MinervaVisualPluginService;
            // This plug-in service is used when displaying visuals on the dashboard
            var DashboardPluginService = (function (_super) {
                __extends(DashboardPluginService, _super);
                function DashboardPluginService(featureSwitches) {
                    _super.call(this);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.featureSwitches = featureSwitches;
                    this.visualPlugins = {};
                    // Although there are no plug-in modifications here, this service allows different parameters such as feature switches to be passed for dashboard visuals.
                }
                DashboardPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                return DashboardPluginService;
            })(VisualPluginService);
            visualPluginFactory.DashboardPluginService = DashboardPluginService;
            var MobileVisualPluginService = (function (_super) {
                __extends(MobileVisualPluginService, _super);
                function MobileVisualPluginService(smallViewPortProperties) {
                    var _this = this;
                    _super.call(this);
                    this.smallViewPortProperties = smallViewPortProperties || {
                        CartesianSmallViewPortProperties: {
                            hideAxesOnSmallViewPort: true,
                            hideLegendOnSmallViewPort: true,
                            MinHeightLegendVisible: MobileVisualPluginService.MinHeightLegendVisible,
                            MinHeightAxesVisible: MobileVisualPluginService.MinHeightAxesVisible,
                        },
                        GaugeSmallViewPortProperties: {
                            hideGaugeSideNumbersOnSmallViewPort: true,
                            smallGaugeMarginsOnSmallViewPort: true,
                            MinHeightGaugeSideNumbersVisible: MobileVisualPluginService.MinHeightGaugeSideNumbersVisible,
                            GaugeMarginsOnSmallViewPort: MobileVisualPluginService.GaugeMarginsOnSmallViewPort,
                        }
                    };
                    // Disable tooltips for mobile
                    visuals.TooltipManager.ShowTooltips = false;
                    this.visualPlugins = {};
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({ chartType: 0 /* Line */, cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 12 /* LineClusteredColumnCombo */, cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({ chartType: 13 /* LineStackedColumnCombo */, cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({ chartType: 8 /* Scatter */, cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({ chartType: visuals.Gauge, gaugeSmallViewPortProperties: _this.smallViewPortProperties.GaugeSmallViewPortProperties }); });
                }
                MobileVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                MobileVisualPluginService.MinHeightLegendVisible = 80;
                MobileVisualPluginService.MinHeightAxesVisible = 80;
                MobileVisualPluginService.MinHeightGaugeSideNumbersVisible = 80;
                MobileVisualPluginService.GaugeMarginsOnSmallViewPort = 10;
                return MobileVisualPluginService;
            })(VisualPluginService);
            visualPluginFactory.MobileVisualPluginService = MobileVisualPluginService;
            function create() {
                return new VisualPluginService();
            }
            visualPluginFactory.create = create;
            function createMinerva(featureSwitches) {
                return new MinervaVisualPluginService(featureSwitches);
            }
            visualPluginFactory.createMinerva = createMinerva;
            function createDashboard(featureSwitches) {
                return new DashboardPluginService(featureSwitches);
            }
            visualPluginFactory.createDashboard = createDashboard;
            function createMobile(smallViewPortProperties) {
                return new MobileVisualPluginService(smallViewPortProperties);
            }
            visualPluginFactory.createMobile = createMobile;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) {
                    for (var i = 0; i < eventHandlers.length; i++) {
                        var h = eventHandlers[i];
                        h(eventArgs);
                    }
                }
            }
            controls.fire = fire;
            var ScrollbarButton = (function () {
                // Constructor
                function ScrollbarButton(owner, direction) {
                    this._owner = owner;
                    this._direction = direction;
                    this._timerHandle = undefined;
                    this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) {
                        that.onMouseDown(e);
                    });
                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Object.defineProperty(ScrollbarButton.prototype, "element", {
                    // Properties
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                // Methods
                ScrollbarButton.prototype.createView = function () {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon");
                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
                    this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute";
                    svgStyle.left = "0px";
                    svgStyle.top = "0px";
                    this._svg.appendChild(this._polygon);
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.arrowClassName;
                    this._element.appendChild(this._svg);
                    this._owner.element.appendChild(this._element);
                };
                ScrollbarButton.prototype.onMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._mouseUpWrapper) {
                        event.cancelBubble = true;
                        var that = this;
                        this._mouseUpWrapper = function (event) {
                            that.onMouseUp(event);
                        };
                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction);
                    this._owner.refresh();
                    this._timerHandle = setTimeout(function () {
                        that.onMouseDown(event);
                    }, 100);
                    if (event.preventDefault) {
                        event.preventDefault(); // prevent dragging
                    }
                };
                ScrollbarButton.prototype.onMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
                    this._mouseUpWrapper = undefined;
                };
                ScrollbarButton.prototype.arrange = function (width, height, angle) {
                    var size = Math.min(width, height);
                    var scale = size / 16;
                    var x = (width - size) / 2;
                    var y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
                    this._svg.setAttributeNS(null, "width", width + "px");
                    this._svg.setAttributeNS(null, "height", height + "px");
                    controls.HTMLElementUtils.setElementWidth(this._element, width);
                    controls.HTMLElementUtils.setElementHeight(this._element, height);
                };
                // Const
                // TODO: Move to style
                ScrollbarButton.MIN_WIDTH = 26;
                ScrollbarButton.ARROW_COLOR = "#404040";
                return ScrollbarButton;
            })();
            controls.ScrollbarButton = ScrollbarButton;
            // Scrollbar base class
            var Scrollbar = (function () {
                function Scrollbar(parentElement) {
                    this.MIN_BAR_SIZE = 10;
                    this.min = 0;
                    this.max = 10;
                    this.viewMin = 0;
                    this.viewSize = 2;
                    this.smallIncrement = 1;
                    this._onscroll = [];
                    this._screenToOffsetScale = 1.0;
                    this.createView(parentElement);
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) {
                        that.onBackgroundMouseDown(e);
                    });
                    this._middleBar.addEventListener("mousedown", function (e) {
                        that.onMiddleBarMouseDown(e);
                    });
                    this._timerHandle = undefined;
                    this._visible = true;
                    this.element["winControl"] = this;
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Scrollbar.prototype.scrollBy = function (delta) {
                    this.scrollTo(this.viewMin + delta);
                };
                Scrollbar.prototype.scrollUp = function () {
                    this.scrollBy(-this.smallIncrement);
                };
                Scrollbar.prototype.scrollDown = function () {
                    this.scrollBy(this.smallIncrement);
                };
                Scrollbar.prototype.scrollPageUp = function () {
                    this.scrollBy(-this.viewSize);
                };
                Scrollbar.prototype.scrollPageDown = function () {
                    this.scrollBy(this.viewSize);
                };
                Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        this._width = value;
                        this._element.style.width = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        this._height = value;
                        this._element.style.height = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.refresh = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
                };
                Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function () {
                        return this._maxButton;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function () {
                        return this._middleBar;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype._scrollSmallIncrement = function (direction) {
                    this.scrollBy(this.smallIncrement * direction);
                };
                Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function () {
                        return this._visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function () {
                        return this._timerHandle !== undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.show = function (value) {
                    this._visible = value;
                    this.element.style.visibility = value ? "visible" : "hidden";
                    this.invalidateArrange();
                };
                Scrollbar.prototype._getMouseOffset = function (event) {
                    if (event.offsetX !== undefined)
                        return { x: event.offsetX, y: event.offsetY };
                    if (event.layerX !== undefined)
                        return { x: event.layerX, y: event.layerY };
                    return { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype._getOffsetXDelta = function (event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetYDelta = function (event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetXTouchDelta = function (event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                };
                Scrollbar.prototype._getOffsetYTouchDelta = function (event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                };
                Scrollbar.prototype.initTouch = function (panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel;
                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                    if ("ontouchmove" in panel) {
                        panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                        panel.addEventListener("touchmove", function (e) { return _this.onTouchMove(e); });
                        panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                    }
                    else {
                        panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                        panel.addEventListener("mousemove", function (e) { return _this.onTouchMouseMove(e); });
                        panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                    }
                };
                Scrollbar.prototype.onTouchStart = function (e) {
                    if (e.touches.length === 1) {
                        this.onTouchMouseDown(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchMove = function (e) {
                    if (e.touches.length === 1) {
                        if (e.preventDefault)
                            e.preventDefault();
                        this.onTouchMouseMove(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchEnd = function (e) {
                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                };
                Scrollbar.prototype.onTouchMouseDown = function (e) {
                    // except IE touch cancels mouse so not need for detection. For IE touch and mouse difference is detected by a flag.
                    if (!this._allowMouseDrag && e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
                        return;
                    }
                    if ("setCapture" in this._touchPanel) {
                        this._touchPanel.setCapture(true);
                    }
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
                    this._touchStarted = true;
                };
                Scrollbar.prototype._getOffsetTouchDelta = function (e) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
                    return null;
                };
                Scrollbar.prototype.onTouchMouseMove = function (e) {
                    if (this._touchStarted) {
                        if (!this._offsetTouchStartPos) {
                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
                        }
                        var delta = this._getOffsetTouchDelta(e);
                        if (delta !== 0) {
                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
                            this._offsetTouchPrevPos = this._getMouseOffset(e);
                        }
                        if (e.preventDefault)
                            e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                Scrollbar.prototype.onTouchMouseUp = function (e, bubble) {
                    if (this._touchStarted) {
                        if (this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
                                if (e.preventDefault)
                                    e.preventDefault();
                                e.cancelBubble = true;
                            }
                        }
                    }
                    if ("releaseCapture" in this._touchPanel) {
                        this._touchPanel.releaseCapture();
                    }
                    this._touchStarted = false;
                };
                Scrollbar.prototype.registerElementForMouseWheelScrolling = function (element) {
                    var _this = this;
                    element.addEventListener("mousewheel", function (e) {
                        _this.onMouseWheel(e);
                    });
                    element.addEventListener("DOMMouseScroll", function (e) {
                        _this.onFireFoxMouseWheel(e);
                    });
                };
                Scrollbar.prototype.createView = function (parentElement) {
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.className;
                    this._element.setAttribute("drag-resize-disabled", "true");
                    parentElement.appendChild(this._element);
                    this._minButton = new ScrollbarButton(this, -1);
                    this._maxButton = new ScrollbarButton(this, 1);
                    this._middleBar = document.createElement("div");
                    this._middleBar.className = Scrollbar.barClassName;
                    this._element.appendChild(this._middleBar);
                };
                Scrollbar.prototype.scrollTo = function (pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    if (viewMin !== this.viewMin) {
                        this.viewMin = viewMin;
                        fire(this._onscroll, null);
                    }
                };
                Scrollbar.prototype._scrollByPage = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
                };
                Scrollbar.prototype._getRunningSize = function (net) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
                    return null;
                };
                Scrollbar.prototype._getOffsetDelta = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
                    return null;
                };
                Scrollbar.prototype.scroll = function (event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
                    if (delta < 0) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
                            return;
                        }
                    }
                    else if (delta > 0) {
                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
                            return;
                        }
                    }
                    this.scrollBy(delta);
                };
                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function () {
                        if (this._actualWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function () {
                        if (!this._actualHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function () {
                        if (!this._actualButtonWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function () {
                        if (!this._actualButtonHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.arrange = function () {
                    if (!this._actualWidth) {
                        this._actualWidth = this._element.offsetWidth;
                        this._actualHeight = this._element.offsetHeight;
                        this._actualButtonWidth = this._calculateButtonWidth();
                        this._actualButtonHeight = this._calculateButtonHeight();
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
                        this._setMaxButtonPosition();
                    }
                };
                Scrollbar.prototype._calculateButtonWidth = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
                    return null;
                };
                Scrollbar.prototype._calculateButtonHeight = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
                    return null;
                };
                Scrollbar.prototype._getMinButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._getMaxButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._setMaxButtonPosition = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
                };
                Scrollbar.prototype.invalidateArrange = function () {
                    this._actualWidth = undefined;
                    this._actualHeight = undefined;
                    this._actualButtonWidth = undefined;
                    this._actualButtonHeight = undefined;
                };
                Scrollbar.prototype.onHoldBackgroundMouseDown = function (event) {
                    var _this = this;
                    var holdDelay = this._timerHandle ? Scrollbar.ScrollbarBackgroundMousedownHoldDelay : Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout(function () {
                        _this.onBackgroundMouseDown(event);
                    }, holdDelay);
                };
                Scrollbar.prototype.onBackgroundMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._backgroundMouseUpWrapper) {
                        event.cancelBubble = true;
                        this._backgroundMouseUpWrapper = function (event) {
                            that.onBackgroundMouseUp(event);
                        };
                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    }
                    this._scrollByPage(event);
                    this.refresh();
                    this.onHoldBackgroundMouseDown(event);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onBackgroundMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    this._timerHandle = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    this._backgroundMouseUpWrapper = undefined;
                };
                Scrollbar.prototype.getPinchZoomY = function () {
                    return document.documentElement.clientHeight / window.innerHeight;
                };
                Scrollbar.prototype.onMiddleBarMouseDown = function (event) {
                    event.cancelBubble = true;
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function (e) {
                        that.onMiddleBarMouseMove(e);
                    };
                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseUpWrapper = function (e) {
                        that.onMiddleBarMouseUp(e);
                    };
                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onMiddleBarMouseMove = function (event) {
                    if (!this._screenPrevMousePos) {
                        return;
                    }
                    this.scroll(event);
                    this.refresh();
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype.onMiddleBarMouseUp = function (event) {
                    this._screenPrevMousePos = undefined;
                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseMoveWrapper = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    this._middleBarMouseUpWrapper = undefined;
                    if (event.preventDefault)
                        event.preventDefault(); // prevent other events
                };
                Scrollbar.prototype._getScreenContextualLeft = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
                    return null;
                };
                Scrollbar.prototype._getScreenContextualRight = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
                    return null;
                };
                Scrollbar.prototype.onMouseWheel = function (e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                };
                Scrollbar.prototype.onFireFoxMouseWheel = function (e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                };
                Scrollbar.prototype.mouseWheel = function (delta) {
                    if (this.visible) {
                        this.scrollBy(-delta / 120 * this.smallIncrement);
                    }
                };
                Scrollbar.prototype._getScreenMousePos = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
                    return null;
                };
                Scrollbar.addDocumentMouseUpEvent = function (func) {
                    document.addEventListener("mouseup", func);
                };
                Scrollbar.removeDocumentMouseUpEvent = function (func) {
                    document.removeEventListener("mouseup", func);
                };
                Scrollbar.addDocumentMouseMoveEvent = function (func) {
                    document.addEventListener("mousemove", func);
                };
                Scrollbar.removeDocumentMouseMoveEvent = function (func) {
                    document.removeEventListener("mousemove", func);
                };
                Scrollbar.DefaultScrollbarWidth = "15px"; // protected
                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
                Scrollbar.className = "scroll-bar-div";
                Scrollbar.barClassName = "scroll-bar-part-bar";
                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
                return Scrollbar;
            })();
            controls.Scrollbar = Scrollbar;
            // Horizontal Scrollbar
            var HorizontalScrollbar = (function (_super) {
                __extends(HorizontalScrollbar, _super);
                function HorizontalScrollbar(parentElement) {
                    _super.call(this, parentElement);
                    this.height = Scrollbar.DefaultScrollbarWidth;
                }
                HorizontalScrollbar.prototype._calculateButtonWidth = function () {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                };
                HorizontalScrollbar.prototype._calculateButtonHeight = function () {
                    return this.actualHeight;
                };
                HorizontalScrollbar.prototype._getMinButtonAngle = function () {
                    return -180;
                };
                HorizontalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 0;
                };
                HorizontalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                };
                HorizontalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                };
                HorizontalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.height = this.height;
                    }
                    else {
                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
                    }
                };
                HorizontalScrollbar.prototype._scrollByPage = function (event) {
                    var left = this.middleBar.offsetLeft;
                    var right = left + this.middleBar.offsetWidth;
                    var x = (event.offsetX === undefined) ? event.layerX : event.offsetX;
                    if (x > right) {
                        this.scrollPageDown();
                    }
                    else if (x < left) {
                        this.scrollPageUp();
                    }
                };
                HorizontalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                HorizontalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetXDelta(event);
                };
                HorizontalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetXTouchDelta(e);
                };
                HorizontalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().left;
                };
                HorizontalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().right;
                };
                HorizontalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenX;
                };
                return HorizontalScrollbar;
            })(Scrollbar);
            controls.HorizontalScrollbar = HorizontalScrollbar;
            // Vertical Scrollbar
            var VerticalScrollbar = (function (_super) {
                __extends(VerticalScrollbar, _super);
                function VerticalScrollbar(parentElement) {
                    _super.call(this, parentElement);
                    this.width = Scrollbar.DefaultScrollbarWidth;
                }
                VerticalScrollbar.prototype._calculateButtonWidth = function () {
                    return this.actualWidth;
                };
                VerticalScrollbar.prototype._calculateButtonHeight = function () {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                };
                VerticalScrollbar.prototype._getMinButtonAngle = function () {
                    return -90;
                };
                VerticalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 90;
                };
                VerticalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                };
                VerticalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                };
                VerticalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.width = this.width;
                    }
                    else {
                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
                    }
                };
                VerticalScrollbar.prototype._scrollByPage = function (event) {
                    var top = this.middleBar.offsetTop;
                    var bottom = top + this.middleBar.offsetHeight;
                    var y = (event.offsetY === undefined) ? event.layerY : event.offsetY;
                    if (y > bottom) {
                        this.scrollPageDown();
                    }
                    else if (y < top) {
                        this.scrollPageUp();
                    }
                };
                VerticalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                VerticalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetYDelta(event);
                };
                VerticalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetYTouchDelta(e);
                };
                VerticalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().top;
                };
                VerticalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().bottom;
                };
                VerticalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenY;
                };
                return VerticalScrollbar;
            })(Scrollbar);
            controls.VerticalScrollbar = VerticalScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /** This class is responsible for tablix header resizing
                  */
                var TablixResizer = (function () {
                    function TablixResizer(element, handler) {
                        this._element = element;
                        this._handler = handler;
                        this._elementMouseDownWrapper = null;
                        this._elementMouseMoveWrapper = null;
                        this._elementMouseOutWrapper = null;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                        this._startMousePosition = null;
                        this._originalCursor = null;
                    }
                    TablixResizer.addDocumentMouseUpEvent = function (listener) {
                        document.addEventListener("mouseup", listener);
                    };
                    TablixResizer.removeDocumentMouseUpEvent = function (listener) {
                        document.removeEventListener("mouseup", listener);
                    };
                    TablixResizer.addDocumentMouseMoveEvent = function (listener) {
                        document.addEventListener("mousemove", listener);
                    };
                    TablixResizer.removeDocumentMouseMoveEvent = function (listener) {
                        document.removeEventListener("mousemove", listener);
                    };
                    TablixResizer.getMouseCoordinates = function (event) {
                        return { x: event.pageX, y: event.pageY };
                    };
                    TablixResizer.getMouseCoordinateDelta = function (previous, current) {
                        return { x: current.x - previous.x, y: current.y - previous.y };
                    };
                    TablixResizer.prototype.initialize = function () {
                        var _this = this;
                        this._elementMouseDownWrapper = function (e) { return _this.onElementMouseDown(e); };
                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseMoveWrapper = function (e) { return _this.onElementMouseMove(e); };
                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseOutWrapper = function (e) { return _this.onElementMouseOut(e); };
                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = function (e) { return _this.onElementMouseDoubleClick(e); };
                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    };
                    TablixResizer.prototype.uninitialize = function () {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseDownWrapper = null;
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseMoveWrapper = null;
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseOutWrapper = null;
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = null;
                    };
                    Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function () {
                            // abstract
                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function () {
                            return this._element;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixResizer.prototype._hotSpot = function (position) {
                        // abstract
                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
                        return false;
                    };
                    TablixResizer.prototype.onElementMouseDown = function (event) {
                        var _this = this;
                        var position = TablixResizer.getMouseCoordinates(event);
                        if (!this._hotSpot(position))
                            return;
                        if ("setCapture" in this._element) {
                            this._element.setCapture();
                        }
                        event.cancelBubble = true;
                        this._startMousePosition = position;
                        this._documentMouseMoveWrapper = function (e) { return _this.onDocumentMouseMove(e); };
                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseUpWrapper = function (e) { return _this.onDocumentMouseUp(e); };
                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        if (document.documentElement) {
                            this._originalCursor = document.documentElement.style.cursor;
                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
                        }
                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
                    };
                    TablixResizer.prototype.onElementMouseMove = function (event) {
                        if (!this._startMousePosition) {
                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
                                if (this._originalCursor === null) {
                                    this._originalCursor = this._element.style.cursor;
                                    this._element.style.cursor = TablixResizer.resizeCursor;
                                }
                            }
                            else {
                                if (this._originalCursor !== null) {
                                    this._element.style.cursor = this._originalCursor;
                                    this._originalCursor = null;
                                }
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseOut = function (event) {
                        if (!this._startMousePosition) {
                            if (this._originalCursor !== null) {
                                this._element.style.cursor = this._originalCursor;
                                this._originalCursor = null;
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseDoubleClick = function (event) {
                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event)))
                            return;
                        this._handler.onReset(this.cell);
                    };
                    TablixResizer.prototype.onDocumentMouseMove = function (event) {
                        if (!this._startMousePosition)
                            return;
                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                        this._handler.onResize(this.cell, delta.x, delta.y);
                    };
                    TablixResizer.prototype.onDocumentMouseUp = function (event) {
                        this._startMousePosition = null;
                        if ("releaseCapture" in this._element) {
                            this._element.releaseCapture();
                        }
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseMoveWrapper = null;
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        this._documentMouseUpWrapper = null;
                        if (document.documentElement)
                            document.documentElement.style.cursor = this._originalCursor;
                        if (event.preventDefault)
                            event.preventDefault(); // prevent other events
                        this._handler.onEndResize(this.cell);
                    };
                    TablixResizer.resizeHandleSize = 4;
                    TablixResizer.resizeCursor = "e-resize";
                    return TablixResizer;
                })();
                internal.TablixResizer = TablixResizer;
                var TablixCell = (function () {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = false;
                        this._presenter = presenter;
                        this.extension = extension;
                        this._presenter.initialize(this);
                        this._row = row;
                        this.item = null;
                        this.type = null;
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this._colSpan = 1;
                        this._rowSpan = 1;
                        this._contentWidth = -1;
                        this._contentHeight = -1;
                    }
                    Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function () {
                            return this._colSpan;
                        },
                        set: function (value) {
                            if (this._colSpan !== value) {
                                this._presenter.onColumnSpanChanged(value);
                                this._colSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function () {
                            return this._rowSpan;
                        },
                        set: function (value) {
                            if (this._rowSpan !== value) {
                                this._presenter.onRowSpanChanged(value);
                                this._rowSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function () {
                            return this._textAlign;
                        },
                        set: function (value) {
                            if (value !== this._textAlign) {
                                this._presenter.onTextAlignChanged(value);
                                this._textAlign = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function () {
                            return this._horizontalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function () {
                            return this._verticalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.isScrollable = function () {
                        return this._scrollable;
                    };
                    TablixCell.prototype.clear = function () {
                        if (this.isScrollable()) {
                            this.initializeScrolling();
                        }
                        this._presenter.onClear();
                        this.setContentWidth(-1);
                        this.setContentHeight(-1);
                    };
                    TablixCell.prototype.initializeScrolling = function () {
                        this._presenter.onInitializeScrolling();
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this.setContentWidth(-1);
                        this.setContentHeight(-1);
                    };
                    TablixCell.prototype.prepare = function (scrollable) {
                        if (this.isScrollable())
                            this.initializeScrolling();
                        this._scrollable = scrollable;
                    };
                    TablixCell.prototype.scrollVertically = function (height, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        var offsetInPixels = -height * offset;
                        this._verticalOffset = offsetInPixels;
                        this._presenter.onVerticalScroll(height, offsetInPixels);
                        this.setContentHeight(height + offsetInPixels);
                    };
                    TablixCell.prototype.scrollHorizontally = function (width, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        var offsetInPixels = -width * offset;
                        this._horizontalOffset = offsetInPixels;
                        this._presenter.onHorizontalScroll(width, offsetInPixels);
                        this.setContentWidth(width + offsetInPixels);
                    };
                    TablixCell.prototype.setContentWidth = function (value) {
                        if (value === this._contentWidth)
                            return;
                        this._contentWidth = value;
                        this._presenter.onContentWidthChanged(value);
                    };
                    TablixCell.prototype.setContentHeight = function (value) {
                        if (value === this._contentHeight)
                            return;
                        this._contentHeight = value;
                        this._presenter.onContentHeightChanged(value);
                    };
                    TablixCell.prototype.enableHorizontalResize = function (enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    };
                    return TablixCell;
                })();
                internal.TablixCell = TablixCell;
                var TablixColumn = (function () {
                    function TablixColumn(presenter) {
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._contentWidth = -1;
                        this._width = -1;
                        this._sizeFixed = false;
                        this._aligningWidth = -1;
                        this._fixedToAligningWidth = false;
                        this._items = [];
                        this._itemType = null;
                        this._footerCell = null;
                    }
                    TablixColumn.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCornerCells = [];
                        this._realizedBodyCells = [];
                    };
                    Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getType = function () {
                        if (this._realizedCornerCells.length > 0)
                            return 0 /* CornerCell */;
                        return 2 /* ColumnHeader */;
                    };
                    TablixColumn.prototype.getColumnHeadersOrCorners = function () {
                        if (this._realizedCornerCells.length > 0)
                            return this._realizedCornerCells;
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.columnHeadersOrCornersEqual = function (newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length)
                            return false;
                        var count = this._items.length;
                        for (var i = 0; i < count; i++) {
                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator))
                                return false;
                        }
                        return true;
                    };
                    Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function () {
                            return this._itemType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getLeafItem = function () {
                        if (this._items.length === 0)
                            return null;
                        return this._items[this._items.length - 1];
                    };
                    TablixColumn.prototype.columnHeaderOrCornerEquals = function (type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2)
                            return false;
                        if (type1 === 0 /* CornerCell */) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2))
                                return false;
                        }
                        else {
                            if (!hierarchyNavigator.headerItemEquals(item1, item2))
                                return false;
                        }
                        return true;
                    };
                    TablixColumn.prototype.OnLeafRealized = function (hierarchyNavigator) {
                        // if the headers/corner have changed we should clear the column size to accomodate for the new content
                        var type = this.getType();
                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
                        }
                        else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; i < count; i++) {
                                this._items.push(columnHeadersOrCorners[i].item);
                            }
                            this._itemType = type;
                            this.clearSize();
                        }
                    };
                    TablixColumn.prototype.clearSpanningCellsWidth = function (cells) {
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (cell.colSpan > 1) {
                                cell.setContentWidth(-1);
                            }
                        }
                    };
                    TablixColumn.prototype.addCornerCell = function (cell) {
                        cell._column = this;
                        this._realizedCornerCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addRowHeader = function (cell) {
                        cell._column = this;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addColumnHeader = function (cell, isLeaf) {
                        cell._column = this;
                        this._realizedColumnHeaders.push(cell);
                        if (isLeaf) {
                            cell.setContentWidth(this._contentWidth);
                        }
                    };
                    TablixColumn.prototype.addBodyCell = function (cell) {
                        cell._column = this;
                        this._realizedBodyCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function () {
                            return this._footerCell;
                        },
                        set: function (footerCell) {
                            this._footerCell = footerCell;
                            footerCell._column = this;
                            footerCell.setContentWidth(this._contentWidth);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.resize = function (width) {
                        if (width === this.getContentContextualWidth())
                            return;
                        this._contentWidth = width;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = false;
                        this._aligningWidth = -1;
                    };
                    TablixColumn.prototype.fixSize = function () {
                        var shouldAlign = this._aligningWidth !== -1;
                        var switched = shouldAlign !== this._fixedToAligningWidth;
                        if ((this._sizeFixed && !switched && !shouldAlign))
                            return;
                        if (this._aligningWidth === -1) {
                            this._contentWidth += 1; // to avoid the ellipsis to appear (Issue with IE)
                            this.setContentWidth(this._contentWidth);
                        }
                        else {
                            this.setContentWidth(this._aligningWidth);
                        }
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = this._aligningWidth !== -1;
                    };
                    TablixColumn.prototype.clearSize = function () {
                        this._contentWidth = -1;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = false;
                    };
                    TablixColumn.prototype.getContentContextualWidth = function () {
                        return this._contentWidth;
                    };
                    TablixColumn.prototype.getCellIContentContextualWidth = function (cell) {
                        return this._presenter.getCellContentWidth(cell);
                    };
                    TablixColumn.prototype.getCellSpanningWidthWithScrolling = function (cell, tablixGrid) {
                        var width = this.getContextualWidth() + this.getScrollingOffset();
                        if (cell.colSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var columns = tablixGrid.realizedColumns;
                            for (var i = 1; i < cell.colSpan; i++)
                                width += columns[i + index].getContextualWidth();
                        }
                        return width;
                    };
                    TablixColumn.prototype.getScrollingOffset = function () {
                        var offset = 0;
                        if (this._realizedColumnHeaders.length > 0)
                            offset = this._realizedColumnHeaders[this._realizedColumnHeaders.length - 1].horizontalOffset;
                        return offset;
                    };
                    TablixColumn.prototype.getContextualWidth = function () {
                        if (this._width === -1 || this._contentWidth === -1)
                            this._width = this._presenter.getWidth();
                        return this._width;
                    };
                    TablixColumn.prototype.calculateSize = function () {
                        if (this._sizeFixed)
                            return;
                        var contentWidth = 0;
                        var count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._realizedCornerCells[i]));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._realizedBodyCells[i]));
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._footerCell));
                        }
                        this._contentWidth = contentWidth;
                    };
                    TablixColumn.prototype.setAligningContextualWidth = function (size) {
                        this._aligningWidth = size;
                    };
                    TablixColumn.prototype.getAligningContextualWidth = function () {
                        return this._aligningWidth;
                    };
                    TablixColumn.prototype.setContentWidth = function (value) {
                        var count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.colSpan === 1)
                                cell.setContentWidth(value);
                        }
                        count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.colSpan === 1)
                                cell.setContentWidth(value);
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContentWidth(value);
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContentWidth(value);
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                this._footerCell.setContentWidth(value);
                        }
                        this._width = -1; // invalidate the cell width
                    };
                    TablixColumn.prototype.getTablixCell = function () {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixColumn.prototype.getIndex = function (grid) {
                        return grid.realizedColumns.indexOf(this);
                    };
                    TablixColumn.prototype.getHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixColumn.prototype.getCellContextualSpan = function (cell) {
                        return cell.colSpan;
                    };
                    TablixColumn.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._row;
                    };
                    return TablixColumn;
                })();
                internal.TablixColumn = TablixColumn;
                var TablixRow = (function () {
                    function TablixRow(presenter) {
                        this._contentHeight = -1;
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._allocatedCells = [];
                        this._heightFixed = false;
                        this._contentHeight = -1;
                        this._height = -1;
                    }
                    TablixRow.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedBodyCells = [];
                        this._realizedCornerCells = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCellsCount = 0;
                    };
                    Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function () {
                            return this._presenter;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixRow.prototype.releaseUnusedCells = function (owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    };
                    TablixRow.prototype.releaseAllCells = function (owner) {
                        this.releaseCells(owner, 0);
                    };
                    TablixRow.prototype.releaseCells = function (owner, startIndex) {
                        var cells = this._allocatedCells;
                        var length = cells.length;
                        for (var i = startIndex; i < length; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell);
                            cell.clear();
                        }
                    };
                    TablixRow.prototype.moveScrollableCellsToEnd = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onAppendCell(cell);
                            this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    };
                    TablixRow.prototype.moveScrollableCellsToStart = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    };
                    TablixRow.prototype.getOrCreateCornerCell = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.addCornerCell(cell);
                        this._realizedCornerCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateRowHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addRowHeader(cell);
                        this._realizedRowHeaders.push(cell);
                        if (leaf)
                            cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateColumnHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addColumnHeader(cell, leaf);
                        this._realizedColumnHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addBodyCell(cell);
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterRowHeader = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.footer = cell;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.footer = cell;
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getRowHeaderLeafIndex = function () {
                        var index = -1;
                        var count = this._allocatedCells.length;
                        for (var i = 0; i < count; i++) {
                            if (this._allocatedCells[i].type !== 1 /* RowHeader */)
                                break;
                            index++;
                        }
                        return index;
                    };
                    TablixRow.prototype.getAllocatedCellAt = function (index) {
                        return this._allocatedCells[index];
                    };
                    TablixRow.prototype.moveCellsBy = function (delta) {
                        if (this._allocatedCells.length === 0)
                            return;
                        if (delta > 0) {
                            var refCell = this._allocatedCells[0];
                            for (var i = 0; i < delta; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell);
                                this._allocatedCells.unshift(cell);
                                refCell = cell;
                            }
                        }
                        else {
                            delta = -delta;
                            for (var i = 0; i < delta; i++) {
                                this._presenter.onRemoveCell(this._allocatedCells[i]);
                            }
                            this._allocatedCells.splice(0, delta);
                        }
                    };
                    TablixRow.prototype.getRealizedCellCount = function () {
                        return this._realizedCellsCount;
                    };
                    TablixRow.prototype.getRealizedHeadersCount = function () {
                        return this._realizedRowHeaders.length;
                    };
                    TablixRow.prototype.getRealizedHeaderAt = function (index) {
                        return this._realizedRowHeaders[index];
                    };
                    TablixRow.prototype.getTablixCell = function () {
                        var realizedCells;
                        if (this._realizedRowHeaders.length > 0) {
                            realizedCells = this._realizedRowHeaders;
                        }
                        else if (this._realizedCornerCells.length > 0) {
                            realizedCells = this._realizedCornerCells;
                        }
                        else {
                            realizedCells = this._realizedColumnHeaders;
                        }
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixRow.prototype.getOrCreateEmptySpaceCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        return cell;
                    };
                    TablixRow.prototype.createCell = function (row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    };
                    TablixRow.prototype.getOrCreateCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        else {
                            cell.colSpan = 1;
                            cell.rowSpan = 1;
                        }
                        this._realizedCellsCount = this._realizedCellsCount + 1;
                        return cell;
                    };
                    TablixRow.prototype.resize = function (height) {
                        if (height === this.getContentContextualWidth())
                            return;
                        this._contentHeight = height;
                        this.setContentHeight();
                        this._heightFixed = true;
                        this.setAligningContextualWidth(-1);
                    };
                    TablixRow.prototype.fixSize = function () {
                        if (this.sizeFixed())
                            return;
                        this.setContentHeight();
                        this._heightFixed = true;
                    };
                    TablixRow.prototype.getContentContextualWidth = function () {
                        return this._contentHeight;
                    };
                    TablixRow.prototype.getCellIContentContextualWidth = function (cell) {
                        return this.presenter.getCellContentHeight(cell);
                    };
                    TablixRow.prototype.getCellSpanningHeight = function (cell, tablixGrid) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var rows = tablixGrid.realizedRows;
                            for (var i = 1; i < cell.rowSpan; i++)
                                height += rows[i + index].getContextualWidth();
                        }
                        return height;
                    };
                    TablixRow.prototype.getContextualWidth = function () {
                        if (this._height === -1 || this._contentHeight === -1)
                            this._height = this._presenter.getHeight();
                        return this._height;
                    };
                    TablixRow.prototype.sizeFixed = function () {
                        return this._heightFixed;
                    };
                    TablixRow.prototype.calculateSize = function () {
                        if (this._heightFixed)
                            return;
                        var contentHeight = 0;
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        }
                        this._contentHeight = contentHeight;
                    };
                    TablixRow.prototype.setAligningContextualWidth = function (size) {
                        // TODO should be implemented when we support variable row heights
                    };
                    TablixRow.prototype.getAligningContextualWidth = function () {
                        // TODO should be implemented when we support variable row heights
                        return -1;
                    };
                    TablixRow.prototype.setContentHeight = function () {
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan)
                                cell.setContentHeight(this._contentHeight);
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContentHeight(this._contentHeight);
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                cell.setContentHeight(this._contentHeight);
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContentHeight(this._contentHeight);
                        }
                        this._height = -1;
                    };
                    TablixRow.prototype.getIndex = function (grid) {
                        return grid.realizedRows.indexOf(this);
                    };
                    TablixRow.prototype.getHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixRow.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixRow.prototype.getCellContextualSpan = function (cell) {
                        return cell.rowSpan;
                    };
                    TablixRow.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._column;
                    };
                    return TablixRow;
                })();
                internal.TablixRow = TablixRow;
                var TablixGrid = (function () {
                    function TablixGrid(presenter) {
                        this._presenter = presenter;
                        this._footerRow = null;
                    }
                    TablixGrid.prototype.initialize = function (owner, gridHost, footerHost) {
                        this._owner = owner;
                        this._presenter.initialize(this, gridHost, footerHost, owner);
                        this.fillColumnsProportionally = false;
                        this._realizedRows = [];
                        this._realizedColumns = [];
                        this._emptySpaceHeaderCell = null;
                        this._emptyFooterSpaceCell = null;
                    };
                    Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function () {
                            return this._fillColumnsProportionally;
                        },
                        set: function (value) {
                            if (this._fillColumnsProportionally === value)
                                return;
                            this._fillColumnsProportionally = value;
                            this._presenter.onFillColumnsProportionallyChanged(value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function () {
                            return this._realizedColumns;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function () {
                            return this._realizedRows;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function () {
                            return this._footerRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function () {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function () {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixGrid.prototype.ShowEmptySpaceCells = function (rowSpan, width) {
                        if (this._realizedRows.length === 0)
                            return;
                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
                            this._emptySpaceHeaderCell.colSpan = 1;
                            this._emptySpaceHeaderCell.setContentWidth(width);
                        }
                        if (this._footerRow && (this._emptyFooterSpaceCell === null)) {
                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
                            this._emptyFooterSpaceCell.rowSpan = 1;
                            this._emptyFooterSpaceCell.colSpan = 1;
                            this._emptyFooterSpaceCell.setContentWidth(width);
                        }
                    };
                    TablixGrid.prototype.HideEmptySpaceCells = function () {
                        if (this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell.clear();
                            this._emptySpaceHeaderCell = null;
                        }
                        if (this._emptyFooterSpaceCell) {
                            this._emptyFooterSpaceCell.clear();
                            this._emptyFooterSpaceCell = null;
                        }
                    };
                    TablixGrid.prototype.onStartRenderingIteration = function (clear) {
                        this.initializeRows(clear);
                        this.initializeColumns(clear);
                    };
                    TablixGrid.prototype.onEndRenderingIteration = function () {
                        var rows = this._rows;
                        if (rows !== undefined) {
                            var rowCount = rows.length;
                            for (var i = 0; i < rowCount; i++) {
                                rows[i].releaseUnusedCells(this._owner);
                            }
                        }
                        if (this._footerRow) {
                            this._footerRow.releaseUnusedCells(this._owner);
                        }
                    };
                    TablixGrid.prototype.onStartRenderingSession = function () {
                    };
                    TablixGrid.prototype.onEndRenderingSession = function () {
                    };
                    TablixGrid.prototype.getOrCreateRow = function (rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        if (currentRow === undefined) {
                            currentRow = new TablixRow(this._presenter.createRowPresenter());
                            currentRow.initialize(this);
                            this._presenter.onAppendRow(currentRow);
                            this._rows[rowIndex] = currentRow;
                        }
                        if (this._realizedRows[rowIndex] === undefined) {
                            this._realizedRows[rowIndex] = currentRow;
                        }
                        return currentRow;
                    };
                    TablixGrid.prototype.getOrCreateFootersRow = function () {
                        if (this._footerRow === null) {
                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
                            this._footerRow.initialize(this);
                            this._presenter.onAddFooterRow(this._footerRow);
                        }
                        return this._footerRow;
                    };
                    TablixGrid.prototype.moveRowsToEnd = function (moveFromIndex, count) {
                        for (var i = 0; i < count; i++) {
                            var row = this._rows[i + moveFromIndex];
                            debug.assertValue(row, "Invalid Row Index");
                            this._presenter.onRemoveRow(row);
                            this._presenter.onAppendRow(row);
                            this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveRowsToStart = function (moveToIndex, count) {
                        var refRow = this._rows[moveToIndex];
                        debug.assertValue(refRow, "Invalid Row Index");
                        for (var i = 0; i < count; i++) {
                            var row = this._rows.pop();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onInsertRowBefore(row, refRow);
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    };
                    TablixGrid.prototype.moveColumnsToEnd = function (moveFromIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToEnd(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns[i + moveFromIndex];
                            //Debug.assertValue(column, "Invalid Column Index");
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveColumnsToStart = function (moveToIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToStart(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    };
                    TablixGrid.prototype.getOrCreateColumn = function (columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        if (currentColumn === undefined) {
                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter());
                            currentColumn.initialize(this);
                            this._columns[columnIndex] = currentColumn;
                        }
                        if (this._realizedColumns[columnIndex] === undefined) {
                            this._realizedColumns[columnIndex] = currentColumn;
                        }
                        return currentColumn;
                    };
                    TablixGrid.prototype.initializeColumns = function (clear) {
                        if (this._columns === undefined || clear) {
                            this._columns = [];
                        }
                        var length = this._columns.length;
                        for (var i = 0; i < length; i++) {
                            this._columns[i].initialize(this);
                        }
                        this._realizedColumns = [];
                    };
                    TablixGrid.prototype.initializeRows = function (clear) {
                        //make sure rowDimension confirms it and it's not null in the grid
                        var hasFooter = this._owner.rowDimension.hasFooter() && (this._footerRow !== null);
                        if (clear) {
                            var rows = this._rows;
                            if (rows) {
                                var length = rows.length;
                                for (var i = 0; i < length; i++) {
                                    rows[i].releaseAllCells(this._owner);
                                }
                                if (hasFooter)
                                    this._footerRow.releaseAllCells(this._owner);
                                this._presenter.onClear();
                                this._footerRow = null;
                                this._rows = null;
                            }
                        }
                        this._realizedRows = [];
                        if (!this._rows) {
                            this._rows = [];
                        }
                        var rows = this._rows;
                        var length = rows.length;
                        for (var i = 0; i < length; i++) {
                            rows[i].initialize(this);
                        }
                        if (hasFooter) {
                            if (!this._footerRow) {
                                this.getOrCreateFootersRow();
                            }
                            this._footerRow.initialize(this);
                        }
                    };
                    TablixGrid.prototype.getWidth = function () {
                        return this._presenter.getWidth();
                    };
                    TablixGrid.prototype.getHeight = function () {
                        return this._presenter.getHeight();
                    };
                    return TablixGrid;
                })();
                internal.TablixGrid = TablixGrid;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="TablixGrid.ts" />
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                var TablixDomResizer = (function (_super) {
                    __extends(TablixDomResizer, _super);
                    function TablixDomResizer(cell, element, handler) {
                        this._cell = cell;
                        _super.call(this, element, handler);
                    }
                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function () {
                            return this._cell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixDomResizer.prototype._hotSpot = function (position) {
                        return position.x >= this.element.getBoundingClientRect().right - internal.TablixResizer.resizeHandleSize;
                    };
                    return TablixDomResizer;
                })(internal.TablixResizer);
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = (function () {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        // Table cell will be created once needed
                        this._tableCell = null;
                        // Content element
                        this._contentElement = internal.TablixUtils.createDiv();
                        this._contentElement.style.position = "relative";
                        if (!fitProportionally)
                            this._contentElement.style.setProperty("float", "left");
                        // Content Host
                        this._contentHost = internal.TablixUtils.createDiv();
                        this._contentHost.style.position = "relative";
                        // TODO: this styling should not happen in the cell presenter; refactor to binder or layout manager
                        if (layoutKind === 1 /* DashboardTile */) {
                            this._contentHost.style.textOverflow = "ellipsis";
                            // With the current styling bold numbers are cut off at the right; adding a small padding
                            this._contentHost.style.paddingRight = "2px";
                        }
                        this._contentElement.appendChild(this._contentHost);
                        this._resizer = null;
                        TablixCellPresenter.addNoMarginStyle();
                    }
                    TablixCellPresenter.prototype.initialize = function (owner) {
                        this._owner = owner;
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerTableCell = function (tableCell) {
                        this._tableCell = tableCell;
                        tableCell.appendChild(this._contentElement);
                        tableCell.className = TablixCellPresenter._noMarginsStyleName;
                        // TODO: Push to CSS
                        tableCell.style.verticalAlign = "top";
                        tableCell.style.lineHeight = "normal";
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function () {
                            return this._tableCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        get: function () {
                            return this._contentElement;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        get: function () {
                            return this._contentHost;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerClickHandler = function (handler) {
                        this._contentElement.onclick = handler;
                    };
                    TablixCellPresenter.prototype.unregisterClickHandler = function () {
                        this._contentElement.onclick = null;
                    };
                    TablixCellPresenter.prototype.onContentWidthChanged = function (value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    };
                    TablixCellPresenter.prototype.onContentHeightChanged = function (height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    };
                    TablixCellPresenter.prototype.onColumnSpanChanged = function (value) {
                        this._tableCell.colSpan = value;
                    };
                    TablixCellPresenter.prototype.onRowSpanChanged = function (value) {
                        this._tableCell.rowSpan = value;
                    };
                    TablixCellPresenter.prototype.onTextAlignChanged = function (value) {
                        this._tableCell.style.textAlign = value;
                    };
                    TablixCellPresenter.prototype.onClear = function () {
                        this._contentHost.className = "";
                        this._contentHostStyle = "";
                        this._tableCell.className = TablixCellPresenter._noMarginsStyleName;
                        this._containerStyle = "";
                    };
                    TablixCellPresenter.prototype.onHorizontalScroll = function (width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    };
                    TablixCellPresenter.prototype.onVerticalScroll = function (height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    };
                    TablixCellPresenter.prototype.onInitializeScrolling = function () {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    };
                    TablixCellPresenter.prototype.setContentHostStyle = function (style) {
                        if (this._contentHostStyle !== style) {
                            this._contentHostStyle = style;
                            this._contentHost.className = this._contentHostStyle;
                        }
                    };
                    TablixCellPresenter.prototype.setContainerStyle = function (style) {
                        if (this._containerStyle !== style) {
                            this._containerStyle = style;
                            this._tableCell.className = this._containerStyle + " " + TablixCellPresenter._noMarginsStyleName;
                        }
                    };
                    TablixCellPresenter.prototype.clearContainerStyle = function () {
                        this._containerStyle = undefined;
                        if (this._tableCell.className !== TablixCellPresenter._noMarginsStyleName)
                            this._tableCell.className = TablixCellPresenter._noMarginsStyleName;
                    };
                    TablixCellPresenter.prototype.enableHorizontalResize = function (enable, handler) {
                        if (enable === (this._resizer !== null))
                            return;
                        if (enable) {
                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
                            this._resizer.initialize();
                        }
                        else {
                            this._resizer.uninitialize();
                            this._resizer = null;
                        }
                    };
                    TablixCellPresenter.addNoMarginStyle = function () {
                        if (!TablixCellPresenter._noMarginsStyle) {
                            var style = document.createElement('style');
                            style.appendChild(document.createTextNode("." + TablixCellPresenter._noMarginsStyleName + "{ padding: 0px; margin: 0px}"));
                            document.head.appendChild(style);
                            TablixCellPresenter._noMarginsStyle = style;
                        }
                    };
                    // In order to allow dragging of the tableCell we need to
                    // disable dragging of the container of the cell in IE.
                    TablixCellPresenter.prototype.disableDragResize = function () {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    };
                    TablixCellPresenter._noMarginsStyleName = "bi-tablix-cellNoMarginStyle";
                    // Attribute used to disable dragging in order to have cell resizing work.
                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
                    return TablixCellPresenter;
                })();
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = (function () {
                    function TablixRowPresenter(fitProportionally) {
                        // Table row will be created once needed
                        this._tableRow = null;
                        this._fitProportionally = fitProportionally;
                    }
                    TablixRowPresenter.prototype.initialize = function (row) {
                        this._row = row;
                    };
                    TablixRowPresenter.prototype.createCellPresenter = function (layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    };
                    TablixRowPresenter.prototype.registerRow = function (tableRow) {
                        this._tableRow = tableRow;
                    };
                    TablixRowPresenter.prototype.onAppendCell = function (cell) {
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reason we use InsertCell() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.appendChild(presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onInsertCellBefore = function (cell, refCell) {
                        debug.assertValue(refCell._presenter.tableCell, 'refTableCell');
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reasons we use InsertCell() to create new table cells instead of AppendChild()
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onRemoveCell = function (cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    };
                    TablixRowPresenter.prototype.getHeight = function () {
                        return this.getCellHeight(this._row.getTablixCell());
                    };
                    TablixRowPresenter.prototype.getCellHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    TablixRowPresenter.prototype.getCellContentHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function () {
                            return this._tableRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TablixRowPresenter;
                })();
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = (function (_super) {
                    __extends(DashboardRowPresenter, _super);
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        _super.call(this, fitProportionally);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardRowPresenter.prototype.getCellHeight = function (cell) {
                        return this._gridPresenter.sizeComputationManager.cellHeight;
                    };
                    DashboardRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return this._gridPresenter.sizeComputationManager.contentHeight;
                    };
                    return DashboardRowPresenter;
                })(TablixRowPresenter);
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = (function (_super) {
                    __extends(CanvasRowPresenter, _super);
                    function CanvasRowPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowPresenter.prototype.getCellHeight = function (cell) {
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell);
                    };
                    CanvasRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement);
                    };
                    return CanvasRowPresenter;
                })(TablixRowPresenter);
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = (function () {
                    function TablixColumnPresenter() {
                    }
                    TablixColumnPresenter.prototype.initialize = function (column) {
                        this._column = column;
                    };
                    TablixColumnPresenter.prototype.getWidth = function () {
                        return this.getCellWidth(this._column.getTablixCell());
                    };
                    TablixColumnPresenter.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
                        return -1;
                    };
                    TablixColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellContentWidth");
                        return -1;
                    };
                    return TablixColumnPresenter;
                })();
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = (function (_super) {
                    __extends(DashboardColumnPresenter, _super);
                    function DashboardColumnPresenter(gridPresenter) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardColumnPresenter.prototype.getCellWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    DashboardColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.contentWidth;
                    };
                    return DashboardColumnPresenter;
                })(TablixColumnPresenter);
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = (function (_super) {
                    __extends(CanvasColumnPresenter, _super);
                    function CanvasColumnPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnPresenter.prototype.getCellWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    return CanvasColumnPresenter;
                })(TablixColumnPresenter);
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = (function () {
                    function TablixGridPresenter() {
                        // Main Table
                        this._table = internal.TablixUtils.createTable();
                        this._table.className = UNSELECTABLE_CLASS_NAME;
                        // Footer Table
                        this._footerTable = internal.TablixUtils.createTable();
                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
                    }
                    TablixGridPresenter.prototype.initialize = function (owner, gridHost, footerHost, control) {
                        this._owner = owner;
                        gridHost.appendChild(this._table);
                        footerHost.appendChild(this._footerTable);
                    };
                    TablixGridPresenter.prototype.getWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioX = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioY = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.createRowPresenter = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.createColumnPresenter = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.onAppendRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onInsertRowBefore = function (row, refRow) {
                        debug.assertValue(refRow.presenter.tableRow, 'refTableRow');
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onRemoveRow = function (row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    };
                    TablixGridPresenter.prototype.onAddFooterRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onClear = function () {
                        controls.HTMLElementUtils.clearChildren(this._table);
                        controls.HTMLElementUtils.clearChildren(this._footerTable);
                    };
                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function (value) {
                        if (value) {
                            this._table.style.width = "100%";
                            this._footerTable.style.width = "100%";
                        }
                        else {
                            this._table.style.width = "auto";
                            this._footerTable.style.width = "auto";
                        }
                    };
                    return TablixGridPresenter;
                })();
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = (function (_super) {
                    __extends(DashboardTablixGridPresenter, _super);
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        _super.call(this);
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    };
                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function () {
                        return new DashboardColumnPresenter(this);
                    };
                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function () {
                            return this._sizeComputationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DashboardTablixGridPresenter.prototype.getWidth = function () {
                        return this._sizeComputationManager.gridWidth;
                    };
                    DashboardTablixGridPresenter.prototype.getHeight = function () {
                        return this._sizeComputationManager.gridHeight;
                    };
                    return DashboardTablixGridPresenter;
                })(TablixGridPresenter);
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = (function (_super) {
                    __extends(CanvasTablixGridPresenter, _super);
                    function CanvasTablixGridPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    };
                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function () {
                        return new CanvasColumnPresenter();
                    };
                    CanvasTablixGridPresenter.prototype.getWidth = function () {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    };
                    CanvasTablixGridPresenter.prototype.getHeight = function () {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    };
                    return CanvasTablixGridPresenter;
                })(TablixGridPresenter);
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /** Base class for Tablix realization manager
                  */
                var TablixDimensionRealizationManager = (function () {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder;
                        this._adjustmentFactor = 1;
                    }
                    TablixDimensionRealizationManager.prototype._getOwner = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
                        return null;
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function () {
                            return this._adjustmentFactor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function () {
                            return this._itemsToRealizeCount;
                        },
                        set: function (count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function () {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function (contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function () {
                        var owner = this._getOwner();
                        if (owner.measureEnabled && !owner.done) {
                            this._getEstimatedItemsToRealizeCount();
                        }
                        this._realizedLeavesCount = 0;
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function (gridContextualWidth, filled) {
                        if (!filled && !this._getOwner().allItemsRealized)
                            this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function () {
                        this._adjustmentFactor = 1;
                    };
                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function (item, cell) {
                    };
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        if (leaf) {
                            this._realizedLeavesCount++;
                        }
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
                    };
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
                        return 1;
                    };
                    return TablixDimensionRealizationManager;
                })();
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                /** DOM implementation for Row Tablix realization manager
                  */
                var RowRealizationManager = (function (_super) {
                    __extends(RowRealizationManager, _super);
                    function RowRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateRowsToRealizeCount();
                    };
                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function () {
                        debug.assertValue(this._owner, '_owner');
                        if (!this._owner.dimension.model) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        if (this._owner.alignToEnd)
                            this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1;
                        else
                            this.itemsToRealizeCount = Math.ceil((this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor)) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
                    };
                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0)
                            return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        var levelsArray = levels.items;
                        var levelCount = levelsArray.length;
                        var width = 0;
                        for (var i = 0; i < levelCount; i++) {
                            var level = levelsArray[i];
                            if (level.maxNonLeafWidth !== 0)
                                width += level.maxNonLeafWidth;
                            else
                                width += level.maxLeafWidth;
                        }
                        return width;
                    };
                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function (items, firstVisibleIndex, levels) {
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var binder = this.binder;
                        var length = hierarchyNavigator.getCount(items);
                        for (var i = firstVisibleIndex; i < length; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount)
                                return;
                            var item = hierarchyNavigator.getAt(items, i);
                            var label = binder.getHeaderLabel(item);
                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
                            var isLeaf = hierarchyNavigator.isLeaf(item);
                            var l = hierarchyNavigator.getLevel(item);
                            var level = levels.items[l];
                            if (!level) {
                                level = new RowWidth();
                                levels.items[l] = level;
                            }
                            if (isLeaf) {
                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
                                levels.leafCount = levels.leafCount + 1;
                            }
                            else {
                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
                            }
                        }
                    };
                    RowRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    };
                    return RowRealizationManager;
                })(TablixDimensionRealizationManager);
                internal.RowRealizationManager = RowRealizationManager;
                /** DOM implementation for Column Tablix realization manager
                  */
                var ColumnRealizationManager = (function (_super) {
                    __extends(ColumnRealizationManager, _super);
                    function ColumnRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    };
                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function () {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (this._owner.otherLayoutManager.done)
                            return this._owner.getOtherHierarchyContextualHeight();
                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    };
                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function (rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        var binder = this.binder;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
                        var endColumnIndex = this._owner.dimension.getItemsCount();
                        this.itemsEstimatedContextualWidth = 0;
                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
                        var endRowIndex = Math.min(startRowIndex + this.rowRealizationManager.itemsToRealizeCount, this._owner.otherLayoutManager.dimension.getItemsCount() - 1);
                        var columnCount = endColumnIndex - startColumnIndex;
                        if (this._owner.alignToEnd) {
                            this.itemsToRealizeCount = columnCount;
                            return;
                        }
                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
                                this.itemsToRealizeCount = i - startColumnIndex;
                                return;
                            }
                            var maxWidth = 0;
                            var visibleSizeRatio;
                            if (i === startColumnIndex) {
                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
                            }
                            else {
                                visibleSizeRatio = 1;
                            }
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
                            var label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; j < endRowIndex; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    };
                    ColumnRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    };
                    return ColumnRealizationManager;
                })(TablixDimensionRealizationManager);
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = (function () {
                    function RowWidths() {
                        this.items = [];
                        this.leafCount = 0;
                    }
                    return RowWidths;
                })();
                internal.RowWidths = RowWidths;
                var RowWidth = (function () {
                    function RowWidth() {
                        this.maxLeafWidth = 0;
                        this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                })();
                internal.RowWidth = RowWidth;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /** This class is used for layouts that don't or cannot
                    rely on DOM measurements.  Instead they compute all required
                    widths and heights and store it in this structure. */
                var SizeComputationManager = (function () {
                    function SizeComputationManager() {
                    }
                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function () {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function () {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function () {
                            return this.visibleWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function () {
                            return this.visibleHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function () {
                            return this._cellWidth - SizeComputationManager.DashboardCellPaddingLeft - SizeComputationManager.DashboardCellPaddingRight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SizeComputationManager.prototype.updateColumnCount = function (columnCount) {
                        this._columnCount = columnCount;
                    };
                    SizeComputationManager.prototype.updateViewport = function (viewport) {
                        this._viewport = viewport;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                        this._cellHeight = SizeComputationManager.DashboardRowHeight;
                    };
                    SizeComputationManager.prototype.computeColumnWidth = function (totalColumnCount) {
                        var width = this._viewport.width;
                        if (width <= 250) {
                            // Small
                            return this.fitToColumnCount(3, totalColumnCount);
                        }
                        else if (width <= 510) {
                            // Medium
                            return this.fitToColumnCount(4, totalColumnCount);
                        }
                        else if (width <= 770) {
                            // Large
                            return this.fitToColumnCount(7, totalColumnCount);
                        }
                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
                    };
                    SizeComputationManager.prototype.fitToColumnCount = function (desiredColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(desiredColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    };
                    // Unfortunately since we are doing manual layout, we need to hardcode some layout properties here.
                    // These must be kept in sync with what is specified in the .bi-dashboard-tablix class.
                    SizeComputationManager.DashboardCellPaddingLeft = 10;
                    SizeComputationManager.DashboardCellPaddingRight = 5;
                    SizeComputationManager.DashboardRowHeight = 19;
                    return SizeComputationManager;
                })();
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = (function () {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        //debug.assertValue(realizationManager, "Realization Manager must be defined");
                        this._owner = owner;
                        this._grid = grid;
                        this._lastScrollOffset = null;
                        this._isScrolling = false;
                        this._fixedSizeEnabled = true;
                        this._done = false;
                        this._realizationManager = realizationManager;
                    }
                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function () {
                            return this._realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function () {
                            return this._fixedSizeEnabled;
                        },
                        set: function (enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onCornerCellRealized = function (item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    };
                    DimensionLayoutManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function () {
                        return 1 - this.dimension.getFractionScrollOffset();
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function () {
                            return this._alignToEnd;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function () {
                            return this._done;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype._requiresMeasure = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
                        return true;
                    };
                    DimensionLayoutManager.prototype.startScrollingSession = function () {
                        this._isScrolling = true;
                    };
                    DimensionLayoutManager.prototype.endScrollingSession = function () {
                        this._isScrolling = false;
                    };
                    DimensionLayoutManager.prototype.isScrolling = function () {
                        return this._isScrolling;
                    };
                    DimensionLayoutManager.prototype.isResizing = function () {
                        return false;
                    };
                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function () {
                        var otherDimension = this.dimension.otherDimension;
                        var count = otherDimension.getDepth();
                        var contextualHeight = 0;
                        var items = this._getRealizedItems();
                        if (items.length > 0) {
                            for (var i = 0; i < count; i++) {
                                contextualHeight += items[i].getContextualWidth();
                            }
                        }
                        return contextualHeight;
                    };
                    DimensionLayoutManager.prototype._isAutoSized = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
                        return false;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingSession = function () {
                        this._measureEnabled = this._requiresMeasure();
                        this._gridOffset = this.dimension.otherDimension.getDepth();
                    };
                    DimensionLayoutManager.prototype.onEndRenderingSession = function () {
                        this._realizationManager.onEndRenderingSession();
                        this._alignToEnd = false;
                        this._done = false;
                        this._measureEnabled = true;
                        this._sendDimensionsToControl();
                    };
                    /**
                    *   Implementing classes must override this to send dimentions to TablixControl
                    **/
                    DimensionLayoutManager.prototype._sendDimensionsToControl = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function () {
                            return this._measureEnabled;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getFooterContextualWidth = function () {
                        return 0;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingIteration = function (clear, contextualWidth) {
                        if (this._measureEnabled && !this._done) {
                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
                        }
                        this._realizationManager.onStartRenderingIteration();
                        if (clear) {
                            this._lastScrollOffset = null;
                        }
                        else if (this._lastScrollOffset !== null) {
                            this.swapElements();
                        }
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function () {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onEndRenderingIteration = function () {
                        if (this._done) {
                            return;
                        }
                        if (!this._measureEnabled) {
                            this._lastScrollOffset = this.dimension.scrollOffset;
                            this._done = true;
                            return;
                        }
                        var gridContextualWidth = this.getGridContextualWidth();
                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        var allRealized = this.allItemsRealized;
                        var newScrollOffset;
                        if (filled) {
                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
                        }
                        else {
                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
                        }
                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
                        this.updateScrollbar(gridContextualWidth);
                        this._done = (filled || allRealized) && this.dimension.scrollbar.visible === originalScrollbarVisible && powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        this.dimension.scrollOffset = newScrollOffset;
                        this._lastScrollOffset = this.dimension.scrollOffset;
                    };
                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function () {
                        if (this._lastScrollOffset !== null) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
                                return delta;
                            }
                        }
                        return null;
                    };
                    DimensionLayoutManager.prototype.swapElements = function () {
                        var delta = this.getScrollDeltaWithinPage();
                        if (delta !== null) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
                                if (delta > 0) {
                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
                                }
                                else if (delta < 0) {
                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype._getRealizedItems = function () {
                        // abstract
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
                        return null;
                    };
                    DimensionLayoutManager.prototype.getRealizedItemsCount = function () {
                        return this._getRealizedItems().length;
                    };
                    DimensionLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
                    };
                    DimensionLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
                    };
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function () {
                        return this.getScrollDeltaWithinPage() !== null;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidth = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
                        return 0;
                    };
                    DimensionLayoutManager.prototype.updateScrollbar = function (gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset;
                        scrollbar.min = 0;
                        scrollbar.max = this.dimension.getItemsCount();
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    };
                    DimensionLayoutManager.prototype.getViewSize = function (gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (count === 0)
                            return 0;
                        var startIndex = this._gridOffset;
                        var sizeInItems = 0;
                        var sizeInPixels = 0;
                        var widthToFill = this._contextualWidthToFill;
                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
                        var error = this.getMeaurementError(gridContextualWidth);
                        for (var i = startIndex; i < count; i++) {
                            var visibleRatio;
                            if (i === startIndex) {
                                visibleRatio = this.getVisibleSizeRatio();
                            }
                            else
                                visibleRatio = 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            sizeInPixels += itemContextualWidth;
                            sizeInItems += visibleRatio;
                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= ((sizeInPixels - scrollableArea) / itemContextualWidth) * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    };
                    DimensionLayoutManager.prototype.isScrollableHeader = function (item, items, index) {
                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
                            return false;
                        }
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) {
                            return true;
                        }
                        var currentItem = item;
                        var currentItems = items;
                        do {
                            currentItems = hierarchyNavigator.getChildren(currentItem);
                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
                            if (currentItem === undefined) {
                                break;
                            }
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
                                return false;
                            }
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return true;
                    };
                    DimensionLayoutManager.prototype.reachedEnd = function () {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    DimensionLayoutManager.prototype.scrollBackwardToFill = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - (widthToFill / averageColumnwidth)));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision); // this is an aproximate scrolling back, we have to ensure it is aligned to the end of the control
                        }
                        return newScrollOffset;
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidth = function (index) {
                        return this._getRealizedItems()[index].getContextualWidth();
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function (index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    };
                    DimensionLayoutManager.prototype.getSizeWithScrolling = function (size, index) {
                        var ratio;
                        if (this._gridOffset === index) {
                            ratio = this.getVisibleSizeRatio();
                        }
                        else {
                            ratio = 1;
                        }
                        return size * ratio;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function () {
                        var count = this.getRealizedItemsCount();
                        var contextualWidth = 0;
                        for (var i = 0; i < count; i++) {
                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        }
                        return contextualWidth;
                    };
                    DimensionLayoutManager.prototype.getMeaurementError = function (gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    };
                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) {
                                var count = this.getRealizedItemsCount();
                                var startIndex = this._gridOffset;
                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
                                var error = this.getMeaurementError(gridContextualWidth);
                                for (var i = startIndex; i < count; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        widthToScroll -= itemContextualWidth;
                                    }
                                    else {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + (widthToScroll * visibleRatio / itemContextualWidth));
                                        break;
                                    }
                                }
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function () {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function () {
                            return this._contextualWidthToFill;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getGridScale = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
                        return 0;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getActualContextualWidth = function (gridContextualWidth) {
                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth))
                            return gridContextualWidth;
                        return this._contextualWidthToFill;
                    };
                    DimensionLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
                        return false;
                    };
                    DimensionLayoutManager.prototype.calculateSizes = function () {
                        if (this.fixedSizeEnabled) {
                            this.calculateContextualWidths();
                            this.calculateSpans();
                        }
                    };
                    DimensionLayoutManager.prototype._calculateSize = function (item) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
                    };
                    DimensionLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var count = items.length;
                        for (var i = 0; i < count; i++) {
                            var item = items[i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            this._calculateSize(item);
                        }
                    };
                    DimensionLayoutManager.prototype.calculateSpans = function () {
                        if (this.measureEnabled) {
                            this.updateNonScrollableItemsSpans();
                            this.updateScrollableItemsSpans();
                        }
                        // TODO override in row layout manager to add footer to calculation, this is required for Matrix
                    };
                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function () {
                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
                        var otherDimensionItemsCount = otherDimensionItems.length;
                        var startIndex = this.dimension.getDepth();
                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function () {
                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
                        for (var i = 0; i < otherRealizedItemsCount; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.fixSizes = function () {
                        if (this.fixedSizeEnabled) {
                            var items = this._getRealizedItems();
                            var count = items.length;
                            for (var i = 0; i < count; i++) {
                                items[i].fixSize();
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateSpans = function (otherRealizedItem, cells) {
                        var realizedItems = this._getRealizedItems();
                        var cellCount = cells.length;
                        for (var j = 0; j < cellCount; j++) {
                            var cell = cells[j];
                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
                            var span = owner.getCellContextualSpan(cell);
                            if (span > 1) {
                                var totalSizeInSpan = 0;
                                var startIndex = owner.getIndex(this._grid);
                                for (var k = 0; k < span; k++) {
                                    var item = realizedItems[k + startIndex];
                                    totalSizeInSpan += this.getSizeWithScrolling(item.getContentContextualWidth(), k + startIndex);
                                    if (k === span - 1)
                                        this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateLastChildSize = function (spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        if (delta > 0)
                            item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    };
                    DimensionLayoutManager._pixelPrecision = 1.0001;
                    DimensionLayoutManager._scrollOffsetPrecision = 0.01;
                    return DimensionLayoutManager;
                })();
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = (function () {
                    function ResizeState(column, width, scale) {
                        this.column = column;
                        this.item = column.getLeafItem();
                        this.itemType = column.itemType;
                        this.startColumnWidth = width;
                        this.resizingDelta = 0;
                        this.animationFrame = null;
                        this.scale = scale;
                    }
                    return ResizeState;
                })();
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = (function (_super) {
                    __extends(ColumnLayoutManager, _super);
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                        this.fillProportionally = false;
                        this._resizeState = null;
                    }
                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.isResizing = function () {
                        return this._resizeState !== null;
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function () {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function (value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioX();
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype._getRealizedItems = function () {
                        return this._grid.realizedColumns;
                    };
                    ColumnLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    };
                    ColumnLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    };
                    ColumnLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension or is scrolling or is resizing
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling()) || this.isScrolling() || this.isResizing();
                    };
                    ColumnLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getWidth();
                    };
                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function () {
                        return this._grid.realizedColumns[this._gridOffset];
                    };
                    ColumnLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeWidth;
                    };
                    ColumnLayoutManager.prototype.applyScrolling = function () {
                        var columnOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleColumnWidth = 0;
                        if (columnOffset !== 0) {
                            var firstVisibleColumn = this.getFirstVisibleColumn();
                            if (firstVisibleColumn !== undefined) {
                                firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                                this.scroll(firstVisibleColumn, firstVisibleColumnWidth, columnOffset);
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.scroll = function (firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
                        if (firstVisibleColumn.footer !== null) {
                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollCells = function (cells, width, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollBodyCells = function (rows, width, offset) {
                        var length = rows.length;
                        var cells;
                        var cell;
                        for (var i = 0; i < length; i++) {
                            cells = rows[i]._realizedBodyCells;
                            if (cells !== undefined) {
                                cell = cells[0];
                                if (cell !== undefined) {
                                    cell.scrollHorizontally(width, offset);
                                }
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.onStartResize = function (cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    };
                    ColumnLayoutManager.prototype.onResize = function (cell, deltaX, deltaY) {
                        var _this = this;
                        this._resizeState.resizingDelta = Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth);
                        if (this._resizeState.animationFrame === null)
                            this._resizeState.animationFrame = requestAnimationFrame(function () { return _this.performResizing(); });
                    };
                    ColumnLayoutManager.prototype.onEndResize = function (cell) {
                        if (this._resizeState.animationFrame !== null) {
                            this.performResizing(); // if we reached the end and we are still waiting for the last animation frame, perform the pending resizing and clear the state 
                        }
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.onReset = function (cell) {
                        this._resizeState = new ResizeState(cell._column, -1, 1);
                        cell._column.clearSize();
                        this.owner.owner.refresh(false);
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.updateItemToResizeState = function (realizedColumns) {
                        if (this._resizeState === null)
                            return;
                        var columnCount = realizedColumns.length;
                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
                        // Only iterate over the columns that belong to column hierachy (i.e. skip the row hierarchy rows)
                        // as this post-rendering adjustment only applies to them.
                        var startIndex = this.otherLayoutManager.dimension.getDepth();
                        for (var i = startIndex; i < columnCount; i++) {
                            var column = realizedColumns[i];
                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator))
                                continue;
                            if (column !== this._resizeState.column) {
                                this._resizeState.column = column;
                                column.resize(this._resizeState.startColumnWidth + this._resizeState.resizingDelta);
                                break;
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.performResizing = function () {
                        if (this._resizeState === null)
                            return;
                        this._resizeState.animationFrame = null;
                        var newSize = this._resizeState.startColumnWidth + this._resizeState.resizingDelta;
                        this._resizeState.column.resize(newSize);
                        this.owner.owner.refresh(false);
                    };
                    /**
                    *   Sends column related data (pixel size, column count, etc) to TablixControl
                    **/
                    ColumnLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale(); // in case of canvas we have to convert the size from device pixel to css pixel
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    };
                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
                        return -1;
                    };
                    ColumnLayoutManager.minColumnWidth = 10;
                    return ColumnLayoutManager;
                })(DimensionLayoutManager);
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = (function (_super) {
                    __extends(DashboardColumnLayoutManager, _super);
                    function DashboardColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        if (this.ignoreColumn(headerIndex))
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardColumnLayoutManager.prototype._calculateSize = function (item) {
                        var headerIndex = item.getIndex(this._grid);
                        var computedSize = 0;
                        if (!this.ignoreColumn(headerIndex)) {
                            // for dashboard layout it does not matter whether we pass an actual cell or not
                            computedSize = this.owner.getContentWidth(undefined);
                        }
                        item.resize(computedSize);
                    };
                    DashboardColumnLayoutManager.prototype.ignoreColumn = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
                    };
                    return DashboardColumnLayoutManager;
                })(ColumnLayoutManager);
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = (function (_super) {
                    __extends(CanvasColumnLayoutManager, _super);
                    function CanvasColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        return this.owner.getEstimatedTextWidth(content);
                    };
                    CanvasColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasColumnLayoutManager.prototype._calculateSize = function (item) {
                        item.calculateSize();
                    };
                    return CanvasColumnLayoutManager;
                })(ColumnLayoutManager);
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = (function (_super) {
                    __extends(RowLayoutManager, _super);
                    function RowLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                    }
                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioY();
                    };
                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.startScrollingSession = function () {
                        _super.prototype.startScrollingSession.call(this);
                    };
                    RowLayoutManager.prototype._getRealizedItems = function () {
                        return this._grid.realizedRows;
                    };
                    RowLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    };
                    RowLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    };
                    RowLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension and the column dimension is not resizing or row fdimension is scrolling and reaching the end while scrolling 
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing()) || (this.isScrolling() && (this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount()));
                    };
                    RowLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getHeight();
                    };
                    RowLayoutManager.prototype.getFirstVisibleRow = function () {
                        return this._grid.realizedRows[this._gridOffset];
                    };
                    RowLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeHeight;
                    };
                    RowLayoutManager.prototype.applyScrolling = function () {
                        var rowOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleRowHeight = 0;
                        if (rowOffset !== 0) {
                            var firstVisibleRow = this.getFirstVisibleRow();
                            if (firstVisibleRow) {
                                firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
                            }
                        }
                    };
                    RowLayoutManager.prototype.scroll = function (firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    };
                    RowLayoutManager.prototype.scrollCells = function (cells, height, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollVertically(height, offset);
                        }
                    };
                    RowLayoutManager.prototype.getFooterContextualWidth = function () {
                        if (this.owner.owner.rowDimension.hasFooter()) {
                            if (this.owner.grid.footerRow) {
                                return this.owner.grid.footerRow.getContextualWidth();
                            }
                        }
                        return 0;
                    };
                    RowLayoutManager.prototype.calculateContextualWidths = function () {
                        _super.prototype.calculateContextualWidths.call(this);
                        if (this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            if (footerRow) {
                                this._calculateSize(footerRow);
                            }
                        }
                    };
                    RowLayoutManager.prototype.fixSizes = function () {
                        _super.prototype.fixSizes.call(this);
                        if (this.fixedSizeEnabled) {
                            if (this._grid.footerRow) {
                                this._grid.footerRow.fixSize();
                            }
                        }
                    };
                    /**
                    *   Sends row related data (pixel size, column count, etc) to TablixControl
                    **/
                    RowLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), (this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0));
                    };
                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    return RowLayoutManager;
                })(DimensionLayoutManager);
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = (function (_super) {
                    __extends(DashboardRowLayoutManager, _super);
                    function DashboardRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    };
                    DashboardRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardRowLayoutManager.prototype._calculateSize = function (item) {
                        var computedSize = this.owner.getEstimatedRowHeight();
                        item.resize(computedSize);
                    };
                    DashboardRowLayoutManager.prototype.getHeaderWidth = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups())
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual text or not
                        return this.owner.getEstimatedTextWidth(undefined);
                    };
                    return DashboardRowLayoutManager;
                })(RowLayoutManager);
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = (function (_super) {
                    __extends(CanvasRowLayoutManager, _super);
                    function CanvasRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasRowLayoutManager.prototype._calculateSize = function (item) {
                        item.calculateSize();
                    };
                    return CanvasRowLayoutManager;
                })(RowLayoutManager);
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = (function () {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = true;
                        this._binder = binder;
                        this._grid = grid;
                        this._columnLayoutManager = columnLayoutManager;
                        this._rowLayoutManager = rowLayoutManager;
                    }
                    TablixLayoutManager.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._container = owner.container;
                        this._gridHost = owner.contentHost;
                        this._footersHost = owner.footerHost;
                        this._grid.initialize(owner, this._gridHost, this._footersHost);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.getTablixClassName = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
                        return null;
                    };
                    TablixLayoutManager.prototype.getLayoutKind = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
                        // TODO ckerer: this method should not be necessary when we are done refactoring!
                        return null;
                    };
                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function (item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        var isLeaf = this.owner.hierarchyNavigator.isLeaf(item);
                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateRowHeader = function (item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex);
                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        if (row.getRealizedCellCount() === 0) {
                            this.alignRowHeaderCells(item, row);
                        }
                        var cell = row.getOrCreateRowHeader(column, scrollable, this.owner.hierarchyNavigator.isLeaf(item));
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateCornerCell = function (item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel);
                        var column = this._grid.getOrCreateColumn(rowLevel);
                        var cell = row.getOrCreateCornerCell(column);
                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
                        var isLeaf = columnLevel === (columnDepth - 1);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateBodyCell = function (cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
                            scrollable = true;
                        }
                        else {
                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        }
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function (cellItem, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0);
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function (item, items) {
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(0);
                        //debug.assert(this.owner.hierarchyNavigator.isLeaf(item), "Leaf item expected");
                        var cell = row.getOrCreateFooterRowHeader(column);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getVisibleWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getVisibleHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
                    };
                    TablixLayoutManager.prototype.updateViewport = function (viewport) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
                    };
                    TablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
                        return -1;
                    };
                    /**
                    * This call makes room for parent header cells where neccessary. Since HTML cells that span vertically displace other rows,
                    * room has to be made for spanning headers that leave an exiting row to enter the new row that it starts from and removed when
                    * returning to an entering row.
                    **/
                    TablixLayoutManager.prototype.alignRowHeaderCells = function (item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (index === -1) {
                            return;
                        }
                        var rowDimension = this._owner.rowDimension;
                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
                            return;
                        }
                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function () {
                            return this._grid;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function () {
                            return this._rowLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function () {
                            return this._columnLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
                        return false;
                    };
                    TablixLayoutManager.prototype.onStartRenderingSession = function (scrollingDimension, parentElement) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceHeaderCell(cell);
                            }
                            cell = this._grid.emptySpaceFooterCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceFooterCell(cell);
                            }
                            this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension;
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.startScrollingSession();
                        }
                        this._grid.onStartRenderingSession();
                        this._rowLayoutManager.onStartRenderingSession();
                        this._columnLayoutManager.onStartRenderingSession();
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        if (measureEnabled)
                            this.measureSampleText(parentElement);
                    };
                    TablixLayoutManager.prototype.onEndRenderingSession = function () {
                        this._rowLayoutManager.onEndRenderingSession();
                        this._columnLayoutManager.onEndRenderingSession();
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.endScrollingSession();
                        }
                        this._scrollingDimension = null;
                        if (this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceHeaderCell(cell);
                                }
                                cell = this._grid.emptySpaceFooterCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }
                        this._grid.onEndRenderingSession();
                    };
                    TablixLayoutManager.prototype.onStartRenderingIteration = function (clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
                        this._grid.onStartRenderingIteration(clear); // TODO clearing should happen only once before the loop
                    };
                    TablixLayoutManager.prototype.onEndRenderingIteration = function () {
                        this._grid.onEndRenderingIteration();
                        // ANDREMI: Comment out for static tablix
                        this._columnLayoutManager.calculateSizes(); // calculate the entire grid first without altering the tree to avoid multiple measure pass invoking
                        this._rowLayoutManager.calculateSizes();
                        this._columnLayoutManager.fixSizes(); // now assign the sizes
                        this._rowLayoutManager.fixSizes();
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns); // if we are in a middle of a resize, the column to resize might have been swaped during the render, restore its resize state
                        this._columnLayoutManager.applyScrolling();
                        this._rowLayoutManager.applyScrolling();
                        this._columnLayoutManager.onEndRenderingIteration();
                        this._rowLayoutManager.onEndRenderingIteration();
                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
                    };
                    TablixLayoutManager.prototype.onCornerCellRealized = function (item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        if (columnLeaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        if (leaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onBodyCellRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.setAllowHeaderResize = function (value) {
                        this._allowHeaderResize = value;
                    };
                    TablixLayoutManager.prototype.enableCellHorizontalResize = function (isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    };
                    TablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
                    };
                    return TablixLayoutManager;
                })();
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = (function (_super) {
                    __extends(DashboardTablixLayoutManager, _super);
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        _super.call(this, binder, grid, new DashboardColumnLayoutManager(this, grid, columnRealizationManager), new DashboardRowLayoutManager(this, grid, rowRealizationManager));
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixLayoutManager.createLayoutManager = function (binder) {
                        // computed sizes are shared between layout manager and grid presenter
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    DashboardTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "bi-dashboard-tablix";
                    };
                    DashboardTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 1 /* DashboardTile */;
                    };
                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return false;
                    };
                    DashboardTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        // Dashboard layout does not use DOM measurements; nothing to do
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function () {
                        return this._sizeComputationManager.visibleWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function () {
                        return this._sizeComputationManager.visibleHeight;
                    };
                    DashboardTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return this._sizeComputationManager.cellWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        // On the dashboard it does not matter what text we render, 
                        // we always use the same content width
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // The total number of columns is the number (depth) of row groups + the number of (leaf) column group instances
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
                        var totalColumnCount = rowDimensionDepth + columnInstances;
                        // Adjust the column count by the static row header (if any)
                        if (!this.binder.hasRowGroups())
                            totalColumnCount--;
                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    };
                    DashboardTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this._sizeComputationManager.cellHeight;
                    };
                    return DashboardTablixLayoutManager;
                })(TablixLayoutManager);
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = (function (_super) {
                    __extends(CanvasTablixLayoutManager, _super);
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        _super.call(this, binder, grid, new CanvasColumnLayoutManager(this, grid, columnRealizationManager), new CanvasRowLayoutManager(this, grid, rowRealizationManager));
                    }
                    CanvasTablixLayoutManager.createLayoutManager = function (binder) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter()), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    CanvasTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "bi-tablix";
                    };
                    CanvasTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 0 /* Canvas */;
                    };
                    CanvasTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        // TODO: Use TextMeasurementService once the DOM methods are fixed (they are not working right now)
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = 'left';
                        parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode);
                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
                        textDiv.removeChild(textNode);
                        parentElement.removeChild(textDiv);
                    };
                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return !this._columnLayoutManager.fillProportionally;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function () {
                        if (this._columnLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
                                return this._owner.maxWidth;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementWidth(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function () {
                        if (this._rowLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
                                return this._owner.maxHeight;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementHeight(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function (text) {
                        return text ? text.length * this.characterWidth : 0;
                    };
                    CanvasTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this.characterHeight;
                    };
                    return CanvasTablixLayoutManager;
                })(TablixLayoutManager);
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var HTMLElementUtils;
            (function (HTMLElementUtils) {
                function clearChildren(element) {
                    if (!element) {
                        return;
                    }
                    while (element.hasChildNodes()) {
                        element.removeChild(element.firstChild);
                    }
                }
                HTMLElementUtils.clearChildren = clearChildren;
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                HTMLElementUtils.setElementTop = setElementTop;
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                HTMLElementUtils.setElementLeft = setElementLeft;
                function setElementHeight(element, height) {
                    if (HTMLElementUtils.isAutoSize(height))
                        element.style.height = "auto";
                    else
                        element.style.height = height + "px";
                }
                HTMLElementUtils.setElementHeight = setElementHeight;
                function setElementWidth(element, width) {
                    if (HTMLElementUtils.isAutoSize(width))
                        element.style.width = "auto";
                    else
                        element.style.width = width + "px";
                }
                HTMLElementUtils.setElementWidth = setElementWidth;
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                HTMLElementUtils.getElementWidth = getElementWidth;
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                HTMLElementUtils.getElementHeight = getElementHeight;
                function isAutoSize(size) {
                    return size === -1;
                }
                HTMLElementUtils.isAutoSize = isAutoSize;
                function getAccumulatedScale(element) {
                    var scale = 1;
                    while (element) {
                        scale *= HTMLElementUtils.getScale(element);
                        element = element.parentElement;
                    }
                    return scale;
                }
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
                // Get scale of element, return 1 when not scaled
                function getScale(element) {
                    element = $(element);
                    var str = element.css('-webkit-transform') || element.css('-moz-transform') || element.css('-ms-transform') || element.css('-o-transform') || element.css('transform');
                    return (str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) || str.match(/\d+/) && Number(str.match(/\d+/)[0]))) || 1;
                }
                HTMLElementUtils.getScale = getScale;
            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var TablixUtils;
                (function (TablixUtils) {
                    function createTable() {
                        return document.createElement("table");
                    }
                    TablixUtils.createTable = createTable;
                    function createDiv() {
                        var div = document.createElement("div");
                        // TODO: Fold these into CSS as well combined with the styling done for the different scenarios where div are used.
                        var divStyle = div.style;
                        divStyle.whiteSpace = "nowrap";
                        divStyle.overflow = "hidden";
                        divStyle.lineHeight = "normal";
                        return div;
                    }
                    TablixUtils.createDiv = createDiv;
                    function appendATagToBodyCell(value, cell) {
                        var element = cell.extension.contentHost;
                        var atag = null;
                        if (element.childElementCount === 0) {
                            atag = document.createElement('a');
                            element.appendChild(atag);
                        }
                        else {
                            atag = element.children[0];
                        }
                        atag.href = value;
                        atag.target = '_blank';
                        atag.title = value;
                        atag.innerText = value;
                    }
                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            (function (TablixCellType) {
                TablixCellType[TablixCellType["CornerCell"] = 0] = "CornerCell";
                TablixCellType[TablixCellType["RowHeader"] = 1] = "RowHeader";
                TablixCellType[TablixCellType["ColumnHeader"] = 2] = "ColumnHeader";
                TablixCellType[TablixCellType["BodyCell"] = 3] = "BodyCell";
            })(controls.TablixCellType || (controls.TablixCellType = {}));
            var TablixCellType = controls.TablixCellType;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            (function (TablixLayoutKind) {
                // The default layout is based on DOM measurements and used on the canvas.
                TablixLayoutKind[TablixLayoutKind["Canvas"] = 0] = "Canvas";
                // The DashboardTile layout must not rely on any kind of DOM measurements
                // since the tiles are created when the dashboard is not visible and the
                // visual is not rendered; thus no measurements are available.
                TablixLayoutKind[TablixLayoutKind["DashboardTile"] = 1] = "DashboardTile";
            })(controls.TablixLayoutKind || (controls.TablixLayoutKind = {}));
            var TablixLayoutKind = controls.TablixLayoutKind;
            var TablixControl = (function () {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this._scrollbarWidth = 9;
                    this._fixSizedClassName = "bi-tablix-fixed-size";
                    // Options
                    this._options = options;
                    var isInteractive = options.interactive;
                    this._isTouchEnabled = isInteractive && options.enableTouchSupport;
                    // Main Div
                    this._mainDiv = controls.internal.TablixUtils.createDiv();
                    var mainDivStyle = this._mainDiv.style;
                    mainDivStyle.position = "absolute";
                    mainDivStyle.left = "0px";
                    mainDivStyle.top = "0px";
                    // Footer Div
                    this._footerDiv = controls.internal.TablixUtils.createDiv();
                    var footerDivStyle = this._footerDiv.style;
                    footerDivStyle.position = "absolute";
                    footerDivStyle.left = "0px";
                    if (this._isTouchEnabled)
                        this.InitializeTouchSupport();
                    this._gridDimensions = {};
                    this._container = controls.internal.TablixUtils.createDiv();
                    this.className = layoutManager.getTablixClassName();
                    this.autoSizeWidth = false;
                    this.autoSizeHeight = false;
                    parentDomElement.appendChild(this._container);
                    this._container.addEventListener("mousewheel", function (e) {
                        _this.onMouseWheel(e);
                    });
                    this._container.addEventListener("DOMMouseScroll", function (e) {
                        _this.onFireFoxMouseWheel(e);
                    });
                    this._container.appendChild(this._mainDiv);
                    this._container.appendChild(this._footerDiv);
                    if (this._isTouchEnabled) {
                        this._touchInterpreter.initTouch(this._mainDiv, null, false);
                        this._footerTouchInterpreter.initTouch(this._footerDiv, this._mainDiv, false);
                    }
                    this._layoutManager = layoutManager;
                    this._layoutManager.initialize(this);
                    this._hierarchyNavigator = hierarchyNavigator;
                    this._binder = binder;
                    this._columnDimension = new controls.TablixColumnDimension(this);
                    this._rowDimension = new controls.TablixRowDimension(this);
                    this._columnDimension._otherDimension = this.rowDimension;
                    this._rowDimension._otherDimension = this.columnDimension;
                    this.InitializeScrollbars();
                    if (!isInteractive) {
                        this.scrollbarWidth = 0;
                    }
                    this.updateHorizontalPosition();
                    this.updateVerticalPosition();
                    this.updateFooterVisibility();
                    this._lastRenderingArgs = {};
                }
                TablixControl.prototype.InitializeTouchSupport = function () {
                    this._touchManager = new controls.TouchUtils.TouchManager();
                    this._touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this._touchManager);
                    this._footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this._touchManager);
                    this._columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._columnTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._rowTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._bodyTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._footerTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._touchManager.addTouchRegion(this._columnTouchDelegate.dimension, this._columnTouchDelegate, this._columnTouchDelegate);
                    this._touchManager.addTouchRegion(this._rowTouchDelegate.dimension, this._rowTouchDelegate, this._rowTouchDelegate);
                    this._touchManager.addTouchRegion(this._bodyTouchDelegate.dimension, this._bodyTouchDelegate, this._bodyTouchDelegate);
                    this._touchManager.addTouchRegion(this._footerTouchDelegate.dimension, this._footerTouchDelegate, this._footerTouchDelegate);
                };
                TablixControl.prototype.InitializeScrollbars = function () {
                    // Row Dimension
                    this._rowDimension._initializeScrollbar(this._container, null);
                    var rowDimensionScrollbarStyle = this._rowDimension.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute";
                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
                    this._rowDimension.scrollbar.width = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    this._rowDimension.scrollbar.show(false);
                    // Column Dimension
                    this._columnDimension._initializeScrollbar(this._container, null);
                    var columnDimensionScrollbarStyle = this._columnDimension.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute";
                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
                    this._columnDimension.scrollbar.height = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    this._columnDimension.scrollbar.show(false);
                };
                Object.defineProperty(TablixControl.prototype, "container", {
                    get: function () {
                        return this._container;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function () {
                        return this._mainDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function () {
                        return this._footerDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "className", {
                    set: function (value) {
                        this._container.className = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function () {
                        return this._hierarchyNavigator;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "binder", {
                    get: function () {
                        return this._binder;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function () {
                        return this._autoSizeWidth;
                    },
                    set: function (value) {
                        this._autoSizeWidth = value;
                        if (this._autoSizeWidth) {
                            this.removeFixSizedClassName();
                        }
                        else {
                            this.addFixedSizeClassNameIfNeeded();
                            this._container.style.minWidth = this._container.style.maxWidth = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function () {
                        return this._autoSizeHeight;
                    },
                    set: function (value) {
                        this._autoSizeHeight = value;
                        if (this._autoSizeHeight) {
                            this.removeFixSizedClassName();
                        }
                        else {
                            this.addFixedSizeClassNameIfNeeded();
                            this._container.style.minHeight = this._container.style.maxHeight = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function () {
                        return this._maxWidth;
                    },
                    set: function (value) {
                        this._maxWidth = value;
                        this._container.style.maxWidth = this._maxWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function () {
                        return this._viewport;
                    },
                    set: function (value) {
                        this._viewport = value;
                        this._container.style.width = this._viewport.width + TablixControl.UnitOfMeasurement;
                        this._container.style.height = this._viewport.height + TablixControl.UnitOfMeasurement;
                        this._rowDimension.scrollbar.invalidateArrange();
                        this._columnDimension.scrollbar.invalidateArrange();
                        this._layoutManager.updateViewport(this._viewport);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function () {
                        return this._maxHeight;
                    },
                    set: function (value) {
                        this._maxHeight = value;
                        this._container.style.maxHeight = this._maxHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function () {
                        return this._minWidth;
                    },
                    set: function (value) {
                        this._minWidth = value;
                        this._container.style.minWidth = this._minWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function () {
                        return this._minHeight;
                    },
                    set: function (value) {
                        this._minHeight = value;
                        this._container.style.minHeight = this._minHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function (value) {
                        this._scrollbarWidth = value;
                        this._rowDimension.scrollbar.width = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._columnDimension.scrollbar.height = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.updateModels = function (resetScrollOffsets, rowModel, columnModel) {
                    if (rowModel) {
                        this._rowDimension.model = rowModel;
                        if (resetScrollOffsets)
                            this._rowDimension.scrollOffset = 0;
                    }
                    if (columnModel) {
                        this._columnDimension.model = columnModel;
                        if (resetScrollOffsets)
                            this._columnDimension.scrollOffset = 0;
                    }
                    this.layoutManager.updateColumnCount(this._rowDimension, this._columnDimension);
                };
                TablixControl.prototype.updateColumnDimensions = function (rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this._gridDimensions;
                    gridDimensions.columnCount = count;
                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                };
                TablixControl.prototype.updateRowDimensions = function (columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this._gridDimensions;
                    gridDimensions.rowCount = count;
                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
                    gridDimensions.footerHeight = footerHeight;
                };
                TablixControl.prototype.updateTouchDimensions = function () {
                    var gridDimensions = this._gridDimensions;
                    this._columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
                    this._columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    this._rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this._rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this._bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this._bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this._footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
                    this._footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                };
                TablixControl.prototype.onMouseWheel = function (e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                };
                TablixControl.prototype.onFireFoxMouseWheel = function (e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                };
                TablixControl.prototype.mouseWheel = function (delta) {
                    if (delta < 0) {
                        delta = Math.min(-TablixControl.MouseWheelRange, delta);
                    }
                    else if (delta > 0) {
                        delta = Math.max(TablixControl.MouseWheelRange, delta);
                    }
                    var dimension = null;
                    if (this._rowDimension.scrollbar.visible) {
                        dimension = this._rowDimension;
                    }
                    else if (this._columnDimension.scrollbar.visible) {
                        dimension = this._columnDimension;
                    }
                    if (dimension) {
                        dimension.scrollOffset -= (delta / TablixControl.MouseWheelRange) * dimension.scrollbar.smallIncrement;
                        dimension.scrollOffset = Math.max(dimension.scrollOffset, 0);
                        dimension.scrollbar.viewMin = dimension.scrollOffset;
                        this._onScrollAsync(dimension);
                    }
                };
                Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function () {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function () {
                        return this._columnDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function () {
                        return this._rowDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.refresh = function (clear) {
                    this.render(clear, null);
                };
                TablixControl.prototype._onScrollAsync = function (dimension) {
                    var _this = this;
                    requestAnimationFrame(function () {
                        _this.performPendingScroll(dimension);
                    });
                };
                TablixControl.prototype.performPendingScroll = function (dimension) {
                    this.render(false, dimension);
                };
                TablixControl.prototype.updateHorizontalPosition = function () {
                    if (this._rowDimension.scrollbar.visible) {
                        this._columnDimension.scrollbar.element.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._mainDiv.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    }
                    else {
                        this._columnDimension.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this._mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.updateFooterVisibility = function () {
                    if (this._rowDimension.hasFooter() ? (this._footerDiv.style.display !== "block") : (this._footerDiv.style.display !== "none")) {
                        if (this._rowDimension.hasFooter()) {
                            this._footerDiv.style.display = "block";
                        }
                        else {
                            this._footerDiv.style.display = "none";
                        }
                    }
                };
                TablixControl.prototype.updateVerticalPosition = function () {
                    // Set the height of the footer div to non-zero if we have a footer to render
                    var footerHeight = 0;
                    if (this._rowDimension.hasFooter()) {
                        footerHeight = this._gridDimensions.footerHeight;
                    }
                    this._footerDiv.style.height = footerHeight + TablixControl.UnitOfMeasurement;
                    var hasVerticalScrollbar = this._rowDimension.scrollbar.visible;
                    // TODO: ideally the tablix control would not know about where it is rendered but the layout manager
                    //       would provider that information; we should refactor the layout manager so that getLayoutKind is not needed anymore.
                    var isDashboardTile = this._layoutManager.getLayoutKind() === 1 /* DashboardTile */;
                    var showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = footerHeight;
                        var footerBottom = 0;
                        var verticalScrollbarBottom = 0;
                        // If we have a horizontal scrollbar, we need to adjust the bottom
                        // value by the scrollbar width
                        var hasHorizontalScrollbar = this._columnDimension.scrollbar.visible;
                        if (hasHorizontalScrollbar) {
                            mainBottom += this._scrollbarWidth;
                            footerBottom += this._scrollbarWidth;
                            verticalScrollbarBottom = this._scrollbarWidth;
                        }
                        this._mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
                        this._rowDimension.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
                        // With a vertical scrollbar, the footer is always rendered at the bottom
                        this._footerDiv.style.removeProperty("top");
                    }
                    else {
                        // Without a vertical scrollbar, the footer is rendered below the last row;
                        // this is controlled by the top value only
                        this._footerDiv.style.top = this._gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.removeProperty("bottom");
                        this._mainDiv.style.removeProperty("bottom");
                    }
                };
                TablixControl.prototype.alreadyRendered = function (scrollingDimension) {
                    if (scrollingDimension !== this._lastRenderingArgs.scrollingDimension || this.rowDimension.scrollOffset !== this._lastRenderingArgs.rowScrollOffset || this.columnDimension.scrollOffset !== this._lastRenderingArgs.columnScrollOffset) {
                        return false;
                    }
                    return true;
                };
                TablixControl.prototype.render = function (clear, scrollingDimension) {
                    // at time of rendering always ensure the scroll offset is valid
                    this._columnDimension.makeScrollOffsetValid();
                    this._rowDimension.makeScrollOffsetValid();
                    if (clear || scrollingDimension === null) {
                        this._lastRenderingArgs = {};
                    }
                    else if (this.alreadyRendered(scrollingDimension)) {
                        return;
                    }
                    var done = false;
                    this._renderIterationCount = 0;
                    this._layoutManager.onStartRenderingSession(scrollingDimension, this._mainDiv);
                    var binder = this._binder;
                    binder.onStartRenderingSession();
                    var priorFooterHeight = this._gridDimensions.footerHeight;
                    var priorRowHierarchyHeight = this._gridDimensions.rowHierarchyHeight;
                    var priorRowHierarchyContentHeight = this._gridDimensions.rowHierarchyContentHeight;
                    while (!done) {
                        var hScrollbarVisibility = this._columnDimension.scrollbar.visible;
                        var vScrollbarVisibility = this._rowDimension.scrollbar.visible;
                        this._columnDimension._onStartRenderingIteration(clear); // TODO clearing should happen only once before the loop
                        this._rowDimension._onStartRenderingIteration(clear);
                        this._layoutManager.onStartRenderingIteration(clear);
                        // These calls add cells to the table.
                        // Column needs to be rendered before rows as the row call will pair up with columns to produce the body cells.
                        this.renderCorner();
                        this._columnDimension._render();
                        this._rowDimension._render();
                        done = this._layoutManager.onEndRenderingIteration();
                        this._columnDimension._onEndRenderingIteration();
                        this._rowDimension._onEndRenderingIteration();
                        if ((hScrollbarVisibility !== this._columnDimension.scrollbar.visible)) {
                            this.updateVerticalPosition();
                        }
                        if (vScrollbarVisibility !== this._rowDimension.scrollbar.visible) {
                            this.updateHorizontalPosition();
                        }
                        this._renderIterationCount++;
                    }
                    this._layoutManager.onEndRenderingSession();
                    binder.onEndRenderingSession();
                    if (this._isTouchEnabled)
                        this.updateTouchDimensions();
                    this._lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    this._lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    this.updateContainerDimensions();
                    if (this._options.interactive) {
                        this._columnDimension.scrollbar.refresh();
                        this._rowDimension.scrollbar.refresh();
                    }
                    var lastRenderingArgs = this._lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    lastRenderingArgs.scrollingDimension = scrollingDimension;
                    if (priorFooterHeight !== this._gridDimensions.footerHeight || priorRowHierarchyHeight !== this._gridDimensions.rowHierarchyHeight || priorRowHierarchyContentHeight !== this._gridDimensions.rowHierarchyContentHeight) {
                        this.updateVerticalPosition();
                    }
                };
                TablixControl.prototype.updateContainerDimensions = function () {
                    var gridDimensions = this._gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this._rowDimension.scrollbar.visible ? this._scrollbarWidth : 0;
                        this._container.style.width = gridDimensions.rowHierarchyWidth + gridDimensions.columnHierarchyWidth + vScrollBarWidth + TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this._columnDimension.scrollbar.visible ? this._scrollbarWidth : 0;
                        this._container.style.height = gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight + gridDimensions.footerHeight + hScrollBarHeight + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.cornerCellMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 0 /* CornerCell */ && previousItem && this._hierarchyNavigator.cornerCellItemEquals(item, previousItem);
                };
                TablixControl.prototype.renderCorner = function () {
                    var columnDepth = this._columnDimension.getDepth();
                    var rowDepth = this._rowDimension.getDepth();
                    for (var i = 0; i < columnDepth; i++) {
                        for (var j = 0; j < rowDepth; j++) {
                            var item = this._hierarchyNavigator.getCorner(j, i);
                            var cell = this._layoutManager.getOrCreateCornerCell(item, j, i);
                            var match = this.cornerCellMatch(item, cell);
                            if (!match) {
                                this._unbindCell(cell);
                                cell.type = 0 /* CornerCell */;
                                cell.item = item;
                                this._binder.bindCornerCell(item, cell);
                            }
                            this._layoutManager.onCornerCellRealized(item, cell);
                        }
                    }
                };
                TablixControl.prototype._unbindCell = function (cell) {
                    switch (cell.type) {
                        case 3 /* BodyCell */:
                            this._binder.unbindBodyCell(cell.item, cell);
                            break;
                        case 2 /* ColumnHeader */:
                            this._binder.unbindColumnHeader(cell.item, cell);
                            break;
                        case 1 /* RowHeader */:
                            this._binder.unbindRowHeader(cell.item, cell);
                            break;
                        case 0 /* CornerCell */:
                            this._binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null;
                    cell.type = null;
                };
                TablixControl.prototype.onTouchEvent = function (args) {
                    var colShift;
                    var rowShift;
                    var that;
                    if ((args) && (args.length > 0)) {
                        if (("_columnDimension" in args[0]) && ("_rowDimension" in args[0])) {
                            that = args[0];
                            colShift = that._columnDimension.scrollbar.visible ? args[1] : 0;
                            rowShift = that._rowDimension.scrollbar.visible ? args[2] : 0;
                            that._columnDimension.scrollbar.viewMin = Math.max(0, that._columnDimension.scrollbar.viewMin + colShift);
                            that._columnDimension.scrollOffset = Math.max(0, that._columnDimension.scrollOffset + colShift);
                            that._rowDimension.scrollbar.viewMin = Math.max(0, that._rowDimension.scrollbar.viewMin + rowShift);
                            that._rowDimension.scrollOffset = Math.max(0, that._rowDimension.scrollOffset + rowShift);
                            if (colShift === 0) {
                                that._onScrollAsync(that._rowDimension);
                            }
                            else if (rowShift === 0) {
                                that._onScrollAsync(that._columnDimension);
                            }
                            else {
                                that._onScrollAsync(null);
                            }
                        }
                    }
                };
                TablixControl.prototype.addFixedSizeClassNameIfNeeded = function () {
                    if (!this._autoSizeHeight && !this._autoSizeWidth && this._container.className.indexOf(this._fixSizedClassName) === -1) {
                        this._container.className += " " + this._fixSizedClassName;
                    }
                };
                TablixControl.prototype.removeFixSizedClassName = function () {
                    this._container.className = this._container.className.replace(this._fixSizedClassName, '');
                };
                TablixControl.UnitOfMeasurement = 'px';
                TablixControl.MouseWheelRange = 120;
                return TablixControl;
            })();
            controls.TablixControl = TablixControl;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TablixDimension = (function () {
                function TablixDimension(tablixControl) {
                    this._scrollStep = 0.1;
                    this._owner = tablixControl;
                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
                    this._binder = tablixControl.binder;
                    this._tablixLayoutManager = tablixControl.layoutManager;
                    this.scrollOffset = 0;
                }
                TablixDimension.prototype._onStartRenderingIteration = function (clear) {
                    this.updateScrollPosition();
                };
                TablixDimension.prototype._onEndRenderingIteration = function () {
                };
                TablixDimension.prototype.getValidScrollOffset = function (scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                };
                TablixDimension.prototype.makeScrollOffsetValid = function () {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                };
                TablixDimension.prototype.getIntegerScrollOffset = function () {
                    return Math.floor(this.scrollOffset);
                };
                TablixDimension.prototype.getFractionScrollOffset = function () {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                };
                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function () {
                        return this._scrollbar;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype.getFirstVisibleItem = function (level) {
                    return this._scrollItems[level];
                };
                TablixDimension.prototype.getFirstVisibleChild = function (item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                };
                TablixDimension.prototype.getFirstVisibleChildIndex = function (item) {
                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    var firstVisibleIndex;
                    if (startItem === undefined || (startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item)) {
                        firstVisibleIndex = 0;
                    }
                    else {
                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
                    }
                    return firstVisibleIndex;
                };
                TablixDimension.prototype._initializeScrollbar = function (parentElement, touchDiv) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement);
                    this._scrollbar._onscroll.push(function (e) { return _this.onScroll(); });
                    if (touchDiv) {
                        this.scrollbar.initTouch(touchDiv, true);
                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
                    }
                };
                TablixDimension.prototype.getItemsCount = function () {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                };
                TablixDimension.prototype.getDepth = function () {
                    return this.model ? this._hierarchyNavigator.getDepth(this.model) : 0;
                };
                TablixDimension.prototype.onScroll = function () {
                    this.scrollOffset = this._scrollbar.viewMin;
                    this._owner._onScrollAsync(this);
                };
                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function () {
                        return this._otherDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function () {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype._createScrollbar = function (parentElement) {
                    // abstract
                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
                    return null;
                };
                TablixDimension.prototype.updateScrollPosition = function () {
                    this._scrollItems = [];
                    if (!this.model) {
                        return;
                    }
                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                    if (!firstVisible) {
                        return;
                    }
                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                    do {
                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
                    } while (firstVisible !== null);
                };
                return TablixDimension;
            })();
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = (function (_super) {
                __extends(TablixRowDimension, _super);
                function TablixRowDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.rowLayoutManager;
                    this._footer = null;
                }
                TablixRowDimension.prototype.setFooter = function (footerHeader) {
                    this._footer = footerHeader;
                    this._owner.updateFooterVisibility();
                };
                TablixRowDimension.prototype.hasFooter = function () {
                    return (this._footer !== null);
                };
                /**
                * This method first populates the footer followed by each row and their correlating body cells from top to bottom.
                **/
                TablixRowDimension.prototype._render = function () {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    if (this.hasFooter()) {
                        this.addFooterRowHeader(this._footer);
                        this.addFooterBodyCells(this._footer);
                    }
                    if (firstVisibleRowItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }
                };
                TablixRowDimension.prototype._createScrollbar = function (parentElement) {
                    return new controls.VerticalScrollbar(parentElement);
                };
                /**
                * addNodes is a recursive call (with its recursive behavior in addNode()) that will navigate
                * through the row hierarchy in DFS (Depth First Search) order and continue into a single row
                * upto its estimated edge.
                **/
                TablixRowDimension.prototype.addNodes = function (items, rowIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var item = this._hierarchyNavigator.getAt(items, i);
                        var cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan; //next node is bumped down according cells vertical span
                    }
                };
                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function (item) {
                    var leaf = item;
                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
                        leaf = this.getFirstVisibleChild(leaf);
                    }
                    return leaf;
                };
                TablixRowDimension.prototype.bindRowHeader = function (item, cell) {
                    this._binder.bindRowHeader(item, cell);
                };
                /**
                * This method can be thought of as the continuation of addNodes() as it continues the DFS (Depth First Search)
                * started from addNodes(). This function also handles ending the recursion with "_needsToRealize" being set to
                * false.
                *
                * Once the body cells are reached, populating is done linearly with addBodyCells().
                **/
                TablixRowDimension.prototype.addNode = function (item, items, rowIndex, depth) {
                    var previousCount;
                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
                    var match = this.rowHeaderMatch(item, rowHeaderCell);
                    if (!match) {
                        this._owner._unbindCell(rowHeaderCell);
                        rowHeaderCell.type = 1 /* RowHeader */;
                        rowHeaderCell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
                        rowHeaderCell.rowSpan = 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                        this.addBodyCells(item, items, rowIndex);
                    }
                    else {
                        previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
                        rowHeaderCell.colSpan = 1;
                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                    }
                    return rowHeaderCell;
                };
                TablixRowDimension.prototype.rowHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 1 /* RowHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                TablixRowDimension.prototype.addBodyCells = function (item, items, rowIndex) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
                    var hierarchyNavigator = this._hierarchyNavigator;
                    var otherModel = this._otherDimension.model;
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell);
                        layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                };
                TablixRowDimension.prototype.bindBodyCell = function (item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 3 /* BodyCell */;
                        cell.item = item;
                        this._binder.bindBodyCell(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterRowHeader = function (item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 1 /* RowHeader */;
                        cell.item = item;
                        this.bindRowHeader(item, cell);
                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterBodyCells = function (rowItem) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
                        //get corelating body cell and bind it
                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell);
                        layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.bodyCelMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 3 /* BodyCell */ && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                };
                return TablixRowDimension;
            })(TablixDimension);
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = (function (_super) {
                __extends(TablixColumnDimension, _super);
                function TablixColumnDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                }
                TablixColumnDimension.prototype._render = function () {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    if (firstVisibleColumnItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }
                };
                TablixColumnDimension.prototype._createScrollbar = function (parentElement) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement);
                    // Set smallest increment of the scrollbar to 0.2 rows
                    scrollbar.smallIncrement = 0.2;
                    return scrollbar;
                };
                TablixColumnDimension.prototype.addNodes = function (items, columnIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                };
                TablixColumnDimension.prototype.addNode = function (item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
                    var match = this.columnHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 2 /* ColumnHeader */;
                        cell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
                    }
                    else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        cell.rowSpan = 1;
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    if (!match)
                        this._binder.bindColumnHeader(item, cell);
                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
                    return cell;
                };
                TablixColumnDimension.prototype.columnHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 2 /* ColumnHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                return TablixColumnDimension;
            })(TablixDimension);
            controls.TablixColumnDimension = TablixColumnDimension;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            /**
            *   This class represents the touch region of the column headers (this can also apply to footer/total).
            *   This class is reponsible for interpreting gestures in terms of pixels to changes in column position.
            *
            *   Unlike the table body, this can only scroll in one direction.
            */
            var ColumnTouchDelegate = (function () {
                /**
                * @param region: location and area of the touch region in respect to its HTML element
                */
                function ColumnTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSize = 1; //default
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Sets the amount of columns to be shifted per delta in pixels.
                *
                * @param: xRatio column to pixel ratio (# columns / # pixels)
                */
                ColumnTouchDelegate.prototype.setScrollDensity = function (xRatio) {
                    this._averageSize = xRatio;
                };
                /**
                * @param x: X location from upper left of listened HTML element.
                * @param y: Y location from upper left of listened HTML element.
                * @param w: Width of area to listen for events.
                * @param h: Height of area to listen for events.
                */
                ColumnTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this._dimension.x = x;
                    this._dimension.y = y;
                    this._dimension.width = width;
                    this._dimension.height = height;
                };
                /**
                * @see: IPixelToItem
                */
                ColumnTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this._averageSize, 0, down, -dx * this._averageSize, 0);
                };
                /**
                * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                *
                * @param e: event recieved from touch manager.
                */
                ColumnTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this._tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this._handlers) {
                        controls.fire([this._handlers], args);
                    }
                };
                /**
                * Asigns handler for scrolling when scroll event is fired.
                *
                * @param tablixObj: TablixControl that's handling the fired event.
                * @param handlerCall: The call to be made (EXAMPLE: handlerCall = object.method;).
                */
                ColumnTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                return ColumnTouchDelegate;
            })();
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            /**
            *   This class represents the touch region of the row headers (left or right side aligned).
            *   This class is reponsible for interpreting gestures in terms of pixels to changes in row position.
            *
            *   Unlike the table body, this can only scroll in one direction.
            */
            var RowTouchDelegate = (function () {
                /**
                * @param region: location and area of the touch region in respect to its HTML element
                */
                function RowTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSize = 30; //default
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Sets the amount of rows to be shifted per delta in pixels.
                *
                * @param: yRatio row to pixel ratio (# rows / # pixels)
                */
                RowTouchDelegate.prototype.setScrollDensity = function (yRatio) {
                    this._averageSize = yRatio;
                };
                /**
                * @param x: X location from upper left of listened HTML element.
                * @param y: Y location from upper left of listened HTML element.
                * @param w: Width of area to listen for events.
                * @param h: Height of area to listen for events.
                */
                RowTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this._dimension.x = x;
                    this._dimension.y = y;
                    this._dimension.width = width;
                    this._dimension.height = height;
                };
                /**
                * @see: IPixelToItem
                */
                RowTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this._averageSize, down, 0, -dy * this._averageSize);
                    return event;
                };
                /**
                * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                *
                * @param e: event recieved from touch manager.
                */
                RowTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this._tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this._handlers) {
                        controls.fire([this._handlers], args);
                    }
                };
                /**
                * Asigns handler for scrolling when scroll event is fired.
                *
                * @param tablixObj: TablixControl that's handling the fired event.
                * @param handlerCall: The call to be made (EXAMPLE: handlerCall = object.method;).
                */
                RowTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                return RowTouchDelegate;
            })();
            controls.RowTouchDelegate = RowTouchDelegate;
            /**
            *   This class represents the touch region covering the body of the table.
            *   This class is reponsible for interpreting gestures in terms of pixels to
            *   changes in row and column position.
            */
            var BodyTouchDelegate = (function () {
                /**
                * @param region: location and area of the touch region in respect to its HTML element
                */
                function BodyTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
                    this._averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    /**
                    * @return: returns the dimentions of the region this delegate listens to.
                    */
                    get: function () {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Sets the amount of rows and columns to be shifted per delta in pixels.
                *
                * @param: xRatio column to pixel ratio (# columns / # pixels)
                * @param: yRatio row to pixel ratio (# rows / # pixels)
                */
                BodyTouchDelegate.prototype.setScrollDensity = function (xRatio, yRatio) {
                    this._averageSizeX = xRatio;
                    this._averageSizeY = yRatio;
                };
                /**
                * @param x: X location from upper left of listened HTML element.
                * @param y: Y location from upper left of listened HTML element.
                * @param w: Width of area to listen for events.
                * @param h: Height of area to listen for events.
                */
                BodyTouchDelegate.prototype.resize = function (x, y, width, height) {
                    var dimension = this._dimension;
                    dimension.x = x;
                    dimension.y = y;
                    dimension.width = width;
                    dimension.height = height;
                };
                /**
                * @see: IPixelToItem
                */
                BodyTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this._averageSizeX, y * this._averageSizeY, down, -dx * this._averageSizeX, -dy * this._averageSizeY);
                };
                /**
                * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                *
                * @param e: event recieved from touch manager.
                */
                BodyTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [this._tablixControl, e.dx, e.dy];
                    if (this._handlers) {
                        controls.fire([this._handlers], args);
                    }
                };
                /**
                * Asigns handler for scrolling when scroll event is fired.
                *
                * @param tablixObj: TablixControl that's handling the fired event.
                * @param handlerCall: The call to be made (EXAMPLE: handlerCall = object.method;).
                */
                BodyTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                BodyTouchDelegate.DefaultAverageSizeX = 30;
                BodyTouchDelegate.DefaultAverageSizeY = 30;
                return BodyTouchDelegate;
            })();
            controls.BodyTouchDelegate = BodyTouchDelegate;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TouchUtils;
            (function (TouchUtils) {
                var Point = (function () {
                    function Point(x, y) {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                    Point.prototype.offset = function (offsetX, offsetY) {
                        this.x += offsetX;
                        this.y += offsetY;
                    };
                    return Point;
                })();
                TouchUtils.Point = Point;
                var Rectangle = (function (_super) {
                    __extends(Rectangle, _super);
                    function Rectangle(x, y, width, height) {
                        _super.call(this, x, y);
                        this.width = width || 0;
                        this.height = height || 0;
                    }
                    Object.defineProperty(Rectangle.prototype, "point", {
                        get: function () {
                            return new Point(this.x, this.y);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Rectangle.prototype.contains = function (p) {
                        return Rectangle.contains(this, p);
                    };
                    Rectangle.contains = function (rect, p) {
                        if (p && !Rectangle.isEmpty(rect)) {
                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
                        }
                        return false;
                    };
                    Rectangle.isEmpty = function (rect) {
                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
                    };
                    return Rectangle;
                })(Point);
                TouchUtils.Rectangle = Rectangle;
                (function (SwipeDirection) {
                    /** Vertical: swipe gesture moves along the y-axis at an angle within an established threshold*/
                    SwipeDirection[SwipeDirection["Vertical"] = 0] = "Vertical";
                    /** Horizontal: swipe gesture moves along the x-axis at an angle within an established threshold*/
                    SwipeDirection[SwipeDirection["Horizontal"] = 1] = "Horizontal";
                    /** FreeForm: swipe gesture does not stay within the thresholds of either x or y-axis*/
                    SwipeDirection[SwipeDirection["FreeForm"] = 2] = "FreeForm";
                })(TouchUtils.SwipeDirection || (TouchUtils.SwipeDirection = {}));
                var SwipeDirection = TouchUtils.SwipeDirection;
                (function (MouseButton) {
                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
                })(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                var MouseButton = TouchUtils.MouseButton;
                /**
                *   A simple touch event class that's abstracted away from any platform specific traits.
                */
                var TouchEvent = (function () {
                    /**
                    * @param x: X location of mouse.
                    * @param y: Y location of mouse.
                    * @param isMouseDown: indicates if the mouse button is held down or a finger press on screen.
                    * @param dx: (optional) the change in x of the gesture.
                    * @param dy: (optional) the change in y of the gesture.
                    */
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x;
                        this._y = y;
                        this._isMouseDown = isMouseDown;
                        this._dx = dx || 0;
                        this._dy = dy || 0;
                    }
                    Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function () {
                            return this._x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function () {
                            return this._y;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function () {
                            return this._dx;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function () {
                            return this._dy;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        /**
                        * @return: returns a boolean indicating if the mouse button is held down.
                        */
                        get: function () {
                            return this._isMouseDown;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TouchEvent;
                })();
                TouchUtils.TouchEvent = TouchEvent;
                /**
                *   This class "listens" to the TouchEventInterpreter  to recieve touch events and sends it to all
                *   "Touch Delegates" with  TouchRegions that contain the mouse event. Prior to sending off the
                *   event, its position is put in respect to the delegate's TouchRegion and converted to the appropriate
                *   unit (see IPixelToItem).
                */
                var TouchManager = (function () {
                    /**
                    * The default behavior is to enable thresholds and lock to axis.
                    */
                    function TouchManager() {
                        this._touchList = [];
                        this._swipeDirection = 2 /* FreeForm */;
                        this._matchingDirectionCount = 0;
                        this._lockThreshold = true;
                        this._scrollThreshold = true;
                        this._lastEvent = new TouchEvent(0, 0, false);
                    }
                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function () {
                            return this._lastEvent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                    * @param region: rectangle indicating the locations of the touch region.
                    * @param handler: handler for recieved touch events.
                    * @param converter: converts from pixels to the wanted item of measure (rows, columns, etc).
                    *                   EXAMPLE: dx -> from # of pixels to the right to # of columns moved to the right
                    */
                    TouchManager.prototype.addTouchRegion = function (region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, false),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this._touchList = this._touchList.concat([item]);
                    };
                    /**
                    * Sends a mouse up event to all regions with their last event as a mouse down event.
                    */
                    TouchManager.prototype.upAllTouches = function () {
                        var eventPoint;
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].lastPoint.isMouseDown) {
                                eventPoint = this._touchList[i].converter.getPixelToItem(this._touchList[i].lastPoint.x, this._touchList[i].lastPoint.y, 0, 0, false);
                                this._touchList[i].handler.touchEvent(eventPoint);
                            }
                            this._touchList[i].lastPoint = new TouchEvent(this._touchList[i].lastPoint.x, this._touchList[i].lastPoint.y, false);
                        }
                        this._lastEvent = new TouchEvent(0, 0, false);
                    };
                    TouchManager.prototype.touchEvent = function (e) {
                        var list;
                        var length;
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = 0;
                        var angle = 0;
                        var eventPoint = null;
                        //assume there are already regions in the middle of a drag event and get those regions
                        list = this._getActive();
                        //if this is the start of a mouse drag event, repopulate the list with touched regions
                        if (!this._lastEvent.isMouseDown && e.isMouseDown) {
                            list = this._findRegions(e);
                        }
                        //determine the delta values and update last event (delta ignored on first mouse down event)
                        dx = this._lastEvent.x - e.x;
                        dy = this._lastEvent.y - e.y;
                        this._lastEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
                        //go through the list
                        length = list.length;
                        for (var i = 0; i < length; i++) {
                            x = e.x - list[i].region.point.x;
                            y = e.y - list[i].region.point.y;
                            //is this in the middle of a drag?
                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
                                dx = x - list[i].lastPoint.x;
                                dy = y - list[i].lastPoint.y;
                                //calculate the absolute angle from the horizontal axis
                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
                                if (this._scrollThreshold) {
                                    //is the gesture already locked? (6 prior events within the threshold)
                                    if (this._lockThreshold && (this._matchingDirectionCount > 5)) {
                                        if (this._swipeDirection === 1 /* Horizontal */) {
                                            dy = 0;
                                        }
                                        else if (this._swipeDirection === 0 /* Vertical */) {
                                            dx = 0;
                                        }
                                    }
                                    else {
                                        //is it within the horizontal threshold?
                                        if (angle < 20) {
                                            dy = 0;
                                            if (this._swipeDirection === 1 /* Horizontal */) {
                                                this._matchingDirectionCount++;
                                            }
                                            else {
                                                this._matchingDirectionCount = 1;
                                                this._swipeDirection = 1 /* Horizontal */;
                                            }
                                        }
                                        else {
                                            //calculate the absolute angle from the vertical axis
                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
                                            //is it within the horizontal threshold?
                                            if (angle < 20) {
                                                dx = 0;
                                                if (this._swipeDirection === 0 /* Vertical */) {
                                                    this._matchingDirectionCount++;
                                                }
                                                else {
                                                    this._matchingDirectionCount = 1;
                                                    this._swipeDirection = 0 /* Vertical */;
                                                }
                                            }
                                            else {
                                                if (this._swipeDirection === 2 /* FreeForm */) {
                                                    this._matchingDirectionCount++;
                                                }
                                                else {
                                                    this._swipeDirection = 2 /* FreeForm */;
                                                    this._matchingDirectionCount = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                dx = 0;
                                dy = 0;
                                this._swipeDirection = 2 /* FreeForm */;
                                this._matchingDirectionCount = 0;
                            }
                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
                            list[i].handler.touchEvent(eventPoint);
                        }
                    };
                    /**
                    * @param e: position of event used to find touched regions
                    * @return: Returns an array of regions that contain the event point.
                    */
                    TouchManager.prototype._findRegions = function (e) {
                        var list = [];
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].region.contains(new Point(e.x, e.y))) {
                                list = list.concat([this._touchList[i]]);
                            }
                        }
                        return list;
                    };
                    /**
                    * @return: Returns an array of regions that contain a mouse down event. (see ITouchHandlerSet.lastPoint)
                    */
                    TouchManager.prototype._getActive = function () {
                        var list = [];
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].lastPoint.isMouseDown) {
                                list = list.concat([this._touchList[i]]);
                            }
                        }
                        return list;
                    };
                    return TouchManager;
                })();
                TouchUtils.TouchManager = TouchManager;
                /**
                *   This class is responsible for establishing connections to handle touch events
                *   and to interpret those events so they're compatible with the touch abstractions.
                *
                *   Touch events with platform specific handles should be done here.
                */
                var TouchEventInterpreter = (function () {
                    function TouchEventInterpreter(manager) {
                        this._manager = manager;
                        this._allowMouseDrag = true;
                        this._touchPanel = null;
                        this._scale = 1;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                    }
                    TouchEventInterpreter.prototype.initTouch = function (panel, touchReferencePoint, allowMouseDrag) {
                        var _this = this;
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
                        this._touchReferencePoint = touchReferencePoint;
                        this._touchPanel = panel;
                        this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                        if ("ontouchmove" in panel) {
                            panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                            panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                        }
                        else {
                            panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                            panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                        }
                    };
                    TouchEventInterpreter.prototype.getXYByClient = function (event) {
                        var rect = this._rect;
                        var x = rect.left;
                        var y = rect.top;
                        // Fix for Safari
                        if (window["scrollX"] !== undefined) {
                            x += window["scrollX"];
                            y += window["scrollY"];
                        }
                        var point = new Point(0, 0);
                        point.offset(event.pageX - x, event.pageY - y);
                        return point;
                    };
                    TouchEventInterpreter.prototype.onTouchStart = function (e) {
                        if (e.touches.length === 1) {
                            e.cancelBubble = true;
                            this.onTouchMouseDown(e.touches[0]);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMove = function (e) {
                        if (e.touches.length === 1) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            this.onTouchMouseMove(e.touches[0]);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchEnd = function (e) {
                        this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                    };
                    TouchEventInterpreter.prototype.onTouchMouseDown = function (e) {
                        var _this = this;
                        this._scale = controls.HTMLElementUtils.getAccumulatedScale(this._touchPanel);
                        //any prior touch scrolling that produced a selection outside Tablix will prevent the next touch scroll (1262519)
                        document.getSelection().removeAllRanges();
                        this._rect = (this._touchReferencePoint ? this._touchReferencePoint : this._touchPanel).getBoundingClientRect();
                        if ("ontouchmove" in this._touchPanel) {
                            this._documentMouseMoveWrapper = function (e) { return _this.onTouchMove(e); };
                            document.addEventListener("touchmove", this._documentMouseMoveWrapper);
                            this._documentMouseUpWrapper = function (e) { return _this.onTouchEnd(e); };
                            document.addEventListener("touchend", this._documentMouseUpWrapper);
                        }
                        else {
                            this._documentMouseMoveWrapper = function (e) { return _this.onTouchMouseMove(e); };
                            document.addEventListener("mousemove", this._documentMouseMoveWrapper);
                            this._documentMouseUpWrapper = function (e) { return _this.onTouchMouseUp(e); };
                            document.addEventListener("mouseup", this._documentMouseUpWrapper);
                        }
                        if ("setCapture" in this._touchPanel) {
                            this._touchPanel.setCapture();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseMove = function (e) {
                        var event;
                        var point;
                        var validMouseDragEvent = (this._rect !== null) && (e.which !== 0 /* NoClick */);
                        // Ignore events that are not part of a drag event
                        if (!validMouseDragEvent)
                            return;
                        point = this.getXYByClient(e);
                        event = new TouchEvent(point.x / this._scale, point.y / this._scale, validMouseDragEvent);
                        this._manager.touchEvent(event);
                        if (e.preventDefault)
                            e.preventDefault();
                        else if ("returnValue" in e)
                            e["returnValue"] = false;
                    };
                    TouchEventInterpreter.prototype.onTouchMouseUp = function (e, bubble) {
                        this._rect = null;
                        this._manager.upAllTouches();
                        if ("releaseCapture" in this._touchPanel) {
                            this._touchPanel.releaseCapture();
                        }
                        if (this._documentMouseMoveWrapper === null)
                            return;
                        if ("ontouchmove" in this._touchPanel) {
                            document.removeEventListener("touchmove", this._documentMouseMoveWrapper);
                            document.removeEventListener("touchend", this._documentMouseUpWrapper);
                        }
                        else {
                            document.removeEventListener("mousemove", this._documentMouseMoveWrapper);
                            document.removeEventListener("mouseup", this._documentMouseUpWrapper);
                        }
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                    };
                    return TouchEventInterpreter;
                })();
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Base class for values that are animated when resized */
        var AnimatedText = (function () {
            function AnimatedText(name) {
                this.mainText = {
                    class: 'mainText',
                    selector: '.mainText'
                };
                this.name = name;
                this.visualConfiguration = { maxFontSize: 60 };
            }
            AnimatedText.prototype.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            this.metaDataColumn = column;
                            break;
                        }
                    }
                }
            };
            AnimatedText.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                // set up the node so we don't keep appending/removing it during the computation
                var nodeSelection = this.svg.append('text').text(textToMeasure);
                var fontHeight = this.getAdjustedFontHeightCore(nodeSelection, availableWidth, seedFontHeight, 0);
                nodeSelection.remove();
                return fontHeight;
            };
            AnimatedText.prototype.getAdjustedFontHeightCore = function (nodeToMeasure, availableWidth, seedFontHeight, iteration) {
                // Too many attempts - just return what we have so we don't sacrifice perf
                if (iteration > 10)
                    return seedFontHeight;
                nodeToMeasure.attr('font-size', seedFontHeight);
                var candidateLength = powerbi.TextMeasurementService.measureSvgTextElementWidth(nodeToMeasure[0][0]);
                if (candidateLength < availableWidth)
                    return seedFontHeight;
                return this.getAdjustedFontHeightCore(nodeToMeasure, availableWidth, seedFontHeight * 0.9, iteration + 1);
            };
            AnimatedText.prototype.clear = function () {
                this.svg.select(this.mainText.selector).text('');
            };
            AnimatedText.prototype.doValueTransition = function (startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate) {
                if (!forceUpdate && startValue === endValue)
                    return;
                if (!startValue)
                    startValue = 0;
                var svg = this.svg, graphicsContext = this.graphicsContext, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [endValue], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(fontHeight), metaDataColumn = this.metaDataColumn, formatter = visuals.valueFormatter.create({
                    format: this.getFormatString(metaDataColumn),
                    value: endValue,
                    displayUnitSystemType: displayUnitSystemType,
                    formatSingleValues: true,
                    allowFormatBeautification: true,
                }), startText = formatter.format(startValue), endText = formatter.format(endValue);
                svg.attr('class', this.name);
                var textElement = graphicsContext.selectAll('text').data(endValueArr);
                textElement.enter().append('text').attr('class', this.mainText.class);
                var textElementUpdate = textElement.text(startText).attr('text-anchor', this.getTextAnchor());
                var node = textElementUpdate.node();
                if (node) {
                    var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                    translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                }
                graphicsContext.attr('font-size', fontHeight).attr('transform', 'translate(' + translateX + ',' + translateY + ')');
                if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) {
                    textElementUpdate.text(endText);
                }
                else {
                    var interpolatedValue = startValue;
                    textElementUpdate.transition().duration(duration).tween('text', function (d) {
                        var i = d3.interpolate(interpolatedValue, d);
                        return function (t) {
                            var num = i(t);
                            this.textContent = formatter.format(num);
                        };
                    });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
            };
            AnimatedText.prototype.getSeedFontHeight = function (boundingWidth, boundingHeight) {
                // Simply an estimate - it should eventually be modified based on the actual text length
                var estimatedSize = Math.floor(Math.min(boundingWidth, boundingHeight) * 0.75);
                var maxFontSize = this.visualConfiguration.maxFontSize;
                if (maxFontSize)
                    return Math.min(maxFontSize, estimatedSize);
                return estimatedSize;
            };
            AnimatedText.prototype.getTranslateX = function (width) {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 0;
                        case 'right':
                            return width;
                    }
                }
                return width / 2;
            };
            AnimatedText.prototype.getTranslateY = function (height) {
                return height;
            };
            AnimatedText.prototype.getTextAnchor = function () {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 'start';
                        case 'right':
                            return 'end';
                    }
                }
                return 'middle';
            };
            AnimatedText.prototype.getFormatString = function (column) {
                debug.assertAnyValue(column, 'column');
                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
            };
            // Public for testability
            AnimatedText.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            AnimatedText.objectDescs = {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                }
            };
            return AnimatedText;
        })();
        visuals.AnimatedText = AnimatedText;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Renders a number that can be animate change in value */
        var AnimatedNumber = (function (_super) {
            __extends(AnimatedNumber, _super);
            function AnimatedNumber(svg) {
                _super.call(this, 'animatedNumber');
                if (svg)
                    this.svg = svg;
            }
            AnimatedNumber.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                if (!this.svg)
                    this.svg = d3.select(element.get(0)).append('svg');
                this.graphicsContext = this.svg.append('g');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportDependantProperties();
            };
            AnimatedNumber.prototype.updateViewportDependantProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width).attr('height', viewport.height);
            };
            AnimatedNumber.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                var dataView = dataViews[0];
                this.updateViewportDependantProperties();
                this.getMetaDataColumn(dataView);
                var newValue = dataView && dataView.single ? dataView.single.value : 0;
                if (newValue != null) {
                    this.updateInternal(newValue, options.duration, true);
                }
            };
            AnimatedNumber.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration,
                    viewport: this.currentViewport
                });
            };
            AnimatedNumber.prototype.onResizing = function (viewport, duration) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewport: viewport
                });
            };
            AnimatedNumber.prototype.canResizeTo = function (viewport) {
                // Temporarily disabling resize restriction.
                return true;
            };
            AnimatedNumber.prototype.updateInternal = function (target, duration, forceUpdate) {
                if (duration === void 0) { duration = 0; }
                if (forceUpdate === void 0) { forceUpdate = false; }
                var start = this.value || 0;
                this.doValueTransition(start, target, null, this.options.animation, duration, forceUpdate);
                this.value = target;
            };
            AnimatedNumber.capabilities = {
                objects: visuals.AnimatedText.objectDescs,
                dataViewMappings: [{
                    single: { role: "Values" }
                }],
            };
            return AnimatedNumber;
        })(visuals.AnimatedText);
        visuals.AnimatedNumber = AnimatedNumber;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = 0.1;
        (function (CartesianChartType) {
            CartesianChartType[CartesianChartType["Line"] = 0] = "Line";
            CartesianChartType[CartesianChartType["Area"] = 1] = "Area";
            CartesianChartType[CartesianChartType["ClusteredColumn"] = 2] = "ClusteredColumn";
            CartesianChartType[CartesianChartType["StackedColumn"] = 3] = "StackedColumn";
            CartesianChartType[CartesianChartType["ClusteredBar"] = 4] = "ClusteredBar";
            CartesianChartType[CartesianChartType["StackedBar"] = 5] = "StackedBar";
            CartesianChartType[CartesianChartType["HundredPercentStackedBar"] = 6] = "HundredPercentStackedBar";
            CartesianChartType[CartesianChartType["HundredPercentStackedColumn"] = 7] = "HundredPercentStackedColumn";
            CartesianChartType[CartesianChartType["Scatter"] = 8] = "Scatter";
            CartesianChartType[CartesianChartType["ComboChart"] = 9] = "ComboChart";
            CartesianChartType[CartesianChartType["DataDot"] = 10] = "DataDot";
            CartesianChartType[CartesianChartType["Waterfall"] = 11] = "Waterfall";
            CartesianChartType[CartesianChartType["LineClusteredColumnCombo"] = 12] = "LineClusteredColumnCombo";
            CartesianChartType[CartesianChartType["LineStackedColumnCombo"] = 13] = "LineStackedColumnCombo";
            CartesianChartType[CartesianChartType["DataDotClusteredColumnCombo"] = 14] = "DataDotClusteredColumnCombo";
            CartesianChartType[CartesianChartType["DataDotStackedColumnCombo"] = 15] = "DataDotStackedColumnCombo";
        })(visuals.CartesianChartType || (visuals.CartesianChartType = {}));
        var CartesianChartType = visuals.CartesianChartType;
        (function (AxisLinesVisibility) {
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnXAxis"] = 1] = "ShowLinesOnXAxis";
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnYAxis"] = 2] = "ShowLinesOnYAxis";
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnBothAxis"] = AxisLinesVisibility.ShowLinesOnXAxis | AxisLinesVisibility.ShowLinesOnYAxis] = "ShowLinesOnBothAxis";
        })(visuals.AxisLinesVisibility || (visuals.AxisLinesVisibility = {}));
        var AxisLinesVisibility = visuals.AxisLinesVisibility;
        /** Renders a data series as a cartestian visual. */
        var CartesianChart = (function () {
            function CartesianChart(options) {
                this.isScrollable = false;
                if (options) {
                    this.type = options.chartType;
                    if (options.isScrollable)
                        this.isScrollable = options.isScrollable;
                    this.animator = options.animator;
                    if (options.cartesianSmallViewPortProperties) {
                        this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                    }
                }
            }
            CartesianChart.getAxisVisibility = function (type) {
                switch (type) {
                    case 5 /* StackedBar */:
                    case 4 /* ClusteredBar */:
                    case 6 /* HundredPercentStackedBar */:
                        return 1 /* ShowLinesOnXAxis */;
                    case 8 /* Scatter */:
                        return AxisLinesVisibility.ShowLinesOnBothAxis;
                    default:
                        return 2 /* ShowLinesOnYAxis */;
                }
            };
            CartesianChart.prototype.init = function (options) {
                this.visualInitOptions = options;
                this.layers = [];
                var element = this.element = options.element;
                var viewport = this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.brush = d3.svg.brush();
                element.addClass(CartesianChart.ClassName);
                this.margin = {
                    top: 1,
                    right: 1,
                    bottom: 1,
                    left: 1
                };
                this.yAxisOrientation = powerbi.yAxisPosition.left;
                this.adjustMargins(viewport);
                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                var showLinesOnX = this.scrollY = EnumExtensions.hasFlag(axisLinesVisibility, AxisLinesVisibility.ShowLinesOnBothAxis) || EnumExtensions.hasFlag(axisLinesVisibility, 1 /* ShowLinesOnXAxis */);
                var showLinesOnY = this.scrollX = EnumExtensions.hasFlag(axisLinesVisibility, AxisLinesVisibility.ShowLinesOnBothAxis) || EnumExtensions.hasFlag(axisLinesVisibility, 2 /* ShowLinesOnYAxis */);
                /*
                    The layout of the visual would look like :
                    <svg>
                        <g>
                            <nonscrollable axis/>
                        </g>
                        <svgScrollable>
                            <g>
                                <scrollable axis/>
                            </g>
                        </svgScrollable>
                        <g xbrush/>
                    </svg>
    
                */
                var svg = this.svg = d3.select(element.get(0)).append('svg');
                svg.style('position', 'absolute');
                var axisGraphicsContext = this.axisGraphicsContext = svg.append('g').classed(CartesianChart.AxisGraphicsContextClassName, true);
                this.svgScrollable = svg.append('svg').classed('svgScrollable', true).style('overflow', 'hidden');
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g').classed(CartesianChart.AxisGraphicsContextClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                this.brushGraphicsContext = svg.append("g").attr('class', 'x brush');
                var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                if (this.type !== 11 /* Waterfall */) {
                    this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
            };
            CartesianChart.prototype.renderAxesLabels = function (axisLabels, legendMargin, viewport, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height;
                var fontSize = CartesianChart.FontSize;
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                if (!hideXAxisTitle) {
                    var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                "transform": visuals.SVGUtil.translate(width / 2, height - fontSize)
                            });
                        });
                    });
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                }
                if (!hideYAxisTitle) {
                    var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? width + margin.right - fontSize : -margin.left,
                                "x": -((height - margin.top - legendMargin) / 2),
                                "dy": "1em"
                            });
                        });
                    });
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                }
                if (!hideY2AxisTitle && axisLabels.y2) {
                    var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? -margin.left : width + margin.right - fontSize,
                                "x": -((height - margin.top - legendMargin) / 2),
                                "dy": "1em"
                            });
                        });
                    });
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                }
            };
            CartesianChart.prototype.adjustMargins = function (viewport) {
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                // Adjust margins if ticks are not going to be shown on either axis
                var xAxis = this.element.find('.x.axis');
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0 && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                    this.margin = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    };
                    xAxis.hide();
                }
                else {
                    xAxis.show();
                }
            };
            CartesianChart.prototype.updateAxis = function (duration, viewport) {
                this.adjustMargins(viewport);
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                this.xAxisGraphicsContext.attr('transform', visuals.SVGUtil.translate(0, height));
                this.y1AxisGraphicsContext.attr('transform', visuals.SVGUtil.translate(showOnRight ? 0 : width, 0));
                this.y2AxisGraphicsContext.attr('transform', visuals.SVGUtil.translate(showOnRight ? 0 : width, 0));
                this.svg.attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                this.svgScrollable.attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                this.svgScrollable.attr({
                    'x': 0
                });
                this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                if (this.isXScrollBarVisible) {
                    this.svgScrollable.attr({
                        'x': this.margin.left
                    });
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.svgScrollable.attr('width', width);
                    this.svg.attr('width', viewport.width).attr('height', viewport.height + CartesianChart.ScrollBarWidth);
                }
                else if (this.isYScrollBarVisible) {
                    this.svgScrollable.attr('height', height + margin.top);
                    this.svg.attr('width', viewport.width + CartesianChart.ScrollBarWidth).attr('height', viewport.height);
                }
            };
            CartesianChart.getIsScalar = function (objects, propertyId, type) {
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                if (!objects || axisTypeValue === undefined) {
                    // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time. 
                    // If we have the property, it will override the type.
                    return !visuals.AxisHelper.isOrdinal(type);
                }
                // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
                return (axisTypeValue === powerbi.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);
            };
            CartesianChart.prototype.populateObjectProperties = function (dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata) {
                        this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                    }
                    else {
                        this.legendObjectProperties = {};
                    }
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    var axisPosition = this.valueAxisProperties['position'];
                    this.yAxisOrientation = axisPosition ? axisPosition.toString() : powerbi.yAxisPosition.left;
                }
            };
            CartesianChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (!dataViews)
                    return;
                var layers = this.layers;
                if (layers.length === 0) {
                    // Lazily instantiate the chart layers on the first data load.
                    this.createAndInitLayers(dataViews);
                    debug.assert(layers.length > 0, 'createAndInitLayers should update the layers.');
                }
                if (dataViews && dataViews.length > 0) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0)
                        this.hostServices.setWarnings(warnings);
                    this.populateObjectProperties(dataViews);
                }
                for (var i = 0, len = layers.length; i < len; i++) {
                    layers[i].setData(getLayerData(dataViews, i, len));
                }
                // Note: interactive legend shouldn't be rendered explicitly here
                // The interactive legend is being rendered in the render method of ICartesianVisual
                if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                    this.renderLegend();
                }
                var duration = options.duration == null ? (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0) : options.duration;
                this.render(this.hasSetData && duration);
                this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            CartesianChart.prototype.onDataChanged = function (options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0),
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            CartesianChart.prototype.onResizing = function (viewport, duration) {
                if (this.currentViewport && (this.currentViewport.height === viewport.height && this.currentViewport.width === viewport.width)) {
                    return;
                }
                this.update({
                    dataViews: this.dataViews,
                    duration: duration || 0,
                    viewport: viewport
                });
            };
            CartesianChart.prototype.enumerateObjectInstances = function (options) {
                // TODO: Extend to all layers
                var objectInstances = [];
                var layersLength = this.layers ? this.layers.length : 0;
                if (options.objectName === 'legend') {
                    if (layersLength > 0 && !this.layers[0].hasLegend())
                        return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
                    objectInstances.push({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText
                        },
                        objectName: options.objectName
                    });
                }
                else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {
                    objectInstances = this.getCategoryAxisValues();
                }
                else if (options.objectName === 'valueAxis') {
                    objectInstances = this.getValueAxisValues();
                }
                for (var i = 0, len = layersLength; i < len; i++) {
                    var layer = this.layers[i];
                    if (layer.enumerateObjectInstances) {
                        var layerInstances = layer.enumerateObjectInstances(options);
                        if (layerInstances) {
                            if (i > 0) {
                                // TODO: This removes redundant DataPoint properties that are defined by multiple layers.  We should consider a more general way to consolidate these properties.
                                if (options.objectName === 'dataPoint') {
                                    var defaultColorObject = this.findObjectWithProperty(layerInstances, 'defaultColor');
                                    if (defaultColorObject) {
                                        var index = layerInstances.indexOf(defaultColorObject);
                                        layerInstances.splice(index, 1);
                                    }
                                    var showAllObject = this.findObjectWithProperty(layerInstances, 'showAllDataPoints');
                                    if (showAllObject) {
                                        var index = layerInstances.indexOf(showAllObject);
                                        layerInstances.splice(index, 1);
                                    }
                                }
                                else if (options.objectName === 'labels' && objectInstances.length > 0) {
                                    //all settings refer to whole chart (- no data point specific ) one set of settings (-slices) is enough
                                    layerInstances = [];
                                }
                            }
                            if (options.objectName === 'categoryAxis' || options.objectName === 'valueAxis') {
                                // override the properties
                                if (objectInstances.length > 0 && layerInstances.length > 0) {
                                    objectInstances[0].properties['showAxisTitle'] = layerInstances[0].properties['showAxisTitle'];
                                }
                            }
                            else {
                                objectInstances = objectInstances.concat(layerInstances);
                            }
                        }
                    }
                }
                return objectInstances;
            };
            CartesianChart.prototype.getCategoryAxisValues = function () {
                var instances = [];
                var supportedType = powerbi.axisType.both;
                var isScalar = false;
                if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                    supportedType = this.layers[0].getSupportedCategoryAxisType();
                    if (supportedType === powerbi.axisType.scalar) {
                        isScalar = true;
                    }
                    else {
                        isScalar = visuals.CartesianHelper.isScalar(supportedType === powerbi.axisType.both, this.categoryAxisProperties);
                    }
                }
                if (!isScalar) {
                    if (this.categoryAxisProperties) {
                        this.categoryAxisProperties['start'] = null;
                        this.categoryAxisProperties['end'] = null;
                    }
                }
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'categoryAxis'
                };
                instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                if (this.yAxisIsCategorical)
                    instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : powerbi.yAxisPosition.left;
                if (supportedType === powerbi.axisType.both) {
                    instance.properties['axisType'] = isScalar ? powerbi.axisType.scalar : powerbi.axisType.categorical;
                }
                if (isScalar) {
                    instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
                    instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
                }
                instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                instances.push(instance);
                instances.push({
                    selector: null,
                    properties: {
                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : powerbi.axisStyle.showTitleOnly
                    },
                    objectName: 'categoryAxis',
                    validValues: this.categoryAxisHasUnitType ? [powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth] : [powerbi.axisStyle.showTitleOnly]
                });
                return instances;
            };
            //todo: wrap all these object getters and other related stuff into an interface
            CartesianChart.prototype.getValueAxisValues = function () {
                var y2AxesRendered = this.layers.length === 2 && this.y2AxesRendered;
                var instances = [];
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'valueAxis'
                };
                instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                if (y2AxesRendered) {
                    instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : true;
                    if (instance.properties['secShow']) {
                        instance.properties['axisLabel'] = ''; //this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made
                    }
                }
                if (!this.yAxisIsCategorical) {
                    instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : powerbi.yAxisPosition.left;
                }
                instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
                instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
                instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
                instances.push(instance);
                instances.push({
                    selector: null,
                    properties: {
                        axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : powerbi.axisStyle.showTitleOnly
                    },
                    objectName: 'valueAxis',
                    validValues: this.valueAxisHasUnitType ? [powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth] : [powerbi.axisStyle.showTitleOnly]
                });
                if (y2AxesRendered && instance.properties['secShow']) {
                    var secInstance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis'
                    };
                    secInstance.properties['secAxisLabel'] = ''; //this.layers[1].getVisualType(); //I will keep or remove this, depending on the decision made                        
                    secInstance.properties['secPosition'] = this.valueAxisProperties && this.valueAxisProperties['secPosition'] != null ? this.valueAxisProperties['secPosition'] : powerbi.yAxisPosition.right;
                    secInstance.properties['secStart'] = this.valueAxisProperties ? this.valueAxisProperties['secStart'] : null;
                    secInstance.properties['secEnd'] = this.valueAxisProperties ? this.valueAxisProperties['secEnd'] : null;
                    secInstance.properties['secShowAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['secShowAxisTitle'] != null ? this.valueAxisProperties['secShowAxisTitle'] : false;
                    instances.push(secInstance);
                    instances.push({
                        selector: null,
                        properties: {
                            secAxisStyle: this.valueAxisProperties && this.valueAxisProperties['secAxisStyle'] ? this.valueAxisProperties['secAxisStyle'] : powerbi.axisStyle.showTitleOnly
                        },
                        objectName: 'valueAxis',
                        validValues: this.secValueAxisHasUnitType ? [powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth] : [powerbi.axisStyle.showTitleOnly]
                    });
                }
                return instances;
            };
            CartesianChart.prototype.findObjectWithProperty = function (objectInstances, propertyName) {
                for (var i = 0, len = objectInstances.length; i < len; i++) {
                    var object = objectInstances[i];
                    if (object.properties[propertyName] !== undefined) {
                        return object;
                    }
                }
            };
            CartesianChart.prototype.onClearSelection = function () {
                if (this.hasSetData) {
                    for (var i = 0, len = this.layers.length; i < len; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection();
                        layer.render(0);
                    }
                }
            };
            CartesianChart.prototype.createAndInitLayers = function (dataViews) {
                var _this = this;
                var objects;
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                }
                // Create the layers
                var layers = this.layers;
                createLayers(layers, this.type, objects, this.interactivityService, this.animator, this.isScrollable);
                // Initialize the layers
                var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                cartesianOptions.svg = this.axisGraphicsContextScrollable;
                cartesianOptions.cartesianHost = {
                    updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
                };
                for (var i = 0, len = layers.length; i < len; i++)
                    layers[i].init(cartesianOptions);
            };
            CartesianChart.prototype.renderLegend = function () {
                var layers = this.layers;
                var legendData = { title: "", dataPoints: [] };
                for (var i = 0, len = layers.length; i < len; i++) {
                    this.layerLegendData = layers[i].calculateLegend();
                    if (this.layerLegendData) {
                        legendData.title = i === 0 ? this.layerLegendData.title || "" : legendData.title;
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                }
                var legendProperties = this.legendObjectProperties;
                if (legendProperties) {
                    visuals.LegendData.update(legendData, legendProperties);
                    var position = legendProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                }
                else {
                    this.legend.changeOrientation(0 /* Top */);
                }
                if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                    legendData.dataPoints = [];
                }
                this.legend.drawLegend(legendData, this.currentViewport);
            };
            CartesianChart.prototype.hideLegends = function () {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.addUnitTypeToAxisLabel = function (axes) {
                var unitType = axes.x.formatter && axes.x.formatter.displayUnit ? axes.x.formatter.displayUnit.title : null;
                this.categoryAxisHasUnitType = unitType !== null;
                if (axes.x.axisLabel && unitType) {
                    if (this.categoryAxisProperties && this.categoryAxisProperties['axisStyle']) {
                        if (this.categoryAxisProperties['axisStyle'] === powerbi.axisStyle.showBoth) {
                            axes.x.axisLabel = axes.x.axisLabel + ' (' + unitType + ')';
                        }
                        else if (this.categoryAxisProperties['axisStyle'] === powerbi.axisStyle.showUnitOnly) {
                            axes.x.axisLabel = unitType;
                        }
                    }
                }
                unitType = axes.y1.formatter && axes.y1.formatter.displayUnit ? axes.y1.formatter.displayUnit.title : null;
                this.valueAxisHasUnitType = unitType !== null;
                if (axes.y1.axisLabel && unitType) {
                    if (this.valueAxisProperties && this.valueAxisProperties['axisStyle']) {
                        if (this.valueAxisProperties['axisStyle'] === powerbi.axisStyle.showBoth) {
                            axes.y1.axisLabel = axes.y1.axisLabel + ' (' + unitType + ')';
                        }
                        else if (this.valueAxisProperties['axisStyle'] === powerbi.axisStyle.showUnitOnly) {
                            axes.y1.axisLabel = unitType;
                        }
                    }
                }
                if (axes.y2) {
                    unitType = axes.y2.formatter && axes.y2.formatter.displayUnit ? axes.y2.formatter.displayUnit.title : null;
                    this.secValueAxisHasUnitType = unitType !== null;
                    if (axes.y2.axisLabel && unitType) {
                        if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {
                            if (this.valueAxisProperties['secAxisStyle'] === powerbi.axisStyle.showBoth) {
                                axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';
                            }
                            else if (this.valueAxisProperties['secAxisStyle'] === powerbi.axisStyle.showUnitOnly) {
                                axes.y2.axisLabel = unitType;
                            }
                        }
                    }
                }
            };
            CartesianChart.prototype.shouldRenderSecondaryAxis = function (axisProperties) {
                if (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"]) {
                    return true;
                }
                return false;
            };
            CartesianChart.prototype.shouldRenderAxis = function (axisProperties) {
                if (!axisProperties) {
                    return false;
                }
                else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties["show"] == null || this.categoryAxisProperties["show"])) {
                    return true;
                }
                else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties["show"] == null || this.valueAxisProperties["show"])) {
                    return true;
                }
                return false;
            };
            CartesianChart.prototype.render = function (duration) {
                if (duration === void 0) { duration = 0; }
                this.duration = duration;
                var legendMargins = this.legendMargins = this.legend.getMargins();
                var viewport = {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
                var maxMarginFactor = this.getMaxMarginFactor();
                var leftMarginLimit = this.leftMarginLimit = viewport.width * maxMarginFactor;
                var bottomMarginLimit = this.bottomMarginLimit = Math.max(CartesianChart.MinBottomMargin, viewport.height * maxMarginFactor);
                var margin = this.margin;
                // reset defaults
                margin.top = CartesianChart.TopMargin;
                margin.bottom = bottomMarginLimit;
                margin.right = 0;
                var axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties);
                this.yAxisIsCategorical = axes.y1.isCategoryAxis;
                this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                if (axes.forceValueDomainStartToZero) {
                    if (!this.valueAxisProperties) {
                        this.valueAxisProperties = {};
                    }
                    visuals.CartesianHelper.forceValueDomainToZero(this.valueAxisProperties);
                }
                var renderXAxis = this.shouldRenderAxis(axes.x);
                var renderYAxes = this.shouldRenderAxis(axes.y1);
                var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);
                var width = viewport.width - (margin.left + margin.right);
                var properties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: CartesianChart.FontSizeString,
                };
                var isScalar = false;
                var mainAxisScale;
                var preferredViewport;
                this.isXScrollBarVisible = false;
                this.isYScrollBarVisible = false;
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                if (this.layers) {
                    if (this.layers[0].getVisualCategoryAxisIsScalar)
                        isScalar = this.layers[0].getVisualCategoryAxisIsScalar();
                    if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {
                        var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;
                        var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                        preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                        if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {
                            this.isXScrollBarVisible = true;
                            viewport.height -= CartesianChart.ScrollBarWidth;
                        }
                        if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {
                            this.isYScrollBarVisible = true;
                            viewport.width -= CartesianChart.ScrollBarWidth;
                            width = viewport.width - (margin.left + margin.right);
                        }
                    }
                }
                var needRotate = this.needRotate = visuals.AxisHelper.LabelLayoutStrategy.willRotate(axes.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, properties);
                var margins = visuals.AxisHelper.getTickLabelMargins({ width: width, height: viewport.height }, leftMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, axes.x, axes.y1, needRotate, bottomMarginLimit, properties, axes.y2, this.isXScrollBarVisible || this.isYScrollBarVisible, showOnRight, renderXAxis, renderYAxes, renderY2Axis);
                // We look at the y axes as main and second sides, if the y axis orientation is right so the main side is represents the right side
                var maxMainYaxisSide = showOnRight ? margins.yRight : margins.yLeft, maxSecondYaxisSide = showOnRight ? margins.yLeft : margins.yRight, xMax = margins.xMax;
                maxMainYaxisSide += CartesianChart.LeftPadding;
                if (hasMultipleYAxes(this.layers))
                    maxSecondYaxisSide += CartesianChart.RightPadding;
                xMax += CartesianChart.BottomPadding;
                if (this.hideAxisLabels(legendMargins)) {
                    axes.x.axisLabel = null;
                    axes.y1.axisLabel = null;
                    if (axes.y2) {
                        axes.y2.axisLabel = null;
                    }
                }
                this.addUnitTypeToAxisLabel(axes);
                var axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                var chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                if (axisLabels.x != null)
                    xMax += CartesianChart.XAxisLabelPadding;
                if (axisLabels.y != null)
                    maxMainYaxisSide += CartesianChart.YAxisLabelPadding;
                if (axisLabels.y2 != null)
                    maxSecondYaxisSide += CartesianChart.YAxisLabelPadding;
                if ((showOnRight && (maxMainYaxisSide !== margin.right || maxSecondYaxisSide !== margin.left)) || (!showOnRight && (maxMainYaxisSide !== margin.left || maxSecondYaxisSide !== margin.right)) || xMax !== margin.bottom || this.currentViewport.height !== viewport.height || this.isXScrollBarVisible || this.isYScrollBarVisible) {
                    margin.left = showOnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                    margin.right = showOnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                    margin.bottom = xMax;
                    this.margin = margin;
                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties);
                    width = viewport.width - (margin.left + margin.right);
                }
                if (this.isXScrollBarVisible) {
                    mainAxisScale = axes.x.scale;
                    var brushX = this.margin.left;
                    var brushY = viewport.height;
                    this.renderChartWithScrollBar(mainAxisScale, brushX, brushY, preferredViewport.width, viewport, axes, width, margins, chartHasAxisLabels, axisLabels);
                }
                else if (this.isYScrollBarVisible) {
                    mainAxisScale = axes.y1.scale;
                    var brushX = viewport.width;
                    var brushY = this.margin.top;
                    this.renderChartWithScrollBar(mainAxisScale, brushX, brushY, preferredViewport.height, viewport, axes, width, margins, chartHasAxisLabels, axisLabels);
                }
                else {
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport);
                }
                this.updateAxis(0, viewport);
                // clear any existing brush if no scrollbar is shown
                if (!(this.isXScrollBarVisible || this.isYScrollBarVisible)) {
                    this.brushGraphicsContext.selectAll("rect").remove();
                }
            };
            CartesianChart.prototype.hideAxisLabels = function (legendMargins) {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.renderChartWithScrollBar = function (inputMainAxisScale, brushX, brushY, svgLength, viewport, axes, width, margins, chartHasAxisLabels, axisLabels) {
                var _this = this;
                var mainAxisScale = inputMainAxisScale;
                var miniAxisScale = mainAxisScale.copy();
                var brush = this.brush;
                var viewportLength;
                var marginTop = this.margin.top;
                var marginLeft = this.margin.left;
                var marginRight = this.margin.right;
                var marginBottom = this.margin.bottom;
                var minExtent;
                if (this.isXScrollBarVisible) {
                    viewportLength = viewport.width - (marginLeft + marginRight);
                    minExtent = this.getMinExtent(svgLength, viewportLength);
                    miniAxisScale.rangeBands([0, viewportLength]);
                    brush.x(miniAxisScale).extent([0, minExtent]);
                }
                else {
                    viewportLength = viewport.height - (marginTop + marginBottom);
                    minExtent = this.getMinExtent(svgLength, viewportLength);
                    miniAxisScale.rangeBands([0, viewportLength]);
                    brush.y(miniAxisScale).extent([0, minExtent]);
                }
                this.brushMinExtent = minExtent;
                var viewportToSvgRatio = svgLength / viewportLength;
                brush.on("brush", function () { return window.requestAnimationFrame(function () { return _this.onBrushed(miniAxisScale, mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, viewportLength); }); }).on("brushend", function () { return _this.onBrushEnd(minExtent); });
                var brushContext = this.brushContext = this.brushGraphicsContext.attr({
                    "transform": visuals.SVGUtil.translate(brushX, brushY),
                    "drag-resize-disabled": "true" /*disables resizing of the visual when dragging the scrollbar in edit mode*/
                }).call(brush); /*call the brush function, causing it to create the rectangles   */
                /* Disabling the zooming feature*/
                brushContext.selectAll(".resize rect").remove();
                var minBrushExtent = this.setMinBrush(viewportLength, minExtent, viewportToSvgRatio);
                brushContext.select(".background").style('cursor', 'pointer').on("mousedown.brush", function () { return minBrushExtent; }).on("touchstart.brush", function () { return minBrushExtent; });
                brushContext.selectAll(".extent").style({
                    'fill-opacity': CartesianChart.fillOpacity,
                    'cursor': 'hand',
                });
                if (this.isXScrollBarVisible)
                    brushContext.selectAll("rect").attr("height", CartesianChart.ScrollBarWidth);
                else
                    brushContext.selectAll("rect").attr("width", CartesianChart.ScrollBarWidth);
                if (mainAxisScale && miniAxisScale) {
                    mainAxisScale.domain(miniAxisScale.domain());
                    mainAxisScale.rangeBands([0, viewportLength]);
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, brush.extent());
                }
            };
            CartesianChart.prototype.getMinExtent = function (svgLength, viewportLength) {
                return viewportLength * viewportLength / (svgLength);
            };
            CartesianChart.prototype.onBrushEnd = function (minExtent) {
                var brushContext = this.brushContext;
                if (this.isXScrollBarVisible) {
                    brushContext.select(".extent").attr("width", minExtent);
                }
                else
                    brushContext.select(".extent").attr("height", minExtent);
            };
            CartesianChart.prototype.onBrushed = function (miniAxisScale, mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, viewportLength) {
                var brush = this.brush;
                if (mainAxisScale && miniAxisScale) {
                    mainAxisScale.domain(miniAxisScale.domain());
                    this.setBrushExtent(this.brush, viewportLength, this.brushMinExtent);
                    var extent = brush.extent();
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, extent, 0);
                }
            };
            /* To show brush every time when mouse is clicked on the empty background */
            CartesianChart.prototype.setMinBrush = function (viewportLength, minExtent, viewportToSvgRatio) {
                this.setBrushExtent(this.brush, viewportLength, minExtent);
            };
            CartesianChart.prototype.setBrushExtent = function (brush, viewportWidth, minExtent) {
                var extent = brush.extent();
                var width = extent[1] - extent[0];
                if (width === minExtent && extent[1] <= viewportWidth && extent[0] >= 0)
                    return;
                if (width > minExtent) {
                    var padding = (width - minExtent) / 2;
                    extent[0] += padding;
                    extent[1] -= padding;
                }
                else if (width < minExtent) {
                    var padding = (minExtent - width) / 2;
                    extent[0] -= padding;
                    extent[1] += padding;
                }
                if (extent[0] < 0) {
                    extent[0] = 0;
                    extent[1] = minExtent;
                }
                else if (extent[0] > viewportWidth - minExtent) {
                    extent[0] = viewportWidth - minExtent;
                    extent[1] = viewportWidth;
                }
                brush.extent(extent);
            };
            CartesianChart.prototype.getMaxMarginFactor = function () {
                return this.visualInitOptions.style.maxMarginFactor || CartesianChart.MaxMarginFactor;
            };
            CartesianChart.prototype.renderChart = function (mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, extent, duration) {
                if (duration === void 0) { duration = this.duration; }
                var bottomMarginLimit = this.bottomMarginLimit;
                var leftMarginLimit = this.leftMarginLimit;
                var needRotate = this.needRotate;
                var layers = this.layers;
                debug.assertValue(layers, 'layers');
                // Filter data that fits viewport
                if (miniAxisScale) {
                    var selected;
                    var data = [];
                    var startValue = extent[0];
                    var endValue = extent[1];
                    var pixelStepSize = miniAxisScale(1) - miniAxisScale(0);
                    var startIndex = Math.floor(startValue / pixelStepSize);
                    var sliceLength = Math.ceil((endValue - startValue) / pixelStepSize);
                    var endIndex = startIndex + sliceLength; //intentionally one past the end index for use with slice(start,end)
                    selected = mainAxisScale.domain().slice(startIndex, endIndex); //up to but not including 'end'
                    if (selected && selected.length > 0) {
                        for (var i = 0; i < layers.length; i++) {
                            data[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                        }
                        mainAxisScale.domain(selected);
                        var dataType = visuals.AxisHelper.getCategoryValueType(data[0].categoryMetadata);
                        var newTickValues = visuals.AxisHelper.getRecommendedTickValuesForAnOrdinalRange(sliceLength, mainAxisScale.domain());
                        var dw = new visuals.DataWrapper(data[0], false);
                        var getValueFn = function (index, type) { return dw.lookupXValue(index - startIndex, type); };
                        var axisPropsToUpdate;
                        if (this.isXScrollBarVisible) {
                            axisPropsToUpdate = axes.x;
                        }
                        else {
                            axisPropsToUpdate = axes.y1;
                        }
                        axisPropsToUpdate.axis.scale(mainAxisScale);
                        axisPropsToUpdate.scale(mainAxisScale);
                        axisPropsToUpdate.axis.ticks(sliceLength);
                        // set an ordinal index array, not the actual values
                        axisPropsToUpdate.axis.tickValues(selected);
                        // this will call axes.x.axis.tickFormat() for us to convert the index to a real formatted value
                        axisPropsToUpdate.values = visuals.AxisHelper.formatAxisTickValues(axisPropsToUpdate.axis, newTickValues, axisPropsToUpdate.formatter, dataType, false, getValueFn);
                    }
                }
                //hide show x-axis here
                if (this.shouldRenderAxis(axes.x)) {
                    axes.x.axis.orient("bottom");
                    if (needRotate)
                        axes.x.axis.tickPadding(CartesianChart.TickPaddingRotatedX);
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    if (duration) {
                        xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis);
                    }
                    else {
                        xAxisGraphicsElement.call(axes.x.axis);
                    }
                    xAxisGraphicsElement.selectAll('text').call(visuals.AxisHelper.LabelLayoutStrategy.rotate, width, bottomMarginLimit, powerbi.TextMeasurementService.svgEllipsis, needRotate, bottomMarginLimit === margins.xMax, axes.x, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                }
                else {
                    this.xAxisGraphicsContext.selectAll('*').remove();
                }
                if (this.shouldRenderAxis(axes.y1)) {
                    var yAxisOrientation = this.yAxisOrientation;
                    var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                    axes.y1.axis.tickSize(width).tickPadding(CartesianChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                    if (duration) {
                        y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis);
                    }
                    else {
                        y1AxisGraphicsElement.call(axes.y1.axis);
                    }
                    if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
                        axes.y2.axis.tickPadding(CartesianChart.TickPaddingY).orient(showOnRight ? powerbi.yAxisPosition.left.toLowerCase() : powerbi.yAxisPosition.right.toLowerCase());
                        if (duration) {
                            this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis);
                        }
                        else {
                            this.y2AxisGraphicsContext.call(axes.y2.axis);
                        }
                        this.y2AxesRendered = true;
                    }
                    else {
                        this.y2AxisGraphicsContext.selectAll('*').remove();
                    }
                    if (margins.yLeft >= leftMarginLimit) {
                        y1AxisGraphicsElement.selectAll('text').call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftMarginLimit - CartesianChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis);
                    }
                }
                else {
                    this.y1AxisGraphicsContext.selectAll('*').remove();
                    this.y2AxisGraphicsContext.selectAll('*').remove();
                }
                // Axis labels
                //TODO: Add label for second Y axis for combo chart
                if (chartHasAxisLabels) {
                    var hideXAxisTitle = this.categoryAxisProperties && this.categoryAxisProperties["showAxisTitle"] != null && this.categoryAxisProperties["showAxisTitle"] === false;
                    var hideYAxisTitle = this.valueAxisProperties && this.valueAxisProperties["showAxisTitle"] != null && this.valueAxisProperties["showAxisTitle"] === false;
                    var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                    this.renderAxesLabels(axisLabels, this.legendMargins.height, viewport, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                }
                else {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                }
                for (var i = 0, len = layers.length; i < len; i++)
                    layers[i].render(duration);
            };
            /** Returns the actual viewportWidth if visual is not scrollable.
            If visual is scrollable, returns the plot area needed to draw all the datapoints */
            CartesianChart.getPreferredPlotArea = function (categoryCount, categoryThickness, viewport, isScrollable, isScalar) {
                var preferredViewport = {
                    height: viewport.height,
                    width: viewport.width
                };
                if (!isScalar && isScrollable) {
                    var preferredWidth = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    preferredViewport.width = Math.max(preferredWidth, viewport.width);
                }
                return preferredViewport;
            };
            /** Returns preferred Category span if the visual is scrollable */
            CartesianChart.getPreferredCategorySpan = function (categoryCount, categoryThickness) {
                return categoryThickness * (categoryCount + (CartesianChart.OuterPaddingRatio * 2));
            };
            // public for testing access
            CartesianChart.getLayout = function (data, options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
                var categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar);
                // Total width of the outer padding, the padding that exist on the far right and far left of the chart.
                var totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2;
                // visibleCategoryCount will be used to discard data that overflows on ordinal-axis charts.
                // Needed for dashboard visuals            
                var calculatedBarCount = Math.round((availableWidth - totalOuterPadding) / categoryThickness);
                var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
                var outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                if (!isScalar) {
                    // use dynamic outer padding
                    var oneOuterPadding = (availableWidth - (categoryThickness * visibleCategoryCount)) / 2;
                    outerPaddingRatio = oneOuterPadding / categoryThickness;
                }
                // If scrollable, visibleCategoryCount will be total categories
                if (!isScalar && isScrollable)
                    visibleCategoryCount = categoryCount;
                return {
                    categoryCount: visibleCategoryCount,
                    categoryThickness: categoryThickness,
                    outerPaddingRatio: outerPaddingRatio,
                    isScalar: isScalar
                };
            };
            /** Returns the thickness for each category.
              * -For clustered charts, you still need to divide by the number of series to get column width after calling this method.
              * -For linear or time scales, category thickness accomodates for the minimum interval between consequtive points.
              * -For all types, return value has accounted for outer padding, but not inner padding
            */
            CartesianChart.getCategoryThickness = function (seriesList, numCategories, plotLength, domain, isScalar) {
                var thickness;
                if (numCategories < 2)
                    thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio);
                else if (isScalar && domain && domain.length > 1) {
                    // the smallest interval defines the column width.
                    var minInterval = CartesianChart.getMinInterval(seriesList);
                    var domainSpan = domain[domain.length - 1] - domain[0];
                    // account for outside padding
                    var ratio = minInterval / (domainSpan + (minInterval * CartesianChart.OuterPaddingRatio * 2));
                    thickness = plotLength * ratio;
                    thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                }
                else {
                    // Divide the available width up including outer padding (in terms of category thickness) on
                    // both sides of the chart, and categoryCount categories. Reverse math:
                    // availableWidth = (categoryThickness * categoryCount) + (categoryThickness * (outerPadding * 2)),
                    // availableWidth = categoryThickness * (categoryCount + (outerPadding * 2)),
                    // categoryThickness = availableWidth / (categoryCount + (outerpadding * 2))
                    thickness = plotLength / (numCategories + (CartesianChart.OuterPaddingRatio * 2));
                    thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                }
                // spec calls for using the whole plot area, but the max rectangle thickness is "as if there were three categories"
                // (outerPaddingRatio has the same units as '# of categories' so they can be added)
                var maxRectThickness = plotLength / (3 + (CartesianChart.OuterPaddingRatio * 2));
                if (!isScalar && numCategories >= 3)
                    return Math.max(Math.min(thickness, maxRectThickness), CartesianChart.MinOrdinalRectThickness);
                return Math.min(thickness, maxRectThickness);
            };
            CartesianChart.getMinInterval = function (seriesList) {
                var minInterval = Number.MAX_VALUE;
                if (seriesList.length > 0) {
                    var series0data = seriesList[0].data.filter(function (d) { return !d.highlight; });
                    for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
                        minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                    }
                }
                return minInterval;
            };
            CartesianChart.MinOrdinalRectThickness = 20;
            CartesianChart.MinScalarRectThickness = 2;
            CartesianChart.OuterPaddingRatio = 0.4;
            CartesianChart.InnerPaddingRatio = 0.2;
            CartesianChart.ClassName = 'cartesianChart';
            CartesianChart.AxisGraphicsContextClassName = 'axisGraphicsContext';
            CartesianChart.MaxMarginFactor = 0.18;
            CartesianChart.MinBottomMargin = 25;
            CartesianChart.TopMargin = 8;
            CartesianChart.LeftPadding = 10;
            CartesianChart.RightPadding = 15;
            CartesianChart.BottomPadding = 12;
            CartesianChart.YAxisLabelPadding = 20;
            CartesianChart.XAxisLabelPadding = 18;
            CartesianChart.TickPaddingY = 10;
            CartesianChart.TickPaddingRotatedX = 5;
            CartesianChart.FontSize = 11;
            CartesianChart.FontSizeString = visuals.SVGUtil.convertToPixelString(CartesianChart.FontSize);
            CartesianChart.ScrollBarWidth = 10;
            CartesianChart.fillOpacity = 0.125;
            return CartesianChart;
        })();
        visuals.CartesianChart = CartesianChart;
        function createLayers(layers, type, objects, interactivityService, animator, isScrollable) {
            if (isScrollable === void 0) { isScrollable = false; }
            debug.assertValue(layers, 'layers');
            debug.assert(layers.length === 0, 'layers.length === 0');
            switch (type) {
                case 1 /* Area */:
                    layers.push(new visuals.LineChart({
                        chartType: 2 /* area */,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService,
                        animator: animator,
                    }));
                    return;
                case 0 /* Line */:
                    layers.push(new visuals.LineChart({
                        chartType: 1 /* default */,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService,
                        animator: animator,
                    }));
                    return;
                case 3 /* StackedColumn */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.stackedColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 2 /* ClusteredColumn */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.clusteredColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 7 /* HundredPercentStackedColumn */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.hundredPercentStackedColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 5 /* StackedBar */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.stackedBar,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 4 /* ClusteredBar */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.clusteredBar,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 6 /* HundredPercentStackedBar */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.hundredPercentStackedBar,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    return;
                case 8 /* Scatter */:
                    layers.push(new visuals.ScatterChart({ interactivityService: interactivityService }));
                    return;
                case 11 /* Waterfall */:
                    layers.push(new visuals.WaterfallChart({ isScrollable: isScrollable }));
                    return;
                case 9 /* ComboChart */:
                    // This support existing serialization of pinned combo-chart visuals
                    var columnType = visuals.ColumnChartType.clusteredColumn;
                    if (objects) {
                        var comboChartTypes = objects.general;
                        if (comboChartTypes) {
                            switch (comboChartTypes.visualType1) {
                                case 'Column':
                                    columnType = visuals.ColumnChartType.clusteredColumn;
                                    break;
                                case 'ColumnStacked':
                                    columnType = visuals.ColumnChartType.stackedColumn;
                                    break;
                                default:
                                    debug.assertFail('Unsupported cartesian chart type ' + comboChartTypes.visualType1);
                            }
                            // second visual is always LineChart (for now)
                            if (comboChartTypes.visualType2) {
                                debug.assert(comboChartTypes.visualType2 === 'Line', 'expecting a LineChart for VisualType2');
                            }
                        }
                    }
                    layers.push(new visuals.ColumnChart({
                        chartType: columnType,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    layers.push(new visuals.LineChart({ chartType: (1 /* default */ | 8 /* lineShadow */), isScrollable: isScrollable, interactivityService: interactivityService, animator: animator }));
                    return;
                case 10 /* DataDot */:
                    layers.push(new visuals.DataDotChart());
                    return;
                case 12 /* LineClusteredColumnCombo */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.clusteredColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    layers.push(new visuals.LineChart({ chartType: (1 /* default */ | 8 /* lineShadow */), isScrollable: isScrollable, interactivityService: interactivityService, animator: animator }));
                    return;
                case 13 /* LineStackedColumnCombo */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.stackedColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    layers.push(new visuals.LineChart({ chartType: (1 /* default */ | 8 /* lineShadow */), isScrollable: isScrollable, interactivityService: interactivityService, animator: animator }));
                    return;
                case 14 /* DataDotClusteredColumnCombo */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.clusteredColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    layers.push(new visuals.DataDotChart());
                    return;
                case 15 /* DataDotStackedColumnCombo */:
                    layers.push(new visuals.ColumnChart({
                        chartType: visuals.ColumnChartType.stackedColumn,
                        animator: animator,
                        isScrollable: isScrollable,
                        interactivityService: interactivityService
                    }));
                    layers.push(new visuals.DataDotChart());
                    return;
            }
        }
        function getLayerData(dataViews, currentIdx, totalLayers) {
            if (totalLayers > 1) {
                if (dataViews && dataViews.length > currentIdx)
                    return [dataViews[currentIdx]];
                return [];
            }
            return dataViews;
        }
        function hasMultipleYAxes(layers) {
            debug.assertValue(layers, 'layers');
            return layers.length > 1;
        }
        //** Returns a boolean, that indicates if y axis title should be displayed. */
        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
            return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) || (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
        }
        function tryMergeYDomains(layers, visualOptions) {
            debug.assert(layers.length < 3, 'merging of more than 2 layers is not supported');
            var noMerge = {
                domain: undefined,
                merged: false,
                tickCount: 3,
                forceStartToZero: false
            };
            if (layers.length < 2)
                return noMerge;
            var min;
            var max;
            var minOfMax;
            var maxOfMin;
            // TODO: replace full calculateAxesProperties with just a data domain calc
            // we need to be aware of which chart require zero (column/bar) and which don't (line)
            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
            var firstYDomain = y1props.scale.domain();
            var secondYDomain = y2props.scale.domain();
            if (firstYDomain[0] >= 0 && secondYDomain[0] >= 0) {
                noMerge.forceStartToZero = true;
            }
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
            }
            // If domains don't intersect don't merge axis.
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0])
                return noMerge;
            min = Math.min(firstYDomain[0], secondYDomain[0]);
            max = Math.max(firstYDomain[1], secondYDomain[1]);
            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
            minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var range = (max - min);
            if (range === 0) {
                return noMerge;
            }
            var intersection = Math.abs((minOfMax - maxOfMin) / range);
            // Only merge if intersection of domains greater than 10% of total range.
            if (intersection < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE)
                return noMerge;
            else
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount,
                    forceStartToZero: false
                };
        }
        /** Computes the Cartesian Chart axes from the set of layers. */
        function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties) {
            debug.assertValue(layers, 'layers');
            var visualOptions = {
                viewport: viewport,
                margin: margin,
                forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                showXLabel: false,
                showYLabel: false
            };
            var yAxisWillMerge = false;
            var mergeResult;
            if (hasMultipleYAxes(layers)) {
                mergeResult = tryMergeYDomains(layers, visualOptions);
                yAxisWillMerge = mergeResult.merged;
                if (yAxisWillMerge) {
                    visualOptions.forcedYDomain = mergeResult.domain;
                }
                else {
                    visualOptions.forcedTickCount = mergeResult.tickCount;
                }
            }
            //set forcedYDomain after attempting the merge
            var forceValueDomainStartToZero = mergeResult ? mergeResult.forceStartToZero : false;
            visualOptions.forcedYDomain = valueAxisProperties ? [valueAxisProperties['start'], valueAxisProperties['end']] : null;
            var result;
            for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                var currentlayer = layers[layerNumber];
                if (layerNumber === 1 && !yAxisWillMerge) {
                    visualOptions.forcedYDomain = valueAxisProperties ? [valueAxisProperties['secStart'], valueAxisProperties['secEnd']] : null;
                }
                visualOptions.showXLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);
                visualOptions.showYLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                var axes = currentlayer.calculateAxesProperties(visualOptions);
                if (layerNumber === 0) {
                    result = {
                        x: axes[0],
                        y1: axes[1],
                        forceValueDomainStartToZero: forceValueDomainStartToZero
                    };
                }
                else if (axes && !result.y2) {
                    if (axes[0].axis.scale().domain().length > result.x.axis.scale().domain().length) {
                        visualOptions.showYLabel = (!!valueAxisProperties && !!valueAxisProperties['showAxisTitle']);
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        // no categories returned for the first layer, use second layer x-axis properties
                        result.x = axes[0];
                        // and 2nd value axis to be the primary
                        result.y1 = axes[1];
                    }
                    else {
                        // make sure all layers use the same x-axis/scale for drawing
                        currentlayer.overrideXScale(result.x);
                        if (!yAxisWillMerge)
                            result.y2 = axes[1];
                    }
                }
            }
            return result;
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getColumnChartCapabilities(transposeAxes) {
            if (transposeAxes === void 0) { transposeAxes = false; }
            return {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: 0 /* Grouping */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                    },
                    {
                        name: 'Series',
                        kind: 0 /* Grouping */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    },
                    {
                        name: 'Y',
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                    },
                    {
                        name: 'Gradient',
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    }
                ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                        },
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                type: { formatting: { legendPosition: true } }
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                type: { bool: true }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                                type: { text: true }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_YAxis') : powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                type: { formatting: { yAxisPosition: true } }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                type: { numeric: true }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                type: { numeric: true }
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                                type: { formatting: { axisType: true } }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { formatting: { axisStyle: true } }
                            }
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_XAxis') : powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                type: { formatting: { yAxisPosition: true } }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                type: { numeric: true }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                type: { numeric: true }
                            },
                            intersection: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
                                type: { numeric: true }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { formatting: { axisStyle: true } }
                            }
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                type: { bool: true }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                type: { formatting: { labelDisplayUnits: true } }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                type: { numeric: true }
                            },
                        },
                    },
                },
                dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                    },
                }],
                supportsHighlight: true,
                sorting: {
                    default: {},
                },
            };
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
        visuals.columnChartProps = {
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var flagBar = 1 << 1;
        var flagColumn = 1 << 2;
        var flagClustered = 1 << 3;
        var flagStacked = 1 << 4;
        var flagStacked100 = flagStacked | (1 << 5);
        (function (ColumnChartType) {
            ColumnChartType[ColumnChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
            ColumnChartType[ColumnChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
            ColumnChartType[ColumnChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
            ColumnChartType[ColumnChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
            ColumnChartType[ColumnChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
            ColumnChartType[ColumnChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
        })(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
        var ColumnChartType = visuals.ColumnChartType;
        var RoleNames = {
            category: 'Category',
            series: 'Series',
            y: 'Y',
        };
        /** Renders a stacked and clustered column chart */
        var ColumnChart = (function () {
            function ColumnChart(options) {
                debug.assertValue(options, 'options');
                var chartType = options.chartType;
                debug.assertValue(chartType, 'chartType');
                this.chartType = chartType;
                this.categoryAxisType = null;
                this.animator = options.animator;
                this.isScrollable = options.isScrollable;
                this.interactivityService = options.interactivityService;
            }
            ColumnChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    if (visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType))
                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            ColumnChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) {
                        return ['Category', 'Y'];
                    }
                }
                return null;
            };
            ColumnChart.prototype.updateVisualMetadata = function (x, y, margin) {
                this.xAxisProperties = x;
                this.yAxisProperties = y;
                this.margin = margin;
            };
            ColumnChart.prototype.init = function (options) {
                this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsContext = this.svg.append('g').classed('columnChartMainGraphicsContext', true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.interactivity = options.interactivity;
                this.colors = this.style.colorPalette.dataColors;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                var element = this.element = options.element;
                element.addClass(ColumnChart.ColumnChartClassName);
                switch (this.chartType) {
                    case ColumnChartType.clusteredBar:
                        this.columnChart = new visuals.ClusteredBarChartStrategy();
                        break;
                    case ColumnChartType.clusteredColumn:
                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
                        break;
                    case ColumnChartType.stackedBar:
                    case ColumnChartType.hundredPercentStackedBar:
                        this.columnChart = new visuals.StackedBarChartStrategy();
                        break;
                    case ColumnChartType.stackedColumn:
                    case ColumnChartType.hundredPercentStackedColumn:
                    default:
                        this.columnChart = new visuals.StackedColumnChartStrategy();
                        break;
                }
            };
            ColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
                var availableWidth;
                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                    availableWidth = this.currentViewport.height - (this.margin.top + this.margin.bottom);
                }
                else {
                    availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                }
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                return visuals.CartesianChart.getLayout(this.data, {
                    availableWidth: availableWidth,
                    categoryCount: numCategoryValues,
                    domain: domain,
                    isScalar: isScalar,
                    isScrollable: this.isScrollable
                });
            };
            ColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                if (supportsOverflow === void 0) { supportsOverflow = false; }
                if (dataViewMetadata === void 0) { dataViewMetadata = null; }
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colors, 'colors');
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                var converterStrategy = new ColumnChartConverterHelper(dataView);
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);
                var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked);
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects['labels'];
                    if (labelsObj) {
                        if (labelsObj.show !== undefined)
                            labelSettings.show = labelsObj.show;
                        if (labelsObj.color !== undefined) {
                            labelSettings.labelColor = labelsObj.color.solid.color;
                            labelSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : 0;
                        }
                    }
                    labelSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataViewMetadata.columns);
                }
                // Allocate colors
                var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);
                var legend = legendAndSeriesInfo.legend.dataPoints;
                var seriesSources = legendAndSeriesInfo.seriesSources;
                // Determine data points
                var result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType);
                var columnSeries = result.series;
                var valuesMetadata = [];
                for (var j = 0, jlen = legend.length; j < jlen; j++) {
                    valuesMetadata.push(seriesSources[j]);
                }
                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                if (!EnumExtensions.hasFlag(chartType, flagColumn)) {
                    // Replace between x and y axes
                    var temp = labels.xAxisLabel;
                    labels.xAxisLabel = labels.yAxisLabel;
                    labels.yAxisLabel = temp;
                }
                return {
                    categories: categories,
                    categoryFormatter: categoryFormatter,
                    series: columnSeries,
                    valuesMetadata: valuesMetadata,
                    legendData: legendAndSeriesInfo.legend,
                    hasHighlights: result.hasHighlights,
                    categoryMetadata: categoryMetadata,
                    scalarCategoryAxis: isScalar,
                    labelSettings: labelSettings,
                    axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
                    hasDynamicSeries: result.hasDynamicSeries,
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                    hasSelection: false,
                };
            };
            ColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                if (supportsOverflow === void 0) { supportsOverflow = false; }
                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                var categoryCount = categories.length;
                var seriesCount = legend.length;
                var columnSeries = [];
                if (seriesCount < 1 || categoryCount < 1)
                    return { series: columnSeries, hasHighlights: false, hasDynamicSeries: false };
                var dvCategories = dataViewCat.categories;
                var categoryMetadata = (dvCategories && dvCategories.length > 0) ? dvCategories[0].source : null;
                var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var baseValuesPos = [], baseValuesNeg = [];
                var rawValues = [];
                var rawHighlightValues = [];
                var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
                var hasHighlights = converterStrategy.hasHighlightValues(0);
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesValues = [];
                    var seriesHighlightValues = [];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                        seriesValues[categoryIndex] = value;
                        if (hasHighlights) {
                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = highlightValue;
                            // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
                            if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) || (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
                                highlightsOverflow = true;
                            }
                        }
                    }
                    rawValues.push(seriesValues);
                    if (hasHighlights) {
                        rawHighlightValues.push(seriesHighlightValues);
                    }
                }
                if (highlightsOverflow && !supportsOverflow) {
                    highlightsOverflow = false;
                    hasHighlights = false;
                    rawValues = rawHighlightValues;
                }
                var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesDataPoints = [], legendItem = legend[seriesIndex];
                    columnSeries.push({
                        displayName: legendItem.label,
                        key: 'series' + seriesIndex,
                        index: seriesIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity,
                    });
                    if (seriesCount > 1)
                        dataPointObjects = seriesObjectsList[seriesIndex];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        if (seriesIndex === 0) {
                            baseValuesPos.push(0);
                            baseValuesNeg.push(0);
                        }
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                        if (value == null) {
                            // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
                            // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
                            if (seriesIndex > 0)
                                continue;
                        }
                        var originalValue = value;
                        var categoryValue = categories[categoryIndex];
                        if (isDateTime && categoryValue)
                            categoryValue = categoryValue.getTime();
                        if (isScalar && (categoryValue == null || isNaN(categoryValue)))
                            continue;
                        var multipliers;
                        if (is100PercentStacked)
                            multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                        var unadjustedValue = value, isNegative = value < 0;
                        if (multipliers) {
                            if (isNegative)
                                value *= multipliers.neg;
                            else
                                value *= multipliers.pos;
                        }
                        var valueAbsolute = Math.abs(value);
                        var position;
                        if (isNegative) {
                            position = baseValuesNeg[categoryIndex];
                            if (!isNaN(valueAbsolute))
                                baseValuesNeg[categoryIndex] -= valueAbsolute;
                        }
                        else {
                            if (!isNaN(valueAbsolute))
                                baseValuesPos[categoryIndex] += valueAbsolute;
                            position = baseValuesPos[categoryIndex];
                        }
                        var identity = visuals.SelectionId.createWithIdsAndMeasure(categoryIdentities ? categoryIdentities[categoryIndex] : undefined, hasDynamicSeries ? grouped[seriesIndex].identity : undefined, converterStrategy.getMeasureNameByIndex(seriesIndex));
                        var rawCategoryValue = categories[categoryIndex];
                        var color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat.categories, rawCategoryValue, dataViewCat.values, originalValue, null, seriesIndex);
                        var labelColor = color;
                        //Stacked column/bar label color is white by default (except last series)
                        if ((EnumExtensions.hasFlag(chartType, flagStacked))) {
                            var lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                            labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? color : '#FFFFFF';
                        }
                        var dataPoint = {
                            categoryValue: categoryValue,
                            value: value,
                            position: position,
                            valueAbsolute: valueAbsolute,
                            valueOriginal: unadjustedValue,
                            seriesIndex: seriesIndex,
                            categoryIndex: categoryIndex,
                            color: color,
                            selected: false,
                            originalValue: value,
                            originalPosition: position,
                            originalValueAbsolute: valueAbsolute,
                            identity: identity,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.overrideDefaultColor || is100PercentStacked ? labelSettings.labelColor : labelColor,
                            lastSeries: lastValue,
                            chartType: chartType
                        };
                        seriesDataPoints.push(dataPoint);
                        if (hasHighlights) {
                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                            var unadjustedValueHighlight = valueHighlight;
                            var highlightedTooltip = true;
                            if (valueHighlight === null) {
                                valueHighlight = 0;
                                highlightedTooltip = false;
                            }
                            if (is100PercentStacked) {
                                valueHighlight *= multipliers.pos;
                            }
                            var absoluteValueHighlight = Math.abs(valueHighlight);
                            var highlightPosition = position;
                            if (valueHighlight > 0) {
                                highlightPosition -= valueAbsolute - absoluteValueHighlight;
                            }
                            else if (valueHighlight === 0 && value > 0) {
                                highlightPosition -= valueAbsolute;
                            }
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var rawCategoryValue = categories[categoryIndex];
                            var highlightedValue = highlightedTooltip ? valueHighlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat.categories, rawCategoryValue, dataViewCat.values, originalValue, null, seriesIndex, highlightedValue);
                            if (highlightedTooltip) {
                                // Override non highlighted data point
                                dataPoint.tooltipInfo = tooltipInfo;
                            }
                            var highlightDataPoint = {
                                categoryValue: categoryValue,
                                value: valueHighlight,
                                position: highlightPosition,
                                valueAbsolute: absoluteValueHighlight,
                                valueOriginal: unadjustedValueHighlight,
                                seriesIndex: seriesIndex,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                highlight: true,
                                originalValue: value,
                                originalPosition: position,
                                originalValueAbsolute: valueAbsolute,
                                drawThinner: highlightsOverflow,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.overrideDefaultColor || is100PercentStacked ? labelSettings.labelColor : labelColor,
                                lastSeries: lastValue,
                                chartType: chartType
                            };
                            seriesDataPoints.push(highlightDataPoint);
                        }
                    }
                }
                return {
                    series: columnSeries,
                    hasHighlights: hasHighlights,
                    hasDynamicSeries: hasDynamicSeries,
                };
            };
            ColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
                debug.assertValue(legendItem, 'legendItem');
                debug.assertValue(categoryIndex, 'categoryIndex');
                debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
                if (dataPointObjects) {
                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                    if (colorOverride)
                        return colorOverride;
                }
                return legendItem.color;
            };
            ColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                for (var i = seriesIndex + 1; i < seriesCount; i++) {
                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                    if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
                        lastValue = false;
                        break;
                    }
                }
                return lastValue;
            };
            ColumnChart.sliceSeries = function (series, endIndex, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    for (var i = 0, len = series.length; i < len; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        // TODO: [investigate] possible perf improvement.
                        // if data[n].categoryIndex > endIndex implies data[n+1].categoryIndex > endIndex
                        // then we could short circuit the filter loop.
                        iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
                    }
                }
                return newSeries;
            };
            ColumnChart.getForcedTickValues = function (min, max, forcedTickCount) {
                debug.assert(min <= max, "min must be less or equal to max");
                debug.assert(forcedTickCount >= 0, "forcedTickCount must be greater or equal to zero");
                if (forcedTickCount <= 1)
                    return [];
                var tickValues = [];
                var interval = (max - min) / (forcedTickCount - 1);
                for (var i = 0; i < forcedTickCount - 1; i++) {
                    tickValues.push(min + i * interval);
                }
                tickValues.push(max);
                if (tickValues.indexOf(0) === -1)
                    tickValues.push(0);
                // It's not needed to sort the array here since when we pass tick value array to D3,
                // D3 does not care whether the elements in the array are in order or not.
                return tickValues;
            };
            ColumnChart.getTickInterval = function (tickValues) {
                if (tickValues.length === 0)
                    return 0;
                if (tickValues.length === 1)
                    return tickValues[0];
                tickValues.sort(function (a, b) { return (a - b); });
                return tickValues[1] - tickValues[0];
            };
            ColumnChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var is100PctStacked = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                this.data = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    valuesMetadata: [],
                    legendData: null,
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    hasSelection: false,
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCat = this.dataViewCat = dataView.categorical;
                        var dvCategories = dataViewCat.categories;
                        var categoryMetadata = (dvCategories && dvCategories.length > 0) ? dvCategories[0].source : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                        this.data = ColumnChart.converter(dataViewCat, this.colors, is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), this.supportsOverflow, dataView.metadata, this.chartType);
                        var series = this.data.series;
                        for (var i = 0, ilen = series.length; i < ilen; i++) {
                            var currentSeries = series[i];
                            if (this.interactivityService) {
                                if (this.interactivityService.applySelectionStateToData(currentSeries.data))
                                    this.data.hasSelection = true;
                            }
                        }
                    }
                }
            };
            ColumnChart.prototype.calculateLegend = function () {
                // if we're in interactive mode, return the interactive legend 
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    return this.createInteractiveLegendDataPoints(0);
                }
                var legendData = this.data ? this.data.legendData : null;
                var legendDataPoints = legendData ? legendData.dataPoints : [];
                if (ArrayExtensions.isUndefinedOrEmpty(legendDataPoints))
                    return null;
                return legendData;
            };
            ColumnChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            ColumnChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat))
                            return this.enumerateDataPoints();
                        break;
                    case 'labels':
                        if (EnumExtensions.hasFlag(this.chartType, flagStacked100))
                            return visuals.dataLabelUtils.enumerateDataLabels(this.data.labelSettings, false);
                        return visuals.dataLabelUtils.enumerateDataLabels(this.data.labelSettings, false, true, true);
                }
                return null;
            };
            ColumnChart.prototype.enumerateDataPoints = function () {
                var data = this.data;
                if (!data)
                    return;
                var instances = [], seriesCount = data.series.length;
                if (seriesCount === 0)
                    return instances;
                var isMultiMeasure = !data.hasDynamicSeries && seriesCount > 1;
                if (!isMultiMeasure) {
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColor(0).value } }
                        },
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesCount > 1;
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        },
                    });
                }
                if (data.hasDynamicSeries || seriesCount > 1) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: series.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.data[0].color } }
                            },
                        });
                    }
                }
                else {
                    var singleSeriesData = data.series[0].data;
                    var categoryFormatter = data.categoryFormatter;
                    for (var i = 0; i < singleSeriesData.length; i++) {
                        var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                            selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), true),
                            properties: {
                                fill: { solid: { color: singleSeriesDataPoints.color } }
                            },
                        });
                    }
                }
                return instances;
            };
            ColumnChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var origCatgSize = (data && data.categories) ? data.categories.length : 0;
                var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                    categoryCount: 0,
                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                    isScalar: false
                };
                this.categoryAxisType = chartLayout.isScalar ? powerbi.axisType.scalar : null;
                if (data && !chartLayout.isScalar && !this.isScrollable) {
                    // trim data that doesn't fit on dashboard
                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = powerbi.Prototype.inherit(data);
                        data.series = ColumnChart.sliceSeries(data.series, catgSize);
                        data.categories = data.categories.slice(0, catgSize);
                    }
                }
                this.columnChart.setData(data);
                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
                 In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= (margin.left + margin.right);
                }
                preferredPlotArea.height -= (margin.top + margin.bottom);
                var is100Pct = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                // When the category axis is scrollable the height of the category axis and value axis will be different
                // The height of the value axis would be same as viewportHeight 
                var chartContext = {
                    height: preferredPlotArea.height,
                    width: preferredPlotArea.width,
                    duration: 0,
                    hostService: this.hostService,
                    mainGraphicsContext: this.mainGraphicsContext,
                    margin: this.margin,
                    layout: chartLayout,
                    animator: this.animator,
                    interactivityService: this.interactivityService,
                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                    is100Pct: is100Pct,
                };
                this.ApplyInteractivity(chartContext);
                this.columnChart.setupVisualProps(chartContext);
                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                    var temp = options.forcedXDomain;
                    options.forcedXDomain = options.forcedYDomain;
                    options.forcedYDomain = temp;
                }
                this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain);
                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain);
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                var viewport = {
                    height: this.currentViewport.height,
                    width: this.currentViewport.width
                };
                if (this.isScrollable && !isScalar) {
                    var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                        viewport.height = Math.max(preferredWidth, viewport.height);
                    }
                    else
                        viewport.width = Math.max(preferredWidth, viewport.width);
                }
                return viewport;
            };
            ColumnChart.prototype.ApplyInteractivity = function (chartContext) {
                var _this = this;
                var interactivity = this.interactivity;
                if (interactivity) {
                    if (interactivity.dragDataPoint) {
                        chartContext.onDragStart = function (datum) {
                            if (!datum.identity)
                                return;
                            _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        };
                    }
                    if (interactivity.isInteractiveLegend) {
                        var dragMove = function () {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
                            var x = mousePoint[0];
                            var y = mousePoint[1];
                            var index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        };
                        //set click interaction on the visual
                        this.svg.on('click', dragMove);
                        //set click interaction on the background
                        d3.select(this.element.get(0)).on('click', dragMove);
                        var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                        //set drag interaction on the visual
                        this.svg.call(drag);
                        //set drag interaction on the background
                        d3.select(this.element.get(0)).call(drag);
                    }
                }
            };
            ColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
                    return; // same column, nothing to do here
                var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected);
                var legendDataPoints = legendData.dataPoints;
                this.cartesianVisualHost.updateLegend(legendData);
                if (legendDataPoints.length > 0) {
                    this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                }
                this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
            };
            ColumnChart.prototype.createInteractiveLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series))
                    return { dataPoints: [] };
                var formatStringProp = visuals.columnChartProps.general.formatString;
                var legendDataPoints = [];
                var category = data.categories && data.categories[columnIndex];
                var allSeries = data.series;
                for (var i = 0, len = allSeries.length; i < len; i++) {
                    var dataPoint = data.series[i].data[columnIndex];
                    var measure = dataPoint && dataPoint.valueOriginal;
                    var valueMetadata = data.valuesMetadata[i];
                    var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                    legendDataPoints.push({
                        color: dataPoint.color,
                        icon: 0 /* Box */,
                        label: formattedLabel,
                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                        identity: visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            ColumnChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ColumnChart.prototype.render = function (duration) {
                var selection = this.columnChart.drawColumns(!!duration);
                var data = this.data;
                visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                if (this.interactivityService) {
                    var allDataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        allDataPoints = allDataPoints.concat(data.series[i].data);
                    }
                    var behaviorOptions = {
                        bars: selection,
                        datapoints: allDataPoints,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights,
                        mainGraphicsContext: this.mainGraphicsContext
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    if (this.data.series.length > 0) {
                        this.selectColumn(0, true); // start with the first column
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            ColumnChart.prototype.onClearSelection = function () {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                }
            };
            ColumnChart.prototype.accept = function (visitor, options) {
                visitor.visitColumnChart(options);
            };
            ColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.scalarCategoryAxis : false;
            };
            ColumnChart.prototype.getSupportedCategoryAxisType = function () {
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                return isOrdinal ? powerbi.axisType.categorical : powerbi.axisType.both;
            };
            ColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = powerbi.Prototype.inherit(this.data);
                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                this.columnChart.setData(data);
                return data;
            };
            ColumnChart.ColumnChartClassName = 'columnChart';
            ColumnChart.SeriesClasses = {
                class: 'series',
                selector: '.series'
            };
            return ColumnChart;
        })();
        visuals.ColumnChart = ColumnChart;
        var ColumnChartConverterHelper = (function () {
            function ColumnChartConverterHelper(dataView) {
                this.dataView = dataView;
            }
            ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultColor) {
                var legend = [];
                var seriesSources = [];
                var seriesObjects = [];
                var grouped = false;
                var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                if (this.dataView && this.dataView.values) {
                    var allValues = this.dataView.values;
                    var valueGroups = allValues.grouped();
                    var hasDynamicSeries = !!(allValues && allValues.source);
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                        var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                        for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                            var series = values[valueIndex];
                            var source = series.source;
                            // Gradient measures do not create series.
                            if (visuals.DataRoleHelper.hasRole(source, 'Gradient') && !visuals.DataRoleHelper.hasRole(source, 'Y'))
                                continue;
                            seriesSources.push(source);
                            seriesObjects.push(series.objects);
                            var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                            var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                            var color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                            legend.push({
                                icon: 0 /* Box */,
                                color: color,
                                label: label,
                                identity: selectionId,
                                selected: false,
                            });
                            if (series.identity && source.groupName !== undefined) {
                                grouped = true;
                            }
                        }
                    }
                    var dvValues = this.dataView.values;
                    var legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legend,
                    grouped: grouped,
                };
                return {
                    legend: legendData,
                    seriesSources: seriesSources,
                    seriesObjects: seriesObjects,
                };
            };
            ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
                return this.dataView.values[series].values[category];
            };
            ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
                return this.dataView.values[index].source.queryName;
            };
            ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                return column && !!column.highlights;
            };
            ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
                return this.dataView.values[series].highlights[category];
            };
            return ColumnChartConverterHelper;
        })();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ClusteredColumnChartStrategy = (function () {
            function ClusteredColumnChartStrategy() {
            }
            ClusteredColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
            };
            ClusteredColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function (s) { return s.index; })).rangeBands([0, seriesLength * columnWidth]);
                props.xLabelMaxWidth = this.categoryLayout.isScalar ? (width / props.values.length) : this.categoryLayout.categoryThickness;
                return props;
            };
            ClusteredColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true);
                var maxTickCount = visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height);
                var bestTickCount = visuals.ColumnUtil.getTickCount(valueDomain[0], valueDomain[1], this.data.valuesMetadata, maxTickCount, is100Pct, forcedTickCount);
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({ min: valueDomain[0], max: valueDomain[1] });
                valueDomain = [normalizedRange.min, normalizedRange.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain);
                var yScale = d3.scale.linear().range([height, 0]).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain));
                visuals.ColumnUtil.normalizeInfinityInScale(yScale);
                var yTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, yScale);
                var yAxis = d3.svg.axis().scale(yScale).tickValues(yTickValues);
                var yInterval = visuals.ColumnChart.getTickInterval(yTickValues);
                var yFormatter = visuals.ClusteredUtil.createValueFormatter(this.data.valuesMetadata, yInterval);
                yAxis.tickFormat(yFormatter.format);
                var values = yTickValues.map(function (d) { return yFormatter.format(d); });
                var yProps = this.yProps = {
                    axis: yAxis,
                    scale: yScale,
                    formatter: yFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({ text: true }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
                return yProps;
            };
            ClusteredColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredColumnLayout = ClusteredColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, dataLabelSettings), true, false, this.yProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredColumnLayout,
                        itemCS: ClusteredColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, { height: this.height, width: this.width });
                        }
                        else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            ClusteredColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /** Get the chart's columns centers (x value) */
            ClusteredColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });
                    }
                }
                return this.columnsCenters;
            };
            ClusteredColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line').classed('interactive-hover-line', true).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle').attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    }).classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            ClusteredColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)); },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset; },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue)); },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0; },
                        height: function (d) { return 0; },
                    },
                };
            };
            ClusteredColumnChartStrategy.prototype.getLabelLayoutXY = function (axisOptions, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var xScaleOffset = 0;
                var scaledY0 = yScale(0);
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0) + halfColumnWidth; },
                    y: function (d) {
                        var outsidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                        var insidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) / 2 - visuals.dataLabelUtils.defaultColumnLabelMargin;
                        // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                        if (outsidePosition <= 0) {
                            // Inside position, if color didn't override, then the color is white
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return insidePosition;
                        }
                        return outsidePosition;
                    },
                };
            };
            ClusteredColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column',
                },
            };
            return ClusteredColumnChartStrategy;
        })();
        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
        var ClusteredBarChartStrategy = (function () {
            function ClusteredBarChartStrategy() {
            }
            ClusteredBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
            };
            ClusteredBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function (s) { return s.index; })).rangeBands([0, seriesLength * columnWidth]);
                return props;
            };
            ClusteredBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                debug.assert(forcedTickCount === undefined, 'Cannot have clustered bar chart as combo chart.');
                var width = this.width;
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true);
                var bestTickCount = visuals.AxisHelper.getBestNumberOfTicks(valueDomain[0], valueDomain[1], this.data.valuesMetadata, visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width));
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({ min: valueDomain[0], max: valueDomain[1] });
                valueDomain = [normalizedRange.min, normalizedRange.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain);
                var xScale = d3.scale.linear().range([0, width]).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain));
                visuals.ColumnUtil.normalizeInfinityInScale(xScale);
                var xTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, xScale);
                var xAxis = d3.svg.axis().scale(xScale).tickSize(-height, 0).tickValues(xTickValues);
                var xInterval = visuals.ColumnChart.getTickInterval(xTickValues);
                var xFormatter = visuals.ClusteredUtil.createValueFormatter(this.data.valuesMetadata, xInterval);
                xAxis.tickFormat(xFormatter.format);
                var values = xTickValues.map(function (d) { return xFormatter.format(d); });
                var xProps = this.xProps = {
                    axis: xAxis,
                    scale: xScale,
                    formatter: xFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({ numeric: true }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
                return xProps;
            };
            ClusteredBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.barsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredBarLayout = ClusteredBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, this.width, dataLabelSettings), false, false, this.xProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredBarLayout,
                        itemCS: ClusteredBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, { height: this.height, width: this.width });
                        }
                        else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            ClusteredBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /** Get the chart's columns centers (y value) */
            ClusteredBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset; });
                    }
                }
                return this.barsCenters;
            };
            ClusteredBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line').classed('interactive-hover-line', true).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y,
                    });
                    handle.append('circle').attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    }).classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            ClusteredBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledX0 = xScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return 0; },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                };
            };
            ClusteredBarChartStrategy.prototype.getLabelLayoutXY = function (axisOptions, visualWidth, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var xScaleOffset = 0;
                var scaledX0 = xScale(0);
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    x: function (d) {
                        var properties = {
                            text: d.labeltext,
                            fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var outsidePosition = scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                        // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                        if (outsidePosition + textWidth > visualWidth) {
                            // Inside position, if color didn't override, then the color is white
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) / 2 - (textWidth / 2);
                        }
                        return outsidePosition;
                    },
                    y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0) + halfColumnWidth + visuals.dataLabelUtils.defaultColumnHalfLabelHeight; },
                };
            };
            ClusteredBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
            };
            return ClusteredBarChartStrategy;
        })();
        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var StackedColumnChartStrategy = (function () {
            function StackedColumnChartStrategy() {
            }
            StackedColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
            };
            StackedColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax);
                props.xLabelMaxWidth = this.categoryLayout.isScalar ? (width / props.values.length) : this.categoryLayout.categoryThickness;
                return props;
            };
            StackedColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.viewportHeight;
                var yProps = this.yProps = visuals.StackedUtil.getValueAxis(this.data, is100Pct, height, [height, 0], forcedTickCount, forcedYDomain);
                return yProps;
            };
            StackedColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedColumnLayout = StackedColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, dataLabelSettings), true, this.graphicsContext.is100Pct, this.yProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: StackedColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, { height: this.height, width: this.width });
                        }
                        else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            StackedColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /** Get the chart's columns centers (x value) */
            StackedColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });
                    }
                }
                return this.columnsCenters;
            };
            StackedColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line').classed('interactive-hover-line', true).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle').attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    }).classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            StackedColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = columnWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d, i) { return columnWidth; },
                        x: function (d, i) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d, i) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                        height: function (d, i) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d, i) { return columnWidth; },
                        x: function (d, i) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d, i) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.originalPosition, 0); },
                        height: function (d, i) { return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute); }
                    },
                    zeroShapeLayout: {
                        width: function (d, i) { return columnWidth; },
                        x: function (d, i) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d, i) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute); },
                        height: function (d, i) { return 0; }
                    },
                };
            };
            StackedColumnChartStrategy.prototype.getLabelLayoutXY = function (axisOptions, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                var scaledY0 = yScale(0);
                var is100Pct = this.graphicsContext.is100Pct;
                var labelLayoutY = this.getLabelLayoutY;
                if (isScalar)
                    xScaleOffset = halfColumnWidth;
                return {
                    x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset + halfColumnWidth; },
                    y: function (d) { return labelLayoutY(d, is100Pct, scaledY0, yScale, labelSettings); }
                };
            };
            StackedColumnChartStrategy.prototype.getLabelLayoutY = function (d, is100Pct, scaledY0, yScale, labelSettings) {
                var insidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute) / 2 + visuals.dataLabelUtils.defaultColumnHalfLabelHeight;
                var outsidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                //Hundrand-percent label position is center by default, and labels on stacked bar that are not last series
                if (is100Pct || !d.lastSeries)
                    return insidePosition;
                // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                if (outsidePosition <= 0) {
                    // Inside position, if color didn't override, then the color is white
                    d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                    return insidePosition;
                }
                return outsidePosition;
            };
            StackedColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column'
                },
                highlightItem: {
                    class: 'highlightColumn',
                    selector: '.highlightColumn'
                },
            };
            return StackedColumnChartStrategy;
        })();
        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
        var StackedBarChartStrategy = (function () {
            function StackedBarChartStrategy() {
            }
            StackedBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
            };
            StackedBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax);
                return props;
            };
            StackedBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain) {
                debug.assert(forcedTickCount === undefined, 'Cannot have stacked bar chart as combo chart.');
                var height = this.viewportHeight;
                var xProps = this.xProps = visuals.StackedUtil.getValueAxis(this.data, is100Pct, this.width, [0, this.width], undefined, forcedXDomain);
                xProps.axis.tickSize(-height, 0);
                return xProps;
            };
            StackedBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.barsCenters = null; // invalidate the barsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedBarLayout = StackedBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, this.width, dataLabelSettings), false, this.graphicsContext.is100Pct, this.xProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedBarLayout,
                        itemCS: StackedBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, { height: this.height, width: this.width });
                        }
                        else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            StackedBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /** Get the chart's columns centers (y value) */
            StackedBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset; });
                    }
                }
                return this.barsCenters;
            };
            StackedBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line').classed('interactive-hover-line', true).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    });
                    handle.append('circle').classed('drag-handle', true).attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    });
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            StackedBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledX0 = xScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = columnWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d, i) { return -visuals.StackedUtil.getSize(xScale, d.valueAbsolute); },
                        x: function (d, i) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0); },
                        y: function (d, i) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        height: function (d, i) { return columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d, i) { return -visuals.StackedUtil.getSize(xScale, d.originalValueAbsolute); },
                        x: function (d, i) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition - d.originalValueAbsolute, 0); },
                        y: function (d, i) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        height: function (d, i) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d, i) { return 0; },
                        x: function (d, i) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0); },
                        y: function (d, i) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        height: function (d, i) { return columnWidth; },
                    },
                };
            };
            StackedBarChartStrategy.prototype.getLabelLayoutXY = function (axisOptions, visualWidth, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                var scaledX0 = xScale(0);
                var is100Pct = this.graphicsContext.is100Pct;
                if (isScalar)
                    xScaleOffset = halfColumnWidth;
                return {
                    x: function (d) {
                        var properties = {
                            text: d.labeltext,
                            fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var insidePosition = scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.StackedUtil.getSize(xScale, d.valueAbsolute) / 2 - (textWidth / 2);
                        var outsidePosition = scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                        //Hundrand-percent label position is center by default, and labels on stacked bar that are not last series
                        if (is100Pct || !d.lastSeries)
                            return insidePosition;
                        // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                        if (outsidePosition + textWidth > visualWidth) {
                            // Inside position, if color didn't override, then the color is white
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return insidePosition;
                        }
                        return outsidePosition;
                    },
                    y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset + halfColumnWidth + visuals.dataLabelUtils.defaultColumnHalfLabelHeight; },
                };
            };
            StackedBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
                highlightItem: {
                    class: 'highlightBar',
                    selector: '.highlightBar'
                },
            };
            return StackedBarChartStrategy;
        })();
        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** This module only supplies the capabilities for comboCharts.
         * Implementation is in cartesianChart and the various ICartesianVisual implementations.
         */
        var ComboChart;
        (function (ComboChart) {
            ComboChart.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: 0 /* Grouping */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Category'),
                    },
                    {
                        name: 'Series',
                        kind: 0 /* Grouping */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Series'),
                    },
                    {
                        name: 'Y',
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y'),
                    },
                    {
                        name: 'Y2',
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2'),
                    },
                ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                            visualType1: {
                                type: { text: true }
                            },
                            visualType2: {
                                type: { text: true }
                            },
                        },
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                type: { numeric: true }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                type: { numeric: true }
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                                type: { formatting: { axisType: true } }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { formatting: { axisStyle: true } }
                            }
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            secShow: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondery'),
                                type: { bool: true }
                            },
                            // TODO: 5005022 use property categories to organize Y & secondary Y properties.
                            axisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ColumnTitle'),
                                type: { none: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                type: { formatting: { yAxisPosition: true } }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                type: { numeric: true }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                type: { numeric: true }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { formatting: { axisStyle: true } }
                            },
                            secAxisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_LineTitle'),
                                type: { none: true }
                            },
                            secPosition: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                type: { formatting: { yAxisPosition: true } }
                            },
                            secStart: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                type: { numeric: true }
                            },
                            secEnd: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                type: { numeric: true }
                            },
                            secShowAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                type: { bool: true }
                            },
                            secAxisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { formatting: { axisStyle: true } }
                            }
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                type: { formatting: { legendPosition: true } }
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                type: { bool: true }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                                type: { text: true }
                            }
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                type: { bool: true }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                type: { formatting: { labelDisplayUnits: true } }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                type: { numeric: true }
                            },
                        },
                    },
                },
                dataViewMappings: [
                    {
                        conditions: [
                            { 'Category': { max: 1 }, 'Series': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { top: {} }
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [
                                        { for: { in: 'Y' } }
                                    ],
                                    dataReductionAlgorithm: { top: {} }
                                }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        }
                    },
                    {
                        conditions: [
                            { 'Category': { max: 1 }, 'Y2': { min: 1 } }
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { top: {} }
                            },
                            values: {
                                select: [
                                    { for: { in: 'Y2' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        },
                    }
                ],
                supportsHighlight: true,
                sorting: {
                    custom: {},
                },
            };
        })(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
        visuals.comboChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataColorPalette = (function () {
            /**
             * Creates a DataColorPalette using the given theme, or the default theme.
             */
            function DataColorPalette(colors) {
                /**
                * Colors used for sentiment visuals, e.g. KPI, Gauge. Since this is only a temporary implementation which will
                * eventually be superseded by conditional formatting, we don't declare them as part of the theme and instead
                * use a hardcoded color scheme here until conditional formatting is ready.
                */
                this.sentimentColors = [
                    { value: '#C0433A' },
                    { value: '#E8D62E' },
                    { value: '#79C75B' },
                ];
                // Hardcoded values for Color Picker.
                this.basePickerColors = [
                    { value: '#FFFFFF' },
                    { value: '#000000' },
                    { value: '#00B8AA' },
                    { value: '#374649' },
                    { value: '#FD625E' },
                    { value: '#F2C811' },
                    { value: '#5F6B6D' },
                    { value: '#8AD4EB' },
                    { value: '#FE9666' },
                    { value: '#A66999' }
                ];
                // TODO: Default theme is currently hardcoded. Theme should eventually come from PV and be added as a parameter in the ctor. 
                this.colors = colors || ThemeManager.getDefaultTheme();
                this.defaultColors = d3.scale.ordinal().range(this.colors);
                this.palettes = {};
            }
            DataColorPalette.prototype.getColor = function (key) {
                // For now though, just return colors in order.
                return this.defaultColors(key);
            };
            DataColorPalette.prototype.getColorByScale = function (scaleKey, key) {
                var colors = this.palettes[scaleKey];
                if (colors === undefined) {
                    colors = d3.scale.ordinal().range(this.colors);
                    this.palettes[scaleKey] = colors;
                }
                return colors(key);
            };
            DataColorPalette.prototype.getSentimentColors = function () {
                return this.sentimentColors;
            };
            DataColorPalette.prototype.getBasePickerColors = function () {
                return this.basePickerColors;
            };
            return DataColorPalette;
        })();
        visuals.DataColorPalette = DataColorPalette;
        // TODO: When theming support is added, this should be changed into a fully fledged service. For now though we will
        // declare the Theme code as a private implementation detail inside the DataColorPalette so that the code stays hidden
        // until it's ready for wider use.
        var ThemeManager = (function () {
            function ThemeManager() {
            }
            ThemeManager.getDefaultTheme = function () {
                if (!ThemeManager.defaultTheme) {
                    // Extend the list of available colors by cycling the base colors
                    ThemeManager.defaultTheme = [];
                    var baseColors = ThemeManager.defaultBaseColors;
                    for (var i = 0; i < ThemeManager.colorSectorCount; ++i) {
                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
                            ThemeManager.defaultTheme.push({
                                value: jsCommon.color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                            });
                        }
                    }
                }
                return ThemeManager.defaultTheme;
            };
            ThemeManager.colorSectorCount = 12;
            ThemeManager.defaultBaseColors = [
                { value: '#01B8AA' },
                { value: '#374649' },
                { value: '#FD625E' },
                { value: '#F2C80F' },
                { value: '#5F6B6D' },
                { value: '#8AD4EB' },
                { value: '#FE9666' },
                { value: '#A66999' },
                { value: '#3599B8' },
                { value: '#DFBFBF' },
                { value: '#4AC5BB' },
                { value: '#5F6B6D' },
                { value: '#FB8281' },
                { value: '#F4D25A' },
                { value: '#7F898A' },
                { value: '#A4DDEE' },
                { value: '#FDAB89' },
                { value: '#B687AC' },
                { value: '#28738A' },
                { value: '#A78F8F' },
                { value: '#168980' },
                { value: '#293537' },
                { value: '#BB4A4A' },
                { value: '#B59525' },
                { value: '#475052' },
                { value: '#6A9FB0' },
                { value: '#BD7150' },
                { value: '#7B4F71' },
                { value: '#1B4D5C' },
                { value: '#706060' },
                { value: '#0F5C55' },
                { value: '#1C2325' },
                { value: '#7D3231' },
                { value: '#796419' },
                { value: '#303637' },
                { value: '#476A75' },
                { value: '#7E4B36' },
                { value: '#52354C' },
                { value: '#0D262E' },
                { value: '#544848' },
            ];
            return ThemeManager;
        })();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
// IMPORTANT: This chart is not currently enabled in the PBI system and is under development.
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /* The data dot chart shows a set of circles with the data value inside them.
         * - The circles are regularly spaced similar to column charts.
         * - The radius of all dots is the same across the chart.
         * - This is most often combined with a column chart to create the 'chicken pox' chart.
         * - If any of the data values do not fit within the circles, then the data values are hidden
         *   and the y axis for the dots is displayed instead.
         * - This chart only supports a single series of data.
         * - This chart does not display a legend.
         */
        var DataDotChart = (function () {
            function DataDotChart() {
            }
            DataDotChart.prototype.init = function (options) {
                this.options = options;
                // Common properties
                this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsG = this.svg.append('g').classed('dataDotChartMainGraphicsContext', true);
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.cartesianVisualHost = options.cartesianHost;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                // Interactivity properties
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.interactivity = options.interactivity;
                var element = this.element = options.element;
                element.addClass(DataDotChart.ClassName);
                element.css('overflow', 'visible');
            };
            DataDotChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
                if (dataViews.length > 0) {
                    // I only handle a single data view
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical;
                        var dvCategories = dataViewCategorical.categories;
                        // I default to text unless there is a category type
                        var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                        if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                            categoryType = dvCategories[0].source.type;
                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null));
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.series.data);
                        }
                    }
                }
            };
            DataDotChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.data;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var series = data ? data.series : null;
                var seriesArray = series && series.data && series.data.length > 0 ? [series] : [];
                var categoryCount = series && series.data ? series.data.length : 0;
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                if (data.hasHighlights) {
                    categoryCount = categoryCount / 2;
                }
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (DataDotChart.hasDataPoint(series)) {
                    xMetaDataColumn = series.xCol;
                    yMetaDataColumn = series.yCol;
                }
                var layout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: false
                });
                var outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                // I clip data the won't fit
                this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount);
                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, true);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatStringProp: DataDotChart.formatStringProp,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true
                });
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                var xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, false, options.forcedXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatStringProp: DataDotChart.formatStringProp,
                    outerPadding: outerPadding,
                    isScalar: false,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    categoryThickness: layout.categoryThickness,
                    getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
                    isCategoryAxis: false
                });
                return [this.xAxisProperties, this.yAxisProperties];
            };
            DataDotChart.createClippedDataIfOverflowed = function (data, categoryCount) {
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, categoryCount * 2) : Math.min(data.series.data.length, categoryCount);
                if (requiredLength >= data.series.data.length) {
                    return data;
                }
                var clipped = powerbi.Prototype.inherit(data);
                clipped.series = powerbi.Prototype.inherit(data.series); // This prevents clipped and data from sharing the series object
                clipped.series.data = clipped.series.data.slice(0, requiredLength);
                return clipped;
            };
            DataDotChart.hasDataPoint = function (series) {
                return (series && series.data && series.data.length > 0);
            };
            DataDotChart.prototype.lookupXValue = function (index, type) {
                var data = this.clippedData;
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime)
                    return new Date(index);
                if (data && data.series) {
                    var seriesData = data.series.data;
                    if (seriesData) {
                        var dataAtIndex = seriesData[index];
                        if (dataAtIndex) {
                            return dataAtIndex.categoryValue;
                        }
                    }
                }
                return index;
            };
            DataDotChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            DataDotChart.prototype.render = function (duration) {
                var _this = this;
                var data = this.clippedData;
                var dataPoints = data.series.data;
                var hasHighlights = data.hasHighlights;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var dotRadius = dotWidth / 2;
                var dotColor = this.colors.getColor(DataDotChart.DotColorKey);
                var hasSelection = visuals.dataHasSelection(dataPoints);
                this.mainGraphicsContext.attr('width', width).attr('height', height);
                var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dots.enter().append('circle').classed(DataDotChart.DotClassName, true);
                dots.style({ 'fill': dotColor.value }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); }).classed('null-value', function (d) { return d.value === null; }).attr({
                    r: function (d) { return dotRadius; },
                    cx: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    cy: function (d) { return yScale(d.value); }
                });
                dots.exit().remove();
                var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dotLabels.enter().append('text').classed(DataDotChart.DotLabelClassName, true).attr({
                    'text-anchor': DataDotChart.DotLabelTextAnchor,
                    dy: DataDotChart.DotLabelVerticalOffset
                });
                dotLabels.classed('null-value', function (d) { return d.value === null; }).classed('overflowed', false).attr({
                    x: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    y: function (d) { return yScale(d.value); }
                }).text(function (d) { return _this.yAxisProperties.formatter.format(d.value); });
                var overflowed = false;
                dotLabels.each(function () {
                    // jQuery fails to properly inspect SVG class elements, the $('<div>') notation works around it.
                    if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                        var width = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                        if (width > dotWidth) {
                            dotLabels.classed('overflowed', true);
                            overflowed = true;
                        }
                    }
                });
                dotLabels.exit().remove();
                if (this.interactivityService) {
                    var behaviorOptions = {
                        dots: dots,
                        datapoints: dataPoints,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DataDotChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0
            };
            DataDotChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            DataDotChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data)
                    return null;
                var series = data.series;
                var seriesData = series.data;
                var legendDataPoints = [];
                var category;
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                // Category will be the same for all series. This is an optimization.
                if (data.series && data.series.data) {
                    var firstDataPoint = data.series.data[0];
                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                }
                // Create a legend data point for the specified column                
                if (series.yCol) {
                    var formatStringProp = DataDotChart.formatStringProp;
                    var lineDataPoint = seriesData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp);
                    var dotColor = this.colors.getColor(DataDotChart.DotColorKey);
                    var dataViewCategoricalValues = this.dataViewCategorical.values;
                    var identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ? dataViewCategoricalValues[columnIndex].identity : null;
                    legendDataPoints.push({
                        color: dotColor.value,
                        icon: 2 /* Line */,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: identity ? visuals.SelectionId.createWithId(identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            DataDotChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
                // cartesianChart handles calling render again.
            };
            DataDotChart.converter = function (dataView, blankCategoryValue) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: undefined,
                    values: [blankCategoryValue],
                    identity: undefined
                };
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                // I only handle a single series
                if (categorical.values) {
                    var measure = categorical.values[0];
                    var hasHighlights = !!measure.highlights;
                    var dataPoints = [];
                    for (var categoryIndex = 0, len = measure.values.length; categoryIndex < len; categoryIndex++) {
                        debug.assert(!category.identity || categoryIndex < category.identity.length, 'Category identities is smaller than category values.');
                        // I create the identity from the category.  If there is no category, then I use the measure name to create identity
                        var identity = category.identity ? visuals.SelectionId.createWithId(category.identity[categoryIndex]) : visuals.SelectionId.createWithMeasure(measure.source.queryName);
                        var categoryValue = categoryValues[categoryIndex];
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: measure.values[categoryIndex],
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlightValue = measure.highlights[categoryIndex];
                            dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: highlightValue,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: highlightIdentity,
                                highlight: true
                            });
                        }
                    }
                    return {
                        series: {
                            xCol: category.source,
                            yCol: measure.source,
                            data: dataPoints
                        },
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: true,
                    };
                }
                return {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
            };
            DataDotChart.prototype.accept = function (visitor, options) {
                debug.assertValue(visitor, 'visitor');
                visitor.visitDataDotChart(options);
            };
            DataDotChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            DataDotChart.ClassName = 'dataDotChart';
            DataDotChart.DotClassName = 'dot';
            DataDotChart.DotClassSelector = '.dot';
            DataDotChart.DotColorKey = 'dataDot';
            DataDotChart.DotLabelClassName = 'label';
            DataDotChart.DotLabelClassSelector = '.label';
            DataDotChart.DotLabelVerticalOffset = '0.4em';
            DataDotChart.DotLabelTextAnchor = 'middle';
            // I support a categorical (ordinal) X with measure Y for a single series
            DataDotChart.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: 0 /* Grouping */,
                    },
                    {
                        name: 'Y',
                        kind: 1 /* Measure */,
                    },
                ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                        },
                    },
                },
                dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{
                                for: { in: 'Y' },
                                dataReductionAlgorithm: { top: {} }
                            }]
                        },
                    },
                }]
            };
            return DataDotChart;
        })();
        visuals.DataDotChart = DataDotChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.donutChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                },
                {
                    name: 'Series',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            type: { numeric: true }
                        },
                    },
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                    },
                }
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [{ bind: { to: 'Y' } }],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                },
            }],
            sorting: {
                default: {},
            },
            supportsHighlight: true,
        };
        visuals.donutChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Renders a donut chart */
        var DonutChart = (function () {
            function DonutChart(options) {
                if (options) {
                    this.sliceWidthRatio = options.sliceWidthRatio;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                }
                if (this.sliceWidthRatio == null) {
                    this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio;
                }
            }
            DonutChart.converter = function (dataView, colors, suppressLabels) {
                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors);
                converter.convert();
                var d3PieLayout = d3.layout.pie().sort(null).value(function (d) {
                    return d.percentage;
                });
                var dataPoints = d3PieLayout(converter.dataPoints);
                var data = {
                    dataPointsToDeprecate: converter.dataPoints,
                    dataPoints: dataPoints,
                    unCulledDataPoints: dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue,
                };
                if (suppressLabels !== undefined)
                    data.suppressLabels = suppressLabels;
                return data;
            };
            DonutChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.parentViewport = options.viewport;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.formatter = visuals.valueFormatter.format;
                this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: { title: "", dataPoints: [] },
                    hasHighlights: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                };
                this.drilled = false;
                // Leaving this false for now, will depend on the datacategory in the future
                this.allowDrilldown = false;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.radius = 0;
                this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                var donutChartSettings = this.options.settings;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.hostService = options.host;
                if (this.isInteractive) {
                    this.chartRotationAnimationDuration = (donutChartSettings && donutChartSettings.chartRotationAnimationDuration) ? donutChartSettings.chartRotationAnimationDuration : 0;
                    // Create interactive legend
                    var legendContainer = this.legendContainer = d3.select(element.get(0)).append('div').classed(DonutChart.InteractiveLegendClassName, true);
                    this.interactivityState = {
                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options),
                        valueToAngleFactor: 0,
                        sliceAngles: [],
                        currentRotate: 0,
                        interactiveChosenSliceFinishedSetting: false,
                        lastChosenInteractiveSliceIndex: 0,
                        totalDragAngleDifference: 0,
                        currentIndexDrag: 0,
                        previousIndexDrag: 0,
                        previousDragAngle: 0,
                        donutCenter: { x: 0, y: 0 },
                    };
                }
                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute').classed(DonutChart.ClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.mainGraphicsContext = this.svg.append('g');
                this.mainGraphicsContext.append("g").classed('slices', true);
                this.mainGraphicsContext.append("g").classed('labels', true);
                this.mainGraphicsContext.append("g").classed('lines', true);
                this.pie = d3.layout.pie().sort(null).value(function (d) {
                    return d.percentage;
                });
            };
            DonutChart.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    this.data = DonutChart.converter(dataViews[0], this.colors);
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend))
                        this.renderLegend();
                    if (this.interactivityService)
                        this.interactivityService.applySelectionStateToData(this.data.dataPoints.map(function (d) { return d.data; }));
                }
                else {
                    this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: { title: "", dataPoints: [] },
                        hasHighlights: false,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                    };
                }
                this.initViewportDependantProperties();
                this.updateInternal(this.data, options.duration);
                this.hasSetData = true;
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (this.data.visibleGeometryCulled) {
                        var cullWarning = new visuals.SmallSlicesCulledWarning();
                        if (!warnings)
                            warnings = [cullWarning];
                        else
                            warnings.unshift(cullWarning);
                    }
                    if (warnings && warnings.length > 0)
                        this.hostService.setWarnings(warnings);
                }
            };
            DonutChart.prototype.onResizing = function (viewport, duration) {
                this.parentViewport = viewport;
                if (this.currentViewport && (this.currentViewport.height === viewport.height && this.currentViewport.width === viewport.width))
                    return;
                this.parentViewport = viewport;
                if (this.hasSetData)
                    this.renderLegend();
                this.initViewportDependantProperties(duration);
                this.updateInternal(this.data, duration);
                this.previousRadius = this.radius;
            };
            DonutChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'legend':
                        return this.enumerateLegend();
                    case 'dataPoint':
                        return this.enumerateDataPoints();
                    case 'labels':
                        if (this.data)
                            return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true);
                        else
                            return visuals.dataLabelUtils.enumerateDataLabels(visuals.dataLabelUtils.getDefaultDonutLabelSettings(), false, true, true);
                    case 'categoryLabels':
                        return (this.data) ? visuals.dataLabelUtils.enumerateCategoryLabels(this.data.dataLabelsSettings, false, true) : visuals.dataLabelUtils.enumerateCategoryLabels(null, false, true);
                }
            };
            DonutChart.prototype.enumerateDataPoints = function () {
                var data = this.data;
                if (!data)
                    return;
                var instances = [];
                var dataPoints = data.dataPointsToEnumerate;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dataPoint = dataPoints[i];
                    instances.push({
                        objectName: 'dataPoint',
                        displayName: dataPoint.label,
                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                        properties: {
                            fill: { solid: { color: dataPoint.color } }
                        },
                    });
                }
                return instances;
            };
            DonutChart.prototype.enumerateLegend = function () {
                var data = this.data;
                if (!data)
                    return;
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title);
                return [{
                    selector: null,
                    objectName: 'legend',
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText
                    }
                }];
            };
            DonutChart.prototype.setInteractiveChosenSlice = function (sliceIndex) {
                var _this = this;
                if (this.interactivityState.sliceAngles.length === 0)
                    return;
                this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex;
                this.interactivityState.interactiveChosenSliceFinishedSetting = false;
                var viewport = this.currentViewport;
                var moduledIndex = sliceIndex % this.data.dataPoints.length;
                var angle = this.interactivityState.sliceAngles[moduledIndex];
                this.svg.select('g').transition().duration(this.chartRotationAnimationDuration).ease('elastic').attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle)).each('end', function () {
                    _this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                });
                this.interactivityState.currentRotate = angle;
                this.interactivityState.interactiveLegend.updateLegend(moduledIndex);
                // Set the opacity of chosen slice to full and the others to semi-transparent
                this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                    return index === moduledIndex ? 1 : 0.6;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.calculateRadius = function () {
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    return Math.min(viewport.height, viewport.width) / 2;
                }
                else {
                    // use a sigmoid to blend the desired denominator from 2 to 3.
                    // if we are taller than we are wide, we need to use a larger denominator
                    var hw = viewport.height / viewport.width;
                    var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
            };
            DonutChart.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                this.currentViewport.height = this.parentViewport.height;
                this.currentViewport.width = this.parentViewport.width;
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    viewport.height -= DonutChart.InteractiveLegendContainerHeight; // leave space for the legend
                }
                else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height;
                    viewport.width -= legendMargins.width;
                }
                this.svg.attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                if (this.isInteractive) {
                    this.legendContainer.style({
                        'width': '100%',
                        'height': DonutChart.InteractiveLegendContainerHeight + 'px',
                        'overflow': 'hidden',
                        'top': 0
                    });
                    this.svg.style('top', DonutChart.InteractiveLegendContainerHeight);
                }
                this.previousRadius = this.radius;
                var radius = this.radius = this.calculateRadius();
                this.arc = d3.svg.arc();
                this.outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                if (this.isInteractive) {
                    this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(viewport.width / 2, viewport.height / 2));
                }
                else {
                    this.mainGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(viewport.width / 2, viewport.height / 2));
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.mergeDatasets = function (first, second) {
                var secondSet = d3.set();
                second.forEach(function (d) {
                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                });
                var onlyFirst = first.filter(function (d) {
                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                }).map(function (d) {
                    var derived = powerbi.Prototype.inherit(d);
                    derived.percentage === undefined ? derived.data.percentage = 0 : derived.percentage = 0;
                    return derived;
                });
                return d3.merge([second, onlyFirst]);
            };
            DonutChart.prototype.updateInternal = function (data, duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.currentViewport;
                this.data.dataPoints = DonutChart.cullDataByViewport(data, viewport);
                if (this.animator) {
                    var layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport);
                    var result;
                    var shapes;
                    var highlightShapes;
                    var animationOptions = {
                        viewModel: data,
                        colors: this.colors,
                        graphicsContext: this.mainGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        radius: this.radius,
                        sliceWidthRatio: this.sliceWidthRatio,
                        viewport: viewport,
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    if (result.failed) {
                        shapes = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius);
                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius);
                        DonutChart.drawDefaultCategoryLabels(this.svg, data, layout, this.sliceWidthRatio, this.radius, this.currentViewport);
                    }
                    this.assignInteractions(shapes, highlightShapes, data);
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                }
                else {
                    this.updateInternalToMove(data, duration);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.renderLegend = function () {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.parentViewport);
                }
                else {
                    this.legend.changeOrientation(0 /* Top */);
                    this.legend.drawLegend({ dataPoints: [] }, this.parentViewport);
                }
            };
            DonutChart.prototype.addInteractiveLegendArrow = function () {
                var arrowHeightOffset = 11;
                var arrowWidthOffset = 33 / 2;
                if (!this.interactiveLegendArrow) {
                    var interactiveLegendArrow = this.svg.append('g');
                    interactiveLegendArrow.append('path').classed(DonutChart.InteractiveLegendArrowClassName, true).attr('d', 'M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z');
                    this.interactiveLegendArrow = interactiveLegendArrow;
                }
                var viewport = this.currentViewport;
                // Calculate the offsets from the legend container to the arrow.
                var distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + arrowHeightOffset;
                var middleOfChart = viewport.width / 2 - arrowWidthOffset;
                this.interactiveLegendArrow.attr('transform', visuals.SVGUtil.translate(middleOfChart, distanceBetweenLegendAndArrow));
            };
            DonutChart.prototype.calculateSliceAngles = function () {
                var angles = [];
                var data = this.data.dataPoints;
                if (data.length === 0) {
                    this.interactivityState.valueToAngleFactor = 0;
                    this.interactivityState.sliceAngles = [];
                    return;
                }
                var sum = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    sum += data[i].data.percentage; // value is an absolute number
                }
                debug.assert(sum !== 0, 'sum of slices values cannot be zero');
                this.interactivityState.valueToAngleFactor = 360 / sum; // Calculate the ratio between 360 and the sum to know the angles to rotate by
                var currentAngle = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    currentAngle += relativeAngle;
                    angles.push((relativeAngle / 2) - currentAngle);
                }
                this.interactivityState.sliceAngles = angles;
            };
            DonutChart.prototype.assignInteractions = function (slices, highlightSlices, data) {
                // assign interactions according to chart interactivity type
                if (this.isInteractive) {
                    this.assignInteractiveChartInteractions(slices);
                }
                else if (this.interactivityService) {
                    var behaviorOptions = {
                        clearCatcher: this.clearCatcher,
                        datapoints: data.dataPoints.map(function (value) { return value.data; }),
                        slices: slices,
                        highlightSlices: highlightSlices,
                        allowDrilldown: this.allowDrilldown,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        svg: this.svg,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
            };
            DonutChart.prototype.setDrilldown = function (selection) {
                if (selection) {
                    var d3PieLayout = d3.layout.pie().sort(null).value(function (d) {
                        return d.percentage;
                    });
                    // Drill into the current selection.
                    var legendDataPoints = [{ label: selection.label, color: selection.color, icon: 0 /* Box */, identity: selection.identity, selected: selection.selected }];
                    var legendData = { title: "", dataPoints: legendDataPoints };
                    var drilledDataPoints = d3PieLayout(selection.internalDataPoints);
                    this.updateInternal({ dataPointsToDeprecate: selection.internalDataPoints, dataPoints: drilledDataPoints, unCulledDataPoints: drilledDataPoints, legendData: legendData, hasHighlights: false, dataLabelsSettings: this.data.dataLabelsSettings }, DonutChart.UpdateAnimationDuration);
                }
                else {
                    // Pop out of drill down to view the "outer" data.
                    this.updateInternal(this.data, DonutChart.UpdateAnimationDuration);
                }
            };
            DonutChart.prototype.assignInteractiveChartInteractions = function (slice) {
                var _this = this;
                var svg = this.svg;
                this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                var svgRect = svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = { x: svgRect.left + svgRect.width / 2, y: svgRect.top + svgRect.height / 2 }; // Center of the donut chart
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.currentRotate = 0;
                this.calculateSliceAngles();
                // Set the on click method for the slices so thsete pie chart will turn according to each slice's corresponding angle [the angle its on top]
                slice.on('click', function (d, clickedIndex) {
                    if (d3.event.defaultPrevented)
                        return; // click was suppressed, for example from drag event
                    _this.setInteractiveChosenSlice(clickedIndex);
                });
                // Set the drag events
                var drag = d3.behavior.drag().origin(Object).on('dragstart', function () { return _this.interactiveDragStart(); }).on('drag', function () { return _this.interactiveDragMove(); }).on('dragend', function () { return _this.interactiveDragEnd(); });
                svg.call(drag);
            };
            // purpose: getting the angle (in degrees) of the drag event coordinates.
            // The angle is calculated against the plane of the center of the donut (meaning, when the center of the donut is at (0,0) coordinates).
            DonutChart.prototype.getAngleFromDragEvent = function () {
                var interactivityState = this.interactivityState;
                // get pageX and pageY (coordinates of the drag event) according to event type
                var pageX, pageY;
                var sourceEvent = d3.event.sourceEvent;
                // check if that's a touch event or not
                if (sourceEvent.type.toLowerCase().indexOf('touch') !== -1) {
                    if (sourceEvent.touches.length !== 1)
                        return null; // in case there isn't a single touch - return null and do nothing.
                    // take the first, single, touch surface.
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX;
                    pageY = touch.pageY;
                }
                else {
                    pageX = sourceEvent.pageX;
                    pageY = sourceEvent.pageY;
                }
                // Adjust the coordinates, putting the donut center as the (0,0) coordinates
                var adjustedCoordinates = { x: pageX - interactivityState.donutCenter.x, y: -pageY + interactivityState.donutCenter.y };
                // Move to polar axis - take only the angle (theta), and convert to degrees
                var angleToThePlane = Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) * 180 / Math.PI;
                return angleToThePlane;
            };
            DonutChart.prototype.interactiveDragStart = function () {
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            };
            DonutChart.prototype.interactiveDragMove = function () {
                var data = this.data.dataPoints;
                var viewport = this.currentViewport;
                var interactivityState = this.interactivityState;
                if (interactivityState.interactiveChosenSliceFinishedSetting === true) {
                    // get current angle from the drag event
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle)
                        return; // if no angle was returned, do nothing
                    // compare it to the previous drag event angle
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff;
                    interactivityState.previousDragAngle = currentDragAngle;
                    // Rotate the chart by the difference in angles
                    interactivityState.currentRotate += angleDragDiff;
                    // Rotate the chart to the current rotate angle
                    this.svg.select('g').attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor;
                    var currentAngle = interactivityState.currentRotate <= 0 ? (interactivityState.currentRotate * -1) % 360 : (360 - (interactivityState.currentRotate % 360));
                    interactivityState.currentIndexDrag = 0;
                    //consider making this  ++interactivityState.currentIndexDrag ? then you don't need the if statement, the interactivityState.currentIndexDrag +1 and interactivityState.currentIndexDrag++
                    // Check the current index according to the angle 
                    var dataLength = data.length;
                    while ((interactivityState.currentIndexDrag < dataLength) && (currentAngle > currentHigherLimit)) {
                        if (interactivityState.currentIndexDrag < (dataLength - 1)) {
                            currentHigherLimit += (data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor);
                        }
                        interactivityState.currentIndexDrag++;
                    }
                    // If the index changed update the legend and opacity
                    if (interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag) {
                        interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag);
                        // set the opacticity of the top slice to full and the others to semi-transparent
                        this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                        });
                        interactivityState.previousIndexDrag = interactivityState.currentIndexDrag;
                    }
                }
            };
            DonutChart.prototype.interactiveDragEnd = function () {
                // If totalDragDifference was changed, means we have a drag event (compared to a click event)
                if (this.interactivityState.totalDragAngleDifference !== 0) {
                    this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag);
                    // drag happened - disable click event
                    d3.event.sourceEvent.stopPropagation();
                }
            };
            DonutChart.prototype.addSliceLabels = function (data, was, is, duration) {
                if (duration === void 0) { duration = 0; }
                var svg = this.svg;
                var d3PieLayout = d3.layout.pie().sort(null).value(function (d) {
                    return d.percentage;
                });
                var key = this.key;
                var arc = this.arc;
                var outerArc = this.outerArc;
                var radius = this.radius;
                var formatter = this.formatter;
                var viewport = this.currentViewport;
                var sliceWidthRatio = this.sliceWidthRatio;
                /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the donut/pie. */
                var innerLinePointMultiplier = sliceWidthRatio ? 2.05 / (2 * (sliceWidthRatio + (1 - sliceWidthRatio) / 2)) : 2.05;
                var text = svg.select('.labels').selectAll('text').data(d3PieLayout(was), key);
                var ellipsisService = powerbi.TextMeasurementService.svgEllipsis;
                var spaceAvaliableForLabels = viewport.width / 2 - radius;
                var previousPosition;
                var previousTextAnchor;
                var fontSize = viewport.height < DonutChart.FontsizeThreshold ? DonutChart.SmallFontSize : DonutChart.NormalFontSize;
                text.enter().append('text').attr('dy', '.35em').style('opacity', 0).each(function (d) {
                    this._current = d;
                });
                text = svg.select('.labels').selectAll('text').data(d3PieLayout(is), key);
                text.text(function (d) { return formatter(d.data.label); }).style('font-size', fontSize).each(function (d) {
                    var text = d3.select(this);
                    ellipsisService(text[0][0], spaceAvaliableForLabels);
                }).transition().duration(duration).attrTween('transform', function (d) {
                    var _this = this;
                    var interpolate = d3.interpolate(this._current, d);
                    return function (t) {
                        var d2 = interpolate(t);
                        _this._current = d2;
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (DonutChart.midAngle(d2) < Math.PI ? 1 : -1);
                        return 'translate(' + pos + ')';
                    };
                }).styleTween('text-anchor', function (d) {
                    var interpolate = d3.interpolate(this._current, d);
                    return function (t) {
                        var d2 = interpolate(t);
                        return DonutChart.midAngle(d2) < Math.PI ? 'start' : 'end';
                    };
                }).each('end', function (d) {
                    var opacity = 1;
                    var text = d3.select(this);
                    var transform = visuals.SVGUtil.parseTranslateTransform(text.attr('transform'));
                    var currentPosition = parseFloat(transform.y);
                    var currentTextAnchor = text.style('text-anchor');
                    d.data.isLabelOverlapping = false;
                    // Checking if the positions of slices being compared are on the same side or opposite sides of pie
                    // If they lie on opposide sides, we don't have to check for overlap and should show the labels
                    if (currentTextAnchor === previousTextAnchor) {
                        var deltaY = currentPosition - previousPosition;
                        if (Math.abs(deltaY) < parseInt(fontSize, 10)) {
                            opacity = 0;
                            d.data.isLabelOverlapping = true;
                        }
                    }
                    // Set the previous position to current only if the current slice text opacity is 1 
                    // else previous position would be the last slice position with opacity 1
                    if (opacity === 1)
                        previousPosition = currentPosition;
                    previousTextAnchor = currentTextAnchor;
                    text.style('opacity', opacity);
                });
                text = svg.select('.labels').selectAll('text').data(data, key);
                text.exit().transition().delay(duration).remove();
                var polyline = svg.select('.lines').selectAll('polyline').data(d3PieLayout(was), key);
                polyline.enter().append('polyline').style('opacity', 0).each(function (d) {
                    this._current = d;
                });
                polyline = svg.select('.lines').selectAll('polyline').data(d3PieLayout(is), key);
                polyline.transition().duration(duration).attrTween('points', function (d) {
                    var _this = this;
                    this._current = this._current;
                    var interpolate = d3.interpolate(this._current, d);
                    return function (t) {
                        var d2 = interpolate(t);
                        _this._current = d2;
                        var textPoint = outerArc.centroid(d2);
                        textPoint[0] = radius * 0.95 * (DonutChart.midAngle(d2) < Math.PI ? 1 : -1);
                        var midPoint = outerArc.centroid(d2);
                        var chartPoint = arc.centroid(d2);
                        chartPoint[0] *= innerLinePointMultiplier;
                        chartPoint[1] *= innerLinePointMultiplier;
                        return [chartPoint, midPoint, textPoint];
                    };
                }).each('end', function () {
                    polyline.style('opacity', function (d) { return d.data.isLabelOverlapping ? 0 : DonutChart.PolylineOpacity; });
                });
                polyline = svg.select('.lines').selectAll('polyline').data(data, key);
                polyline.exit().transition().delay(duration).remove();
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.midAngle = function (d) {
                return d.startAngle + (d.endAngle - d.startAngle) / 2;
            };
            DonutChart.prototype.accept = function (visitor, options) {
                visitor.visitDonutChart(options);
            };
            DonutChart.prototype.updateInternalToMove = function (data, duration) {
                if (duration === void 0) { duration = 0; }
                // Cache for performance
                var svg = this.svg;
                var pie = this.pie;
                var key = this.key;
                var arc = this.arc;
                var radius = this.radius;
                var previousRadius = this.previousRadius;
                var sliceWidthRatio = this.sliceWidthRatio;
                var existingData = this.svg.select('.slices').selectAll('path' + DonutChart.sliceClass.selector).data().map(function (d) { return d.data; });
                if (existingData.length === 0) {
                    existingData = data.dataPointsToDeprecate;
                }
                var was = this.mergeDatasets(data.dataPointsToDeprecate, existingData);
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate);
                var slice = svg.select('.slices').selectAll('path' + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.enter().insert('path').classed(DonutChart.sliceClass.class, true).each(function (d) {
                    this._current = d;
                });
                slice = svg.select('.slices').selectAll('path' + DonutChart.sliceClass.selector).data(pie(is), key);
                var innerRadius = radius * sliceWidthRatio;
                slice.style('fill', function (d) { return d.data.color; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, data.hasHighlights); }).style('stroke', 'white').transition().duration(duration).attrTween('d', function (d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                    this._current = i(0);
                    return function (t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                });
                slice = svg.select('.slices').selectAll('path' + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.exit().transition().delay(duration).duration(0).remove();
                // For interactive chart, there shouldn't be slice labels (as you have the legend).
                if (!this.isInteractive)
                    this.addSliceLabels(pie(data.dataPointsToDeprecate), was, is, duration);
                if (data.hasHighlights) {
                    // Draw partial highlight slices.
                    var highlightSlices = svg.select('.slices').selectAll('path' + DonutChart.sliceHighlightClass.selector).data(pie(data.dataPointsToDeprecate), key);
                    highlightSlices.enter().insert('path').classed(DonutChart.sliceHighlightClass.class, true).each(function (d) {
                        this._current = d;
                    });
                    highlightSlices.style('fill', function (d) { return d.data.color; }).style('fill-opacity', 1.0).style('stroke', 'white').transition().duration(duration).attrTween('d', function (d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                        this._current = i(0);
                        return function (t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    });
                    highlightSlices.exit().transition().delay(duration).duration(0).remove();
                }
                else {
                    svg.selectAll('path' + DonutChart.sliceHighlightClass.selector).transition().delay(duration).duration(0).remove();
                }
                this.assignInteractions(slice, highlightSlices, data);
                visuals.TooltipManager.addTooltip(slice, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                if (data.hasHighlights) {
                    visuals.TooltipManager.addTooltip(highlightSlices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                if (this.isInteractive) {
                    this.addInteractiveLegendArrow();
                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate);
                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0);
                }
            };
            DonutChart.drawDefaultShapes = function (graphicsContext, donutData, layout, colors, radius, defaultColor) {
                var hasSelection = visuals.dataHasSelection(donutData.dataPoints.map(function (d) { return d.data; }));
                var shapes = graphicsContext.select('.slices').selectAll('path' + DonutChart.sliceClass.selector).data(donutData.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter().insert('path').classed(DonutChart.sliceClass.class, true);
                shapes.style('fill', function (d) { return d.data.color; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, donutData.hasHighlights); }).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            DonutChart.drawDefaultHighlightShapes = function (graphicsContext, donutData, layout, colors, radius) {
                var shapes = graphicsContext.select('.slices').selectAll('path' + DonutChart.sliceHighlightClass.selector).data(donutData.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                shapes.enter().insert('path').classed(DonutChart.sliceHighlightClass.class, true).each(function (d) {
                    this._current = d;
                });
                shapes.style('fill', function (d) { return d.data.color; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, donutData.hasHighlights); }).style('stroke', 'white').attr(layout.highlightShapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            DonutChart.drawDefaultCategoryLabels = function (graphicsContext, donutData, layout, sliceWidthRatio, radius, viewport) {
                /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the donut/pie. */
                var arc = d3.svg.arc().innerRadius(0).outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                var outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                var dataPointsWithLabels = donutData.suppressLabels || (!donutData.dataLabelsSettings.show && !donutData.dataLabelsSettings.showCategory) ? [] : _.filter(donutData.dataPoints, function (d) { return d.data.label != null && !d.data.isLabelOverlapping; });
                DonutChart.drawDefaultCategoryLabelText(graphicsContext, dataPointsWithLabels, layout, radius, viewport, outerArc);
                DonutChart.drawDefaultCategoryLabelLines(graphicsContext, dataPointsWithLabels, radius, sliceWidthRatio, arc, outerArc);
            };
            DonutChart.drawDefaultCategoryLabelText = function (graphicsContext, donutDataPoints, layout, radius, viewport, outerArc) {
                var formatter = visuals.valueFormatter.format;
                var text = graphicsContext.select('.labels').selectAll('text').data(donutDataPoints, function (d) { return d.data.identity.getKey(); });
                var spaceAvaliableForLabels = viewport.width / 2 - radius;
                text.enter().append('text').attr('dy', '.35em').each(function (d) {
                    this._current = d;
                });
                text.text(function (d) { return formatter(d.data.label); }).style({
                    'font-size': layout.fontSize,
                    'text-anchor': function (d) { return DonutChart.midAngle(d) < Math.PI ? 'start' : 'end'; },
                    'fill': function (d) { return d.data.labelColor; },
                    'opacity': 1,
                }).each(function (d) {
                    var text = d3.select(this);
                    text[0][0].textContent = visuals.dataLabelUtils.getLabelFormattedText(text[0][0].textContent, spaceAvaliableForLabels);
                }).attr('transform', function (d) {
                    this._current = d;
                    var pos = outerArc.centroid(d);
                    pos[0] = radius * (DonutChart.midAngle(d) < Math.PI ? 1 : -1);
                    return 'translate(' + pos + ')';
                }).each(layout.categoryLabelTextOverlap);
                text.exit().remove();
                return text;
            };
            DonutChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            DonutChart.drawDefaultCategoryLabelLines = function (graphicsContext, donutDataPoints, radius, sliceWidthRatio, arc, outerArc) {
                var lines = graphicsContext.select('.lines').selectAll('polyline').data(donutDataPoints, function (d) { return d.data.identity.getKey(); });
                var innerLinePointMultiplier = 2.05;
                lines.enter().append('polyline').each(function (d) {
                    this._current = d;
                });
                lines.attr('points', function (d) {
                    var textPoint = outerArc.centroid(d);
                    textPoint[0] = radius * 0.95 * (DonutChart.midAngle(d) < Math.PI ? 1 : -1);
                    var midPoint = outerArc.centroid(d);
                    var chartPoint = arc.centroid(d);
                    chartPoint[0] *= innerLinePointMultiplier;
                    chartPoint[1] *= innerLinePointMultiplier;
                    return [chartPoint, midPoint, textPoint];
                }).style({
                    'opacity': function (d) { return d.data.isLabelOverlapping ? 0 : DonutChart.PolylineOpacity; },
                    'stroke': function (d) { return d.data.labelColor; },
                });
                lines.exit().remove();
                return lines;
            };
            DonutChart.getLayout = function (radius, sliceWidthRatio, viewport) {
                var innerRadius = radius * sliceWidthRatio;
                var arc = d3.svg.arc().innerRadius(innerRadius);
                var arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                var previousPosition;
                var previousTextAnchor;
                var fontSize = viewport.height < DonutChart.FontsizeThreshold ? DonutChart.SmallFontSize : DonutChart.NormalFontSize;
                return {
                    fontSize: fontSize,
                    shapeLayout: {
                        d: function (d) {
                            return arcWithRadius(d);
                        }
                    },
                    highlightShapeLayout: {
                        d: function (d) {
                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                            return highlightArc(d);
                        }
                    },
                    zeroShapeLayout: {
                        d: function (d) {
                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                            return zeroWithZeroRadius(d);
                        }
                    },
                    categoryLabelTextOverlap: function (d) {
                        var opacity = 1;
                        var text = d3.select(this);
                        var transform = visuals.SVGUtil.parseTranslateTransform(text.attr('transform'));
                        var currentPosition = parseFloat(transform.y);
                        var currentTextAnchor = text.style('text-anchor');
                        d.data.isLabelOverlapping = false;
                        // Checking if the positions of slices being compared are on the same side or opposite sides of pie
                        // If they lie on opposide sides, we don't have to check for overlap and should show the labels
                        if (currentTextAnchor === previousTextAnchor) {
                            var deltaY = currentPosition - previousPosition;
                            if (Math.abs(deltaY) < parseInt(fontSize, 10)) {
                                opacity = 0;
                                d.data.isLabelOverlapping = true;
                            }
                        }
                        // Set the previous position to current only if the current slice text opacity is 1 
                        // else previous position would be the last slice position with opacity 1
                        if (opacity === 1)
                            previousPosition = currentPosition;
                        else
                            text.style('opacity', opacity);
                        previousTextAnchor = currentTextAnchor;
                    }
                };
            };
            DonutChart.getHighlightRadius = function (radius, sliceWidthRatio, highlightRatio) {
                var innerRadius = radius * sliceWidthRatio;
                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
            };
            DonutChart.cullDataByViewport = function (data, viewport) {
                var dataPoints = data.unCulledDataPoints;
                var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
                var invisibleAngle = this.invisibleArcLengthInPixels / estimatedRadius; // Angle at which slices would be invisible
                var minimumAngle = this.minimumArcLengthInPixels / estimatedRadius; // Angle at which slices will be small enough to cull
                var minimumValueCutoff = data.maxValue * 0.01; // Value must be less than this to cull
                var culledDataPoints = [];
                var visibleGeometryCulled = false;
                for (var i = 0, ilen = dataPoints.length; i < ilen; i++) {
                    var dataPoint = dataPoints[i];
                    var angleDelta = Math.abs(dataPoint.endAngle - dataPoint.startAngle);
                    if (angleDelta >= invisibleAngle) {
                        if (angleDelta >= minimumAngle || dataPoint.value > minimumValueCutoff) {
                            culledDataPoints.push(dataPoint);
                        }
                        else {
                            visibleGeometryCulled = true;
                        }
                    }
                }
                data.visibleGeometryCulled = visibleGeometryCulled;
                return culledDataPoints;
            };
            DonutChart.ClassName = 'donutChart';
            DonutChart.InteractiveLegendClassName = 'donutLegend';
            DonutChart.InteractiveLegendArrowClassName = 'donutLegendArrow';
            DonutChart.UpdateAnimationDuration = 1000;
            DonutChart.OuterArcRadiusRatio = 0.9;
            DonutChart.InnerArcRadiusRatio = 0.8;
            DonutChart.FontsizeThreshold = 150;
            DonutChart.SmallFontSize = '8px';
            DonutChart.NormalFontSize = '11px';
            DonutChart.InteractiveLegendContainerHeight = 70;
            DonutChart.OpaqueOpacity = 1.0;
            DonutChart.SemiTransparentOpacity = 0.6;
            DonutChart.defaultSliceWidthRatio = 0.48;
            DonutChart.invisibleArcLengthInPixels = 2;
            DonutChart.minimumArcLengthInPixels = 4;
            DonutChart.sliceClass = {
                class: 'slice',
                selector: '.slice',
            };
            DonutChart.sliceHighlightClass = {
                class: 'slice-highlight',
                selector: '.slice-highlight',
            };
            DonutChart.EffectiveZeroValue = 0.000000001; // Very small multiplier so that we have a properly shaped zero arc to animate to/from.
            DonutChart.PolylineOpacity = 0.5;
            return DonutChart;
        })();
        visuals.DonutChart = DonutChart;
        /**
        * This class is an interactive legend for the Donut Chart.
        * Features:
        *   it is scrollable indefinitely, using drag gesture
        *   when you interact with it, it updates the donut chart itself
        */
        var DonutChartInteractiveLegend = (function () {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions) {
                this.legendContainerParent = legendContainer;
                this.colors = colors;
                this.donutChart = donutChart;
                this.visualInitOptions = visualInitOptions;
                this.legendItemsPositions = [];
                var donutChartSettings = visualInitOptions.settings;
                this.legendTransitionAnimationDuration = donutChartSettings && donutChartSettings.legendTransitionAnimationDuration ? donutChartSettings.legendTransitionAnimationDuration : 0;
            }
            DonutChartInteractiveLegend.prototype.drawLegend = function (data) {
                var _this = this;
                this.data = data;
                this.currentNumberOfLegendItems = data.length;
                this.currentIndex = 0;
                this.leftMostIndex = 0;
                this.rightMostIndex = data.length - 1;
                if (this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty()) {
                    this.legendContainer = this.legendContainerParent.append('div').classed(DonutChartInteractiveLegend.LegendContainerClassName, true);
                }
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data);
                var legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width;
                var initialXOffset = legendContainerWidth / 2 - (legendContainerWidth * 0.4 / 2) + DonutChartInteractiveLegend.ItemMargin;
                var currX = initialXOffset;
                this.currentXOffset = initialXOffset;
                /* Given the legend item div, create the item values (category, percentage and measure) on top of it.
                 */
                var createLegendItem = function (itemDiv, datum) {
                    // position the legend item
                    itemDiv.attr('data-legend-index', datum.index).css({
                        'position': 'absolute',
                        'left': currX,
                    });
                    // Add the category, percentage and value
                    var itemCategory = visuals.valueFormatter.format(datum.label);
                    var itemValue = visuals.valueFormatter.format(datum.measure, datum.measureFormat);
                    var itemPercentage = visuals.valueFormatter.format(datum.percentage, '0.00 %;-0.00 %;0.00 %');
                    var itemColor = datum.color;
                    // Create basic spans for width calculations
                    var itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11);
                    var itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11);
                    var itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20);
                    // Calculate Legend Box size according to widths and set the width accordingly
                    var valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan);
                    var categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan);
                    var precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan);
                    var currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                    itemDiv.css('width', currentLegendBoxWidth);
                    // Calculate margins so that all the spans will be placed in the middle
                    var getLeftValue = function (spanWidth) {
                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                    };
                    var marginLeftValue = getLeftValue(valueSpanWidth);
                    var marginLeftCategory = getLeftValue(categorySpanWidth);
                    var marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                    // Create the actual spans with the right styling and margins so it will be center aligned and add them
                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css('color', itemColor);
                    itemDiv.append(itemCategorySpan);
                    itemDiv.append(itemPercentageSpan);
                    itemDiv.append(itemValueSpan);
                    _this.legendItemsPositions.push({
                        startX: currX,
                        boxWidth: currentLegendBoxWidth,
                    });
                    currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                };
                // Create the Legend Items
                legendItems.enter().insert('div').classed(DonutChartInteractiveLegend.LegendItemClassName, true).each(function (d) {
                    createLegendItem($(this), d);
                });
                legendItems.exit().remove();
                // Assign interactions on the legend
                this.assignInteractions();
            };
            DonutChartInteractiveLegend.prototype.updateLegend = function (sliceIndex) {
                var _this = this;
                if (this.currentNumberOfLegendItems <= 1)
                    return; // If the number of labels is one no updates are needed
                var legendContainerWidth = this.legendContainerWidth;
                this.currentIndex = sliceIndex;
                // "rearrange" legend items if needed, so we would have contnious endless scrolling
                this.updateLabelBlocks(sliceIndex);
                var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration;
                // Transform the legend so that the selected slice would be in the middle
                var nextXOffset = (this.legendItemsPositions[sliceIndex].startX + (this.legendItemsPositions[sliceIndex].boxWidth / 2) - (legendContainerWidth / 2)) * (-1);
                this.legendContainer.transition().styleTween('-webkit-transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                }).styleTween('transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                }).duration(legendTransitionAnimationDuration).ease('bounce').each('end', function () {
                    _this.currentXOffset = nextXOffset;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
            };
            DonutChartInteractiveLegend.prototype.assignInteractions = function () {
                var _this = this;
                var currentDX = 0; // keep how much drag had happened
                var hasChanged = false; // flag to indicate if we changed the "center" value in the legend. We only change it once per swipe.
                var dragStart = function () {
                    currentDX = 0; // start of drag gesture
                    hasChanged = false;
                };
                var dragMove = function () {
                    currentDX += d3.event.dx;
                    // Detect if swipe occured and if the index already changed in this drag
                    if (hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)
                        return;
                    var dragDirectionLeft = (currentDX < 0);
                    _this.dragLegend(dragDirectionLeft);
                    hasChanged = true;
                };
                var drag = d3.behavior.drag().origin(Object).on('drag', dragMove).on('dragstart', dragStart);
                this.legendContainer.call(drag);
            };
            DonutChartInteractiveLegend.prototype.dragLegend = function (dragDirectionLeft) {
                if (this.currentNumberOfLegendItems > (DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1)) {
                    this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft);
                }
                else {
                    if (this.shouldChangeIndexInNonCycling(dragDirectionLeft)) {
                        if (dragDirectionLeft) {
                            this.currentIndex++;
                        }
                        else {
                            this.currentIndex--;
                        }
                    }
                }
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            };
            DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function (dragDirectionLeft) {
                if ((this.currentIndex === 0 && !dragDirectionLeft) || (this.currentIndex === (this.currentNumberOfLegendItems - 1) && dragDirectionLeft)) {
                    return false;
                }
                return true;
            };
            DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function (dragDirectionLeft) {
                var dataLen = this.data.length;
                var delta = dragDirectionLeft ? 1 : -1;
                var newIndex = (this.currentIndex + delta) % (dataLen || 1); // modolu of negative number stays negative on javascript
                return (newIndex < 0) ? newIndex + dataLen : newIndex;
            };
            DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function (rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer[0]);
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']');
                    smallestItem.remove().insertAfter(legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.leftMostIndex].startX = newX;
                    smallestItem.css('left', newX);
                    this.rightMostIndex = this.leftMostIndex;
                    this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                }
                else {
                    var highestItem = legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']');
                    highestItem.remove().insertBefore(legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.rightMostIndex].startX = newX;
                    highestItem.css('left', newX);
                    this.leftMostIndex = this.rightMostIndex;
                    this.rightMostIndex = (this.rightMostIndex - 1) === -1 ? (this.legendItemsPositions.length - 1) : (this.rightMostIndex - 1);
                }
                if ((numberOfLegendItemsBlocksToShift - 1) !== 0) {
                    this.updateLegendItemsBlocks(rightSidedShift, (numberOfLegendItemsBlocksToShift - 1));
                }
            };
            // Update the legend items, allowing for endless rotation
            DonutChartInteractiveLegend.prototype.updateLabelBlocks = function (index) {
                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                    // The idea of the four if's is to keep two labels before and after the current one so it will fill the screen.
                    // If the index of the slice is the highest currently availble add 2 labels "ahead" of it
                    if (this.rightMostIndex === index)
                        this.updateLegendItemsBlocks(true, 2);
                    // If the index of the slice is the lowest currently availble add 2 labels "before" it
                    if (this.leftMostIndex === index)
                        this.updateLegendItemsBlocks(false, 2);
                    // If the index of the slice is the second highest currently availble add a labels "ahead" of it
                    if (this.rightMostIndex === (index + 1) || ((this.rightMostIndex === 0) && (index === (this.currentNumberOfLegendItems - 1))))
                        this.updateLegendItemsBlocks(true, 1);
                    // If the index of the slice is the second lowest currently availble add a labels "before" it
                    if (this.leftMostIndex === (index - 1) || ((this.leftMostIndex === (this.currentNumberOfLegendItems - 1) && (index === 0))))
                        this.updateLegendItemsBlocks(false, 1);
                }
                else {
                    if (this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                        // If the index of the slice is the highest currently availble add a label "ahead" of it
                        if (this.rightMostIndex === index)
                            this.updateLegendItemsBlocks(true, 1);
                        // If the index of the slice is the lowest currently availble add a label "before" it
                        if (this.leftMostIndex === index)
                            this.updateLegendItemsBlocks(false, 1);
                    }
                }
            };
            DonutChartInteractiveLegend.createBasicLegendItemSpan = function (spanClass, text, fontSize) {
                return $('<span/>').addClass(spanClass).css({
                    'white-space': 'nowrap',
                    'font-size': fontSize + 'px',
                }).text(text);
            };
            // this method alters the given span and sets it to the final legen item span style
            DonutChartInteractiveLegend.createLegendItemSpan = function (existingSpan, marginLeft) {
                existingSpan.css({
                    'overflow': 'hidden',
                    'text-overflow': 'ellipsis',
                    'display': 'inline-block',
                    'width': '100%',
                    'margin-left': marginLeft
                });
                return existingSpan;
            };
            // caclulte entire legend box size according to its building spans
            DonutChartInteractiveLegend.legendBoxSize = function (valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth;
                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : (boxSize + 2);
                return boxSize;
            };
            DonutChartInteractiveLegend.spanWidth = function (span) {
                if (!this.FakeElementSpan) {
                    this.FakeElementSpan = $('<span>').hide().appendTo(document.body);
                }
                this.FakeElementSpan.empty();
                this.FakeElementSpan.append(span);
                return this.FakeElementSpan.width();
            };
            DonutChartInteractiveLegend.LegendContainerClassName = 'legend-container';
            DonutChartInteractiveLegend.LegendContainerSelector = '.legend-container';
            DonutChartInteractiveLegend.LegendItemClassName = 'legend-item';
            DonutChartInteractiveLegend.LegendItemSelector = '.legend-item';
            DonutChartInteractiveLegend.LegendItemCategoryClassName = 'category';
            DonutChartInteractiveLegend.LegendItemPercentageClassName = 'percentage';
            DonutChartInteractiveLegend.LegendItemValueClassName = 'value';
            DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160;
            DonutChartInteractiveLegend.ItemMargin = 30; // Margin between items
            DonutChartInteractiveLegend.MinimumSwipeDX = 15; // Minimup swipe gesture to create a change in the legend
            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3; // Minimum items in the legend before we cycle it
            return DonutChartInteractiveLegend;
        })();
        var DonutChartConversion;
        (function (DonutChartConversion) {
            ;
            var DonutChartConverter = (function () {
                function DonutChartConverter(dataView, colors) {
                    var dataViewCategorical = dataView.categorical;
                    this.dataViewCategorical = dataViewCategorical;
                    this.dataViewMetadata = dataView.metadata;
                    this.seriesCount = dataViewCategorical.values ? dataViewCategorical.values.length : 0;
                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill);
                    this.maxValue = 0;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var category = dataViewCategorical.categories[0];
                        this.categoryIdentities = category.identity;
                        this.categoryValues = category.values;
                        this.allCategoryObjects = category.objects;
                        this.categoryColumnRef = category.identityFields;
                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                    }
                    var grouped = this.grouped = dataViewCategorical && dataViewCategorical.values ? dataViewCategorical.values.grouped() : undefined;
                    this.isMultiMeasure = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    this.isSingleMeasure = grouped && grouped.length === 1 && grouped[0].values && grouped[0].values.length === 1;
                    this.hasHighlights = this.seriesCount > 0 && !!dataViewCategorical.values[0].highlights;
                    this.highlightsOverflow = false;
                    this.total = 0;
                    this.highlightTotal = 0;
                    this.dataPoints = [];
                    this.legendDataPoints = [];
                    this.dataLabelsSettings = null;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        for (var measureIndex = 0; measureIndex < seriesData.values.length; measureIndex++) {
                            this.total += Math.abs(seriesData.values[measureIndex]);
                            this.highlightTotal += this.hasHighlights ? Math.abs(seriesData.highlights[measureIndex]) : 0;
                        }
                    }
                }
                DonutChartConverter.prototype.convert = function () {
                    var convertedData;
                    if (this.total !== 0) {
                        // If category exists, we render labels using category values. If not, we render labels
                        // using measure labels.
                        if (this.categoryValues) {
                            convertedData = this.convertCategoricalWithSlicing();
                        }
                        else {
                            if (this.isSingleMeasure || this.isMultiMeasure) {
                                // Either single- or multi-measure (no category or series)
                                convertedData = this.convertMeasures();
                            }
                            else {
                                // Series but no category.
                                convertedData = this.convertSeries();
                            }
                        }
                    }
                    else {
                        convertedData = [];
                    }
                    // Check if any of the highlight values are > non-highlight values
                    var highlightsOverflow = false;
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount && !highlightsOverflow; i++) {
                        var point = convertedData[i];
                        if (Math.abs(point.highlight.measure) > Math.abs(point.nonHighlight.measure)) {
                            highlightsOverflow = true;
                        }
                    }
                    // Create data labels settings
                    this.dataLabelsSettings = this.convertDataLableSettings();
                    var dataViewMetadata = this.dataViewMetadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            this.legendObjectProperties = objects['legend'];
                        }
                    }
                    this.dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var formatter = visuals.valueFormatter.create(visuals.dataLabelUtils.getLabelFormatterOptions(this.dataLabelsSettings));
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
                        var point = convertedData[i];
                        var measure = point.nonHighlight.measure;
                        var percentage = (this.total > 0) ? point.nonHighlight.value / this.total : 0.0;
                        var highlightRatio = 0;
                        if (point.nonHighlight.value > this.maxValue)
                            this.maxValue = point.nonHighlight.value;
                        if (point.highlight.value > this.maxValue)
                            this.maxValue = point.nonHighlight.value;
                        if (this.hasHighlights) {
                            // When any highlight value is greater than the corresponding non-highlight value
                            // we just render all of the highlight values and discard the non-highlight values.
                            if (highlightsOverflow) {
                                measure = point.highlight.measure;
                                percentage = (this.highlightTotal > 0) ? point.highlight.value / this.highlightTotal : 0.0;
                                highlightRatio = 1;
                            }
                            else {
                                highlightRatio = point.highlight.value / point.nonHighlight.value;
                            }
                            if (!highlightRatio) {
                                highlightRatio = DonutChart.EffectiveZeroValue;
                            }
                        }
                        var formattedMeasure = formatter.format(measure);
                        // If category exists the label content is category. Add meaure to it if necessary
                        if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show)
                            point.label += " " + formattedMeasure;
                        else
                            point.label = this.dataLabelsSettings.show ? formattedMeasure : point.label;
                        var value = measure;
                        var categoryValue = point.categoryLabel;
                        var categorical = this.dataViewCategorical;
                        var valueIndex = categorical.categories ? null : i;
                        valueIndex = point.seriesIndex !== undefined ? point.seriesIndex : valueIndex;
                        var highlightedValue = this.hasHighlights && point.highlight.value !== 0 ? point.highlight.measure : undefined;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, valueIndex, highlightedValue);
                        this.dataPoints.push({
                            identity: point.identity,
                            measure: measure,
                            measureFormat: point.measureFormat,
                            percentage: percentage,
                            index: point.index,
                            label: point.label,
                            highlightRatio: highlightRatio,
                            selected: false,
                            tooltipInfo: tooltipInfo,
                            color: point.color,
                            labelColor: this.dataLabelsSettings.labelColor,
                        });
                    }
                    this.legendData = { title: this.getLegendTitle(), dataPoints: this.legendDataPoints };
                };
                DonutChartConverter.prototype.getLegendTitle = function () {
                    if (this.total !== 0) {
                        // If category exists, we render title using category source. If not, we render title
                        // using measure.
                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source ? this.dataViewCategorical.values.source.displayName : "";
                        var dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source ? this.dataViewCategorical.categories[0].source.displayName : "";
                        if (this.categoryValues) {
                            return dvCategorySourceName;
                        }
                        else {
                            return dvValuesSourceName;
                        }
                    }
                    else {
                        return "";
                    }
                };
                DonutChartConverter.prototype.convertCategoricalWithSlicing = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var dataPoints = [];
                    for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                        var categoryValue = this.categoryValues[categoryIndex];
                        var thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : undefined;
                        var legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]);
                        var color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue);
                        var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                        for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var seriesData = dataViewCategorical.values[seriesIndex];
                            var label = this.isSingleMeasure ? categoryLabel : visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                            var nonHighlight = seriesData.values[categoryIndex] || 0;
                            var highlight = this.hasHighlights ? seriesData.highlights[categoryIndex] || 0 : 0;
                            var identity = this.isMultiMeasure ? visuals.SelectionId.createWithIdAndMeasure(this.categoryIdentities[categoryIndex], seriesData.source.queryName) : visuals.SelectionId.createWithIds(this.categoryIdentities[categoryIndex], seriesData.identity);
                            var dataPoint = {
                                identity: identity,
                                measureFormat: visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true),
                                nonHighlight: {
                                    measure: nonHighlight,
                                    value: Math.abs(nonHighlight),
                                },
                                highlight: {
                                    measure: highlight,
                                    value: Math.abs(highlight),
                                },
                                index: categoryIndex,
                                label: label,
                                categoryLabel: categoryLabel,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint);
                        }
                        this.legendDataPoints.push({
                            label: categoryLabel,
                            color: color,
                            icon: 0 /* Box */,
                            identity: legendIdentity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertMeasures = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                        var measureData = dataViewCategorical.values[measureIndex];
                        var measureFormat = visuals.valueFormatter.getFormatString(measureData.source, formatStringProp, true);
                        var measureLabel = measureData.source.displayName;
                        var identity = visuals.SelectionId.createWithMeasure(measureData.source.queryName);
                        debug.assert(measureData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || measureData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = measureData.values[0] || 0;
                        var highlight = this.hasHighlights ? measureData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForMeasure(measureData.source.objects, measureData.source.queryName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: measureFormat,
                            nonHighlight: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlight: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: measureIndex,
                            label: measureLabel,
                            categoryLabel: measureLabel,
                            color: color
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: 0 /* Box */,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertSeries = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        var seriesFormat = visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true);
                        var label = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                        var identity = visuals.SelectionId.createWithId(seriesData.identity);
                        var seriesName = visuals.converterHelper.getSeriesName(seriesData.source);
                        var seriesObjects = seriesData.objects && seriesData.objects[0];
                        debug.assert(seriesData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || seriesData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = seriesData.values[0] || 0;
                        var highlight = this.hasHighlights ? seriesData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForSeriesValue(seriesObjects, dataViewCategorical.values.identityFields, seriesName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: seriesFormat,
                            nonHighlight: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlight: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: seriesIndex,
                            label: label,
                            categoryLabel: label,
                            color: color,
                            seriesIndex: seriesIndex
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: 0 /* Box */,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertDataLableSettings = function () {
                    var dataViewMetadata = this.dataViewMetadata;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            // Handle lables settings
                            var labelsObj = objects['labels'];
                            if (labelsObj) {
                                if (labelsObj.show !== undefined)
                                    dataLabelsSettings.show = labelsObj.show;
                                if (labelsObj.color !== undefined) {
                                    dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                                    dataLabelsSettings.overrideDefaultColor = true;
                                }
                                if (labelsObj.labelDisplayUnits !== undefined) {
                                    dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                                }
                                if (labelsObj.labelPrecision !== undefined) {
                                    dataLabelsSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : 0;
                                }
                            }
                            dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataViewMetadata.columns);
                            var categoryLabelsObject = objects['categoryLabels'];
                            if (categoryLabelsObject) {
                                // Update category label visibility
                                var category = categoryLabelsObject['show'];
                                if (category !== undefined)
                                    dataLabelsSettings.showCategory = category;
                            }
                        }
                    }
                    return dataLabelsSettings;
                };
                return DonutChartConverter;
            })();
            DonutChartConversion.DonutChartConverter = DonutChartConverter;
        })(DonutChartConversion || (DonutChartConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.filledMapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                },
                {
                    name: 'Series',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                },
                {
                    name: 'Size',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values')
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Size',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Size': { max: 1 } }
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [
                                { bind: { to: 'Size' } }
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 2 } }
                },
            }],
            sorting: {
                custom: {},
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.funnelChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                },
                {
                    name: 'Gradient',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                }
            ],
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 0 }, 'Gradient': { max: 0 } },
                    { 'Category': { max: 0 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                    { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 1 } },
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [{ bind: { to: 'Y' } }, { bind: { to: 'Gradient' } }],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 1 } }
                },
            }],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelPosition: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Position'),
                            type: { formatting: { labelPosition: true } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            type: { numeric: true }
                        },
                    }
                },
            },
            supportsHighlight: true,
            sorting: {
                default: {},
            },
        };
        visuals.funnelChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Renders a funnel chart */
        var FunnelChart = (function () {
            function FunnelChart(options) {
                this.labelPositionObjects = [powerbi.labelPosition.outsideEnd, powerbi.labelPosition.insideCenter];
                if (options && options.animator) {
                    this.animator = options.animator;
                }
            }
            FunnelChart.converter = function (dataView, colors, defaultDataPointColor) {
                var slices = [];
                var formatStringProp = visuals.funnelChartProps.general.formatString;
                var valueMetaData = dataView.metadata ? dataView.metadata.columns.filter(function (d) { return d.isMeasure; }) : [];
                var categories = dataView.categorical.categories || [];
                var values = dataView.categorical.values;
                var hasHighlights = values && values[0] && !!values[0].highlights;
                var highlightsOverflow = false;
                var categorical = dataView.categorical;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultFunnelLabelSettings(defaultDataPointColor);
                var colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor);
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects['labels'];
                    if (labelsObj) {
                        dataLabelsSettings.show = (labelsObj.show !== undefined) ? labelsObj.show : dataLabelsSettings.show;
                        dataLabelsSettings.position = (labelsObj.labelPosition !== undefined) ? labelsObj.labelPosition : dataLabelsSettings.position;
                        if (labelsObj.color !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            dataLabelsSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : 0;
                        }
                    }
                    dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                }
                if (categories.length === 1 && categories[0].values.length > 1 && values) {
                    var category = categories[0];
                    var categoryValues = category.values;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);
                    for (var i = 0, ilen = categoryValues.length; i < ilen; i++) {
                        var measureName = values[0].source.queryName;
                        var identity = category.identity ? visuals.SelectionId.createWithIdAndMeasure(category.identity[i], measureName) : visuals.SelectionId.createWithMeasure(measureName);
                        var value = d3.sum(values.map(function (d) { return d.values[i]; }));
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0);
                        if (hasHighlights) {
                            var highlight = d3.sum(values.map(function (d) { return d.highlights[i]; }));
                            if (highlight !== 0) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0, highlight);
                            }
                        }
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(category.objects && category.objects[i], '');
                        slices.push({
                            label: formattedCategoryValue,
                            value: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = d3.sum(values.map(function (d) { return d.highlights[i]; }));
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0, highlightedValue);
                            slices.push({
                                label: formattedCategoryValue,
                                value: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                selected: false,
                                key: highlightIdentity.getKey(),
                                highlight: true,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo,
                                color: color,
                            });
                        }
                    }
                }
                else if (valueMetaData.length > 0 && values) {
                    for (var i = 0, len = values.length; i < len; i++) {
                        var valueColumn = values[i];
                        var value = d3.sum(valueColumn.values);
                        var identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName);
                        var categoryValue = valueMetaData[i].displayName;
                        var valueIndex = categorical.categories ? null : i;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, valueIndex);
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(valueColumn.source.objects, '');
                        if (hasHighlights) {
                            var highlight = d3.sum(values.map(function (d) { return d.highlights[i]; }));
                            if (highlight !== 0) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlight);
                            }
                        }
                        slices.push({
                            label: valueMetaData[i].displayName,
                            value: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = d3.sum(values[i].highlights);
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlightedValue);
                            slices.push({
                                label: valueMetaData[i].displayName,
                                value: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: false,
                                highlight: true,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo,
                                color: color,
                            });
                        }
                    }
                }
                return {
                    slices: slices,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    dataLabelsSettings: dataLabelsSettings,
                };
            };
            FunnelChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole) {
                            return this.enumerateDataPoints();
                        }
                        break;
                    case 'labels':
                        return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, true, true, true, this.labelPositionObjects);
                }
            };
            FunnelChart.prototype.enumerateDataPoints = function () {
                var data = this.data;
                if (!data)
                    return;
                var instances = [];
                var slices = data.slices;
                instances.push({
                    objectName: 'dataPoint',
                    selector: null,
                    properties: {
                        defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColor(0).value } }
                    },
                });
                for (var i = 0; i < slices.length; i++) {
                    var slice = slices[i];
                    if (slice.highlight)
                        continue;
                    var color = slice.color;
                    var selector = slice.identity.getSelector();
                    var isSingleSeries = !!selector.data;
                    var dataPointInstance = {
                        objectName: 'dataPoint',
                        displayName: slice.label,
                        selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                        properties: {
                            fill: { solid: { color: color } }
                        },
                    };
                    instances.push(dataPointInstance);
                }
                return instances;
            };
            FunnelChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0)).append('svg').classed(FunnelChart.VisualClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.currentViewport = options.viewport;
                this.margin = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                var style = options.style;
                this.colors = style.colorPalette.dataColors;
                this.hostServices = options.host;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.funnelGraphicsContext = svg.append('g');
                this.axisGraphicsContext = svg.append('g');
                var lgc = this.labelGraphicsContext = svg.append('g');
                lgc.classed(FunnelChart.InnerTextGroupClassName, true);
                this.updateViewportProperties();
            };
            FunnelChart.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width).attr('height', viewport.height);
            };
            FunnelChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.data = {
                    slices: [],
                    valuesMetadata: [],
                    hasHighlights: false,
                    highlightsOverflow: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
                };
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                        if (defaultColor)
                            this.defaultDataPointColor = defaultColor;
                    }
                    if (dataView.categorical) {
                        this.data = FunnelChart.converter(dataView, this.colors, this.defaultDataPointColor);
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.slices);
                        }
                    }
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0)
                        this.hostServices.setWarnings(warnings);
                }
                this.updateViewportProperties();
                this.updateInternal(true);
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onDataChanged = function (options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || 0,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onResizing = function (viewport, duration) {
                this.currentViewport = viewport;
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewport: this.currentViewport
                });
            };
            FunnelChart.prototype.getMaxLeftMargin = function (labels, properties) {
                var max = 0;
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                for (var i = 0, len = labels.length; i < len; i++) {
                    properties.text = labels[i];
                    max = Math.max(max, textMeasurer(properties));
                }
                return max + FunnelChart.LabelFunnelPadding;
            };
            FunnelChart.prototype.updateInternal = function (useAnimation) {
                if (this.data == null)
                    return;
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function (d) { return !d.highlight; });
                var axisOptions = this.setUpAxis();
                var margin = axisOptions.margin;
                var verticalRange = axisOptions.verticalRange;
                var funnelContext = this.funnelGraphicsContext.attr('transform', visuals.SVGUtil.translateAndRotate(margin.left, margin.top, verticalRange / 2, verticalRange / 2, 90));
                this.svg.style('font-size', FunnelChart.StandardTextProperties.fontSize);
                this.svg.style('font-weight', FunnelChart.StandardTextProperties.fontWeight);
                this.svg.style('font-family', FunnelChart.StandardTextProperties.fontFamily);
                var layout = FunnelChart.getLayout(data, axisOptions);
                var labelLayout = visuals.dataLabelUtils.getFunnelChartLabelLayout(data, axisOptions, FunnelChart.InnerTextHeightDelta, FunnelChart.InnerTextMinimumPadding, data.dataLabelsSettings, this.currentViewport);
                var result;
                var shapes;
                var dataLabels;
                if (this.animator) {
                    var animationOptions = {
                        viewModel: data,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        axisGraphicsContext: this.axisGraphicsContext,
                        shapeGraphicsContext: funnelContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        axisOptions: axisOptions,
                        slicesWithoutHighlights: slicesWithoutHighlights,
                        colors: this.colors,
                        labelLayout: labelLayout
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    dataLabels = result.dataLabels;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions);
                    shapes = FunnelChart.drawDefaultShapes(data, slices, funnelContext, layout, this.colors);
                    if (data.dataLabelsSettings.show && !axisOptions.hideInnerLabels) {
                        visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(slicesWithoutHighlights, this.labelGraphicsContext, labelLayout);
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.labelGraphicsContext);
                    }
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        datapoints: slices,
                        bars: shapes,
                        labels: dataLabels,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            FunnelChart.prototype.setUpAxis = function () {
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function (d) { return !d.highlight; });
                var categoryLabels = slicesWithoutHighlights.map(function (d) { return d.label; });
                var hideInnerLabels = false;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var horizontalRange = viewport.height - (margin.top + margin.bottom);
                if (categoryLabels.length > 0 && (horizontalRange / categoryLabels.length) < FunnelChart.MinBarThickness) {
                    categoryLabels = [];
                    hideInnerLabels = true;
                }
                else {
                    var textProperties = FunnelChart.StandardTextProperties;
                    margin.left = this.getMaxLeftMargin(categoryLabels, textProperties);
                }
                var verticalRange = viewport.width - (margin.left + margin.right);
                var barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                var maxScore = d3.max(slices.map(function (d) { return d.value; }));
                var minScore = 0;
                var rangeStart = 0;
                var rangeEnd = horizontalRange;
                if (categoryLabels.length > 0 && horizontalRange / categoryLabels.length > FunnelChart.MaxBarWidth) {
                    var delta = horizontalRange - (categoryLabels.length * FunnelChart.MaxBarWidth);
                    rangeStart = Math.ceil(delta / 2);
                    rangeEnd = Math.ceil(horizontalRange - delta / 2);
                    barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                }
                var yScale = d3.scale.linear().domain([minScore, maxScore]).range([verticalRange, 0]);
                var xScale = d3.scale.ordinal().domain(d3.range(0, slicesWithoutHighlights.length)).rangeBands([rangeStart, rangeEnd], barToSpaceRatio);
                return {
                    margin: margin,
                    xScale: xScale,
                    yScale: yScale,
                    maxScore: maxScore,
                    verticalRange: verticalRange,
                    rangeStart: rangeStart,
                    rangeEnd: rangeEnd,
                    barToSpaceRatio: barToSpaceRatio,
                    hideInnerLabels: hideInnerLabels,
                    categoryLabels: categoryLabels,
                };
            };
            FunnelChart.prototype.accept = function (visitor, options) {
                visitor.visitFunnel(options);
            };
            FunnelChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            FunnelChart.getLayout = function (data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow;
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var maxScore = axisOptions.maxScore;
                var columnWidth = xScale.rangeBand();
                var overFlowHighlightColumnWidth = columnWidth * FunnelChart.OverflowingHighlightWidthRatio;
                var overFlowHighlightOffset = overFlowHighlightColumnWidth / 2;
                return {
                    shapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(d.highlight ? d.highlightValue : d.value) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            return yScale(d.highlight ? d.highlightValue : d.value) - (Math.abs(yScale(maxScore) - yScale(0)) - Math.abs(yScale(d.highlight ? d.highlightValue : d.value) - yScale(0))) / 2;
                        },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: (function (d) { return columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(d.value) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (0);
                        },
                        y: function (d) {
                            return yScale(d.value) - (Math.abs(yScale(maxScore) - yScale(0)) - Math.abs(yScale(d.value) - yScale(0))) / 2;
                        },
                    },
                    zeroShapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) { return 0; },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            return yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);
                        },
                    }
                };
            };
            FunnelChart.drawDefaultAxis = function (graphicsContext, axisOptions) {
                var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio);
                var xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(FunnelChart.TickPadding).innerTickSize(FunnelChart.InnerTickSize);
                graphicsContext.classed('axis', true).attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
            };
            FunnelChart.drawDefaultShapes = function (data, slices, graphicsContext, layout, colors) {
                var hasHighlights = data.hasHighlights;
                var columns = graphicsContext.selectAll('.funnelBar').data(slices, function (d) { return d.key; });
                columns.enter().append('rect').attr("class", function (d) { return d.highlight ? "funnelBar highlight" : "funnelBar"; });
                columns.style("fill", function (d) {
                    return d.color;
                }).style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }; }).attr(layout.shapeLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.DefaultBarOpacity = 1;
            FunnelChart.DimmedBarOpacity = 0.4;
            FunnelChart.InnerTextClassName = 'labelSeries';
            FunnelChart.VisualClassName = 'funnelChart';
            FunnelChart.BarToSpaceRatio = 0.1;
            FunnelChart.MaxBarWidth = 40;
            FunnelChart.MinBarThickness = 12;
            FunnelChart.LabelFunnelPadding = 6;
            FunnelChart.InnerTextMinimumPadding = 10;
            FunnelChart.InnerTextHeightDelta = 4;
            FunnelChart.InnerTextGroupClassName = 'innerTextGroup';
            FunnelChart.StandardTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: '12px',
            };
            FunnelChart.OverflowingHighlightWidthRatio = 0.5;
            FunnelChart.TickPadding = 0;
            FunnelChart.InnerTickSize = 0;
            return FunnelChart;
        })();
        visuals.FunnelChart = FunnelChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var RoleNames = {
            y: 'Y',
            minValue: 'MinValue',
            maxValue: 'MaxValue',
            targetValue: 'TargetValue'
        };
        /** Renders a number that can be animate change in value */
        var Gauge = (function () {
            function Gauge(options) {
                this.lastAngle = -Math.PI / 2;
                if (options) {
                    if (options.gaugeSmallViewPortProperties) {
                        this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties;
                    }
                }
            }
            Gauge.prototype.init = function (options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.options = options;
                this.settings = Gauge.DefaultStyleProperties;
                this.targetSettings = Gauge.DefaultTargetSettings;
                this.setMargins();
                this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function (color) { return color.value; }));
                this.hostService = options.host;
                var svg = this.svg = d3.select(this.element.get(0)).append('svg');
                svg.classed(Gauge.VisualClassName, true);
                var mainGraphicsContext = this.mainGraphicsContext = svg.append('g');
                mainGraphicsContext.attr('class', Gauge.MainGaugeGroupElementName);
                this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
                var foregroundArc = this.foregroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append('path').classed('backgroundArc', true).attr('d', backgroundArc);
                this.foregroundArcPath = mainGraphicsContext.append('path').datum({ endAngle: -Math.PI / 2 }).classed('foregroundArc', true).attr('d', foregroundArc);
                var g = this.animatedNumberGrapicsContext = svg.append('g');
                this.animatedNumber = new visuals.AnimatedNumber(g);
                this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumber.svg.attr('transform', animatedNumberProperties.transformString);
                this.animatedNumber.onResizing(animatedNumberProperties.viewport, 0);
            };
            Gauge.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                this.data = Gauge.converter(dataViews[0]);
                this.targetSettings = this.data.targetSettings;
                if (dataViews[0])
                    dataViews[0].single = { value: this.data.total };
                // Only show the target label if:
                //   1. There is a target
                //   2. The viewport width is big enough for a target
                //   3. We're showing label text for side numbers
                this.showTargetLabel = this.targetSettings.target != null && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || !this.showMinMaxLabelsOnBottom()) && this.showSideNumbersLabelText();
                this.setMargins();
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.drawViewPort(this.gaugeVisualProperties);
                this.updateInternal(options.duration);
                this.animatedNumber.svg.attr('transform', animatedNumberProperties.transformString);
                this.animatedNumber.update({
                    viewport: animatedNumberProperties.viewport,
                    dataViews: options.dataViews,
                    duration: options.duration,
                });
                var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                if (warnings && warnings.length > 0)
                    this.hostService.setWarnings(warnings);
            };
            Gauge.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || 0,
                    viewport: this.currentViewport
                });
            };
            Gauge.prototype.onResizing = function (viewport, duration) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewMode: 0 /* View */,
                    viewport: viewport
                });
            };
            Gauge.prototype.onStyleChanged = function (newStyle) {
                this.style = newStyle;
                this.color = d3.scale.ordinal().range(newStyle.colorPalette.dataColors.getSentimentColors().map(function (color) { return color.value; }));
                this.updateInternal(0);
            };
            Gauge.getValidSettings = function (targetData) {
                var maxVal = (targetData.max === Gauge.MAX_VALUE) ? Gauge.DEFAULT_MAX : targetData.max;
                var minVal = (targetData.min === Gauge.MIN_VALUE) ? Gauge.DEFAULT_MIN : targetData.min;
                var targetVal = targetData.target;
                return {
                    min: minVal,
                    max: maxVal,
                    target: targetVal
                };
            };
            Gauge.getGaugeData = function (dataView) {
                var settings = {
                    max: Gauge.MAX_VALUE,
                    min: Gauge.MIN_VALUE,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length === values.length, 'length');
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[RoleNames.y]) {
                                settings.total = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                            else if (col.roles[RoleNames.minValue]) {
                                settings.min = value;
                            }
                            else if (col.roles[RoleNames.maxValue]) {
                                settings.max = value;
                            }
                            else if (col.roles[RoleNames.targetValue]) {
                                settings.target = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                        }
                    }
                }
                return settings;
            };
            //Made public for testability
            Gauge.converter = function (dataView) {
                var gaugeData = Gauge.getGaugeData(dataView);
                var total = gaugeData.total;
                if (total > 0 && gaugeData.max === Gauge.MAX_VALUE) {
                    var hasPercent = false;
                    var columns = dataView.metadata.columns;
                    if (!_.isEmpty(columns)) {
                        var formatString = visuals.valueFormatter.getFormatString(dataView.metadata.columns[0], Gauge.formatStringProp, true);
                        hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent;
                    }
                    gaugeData.max = hasPercent ? Gauge.DEFAULT_MAX : total * 2;
                }
                var settings = Gauge.getValidSettings(gaugeData);
                //Checking that the value is plotted inside the guage boundries
                var adjustedTotal = Math.max(total, settings.min);
                adjustedTotal = Math.min(adjustedTotal, settings.max);
                var percent = (settings.min !== settings.max) ? (adjustedTotal - settings.min) / (settings.max - settings.min) : 0;
                var tooltipInfo;
                if (dataView) {
                    if (gaugeData.tooltipItems.length > 0) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, null, null, gaugeData.tooltipItems, null, null);
                    }
                    else {
                        var dataViewCat = dataView.categorical;
                        if (dataViewCat && dataViewCat.values && dataViewCat.values.length > 0) {
                            var categoryValue = dataViewCat.values[0];
                            var value = categoryValue.values[0];
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, dataViewCat.values, value, null, null, null);
                        }
                    }
                }
                return {
                    percent: percent,
                    adjustedTotal: adjustedTotal,
                    total: total,
                    metadataColumn: Gauge.getMetaDataColumn(dataView),
                    targetSettings: settings,
                    tooltipInfo: tooltipInfo,
                };
            };
            Gauge.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
                return null;
            };
            Gauge.prototype.initKpiBands = function () {
                if (!this.settings.kpiBands.show)
                    return;
                var kpiArcs = this.kpiArcs = [];
                var kpiArcPaths = this.kpiArcPaths = [];
                var mainGraphicsContext = this.mainGraphicsContext;
                for (var i = 0; i < 3; i++) {
                    var arc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(0).endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append('path').attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            };
            Gauge.prototype.updateKpiBands = function (radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (!this.settings.kpiBands.show)
                    return;
                for (var i = 0; i < kpiAngleAttr.length; i++) {
                    this.kpiArcs[i].innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)).outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc).startAngle(kpiAngleAttr[i].start).endAngle(kpiAngleAttr[i].end);
                    this.kpiArcPaths[i].attr('fill', kpiAngleAttr[i].fill).attr('d', this.kpiArcs[i]).attr('transform', tString);
                }
            };
            Gauge.prototype.removeTargetElements = function () {
                if (this.targetLine) {
                    this.targetLine.remove();
                    this.targetText.remove();
                    this.targetConnector.remove();
                    this.targetLine = this.targetConnector = this.targetText = null;
                }
            };
            Gauge.prototype.updateTargetLine = function (radius, innerRadius, left, top) {
                var targetSettings = this.targetSettings;
                if (!this.targetLine) {
                    this.targetLine = this.mainGraphicsContext.append('line');
                }
                var angle = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min) * Math.PI;
                var outY = top - radius * Math.sin(angle);
                var outX = left - radius * Math.cos(angle);
                var inY = top - innerRadius * Math.sin(angle);
                var inX = left - innerRadius * Math.cos(angle);
                this.targetLine.attr({
                    x1: inX,
                    y1: inY,
                    x2: outX,
                    y2: outY
                });
            };
            //public for testability
            Gauge.prototype.getAnimatedNumberProperties = function (radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4;
                var scale = 1;
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show ? (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness) : 0);
                var innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle);
                var innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle);
                var innerY = top - innerRSin;
                var innerX = left - innerRCos;
                var innerY = innerY * scale;
                var innerX = innerX * scale;
                var animatedNumberWidth = innerRCos * 2;
                var properties = {
                    transformString: visuals.SVGUtil.translate(innerX, innerY),
                    viewport: { height: innerRSin, width: animatedNumberWidth }
                };
                return properties;
            };
            //public for testability
            Gauge.prototype.getGaugeVisualProperties = function () {
                var viewport = this.currentViewport;
                var margin = this.margin;
                var width = viewport.width - margin.right - margin.left;
                var halfWidth = width / 2;
                var height = viewport.height - margin.top - margin.bottom;
                var radius = Math.min(halfWidth, height);
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var left = margin.left + halfWidth;
                var top = radius + (height - radius) / 2 + margin.top;
                var tString = visuals.SVGUtil.translate(left, top);
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var gaugeData = {
                    radius: radius,
                    innerRadiusOfArc: innerRadiusOfArc,
                    left: left,
                    top: top,
                    height: height,
                    width: width,
                    margin: margin,
                    transformString: tString,
                    innerRadiusFactor: innerRadiusFactor
                };
                return gaugeData;
            };
            //public for testability
            Gauge.prototype.drawViewPort = function (drawOptions) {
                debug.assertAnyValue(drawOptions, "Gauge options");
                var separation = this.settings.kpiBands.separationRadians;
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var backgroudArc = this.backgroundArc;
                var color = this.color;
                var attrs = [{
                    fill: color(0),
                    start: -Math.PI / 2,
                    end: -Math.PI / 2 + Math.PI / 4 - separation
                }, {
                    fill: color(1),
                    start: -Math.PI / 2 + Math.PI * 1 / 4 + separation,
                    end: -Math.PI / 2 + Math.PI * 3 / 4 - separation
                }, {
                    fill: color(2),
                    start: -Math.PI / 2 + Math.PI * 3 / 4 + separation,
                    end: Math.PI / 2
                }];
                var radius = drawOptions.radius;
                var transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
                backgroudArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
                this.backgroundArcPath.attr("d", backgroudArc).attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                foregroundArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2);
                this.foregroundArcPath.datum({ endAngle: this.lastAngle }).attr("transform", transformString).attr("d", foregroundArc);
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc;
                var left = drawOptions.left;
                var top = drawOptions.top;
                var margin = drawOptions.margin;
                var height = drawOptions.height;
                var targetSettings = this.targetSettings;
                if (!this.settings.targetLine.show || targetSettings.target == null) {
                    this.removeTargetElements();
                }
                else {
                    if (targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target) {
                        this.removeTargetElements();
                    }
                    else {
                        this.updateTargetLine(radius, innerRadiusOfArc, left, top);
                        this.appendTargetTextAlongArc(radius, height, drawOptions.width, margin);
                    }
                }
                this.svg.attr('height', this.currentViewport.height).attr('width', this.currentViewport.width);
            };
            Gauge.prototype.createTicks = function (total) {
                var settings = this.settings;
                var targetSettings = this.targetSettings;
                var total = targetSettings.max - targetSettings.min;
                var numberOfLabels = settings.labels.count;
                var step = total / numberOfLabels;
                var arr = [];
                var formatter = visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp),
                    value: targetSettings.min,
                    value2: targetSettings.max,
                    formatSingleValues: true,
                    allowFormatBeautification: true,
                });
                for (var i = 0; i < numberOfLabels + 1; i++) {
                    arr.push(formatter.format(targetSettings.min + (i * step)));
                }
                return arr;
            };
            Gauge.prototype.updateInternal = function (duration) {
                if (duration === void 0) { duration = 0; }
                var height = this.gaugeVisualProperties.height;
                var width = this.gaugeVisualProperties.width;
                var radius = this.gaugeVisualProperties.radius;
                var margin = this.margin;
                var data = this.data;
                var lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * data.percent;
                var ticks = this.createTicks(data.adjustedTotal);
                this.foregroundArcPath.transition().ease(this.settings.transition.ease).duration(duration).call(this.arcTween, [lastAngle, this.foregroundArc]);
                this.appendTextAlongArc(ticks, radius, height, width, margin);
                this.updateVisualConfigurations();
                this.updateVisualStyles();
                visuals.TooltipManager.addTooltip(this.foregroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
            };
            Gauge.prototype.updateVisualStyles = function () {
                this.mainGraphicsContext.selectAll('text').style({
                    'fill': this.style.labelText.color.value
                });
            };
            Gauge.prototype.updateVisualConfigurations = function () {
                var configOptions = this.settings;
                this.mainGraphicsContext.select('line').attr({
                    stroke: configOptions.targetLine.color,
                    'stroke-width': configOptions.targetLine.thickness
                });
                this.backgroundArcPath.style('fill', configOptions.arcColors.background);
                this.foregroundArcPath.style('fill', configOptions.arcColors.foreground);
            };
            Gauge.prototype.appendTextAlongArc = function (ticks, radius, height, width, margin) {
                this.svg.selectAll(Gauge.LabelText.selector).remove();
                var total = ticks.length;
                var divisor = total - 1;
                var top = (radius + (height - radius) / 2 + margin.top);
                var showMinMaxLabelsOnBottom = this.showMinMaxLabelsOnBottom();
                var fontSize = this.style.labelText.fontSize;
                var padding = this.settings.labels.padding;
                for (var count = 0; count < total; count++) {
                    if (Math.floor(total / 2) === count)
                        continue; // Skip Middle label, by design
                    if (this.showSideNumbersLabelText()) {
                        var x = (margin.left + width / 2) - (radius * Math.cos(Math.PI * count / divisor));
                        var y = top - (radius * Math.sin(Math.PI * count / divisor));
                        var anchor;
                        var onRight = count * 2 > total;
                        var onBottom = false;
                        if (showMinMaxLabelsOnBottom && (count === 0 || count === total - 1)) {
                            // If this is a min or max label and we're showing them on the bottom rather than the sides
                            // Adjust the label display properties to appear under the arc
                            onBottom = true;
                            y += padding / 2;
                            // Align the labels with the outer edge of the arc
                            anchor = onRight ? 'end' : 'start';
                        }
                        else {
                            // For all other labels, display around the arc
                            anchor = onRight ? 'start' : 'end';
                            x += padding * (onRight ? 1 : -1);
                        }
                        var text = this.mainGraphicsContext.append('text').attr({
                            'x': x,
                            'y': y,
                            'dy': onBottom ? fontSize : 0,
                            'class': Gauge.LabelText.class
                        }).style({
                            'text-anchor': anchor,
                            'font-size': fontSize
                        }).text(ticks[count]);
                        if (!onBottom)
                            this.truncateTextIfNeeded(text, x, onRight);
                    }
                }
            };
            Gauge.prototype.truncateTextIfNeeded = function (text, positionX, onRight) {
                var availableSpace = (onRight ? this.currentViewport.width - positionX : positionX);
                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
            };
            Gauge.prototype.appendTargetTextAlongArc = function (radius, height, width, margin) {
                var targetSettings = this.targetSettings;
                var target = targetSettings.target;
                var tRatio = (target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                var top = (radius + (height - radius) / 2 + margin.top);
                var flag = tRatio > 0.5;
                var padding = this.settings.labels.padding;
                var anchor = flag ? 'start' : 'end';
                var formatter = visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp),
                    value: targetSettings.min,
                    value2: targetSettings.max,
                    formatSingleValues: true,
                    allowFormatBeautification: true,
                });
                var maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI;
                var finalRatio = tRatio < maxRatio || tRatio > (1 - maxRatio) ? flag ? 1 - maxRatio : maxRatio : tRatio;
                var targetX = (margin.left + width / 2) - ((radius + padding) * Math.cos(Math.PI * finalRatio));
                var targetY = top - ((radius + padding) * Math.sin(Math.PI * finalRatio));
                if (!this.targetText) {
                    this.targetText = this.mainGraphicsContext.append('text').classed(Gauge.TargetText.class, true);
                }
                this.targetText.attr({
                    'x': targetX,
                    'y': targetY,
                }).style({
                    'text-anchor': anchor,
                    'display': this.showTargetLabel ? '' : 'none',
                    'font-size': this.style.labelText.fontSize
                }).text(formatter.format(target));
                this.truncateTextIfNeeded(this.targetText, targetX, flag);
                if (!this.targetConnector) {
                    this.targetConnector = this.mainGraphicsContext.append('line').classed(Gauge.TargetConnector.class, true);
                }
                // Hide the target connector if the text is going to align with the target line in the arc
                // It should only be shown if the target text is displaced (ex. when the target is very close to min/max)
                if (tRatio === finalRatio) {
                    this.targetConnector.style('display', 'none');
                }
                else {
                    this.targetConnector.attr({
                        'x1': (margin.left + width / 2) - (radius * Math.cos(Math.PI * tRatio)),
                        'y1': top - (radius * Math.sin(Math.PI * tRatio)),
                        'x2': targetX,
                        'y2': targetY
                    }).style({
                        'stroke-width': this.settings.targetLine.thickness,
                        'stroke': this.settings.targetLine.color,
                        'display': ''
                    });
                }
            };
            Gauge.prototype.arcTween = function (transition, arr) {
                transition.attrTween('d', function (d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function (t) {
                        d.endAngle = interpolate(t);
                        return arr[1](d);
                    };
                });
            };
            Gauge.prototype.showMinMaxLabelsOnBottom = function () {
                // We want to show the start/end ticks on the bottom when there is more vertical space than horizontal
                // and we aren't displaying other ticks on the side that will use the horizontal space anyway
                return this.currentViewport.height > this.currentViewport.width && this.settings.labels.count <= 3;
            };
            Gauge.prototype.setMargins = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible)) {
                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                        this.margin = { top: margins, bottom: margins, left: margins, right: margins };
                        return;
                    }
                }
                this.margin = {
                    top: Gauge.DefaultTopBottomMargin,
                    bottom: Gauge.DefaultTopBottomMargin,
                    left: Gauge.DefaultLeftRightMargin,
                    right: Gauge.DefaultLeftRightMargin
                };
                // If we're not showing side labels, reduce the margin so that the gauge has more room to display
                if (!this.showSideNumbersLabelText() || this.showMinMaxLabelsOnBottom()) {
                    var targetSettings = this.targetSettings;
                    if (this.showTargetLabel) {
                        // If we're showing the target label, only reduce the margin on the side that doesn't have a target label
                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                        if (tRatio > 0.5)
                            this.margin.left = Gauge.ReducedLeftRightMargin;
                        else
                            this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                    else {
                        // Otherwise, reduce both margins
                        this.margin.left = this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                }
            };
            Gauge.prototype.showSideNumbersLabelText = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort) {
                        if (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Gauge.MIN_VALUE = -Infinity;
            Gauge.MAX_VALUE = +Infinity;
            Gauge.MinDistanceFromBottom = 10;
            Gauge.MinWidthForTargetLabel = 150;
            Gauge.DefaultTopBottomMargin = 20;
            Gauge.DefaultLeftRightMargin = 45;
            Gauge.ReducedLeftRightMargin = 15;
            Gauge.DEFAULT_MAX = 1;
            Gauge.DEFAULT_MIN = 0;
            Gauge.VisualClassName = 'gauge';
            Gauge.DefaultStyleProperties = {
                transition: {
                    ease: 'bounce'
                },
                arcColors: {
                    background: '#e9e9e9',
                    foreground: '#00B8AA'
                },
                targetLine: {
                    show: true,
                    color: '#666666',
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5
                },
                kpiBands: {
                    show: false,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                },
            };
            Gauge.DefaultTargetSettings = {
                min: 0,
                max: 1,
                target: undefined
            };
            Gauge.InnerRadiusFactor = 0.7;
            Gauge.KpiBandDistanceFromMainArc = 2;
            Gauge.MainGaugeGroupElementName = 'mainGroup';
            Gauge.LabelText = {
                class: 'labelText',
                selector: '.labelText'
            };
            Gauge.TargetConnector = {
                class: 'targetConnector',
                selector: '.targetConnector'
            };
            Gauge.TargetText = {
                class: 'targetText',
                selector: '.targetText'
            };
            // Public for testability
            Gauge.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            Gauge.capabilities = {
                dataRoles: [
                    {
                        name: RoleNames.y,
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                    },
                    {
                        name: RoleNames.minValue,
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValue'),
                    },
                    {
                        name: RoleNames.maxValue,
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValue'),
                    },
                    {
                        name: RoleNames.targetValue,
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValue'),
                    }
                ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                        },
                    }
                },
                dataViewMappings: [{
                    conditions: [
                        { 'Y': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'TargetValue': { max: 1 } },
                    ],
                    categorical: {
                        values: {
                            select: [
                                { bind: { to: 'Y' } },
                                { bind: { to: 'MinValue' } },
                                { bind: { to: 'MaxValue' } },
                                { bind: { to: 'TargetValue' } },
                            ]
                        },
                    },
                }],
            };
            return Gauge;
        })();
        visuals.Gauge = Gauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ImageVisual = (function () {
            function ImageVisual() {
            }
            ImageVisual.prototype.init = function (options) {
                this.element = options.element;
            };
            ImageVisual.prototype.onDataChanged = function (options) {
                this.element.empty();
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general)
                    return;
                var div = $("<div class='imageBackground' />");
                if (objects.general.imageUrl)
                    div.css("backgroundImage", "url(" + objects.general.imageUrl + ")");
                div.appendTo(this.element);
            };
            ImageVisual.prototype.onResizing = function (viewport, duration) {
            };
            ImageVisual.capabilities = {
                objects: {
                    general: {
                        properties: {
                            imageUrl: {
                                type: { misc: { imageUrl: true } }
                            }
                        }
                    }
                }
            };
            return ImageVisual;
        })();
        visuals.ImageVisual = ImageVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    (function (VisualDataRoleKind) {
        /** Indicates that the role should be bound to something that evaluates to a grouping of values. */
        VisualDataRoleKind[VisualDataRoleKind["Grouping"] = 0] = "Grouping";
        /** Indicates that the role should be bound to something that evaluates to a single value in a scope. */
        VisualDataRoleKind[VisualDataRoleKind["Measure"] = 1] = "Measure";
        /** Indicates that the role can be bound to either Grouping or Measure. */
        VisualDataRoleKind[VisualDataRoleKind["GroupingOrMeasure"] = 2] = "GroupingOrMeasure";
    })(powerbi.VisualDataRoleKind || (powerbi.VisualDataRoleKind = {}));
    var VisualDataRoleKind = powerbi.VisualDataRoleKind;
    (function (VisualDataChangeOperationKind) {
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Create"] = 0] = "Create";
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Append"] = 1] = "Append";
    })(powerbi.VisualDataChangeOperationKind || (powerbi.VisualDataChangeOperationKind = {}));
    var VisualDataChangeOperationKind = powerbi.VisualDataChangeOperationKind;
    (function (ViewMode) {
        ViewMode[ViewMode["View"] = 0] = "View";
        ViewMode[ViewMode["Edit"] = 1] = "Edit";
    })(powerbi.ViewMode || (powerbi.ViewMode = {}));
    var ViewMode = powerbi.ViewMode;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    // TODO: Deprecate this.
    var SettingsUtil;
    (function (SettingsUtil) {
        function copyCommonSettings(settings) {
            return {
                DisplayUnitSystemType: settings.DisplayUnitSystemType
            };
        }
        SettingsUtil.copyCommonSettings = copyCommonSettings;
    })(SettingsUtil = powerbi.SettingsUtil || (powerbi.SettingsUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.lineChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                },
                {
                    name: 'Series',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                },
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            type: { numeric: true }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            type: { numeric: true }
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                            type: { formatting: { axisType: true } }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { formatting: { yAxisPosition: true } }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            type: { numeric: true }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            type: { numeric: true }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            type: { numeric: true }
                        },
                    },
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [{ for: { in: 'Y' } }],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                },
            }],
            sorting: {
                default: {},
            },
        };
        visuals.lineChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        (function (LineChartType) {
            LineChartType[LineChartType["default"] = 1] = "default";
            LineChartType[LineChartType["area"] = 2] = "area";
            LineChartType[LineChartType["smooth"] = 4] = "smooth";
            LineChartType[LineChartType["lineShadow"] = 8] = "lineShadow";
        })(visuals.LineChartType || (visuals.LineChartType = {}));
        var LineChartType = visuals.LineChartType;
        /** Renders a data series as a line visual. */
        var LineChart = (function () {
            function LineChart(options) {
                this.isScrollable = options.isScrollable ? options.isScrollable : false;
                this.lineType = options.chartType ? options.chartType : 1 /* default */;
                this.interactivityService = options.interactivityService;
                this.animator = options.animator;
            }
            LineChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!jsCommon.ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    if (visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            LineChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!jsCommon.ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: line chart should be sortable by X if it has scalar axis
                    // But currently it doesn't support this. Always return 'category' 
                    // once it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
                        return ['Category'];
                }
                return null;
            };
            LineChart.converter = function (dataView, blankCategoryValue, colors, isScalar, interactivityService) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: undefined,
                    values: [blankCategoryValue],
                    identity: undefined,
                };
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                var series = [];
                var seriesLen = categorical.values ? categorical.values.length : 0;
                var hasDynamicSeries = !!(categorical.values && categorical.values.source);
                var values = categorical.values;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                if (dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects['labels'];
                    if (labelsObj) {
                        if (labelsObj.show !== undefined)
                            dataLabelsSettings.show = labelsObj.show;
                        if (labelsObj.color !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            dataLabelsSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : 0;
                        }
                    }
                    dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                }
                var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultDataPointColor);
                var grouped;
                if (dataView.categorical.values)
                    grouped = dataView.categorical.values.grouped();
                for (var seriesIndex = 0; seriesIndex < seriesLen; seriesIndex++) {
                    var column = categorical.values[seriesIndex];
                    var dataPoints = [];
                    var groupedIdentity = grouped[seriesIndex];
                    var identity = hasDynamicSeries ? visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName) : visuals.SelectionId.createWithMeasure(column.source.queryName);
                    var key = identity.getKey();
                    var color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
                    for (var categoryIndex = 0, len = column.values.length; categoryIndex < len; categoryIndex++) {
                        var categoryValue = categoryValues[categoryIndex];
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(column.values[categoryIndex]);
                        // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
                        if (isScalar && (categoryValue == null || value == null))
                            continue;
                        var categorical = dataView.categorical;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, seriesIndex);
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: value,
                            categoryIndex: categoryIndex,
                            seriesIndex: seriesIndex,
                            tooltipInfo: tooltipInfo,
                            selected: false,
                            identity: identity,
                            key: JSON.stringify({ ser: key, catIdx: categoryIndex }),
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color,
                        });
                    }
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    series.push({
                        key: key,
                        lineIndex: seriesIndex,
                        color: color,
                        xCol: category.source,
                        yCol: column.source,
                        data: dataPoints,
                        identity: identity,
                        selected: false,
                    });
                }
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                // Convert to DataViewMetadataColumn
                var valuesMetadataArray = [];
                if (values) {
                    for (var i = 0; i < values.length; i++) {
                        if (values[i] && values[i].source && values[i].source.displayName) {
                            valuesMetadataArray.push({ displayName: values[i].source.displayName });
                        }
                    }
                }
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                var hasSelection = false;
                if (interactivityService) {
                    if (interactivityService.applySelectionStateToData(series))
                        hasSelection = true;
                }
                return {
                    series: series,
                    isScalar: isScalar,
                    dataLabelsSettings: dataLabelsSettings,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                    hasDynamicSeries: hasDynamicSeries,
                    hasSelection: hasSelection,
                    categoryMetadata: category.source,
                    categories: categoryValues,
                };
            };
            LineChart.getColor = function (colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                var objects;
                if (hasDynamicSeries) {
                    if (grouped)
                        objects = grouped[seriesIndex].objects;
                }
                else {
                    objects = values[seriesIndex].source.objects;
                }
                return hasDynamicSeries ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name) : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
            };
            LineChart.prototype.init = function (options) {
                this.options = options;
                var element = this.element = options.element;
                this.host = options.host;
                this.currentViewport = options.viewport;
                this.colors = options.style.colorPalette.dataColors;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                element.addClass(LineChart.ClassName);
                var svg = options.svg;
                this.clearCatcher = svg.select(".clearCatcher");
                this.mainGraphicsSVG = svg.append('svg');
                this.mainGraphicsContext = this.mainGraphicsSVG.append('g').classed(LineChart.MainGraphicsContextClassName, true);
                this.dataLabelsSVG = svg.append('g').classed(LineChart.DataLabelsSVGClassName, true);
                this.toolTipContext = svg.append('g').classed('hover-line', true);
                this.toolTipContext.append(LineChart.LineElementName).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
                var hoverLine = this.hoverLine = this.toolTipContext.select(LineChart.LineElementName);
                if (this.isInteractiveChart) {
                    hoverLine.classed('interactive', true);
                }
                // define circles object - which will hold the handle circles. 
                // this object will be populated on render() function, with number of circles which matches the nubmer of lines.
                // in init(), this method, we don't have the data yet.
                this.selectionCircles = [];
                var callout = visuals.AxisHelper.ToolTip.createCallout();
                this.element.append(callout);
                hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
                callout.css('opacity', visuals.SVGUtil.AlmostZero);
                var that = this;
                this.xAxisProperties = {
                    axis: null,
                    scale: null,
                    axisType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: null,
                    axisLabel: null,
                    isCategoryAxis: true
                };
                var dragMove = function () {
                    var x = d3.mouse(this)[0];
                    var index = that.findIndex(x);
                    that.selectColumn(index);
                };
                if (this.isInteractiveChart) {
                    // assign drag and onClick events
                    var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                    svg.call(drag);
                    d3.select(this.element.get(0)).call(drag);
                    svg.on('click', dragMove);
                    d3.select(this.element.get(0)).on('click', dragMove);
                }
            };
            LineChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    hasSelection: false,
                    categories: [],
                    categoryMetadata: undefined,
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            var dvCategories = dataViewCat.categories;
                            var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                            if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                                categoryType = dvCategories[0].source.type;
                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.colors, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType), this.interactivityService);
                            this.data = convertedData;
                        }
                    }
                }
            };
            LineChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0 
            };
            LineChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            LineChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var catgSize = endIndex - startIndex;
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = LineChart.sliceSeries(data.series, catgSize, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            LineChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                var data = this.data;
                var viewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
                var categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness;
                var isScalar = this.data.isScalar;
                var preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
                  In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= (margin.left + margin.right);
                }
                preferredPlotArea.height -= (margin.top + margin.bottom);
                this.clippedData = undefined;
                if (data && !isScalar && !this.isScrollable) {
                    // trim data that doesn't fit on dashboard
                    var categoryCount = this.getCategoryCount(origCatgSize);
                    var catgSize = Math.min(origCatgSize, categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = this.clippedData = powerbi.Prototype.inherit(data);
                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize);
                    }
                }
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (data.series && data.series.length > 0) {
                    xMetaDataColumn = data.series[0].xCol;
                    yMetaDataColumn = data.series[0].yCol;
                }
                var valueDomain = visuals.AxisHelper.createValueDomain(data.series, false);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatStringProp: visuals.lineChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    shouldClamp: visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain)
                });
                var xDomain = visuals.AxisHelper.createDomain(data.series, this.xAxisProperties.axisType, this.data.isScalar, options.forcedXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatStringProp: visuals.lineChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: this.data.isScalar,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar),
                    isCategoryAxis: true
                });
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [this.xAxisProperties, this.yAxisProperties];
            };
            LineChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        return this.enumerateDataPoints();
                    case 'labels':
                        return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true);
                }
            };
            LineChart.prototype.enumerateDataPoints = function () {
                var data = this.data;
                if (!data || !data.series || data.series.length === 0)
                    return;
                var instances = [];
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                if (data.hasDynamicSeries) {
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColor(0).value } }
                        },
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesLength > 1;
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        },
                    });
                    if (!showAllDataPoints)
                        return instances;
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                for (var i = 0; i < seriesLength; i++) {
                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector());
                    var label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                    instances.push({
                        objectName: 'dataPoint',
                        displayName: label,
                        selector: selector,
                        properties: {
                            fill: { solid: { color: singleSeriesData[i].color } }
                        },
                    });
                }
                return instances;
            };
            LineChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            LineChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            LineChart.prototype.render = function (duration) {
                if (this.animator)
                    this.renderNew(duration);
                else
                    this.renderOld(duration);
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            LineChart.prototype.renderNew = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = visuals.dataHasSelection(data.series);
                var renderAreas = EnumExtensions.hasFlag(this.lineType, 2 /* area */);
                var area;
                if (renderAreas) {
                    area = d3.svg.area().x(function (d) {
                        return xScale(_this.getXValue(d));
                    }).y0(height).y1(function (d) {
                        return yScale(d.value);
                    }).defined(function (d) {
                        return d.value !== null;
                    });
                }
                var line = d3.svg.line().x(function (d) {
                    return xScale(_this.getXValue(d));
                }).y(function (d) {
                    return yScale(d.value);
                }).defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                var extraLineShift = this.extraLineShift();
                this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.dataLabelsSVG.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight()).attr('width', this.getAvailableWidth());
                this.toolTipContext.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                // Render Areas
                if (renderAreas) {
                    var areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector).data(data.series, function (d) { return d.identity.getKey(); });
                    areas.enter().append(LineChart.PathElementName).classed(LineChart.CategoryAreaClassName, true);
                    areas.style('fill', function (d) { return d.color; }).style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; }).transition().ease('linear').duration(duration).attr('d', function (d) { return area(d.data); });
                    areas.exit().remove();
                }
                // Render Lines
                var lines = this.mainGraphicsContext.selectAll(".line").data(data.series, function (d) { return d.identity.getKey(); });
                lines.enter().append(LineChart.PathElementName).classed('line', true);
                lines.style('stroke', function (d) { return d.color; }).style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); }).transition().ease('linear').duration(duration).attr('d', function (d) {
                    return line(d.data);
                });
                lines.exit().remove();
                // Render extra lines that are wider and invisible used for better interactivity
                var interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function (d) { return d.identity.getKey(); });
                interactivityLines.enter().append(LineChart.PathElementName).classed('interactivity-line', true);
                interactivityLines.attr('d', function (d) {
                    return line(d.data);
                });
                interactivityLines.exit().remove();
                // Prepare grouping for dots
                var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).data(data.series, function (d) { return d.identity.getKey(); });
                dotGroups.enter().append('g').classed(LineChart.CategoryClassName, true);
                dotGroups.exit().remove();
                // Render dots
                var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector).data(function (series) {
                    return series.data.filter(function (value, i) {
                        return _this.shouldDrawCircle(series, i);
                    });
                }, function (d) { return d.key; });
                dots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint.class, true);
                dots.style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                }).style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                }).transition().duration(duration).attr({
                    cx: function (d, i) { return xScale(_this.getXValue(d)); },
                    cy: function (d, i) { return yScale(d.value); },
                    r: LineChart.CircleRadius
                });
                dots.exit().remove();
                // Add data labels
                if (data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getLineChartLabelLayout(xScale, yScale, data.dataLabelsSettings, data.isScalar);
                    var dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, layout, this.currentViewport);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                // Add tooltips
                var seriesTooltipApplier = function (tooltipEvent) {
                    var pointX = tooltipEvent.elementCoordinates[0];
                    return LineChart.getTooltipInfoByPointX(_this, tooltipEvent.data, pointX);
                };
                visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, true);
                if (renderAreas)
                    visuals.TooltipManager.addTooltip(areas, seriesTooltipApplier, true);
                visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                // Register interactivity
                if (this.interactivityService) {
                    var dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    var options = {
                        dataPoints: dataPointsToBind,
                        lines: lines,
                        interactivityLines: interactivityLines,
                        dots: dots,
                        areas: areas,
                        background: d3.selectAll(this.element.toArray()),
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, options);
                }
            };
            LineChart.prototype.renderOld = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = this.data.hasSelection;
                var area;
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    area = d3.svg.area().x(function (d) {
                        return xScale(_this.getXValue(d));
                    }).y0(height).y1(function (d) {
                        return yScale(d.value);
                    }).defined(function (d) {
                        return d.value !== null;
                    });
                }
                var line = d3.svg.line().x(function (d) {
                    return xScale(_this.getXValue(d));
                }).y(function (d) {
                    return yScale(d.value);
                }).defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                var extraLineShift = this.extraLineShift();
                this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.dataLabelsSVG.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight()).attr('width', this.getAvailableWidth());
                this.toolTipContext.attr('transform', visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector).data(data.series, function (d) { return d.identity.getKey(); });
                    var catAreaEnter = catAreaSelect.enter().append('g').classed(LineChart.CategoryAreaClassName, true);
                    catAreaEnter.append(LineChart.PathElementName);
                    var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector);
                    catAreaUpdate.select(LineChart.PathElementName).transition().ease('linear').duration(duration).attr('d', function (d) { return area(d.data); }).style('fill', function (d) { return d.color; }).style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; });
                    catAreaSelect.exit().remove();
                }
                var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).data(data.series, function (d) { return d.identity.getKey(); });
                var catEnter = catSelect.enter().append('g').classed(LineChart.CategoryClassName, true);
                catEnter.append(LineChart.PathElementName);
                catEnter.selectAll(LineChart.CategoryValuePoint.selector).data(function (d) { return d.data; }).enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint.class, true);
                // moving this up to avoid using the svg path generator with NaN values
                // do not move this without validating that no errors are thrown in the browser console
                catSelect.exit().remove();
                // add the drag handle, if needed
                if (this.isInteractiveChart && !this.dragHandle) {
                    var handleTop = this.getAvailableHeight();
                    this.dragHandle = this.toolTipContext.append('circle').attr('cx', 0).attr('cy', handleTop).attr('r', '6px').classed('drag-handle', true);
                }
                // Create the selection circles 
                var linesCount = catSelect.data().length; // number of lines plotted
                while (this.selectionCircles.length < linesCount) {
                    var addedCircle = this.toolTipContext.append(LineChart.CircleElementName).classed(LineChart.CircleClassName, true).attr('r', LineChart.CircleRadius).style('opacity', 0);
                    this.selectionCircles.push(addedCircle);
                }
                while (this.selectionCircles.length > linesCount) {
                    this.selectionCircles.pop().remove();
                }
                var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector);
                var lineSelection = catUpdate.select(LineChart.PathElementName).classed('line', true).style('stroke', function (d) { return d.color; }).style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                lineSelection.transition().ease('linear').duration(duration).attr('d', function (d) {
                    return line(d.data);
                });
                var that = this;
                var updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector);
                var transitions = updateSelection.style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                }).style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                }).transition().duration(duration).attr({
                    'cx': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? xScale(that.getXValue(d)) : 0;
                    },
                    'cy': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? yScale(d.value) : 0;
                    },
                    'r': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? LineChart.CircleRadius : 0;
                    }
                });
                if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                    var selectionSize = updateSelection.size();
                    var endedTransitionCount = 0;
                    transitions.each('end', function () {
                        // When transitions finish, and it's an interactive chart - select the first column (draw the legend and the handle)
                        endedTransitionCount++;
                        if (endedTransitionCount === selectionSize) {
                            _this.selectColumn(0, true);
                        }
                    });
                }
                if (data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getLineChartLabelLayout(xScale, yScale, data.dataLabelsSettings, data.isScalar);
                    var dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, layout, this.currentViewport);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                visuals.TooltipManager.addTooltip(catSelect, function (tooltipEvent) {
                    var pointX = tooltipEvent.elementCoordinates[0];
                    return LineChart.getTooltipInfoByPointX(that, tooltipEvent.data, pointX);
                }, true);
                catSelect.exit().remove();
                if (this.interactivityService) {
                    var dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    var options = {
                        dataPoints: dataPointsToBind,
                        lines: lineSelection,
                        interactivityLines: lineSelection,
                        dots: this.mainGraphicsContext.selectAll(".cat .dot"),
                        areas: catAreaUpdate,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, options);
                }
            };
            // Static for tests
            LineChart.getTooltipInfoByPointX = function (lineChart, pointData, pointX) {
                var index = 0;
                if (lineChart.data.isScalar) {
                    var currentX = powerbi.visuals.AxisHelper.invertScale(lineChart.xAxisProperties.scale, pointX);
                    index = lineChart.findClosestXAxisIndex(currentX, pointData.data);
                }
                else {
                    var scale = lineChart.xAxisProperties.scale;
                    index = visuals.AxisHelper.getOrdinalScaleClosestDataPointIndex(scale, pointX);
                }
                return pointData.data[index].tooltipInfo;
            };
            LineChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.isScalar : false;
            };
            LineChart.prototype.getSupportedCategoryAxisType = function () {
                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : undefined;
                var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                    categoryType = dvCategories[0].source.type;
                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                return isOrdinal ? powerbi.axisType.categorical : powerbi.axisType.both;
            };
            LineChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar);
            };
            LineChart.prototype.getCategoryCount = function (origCatgSize) {
                var availableWidth = this.getAvailableWidth();
                var categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
            };
            LineChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            LineChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            LineChart.sliceSeries = function (series, newLength, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    debug.assert(series[0].data.length >= newLength, "invalid newLength");
                    for (var i = 0, len = series.length; i < len; i++) {
                        newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                    }
                }
                return newSeries;
            };
            LineChart.prototype.extraLineShift = function () {
                if (!this.data.isScalar) {
                    // This will place the line points in the middle of the bands
                    // So they center with Labels when scale is ordinal.
                    var xScale = this.xAxisProperties.scale;
                    if (xScale.rangeBand)
                        return xScale.rangeBand() / 2;
                }
                return 0;
            };
            LineChart.prototype.hasDataPoint = function (series) {
                if (series.length === 0)
                    return false;
                for (var i = 0, len = series.length; i < len; i++) {
                    if (series[i].data.length > 0)
                        return true;
                }
                return false;
            };
            LineChart.prototype.lookupXValue = function (index, type) {
                debug.assertValue(this.data, 'this.data');
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime && this.data.isScalar)
                    return new Date(index);
                if (this.data && this.data.series && this.data.series.length > 0) {
                    var firstSeries = this.data.series[0];
                    if (firstSeries) {
                        var data = firstSeries.data;
                        if (data) {
                            var dataAtIndex = data[index];
                            if (dataAtIndex) {
                                if (isDateTime)
                                    return new Date(dataAtIndex.categoryValue);
                                return dataAtIndex.categoryValue;
                            }
                        }
                    }
                }
                return index;
            };
            LineChart.prototype.getXValue = function (d) {
                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
            };
            /**
              * This checks to see if a data point is isolated, which means
              * the previous and next data point are both null.
              */
            LineChart.prototype.shouldDrawCircle = function (d, i) {
                var dataLength = d.data.length;
                var isLastPoint = i === (dataLength - 1);
                var isFirstPoint = i === 0;
                if (i > dataLength - 1 || d.data[i] === null || d.data[i].value === null)
                    return false;
                if (isFirstPoint && isLastPoint)
                    return true;
                if (isFirstPoint && dataLength > 1 && d.data[i + 1].value === null)
                    return true;
                if (!isFirstPoint && isLastPoint && d.data[i - 1].value === null)
                    return true;
                if (!isFirstPoint && !isLastPoint && d.data[i - 1].value === null && d.data[i + 1].value === null)
                    return true;
                return false;
            };
            // this function updates the hover line and the legend with the selected colums (given by columnIndex).
            LineChart.prototype.selectColumn = function (columnIndex, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === columnIndex)
                    return; // same column, nothing to do here
                this.lastInteractiveSelectedColumnIndex = columnIndex;
                var x = this.getChartX(columnIndex);
                this.setHoverLine(x);
                var legendItems = this.createLegendDataPoints(columnIndex);
                this.options.cartesianHost.updateLegend(legendItems);
            };
            LineChart.prototype.setHoverLine = function (chartX) {
                this.hoverLine.attr('x1', chartX).attr('x2', chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style('opacity', 1);
                var that = this;
                this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).selectAll(LineChart.PathElementName).each(function (series) {
                    var _this = this;
                    // Get the item color for the handle dots
                    var color = series.color;
                    var circleToChange = that.selectionCircles[series.lineIndex];
                    circleToChange.attr({
                        'cx': chartX,
                        'cy': function () {
                            var pathElement = d3.select(_this).node();
                            var pos = that.getPosition(chartX, pathElement);
                            return pos.y;
                        }
                    }).style({
                        'opacity': 1,
                        'fill': color
                    });
                    if (that.dragHandle)
                        that.dragHandle.attr('cx', chartX);
                });
            };
            LineChart.prototype.getChartX = function (columnIndex) {
                var x;
                if (this.data.isScalar) {
                    x = Math.max(0, this.xAxisProperties.scale(this.data.series[0].data[columnIndex].categoryValue));
                }
                else {
                    x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                }
                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                x = Math.min(x, rangeEnd);
                if (isNaN(x)) {
                    return;
                }
                return x;
            };
            // this function finds the index of the category of the given x coordinate given
            LineChart.prototype.findIndex = function (x) {
                x -= (this.margin.left + powerbi.visuals.LineChart.HorizontalShift);
                // Get the x value of the selected position, according to the axis.
                var currentX = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, x);
                var index = currentX;
                if (this.data.isScalar) {
                    index = this.findClosestXAxisIndex(currentX, this.data.series[0].data);
                }
                return index;
            };
            LineChart.prototype.findClosestXAxisIndex = function (currentX, xAxisValues) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                for (var i in xAxisValues) {
                    var distance = Math.abs(currentX - xAxisValues[i].categoryValue);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = i;
                    }
                }
                return closestValueIndex;
            };
            LineChart.prototype.getPosition = function (x, pathElement) {
                var pathLength = pathElement.getTotalLength();
                var pos;
                var beginning = 0, end = pathLength, target;
                while (true) {
                    target = Math.floor((beginning + end) / 2);
                    pos = pathElement.getPointAtLength(target);
                    visuals.SVGUtil.ensureValidSVGPoint(pos);
                    if ((target === end || target === beginning) && pos.x !== x)
                        break;
                    if (pos.x > x)
                        end = target;
                    else if (pos.x < x)
                        beginning = target;
                    else
                        break;
                }
                return pos;
            };
            LineChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data)
                    return null;
                var legendDataPoints = [];
                var category;
                // Category will be the same for all series. This is an optimization.
                if (data.series.length > 0) {
                    var lineDatePointFirstSeries = data.series[0].data[columnIndex];
                    var isDateTime = visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType);
                    var value = (isDateTime && this.data.isScalar) ? lineDatePointFirstSeries.categoryValue : columnIndex;
                    category = lineDatePointFirstSeries && this.lookupXValue(value, this.xAxisProperties.axisType);
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var seriesYCol = null;
                for (var i = 0, len = data.series.length; i < len; i++) {
                    var series = data.series[i];
                    var lineData = series.data;
                    var lineDataPoint = lineData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                    seriesYCol = series.yCol;
                    legendDataPoints.push({
                        color: series.color,
                        icon: 2 /* Line */,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: series.identity,
                        selected: false
                    });
                }
                var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
                var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                return {
                    title: title,
                    dataPoints: legendDataPoints
                };
            };
            LineChart.prototype.accept = function (visitor, options) {
                visitor.visitLineChart(options);
            };
            LineChart.ClassName = 'lineChart';
            LineChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            LineChart.DataLabelsSVGClassName = 'dataLabelsSVG';
            LineChart.CategoryClassName = 'cat';
            LineChart.CategoryClassSelector = '.cat';
            LineChart.CategoryValuePoint = {
                class: 'dot',
                selector: '.dot'
            };
            LineChart.CategoryAreaClassName = 'catArea';
            LineChart.CategoryAreaClassSelector = '.catArea';
            LineChart.HorizontalShift = 0;
            LineChart.CircleRadius = 4;
            LineChart.PathElementName = 'path';
            LineChart.CircleElementName = 'circle';
            LineChart.CircleClassName = 'selection-circle';
            LineChart.LineElementName = 'line';
            LineChart.AreaFillOpacity = 0.4;
            LineChart.DimmedAreaFillOpacity = 0.2;
            return LineChart;
        })();
        visuals.LineChart = LineChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Point = (function () {
            function Point(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x || 0;
                this.y = y || 0;
            }
            return Point;
        })();
        visuals.Point = Point;
        var Rect = (function () {
            // Constructor
            function Rect(left, top, width, height) {
                if (left === void 0) { left = 0; }
                if (top === void 0) { top = 0; }
                if (width === void 0) { width = 0; }
                if (height === void 0) { height = 0; }
                this.left = left || 0;
                this.top = top || 0;
                this.width = width || 0;
                this.height = height || 0;
            }
            return Rect;
        })();
        visuals.Rect = Rect;
        /** Transformation matrix math wrapper */
        var Transform = (function () {
            // Constructor
            function Transform(m) {
                this.matrix = m || {
                    m00: 1,
                    m01: 0,
                    m02: 0,
                    m10: 0,
                    m11: 1,
                    m12: 0,
                };
            }
            // Methods
            Transform.prototype.applyToPoint = function (point) {
                if (!point) {
                    return point;
                }
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12,
                };
            };
            Transform.prototype.applyToRect = function (rect) {
                if (!rect) {
                    return rect;
                }
                var x0 = rect.left;
                var y0 = rect.top;
                var m = this.matrix;
                var isScaled = m.m00 !== 1 || m.m11 !== 1;
                var isRotated = m.m01 !== 0 || m.m10 !== 0;
                if (!isRotated && !isScaled) {
                    // Optimize for the translation only case
                    return { left: x0 + m.m02, top: y0 + m.m12, width: rect.width, height: rect.height };
                }
                var x1 = rect.left + rect.width;
                var y1 = rect.top + rect.height;
                var minX;
                var maxX;
                var minY;
                var maxY;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x);
                    maxX = Math.max(p0x, p1x, p2x, p3x);
                    minY = Math.min(p0y, p1y, p2y, p3y);
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                }
                else {
                    var p0x = m.m00 * x0 + m.m02;
                    var p0y = m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m02;
                    var p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x);
                    maxX = Math.max(p0x, p3x);
                    minY = Math.min(p0y, p3y);
                    maxY = Math.max(p0y, p3y);
                }
                return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
            };
            Transform.prototype.translate = function (xOffset, yOffset) {
                if (xOffset !== 0 || yOffset !== 0) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.scale = function (xScale, yScale) {
                if (xScale !== 1 || yScale !== 1) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.rotate = function (angleInRadians) {
                if (angleInRadians !== 0) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.add = function (other) {
                if (other) {
                    this.matrix = mutliplyMatrices(this.matrix, other.matrix);
                    this._inverse = null;
                }
            };
            Transform.prototype.getInverse = function () {
                if (!this._inverse) {
                    this._inverse = new Transform(createInverseMatrix(this.matrix));
                }
                return this._inverse;
            };
            return Transform;
        })();
        visuals.Transform = Transform;
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1,
                m01: 0,
                m02: xOffset,
                m10: 0,
                m11: 1,
                m12: yOffset,
            };
        }
        visuals.createTranslateMatrix = createTranslateMatrix;
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale,
                m01: 0,
                m02: 0,
                m10: 0,
                m11: yScale,
                m12: 0
            };
        }
        visuals.createScaleMatrix = createScaleMatrix;
        function createRotationMatrix(angleInRads) {
            var a = angleInRads;
            var sinA = Math.sin(a);
            var cosA = Math.cos(a);
            return {
                m00: cosA,
                m01: -sinA,
                m02: 0,
                m10: sinA,
                m11: cosA,
                m12: 0,
            };
        }
        visuals.createRotationMatrix = createRotationMatrix;
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
            var invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        visuals.createInverseMatrix = createInverseMatrix;
        function mutliplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12,
            };
        }
        var defaultLevelOfDetail = 11;
        var MapPolygonInfo = (function () {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            MapPolygonInfo.prototype.reCalc = function (mapControl, width, height) {
                var baseLocations = [this._locationRect.getNorthwest(), this._locationRect.getSoutheast()];
                var width = width / 2.00;
                var height = height / 2.00;
                if (!this._baseRect) {
                    var l0 = powerbi.visuals.BI.Services.MapServices.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
                    var l1 = powerbi.visuals.BI.Services.MapServices.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            };
            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function () {
                    if (this._baseRect) {
                        return this._currentRect.width / this._baseRect.width;
                    }
                    return 1.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    transform.translate(current.left, current.top);
                    transform.scale((current.width / base.width), (current.height / base.height));
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    transform.scale(scale, scale);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.setViewBox = function (svg) {
                var rect = svg.getBoundingClientRect();
                var current = this._currentRect;
                svg.setAttribute("viewBox", [-current.left, -current.top, rect.width, rect.height].join(" "));
            };
            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    var scale = current.width / base.width;
                    transform.scale(scale, scale);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.transformToString = function (transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            };
            return MapPolygonInfo;
        })();
        visuals.MapPolygonInfo = MapPolygonInfo;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BI;
        (function (BI) {
            var Services;
            (function (Services) {
                var GeocodingManager;
                (function (GeocodingManager) {
                    'use strict';
                    GeocodingManager.Settings = {
                        // Maximum Bing requests at once. The Bing have limit how many request at once you can do per socket.
                        MaxBingRequest: 6,
                        // Maximum cache size of cached geocode data.
                        MaxCacheSize: 3000,
                        // Maximum cache overflow of cached geocode data to kick the cache reducing.
                        MaxCacheSizeOverflow: 100,
                        // Bing Keys and URL
                        BingKey: "INSERT KEY",
                        BingUrl: "https://dev.virtualearth.net/REST/v1/Locations?",
                        BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                        // Switch the data result for geodata polygons to by double array instead locations array
                        UseDoubleArrayGeodataResult: true,
                        UseDoubleArrayDequeueTimeout: 0,
                    };
                    GeocodingManager.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
                    // Used for test mockup    
                    GeocodingManager.BingAjaxCall = $.ajax;
                    GeocodingManager.CategoryTypes = {
                        Address: "Address",
                        City: "City",
                        Continent: "Continent",
                        CountryRegion: "Country",
                        County: "County",
                        Longitude: "Longitude",
                        Latitude: "Latitude",
                        Place: "Place",
                        PostalCode: "PostalCode",
                        StateOrProvince: "StateOrProvince"
                    };
                    GeocodingManager.CategoryTypeArray = [
                        "Address",
                        "City",
                        "Continent",
                        "Country",
                        "County",
                        "Longitude",
                        "Latitude",
                        "Place",
                        "PostalCode",
                        "StateOrProvince"
                    ];
                    function isCategoryType(value) {
                        return GeocodingManager.CategoryTypeArray.indexOf(value) > -1;
                    }
                    GeocodingManager.isCategoryType = isCategoryType;
                    GeocodingManager.BingEntities = {
                        Continent: "Continent",
                        Sovereign: "Sovereign",
                        CountryRegion: "CountryRegion",
                        AdminDivision1: "AdminDivision1",
                        AdminDivision2: "AdminDivision2",
                        PopulatedPlace: "PopulatedPlace",
                        Postcode: "Postcode",
                        Postcode1: "Postcode1",
                        Neighborhood: "Neighborhood",
                        Address: "Address",
                    };
                    // Static variables for caching, maps, etc
                    var geocodeQueue;
                    var activeRequests;
                    var categoryToBingEntity;
                    var categoryToBingEntityGeodata;
                    var geocodingCache;
                    var GeocodeQuery = (function () {
                        function GeocodeQuery(query, category) {
                            if (query === void 0) { query = ""; }
                            if (category === void 0) { category = ""; }
                            this.query = query;
                            this.category = category;
                            this.key = (this.query + "/" + this.category).toLowerCase();
                            this._cacheHits = 0;
                            if (!geocodingCache) {
                                geocodingCache = Services.createGeocodingCache(GeocodingManager.Settings.MaxCacheSize, GeocodingManager.Settings.MaxCacheSizeOverflow);
                            }
                        }
                        GeocodeQuery.prototype.incrementCacheHit = function () {
                            this._cacheHits++;
                        };
                        GeocodeQuery.prototype.getCacheHits = function () {
                            return this._cacheHits;
                        };
                        GeocodeQuery.prototype.getBingEntity = function () {
                            var category = this.category.toLowerCase();
                            if (!categoryToBingEntity) {
                                categoryToBingEntity = {};
                                categoryToBingEntity[GeocodingManager.CategoryTypes.Continent.toLowerCase()] = GeocodingManager.BingEntities.Continent;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.CountryRegion.toLowerCase()] = GeocodingManager.BingEntities.Sovereign;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.StateOrProvince.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision1;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.County.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision2;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.City.toLowerCase()] = GeocodingManager.BingEntities.PopulatedPlace;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.PostalCode.toLowerCase()] = GeocodingManager.BingEntities.Postcode;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.Address.toLowerCase()] = GeocodingManager.BingEntities.Address;
                            }
                            return categoryToBingEntity[category] || "";
                        };
                        GeocodeQuery.prototype.getUrl = function () {
                            var url = GeocodingManager.Settings.BingUrl + "key=" + GeocodingManager.Settings.BingKey;
                            var entityType = this.getBingEntity();
                            var queryAdded = false;
                            if (entityType) {
                                if (entityType === GeocodingManager.BingEntities.Postcode) {
                                    url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4";
                                }
                                else if (this.query.indexOf(",") === -1 && (entityType === GeocodingManager.BingEntities.AdminDivision1 || entityType === GeocodingManager.BingEntities.AdminDivision2)) {
                                    queryAdded = true;
                                    url += "&adminDistrict=" + decodeURIComponent(this.query);
                                }
                                else {
                                    url += "&includeEntityTypes=" + entityType;
                                }
                            }
                            if (!queryAdded) {
                                url += "&q=" + decodeURIComponent(this.query);
                            }
                            var cultureName = navigator.userLanguage || navigator["language"];
                            if (cultureName) {
                                url += "&c=" + cultureName;
                            }
                            url += "&maxRes=20";
                            return url;
                        };
                        return GeocodeQuery;
                    })();
                    GeocodingManager.GeocodeQuery = GeocodeQuery;
                    var GeocodeBoundaryQuery = (function (_super) {
                        __extends(GeocodeBoundaryQuery, _super);
                        function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                            if (maxGeoData === void 0) { maxGeoData = 3; }
                            _super.call(this, [latitude, longitude, levelOfDetail, maxGeoData].join(","), category);
                            this.latitude = latitude;
                            this.longitude = longitude;
                            this.levelOfDetail = levelOfDetail;
                            this.maxGeoData = maxGeoData;
                        }
                        GeocodeBoundaryQuery.prototype.getBingEntity = function () {
                            var category = this.category.toLowerCase();
                            if (!categoryToBingEntityGeodata) {
                                categoryToBingEntityGeodata = {};
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.CountryRegion.toLowerCase()] = GeocodingManager.BingEntities.CountryRegion;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.StateOrProvince.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision1;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.County.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision2;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.City.toLowerCase()] = GeocodingManager.BingEntities.PopulatedPlace;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.PostalCode.toLowerCase()] = GeocodingManager.BingEntities.Postcode1;
                            }
                            return categoryToBingEntityGeodata[category] || "";
                        };
                        GeocodeBoundaryQuery.prototype.getUrl = function () {
                            var url = GeocodingManager.Settings.BingUrlGeodata + "key=" + GeocodingManager.Settings.BingKey + "&$format=json";
                            var entityType = this.getBingEntity();
                            if (!entityType) {
                                return null;
                            }
                            var cultureName = navigator.userLanguage || navigator["language"];
                            var cultures = cultureName.split("-");
                            var data = [this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'"];
                            if (cultures.length > 1) {
                                data.push("'" + cultures[1] + "'");
                            }
                            return url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                        };
                        return GeocodeBoundaryQuery;
                    })(GeocodeQuery);
                    GeocodingManager.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
                    function geocodeCore(geocodeQuery) {
                        var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery) : undefined;
                        var deferred = $.Deferred();
                        if (result) {
                            deferred.resolve(result);
                        }
                        else {
                            geocodeQueue.push({ query: geocodeQuery, deferred: deferred });
                            dequeue();
                        }
                        return deferred;
                    }
                    GeocodingManager.geocodeCore = geocodeCore;
                    function geocode(query, category) {
                        if (category === void 0) { category = ""; }
                        return geocodeCore(new GeocodeQuery(query, category));
                    }
                    GeocodingManager.geocode = geocode;
                    function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData) {
                        if (category === void 0) { category = ""; }
                        if (levelOfDetail === void 0) { levelOfDetail = 2; }
                        if (maxGeoData === void 0) { maxGeoData = 3; }
                        return geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData));
                    }
                    GeocodingManager.geocodeBoundary = geocodeBoundary;
                    function dequeue(decrement) {
                        if (decrement === void 0) { decrement = 0; }
                        activeRequests -= decrement;
                        while (activeRequests < GeocodingManager.Settings.MaxBingRequest) {
                            if (geocodeQueue.length === 0) {
                                break;
                            }
                            activeRequests++;
                            makeRequest(geocodeQueue.shift());
                        }
                    }
                    function makeRequest(item) {
                        // Check again if we already got the coordinate;
                        var result = geocodingCache ? geocodingCache.getCoordinates(item.query) : undefined;
                        if (result) {
                            setTimeout(function () { return dequeue(1); });
                            item.deferred.resolve(result);
                            return;
                        }
                        // Unfortunately the Bing service doesn't support CORS, only jsonp. This issue must be raised and revised.
                        // VSTS: 1396088 - Tracking: Ask: Bing geocoding to support CORS
                        var config = {
                            type: "GET",
                            dataType: "jsonp",
                            jsonp: "jsonp"
                        };
                        var url = item.query.getUrl();
                        if (!url) {
                            completeRequest(item, new Error("Unsupported query."));
                        }
                        GeocodingManager.BingAjaxCall(url, config).then(function (data) {
                            try {
                                if (item.query instanceof GeocodeBoundaryQuery) {
                                    var result = data;
                                    if (result && result.d && Array.isArray(result.d.results) && result.d.results.length > 0) {
                                        var entity = result.d.results[0];
                                        var primitives = entity.Primitives;
                                        if (primitives && primitives.length > 0) {
                                            var coordinates = {
                                                latitude: item.query.latitude,
                                                longitude: item.query.longitude,
                                                locations: []
                                            };
                                            primitives.sort(function (a, b) {
                                                if (a.Shape.length < b.Shape.length) {
                                                    return 1;
                                                }
                                                if (a.Shape.length > b.Shape.length) {
                                                    return -1;
                                                }
                                                return 0;
                                            });
                                            var maxGeoData = Math.min(primitives.length, item.query.maxGeoData);
                                            for (var i = 0; i < maxGeoData; i++) {
                                                var ringStr = primitives[i].Shape;
                                                var ringArray = ringStr.split(",");
                                                for (var j = 1; j < ringArray.length; j++) {
                                                    coordinates.locations.push({ nativeBing: ringArray[j] });
                                                }
                                            }
                                            completeRequest(item, null, coordinates);
                                        }
                                        else {
                                            completeRequest(item, new Error("Geocode result is empty."));
                                        }
                                    }
                                    else {
                                        completeRequest(item, new Error("Geocode result is empty."));
                                    }
                                }
                                else {
                                    var resources = data.resourceSets[0].resources;
                                    if (Array.isArray(resources) && resources.length > 0) {
                                        var index = getBestResultIndex(resources, item.query);
                                        var pointData = resources[index].point.coordinates;
                                        var coordinates = {
                                            latitude: parseFloat(pointData[0]),
                                            longitude: parseFloat(pointData[1])
                                        };
                                        completeRequest(item, null, coordinates);
                                    }
                                    else {
                                        completeRequest(item, new Error("Geocode result is empty."));
                                    }
                                }
                            }
                            catch (error) {
                                completeRequest(item, error);
                            }
                        }, function (error) {
                            completeRequest(item, error);
                        });
                    }
                    var dequeueTimeoutId;
                    function completeRequest(item, error, coordinate) {
                        if (coordinate === void 0) { coordinate = null; }
                        dequeueTimeoutId = setTimeout(function () { return dequeue(1); }, GeocodingManager.Settings.UseDoubleArrayGeodataResult ? GeocodingManager.Settings.UseDoubleArrayDequeueTimeout : 0);
                        if (error) {
                            item.deferred.reject(error);
                        }
                        else {
                            if (geocodingCache)
                                geocodingCache.registerCoordinates(item.query, coordinate);
                            item.deferred.resolve(coordinate);
                        }
                    }
                    function getBestResultIndex(resources, query) {
                        var targetEntity = query.getBingEntity().toLowerCase();
                        for (var index = 0; index < resources.length; index++) {
                            var resultEntity = (resources[index].entityType || "").toLowerCase();
                            if (resultEntity === targetEntity) {
                                return index;
                            }
                        }
                        return 0;
                    }
                    function reset() {
                        geocodeQueue = [];
                        activeRequests = 0;
                        categoryToBingEntity = null;
                        clearTimeout(dequeueTimeoutId);
                    }
                    GeocodingManager.reset = reset;
                    reset();
                })(GeocodingManager = Services.GeocodingManager || (Services.GeocodingManager = {}));
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BI;
        (function (BI) {
            var Services;
            (function (Services) {
                var MapServices;
                (function (MapServices) {
                    'use strict';
                    // Bing map min/max boundaries
                    MapServices.MinAllowedLatitude = -85.05112878;
                    MapServices.MaxAllowedLatitude = 85.05112878;
                    MapServices.MinAllowedLongitude = -180;
                    MapServices.MaxAllowedLongitude = 180;
                    MapServices.TileSize = 256;
                    MapServices.MaxLevelOfDetail = 23;
                    MapServices.MinLevelOfDetail = 1;
                    MapServices.MaxAutoZoomLevel = 5;
                    MapServices.DefaultLevelOfDetail = 11;
                    MapServices.WorkerErrorName = "___error___";
                    var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
                    function clip(n, minValue, maxValue) {
                        return Math.min(Math.max(n, minValue), maxValue);
                    }
                    MapServices.clip = clip;
                    function getMapSize(levelOfDetail) {
                        if (levelOfDetail === 23)
                            return 2147483648; //256 << 23 overflow the integer and return a negative value
                        if (Math.floor(levelOfDetail) === levelOfDetail)
                            return 256 << levelOfDetail;
                        return 256 * Math.pow(2, levelOfDetail);
                    }
                    MapServices.getMapSize = getMapSize;
                    // latLongArray is a Float64Array as [lt0, lon0, lat1, long1, lat2, long2,....]
                    // the output is a Float64Array as [x0, y0, x1, y1, x2, y2,....]
                    function latLongToPixelXYArray(latLongArray, levelOfDetail) {
                        var result = new Float64Array(latLongArray.length);
                        for (var i = 0; i < latLongArray.length; i += 2) {
                            var latitude = clip(latLongArray[i], MapServices.MinAllowedLatitude, MapServices.MaxAllowedLatitude);
                            var longitude = clip(latLongArray[i + 1], MapServices.MinAllowedLongitude, MapServices.MaxAllowedLongitude);
                            var x = (longitude + 180) / 360;
                            var sinLatitude = Math.sin(latitude * Math.PI / 180);
                            var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
                            var mapSize = getMapSize(levelOfDetail);
                            result[i] = clip(x * mapSize + 0.5, 0.0, mapSize - 1);
                            result[i + 1] = clip(y * mapSize + 0.5, 0.0, mapSize - 1);
                        }
                        return result;
                    }
                    MapServices.latLongToPixelXYArray = latLongToPixelXYArray;
                    function pointArrayToString(array) {
                        var maxLength = 80000;
                        if (array.length > maxLength) {
                            var result = "";
                            for (var i = 0; i < array.length; i += maxLength) {
                                var array1 = Array.apply([], array.subarray(i, i + maxLength));
                                result += array1.join(" ") + " ";
                            }
                            return result;
                        }
                        return Array.apply([], array).join(" ");
                    }
                    MapServices.pointArrayToString = pointArrayToString;
                    function pointArrayToArray(array) {
                        var maxLength = 80000;
                        var result = [];
                        if (array.length > maxLength) {
                            for (var i = 0; i < array.length; i += maxLength) {
                                var array1 = Array.apply([], array.subarray(i, i + maxLength));
                                result.concat(array1);
                            }
                            return result;
                        }
                        return Array.apply([], array);
                    }
                    MapServices.pointArrayToArray = pointArrayToArray;
                    function getLocationBoundaries(latLongArray) {
                        var northWest = {
                            latitude: -90,
                            longitude: 180
                        };
                        var southEast = {
                            latitude: 90,
                            longitude: -180
                        };
                        for (var i = 0; i < latLongArray.length; i += 2) {
                            northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
                            northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
                            southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
                            southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                        }
                        northWest.longitude = clip(northWest.longitude, -180, 180);
                        southEast.longitude = clip(southEast.longitude, -180, 180);
                        return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
                    }
                    MapServices.getLocationBoundaries = getLocationBoundaries;
                    // this code is taken from Bing.
                    // see Point Compression Algorithm http://msdn.microsoft.com/en-us/library/jj158958.aspx
                    // see Decompression Algorithm in http://msdn.microsoft.com/en-us/library/dn306801.aspx
                    function parseEncodedSpatialValueArray(value) {
                        var list = [];
                        var index = 0;
                        var xsum = 0;
                        var ysum = 0;
                        var max = 4294967296;
                        while (index < value.length) {
                            var n = 0;
                            var k = 0;
                            while (1) {
                                if (index >= value.length) {
                                    return null;
                                }
                                var b = safeCharacters.indexOf(value.charAt(index++));
                                if (b === -1) {
                                    return null;
                                }
                                var tmp = ((b & 31) * (Math.pow(2, k)));
                                var ht = tmp / max;
                                var lt = tmp % max;
                                var hn = n / max;
                                var ln = n % max;
                                var nl = (lt | ln) >>> 0;
                                n = (ht | hn) * max + nl;
                                k += 5;
                                if (b < 32)
                                    break;
                            }
                            var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                            n -= diagonal * (diagonal + 1) / 2;
                            var ny = Math.floor(n);
                            var nx = diagonal - ny;
                            nx = (nx >> 1) ^ -(nx & 1);
                            ny = (ny >> 1) ^ -(ny & 1);
                            xsum += nx;
                            ysum += ny;
                            var lat = ysum * 0.00001;
                            var lon = xsum * 0.00001;
                            list.push(lat);
                            list.push(lon);
                        }
                        return new Float64Array(list);
                    }
                    MapServices.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
                    function calcGeoData(data) {
                        var locations = data.locations;
                        for (var i = 0; i < locations.length; i++) {
                            var location = locations[i];
                            if (!location.geographic) {
                                location.geographic = MapServices.parseEncodedSpatialValueArray(location.nativeBing);
                            }
                            var polygon = location.geographic;
                            if (polygon) {
                                if (!location.absolute) {
                                    location.absolute = MapServices.latLongToPixelXYArray(polygon, MapServices.DefaultLevelOfDetail);
                                    location.absoluteString = MapServices.pointArrayToString(location.absolute);
                                    location.geographicBounds = MapServices.getLocationBoundaries(polygon);
                                    location.absoluteBounds = MapServices.locationRectToRectXY(location.geographicBounds, MapServices.DefaultLevelOfDetail);
                                }
                            }
                        }
                    }
                    MapServices.calcGeoData = calcGeoData;
                    function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                        var array = latLongToPixelXYArray(new Float64Array([latitude, longitude]), levelOfDetail);
                        return new powerbi.visuals.Point(array[0], array[1]);
                    }
                    MapServices.latLongToPixelXY = latLongToPixelXY;
                    function locationToPixelXY(location, levelOfDetail) {
                        return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
                    }
                    MapServices.locationToPixelXY = locationToPixelXY;
                    function locationRectToRectXY(locationRect, levelOfDetail) {
                        var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
                        var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                        return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
                    }
                    MapServices.locationRectToRectXY = locationRectToRectXY;
                    function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                        var mapSize = getMapSize(levelOfDetail);
                        var x = (clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
                        var y = 0.5 - (clip(pixelY, 0, mapSize - 1) / mapSize);
                        var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                        var longitude = 360 * x;
                        return new Microsoft.Maps.Location(latitude, longitude);
                    }
                    MapServices.pixelXYToLocation = pixelXYToLocation;
                })(MapServices = Services.MapServices || (Services.MapServices = {}));
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        (function (LegendIcon) {
            LegendIcon[LegendIcon["Box"] = 0] = "Box";
            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
            LegendIcon[LegendIcon["Line"] = 2] = "Line";
        })(visuals.LegendIcon || (visuals.LegendIcon = {}));
        var LegendIcon = visuals.LegendIcon;
        (function (LegendPosition) {
            LegendPosition[LegendPosition["Top"] = 0] = "Top";
            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
            LegendPosition[LegendPosition["Right"] = 2] = "Right";
            LegendPosition[LegendPosition["Left"] = 3] = "Left";
            LegendPosition[LegendPosition["None"] = 4] = "None";
        })(visuals.LegendPosition || (visuals.LegendPosition = {}));
        var LegendPosition = visuals.LegendPosition;
        visuals.legendProps = {
            show: 'show',
            position: 'position',
            titleText: 'titleText',
            showTitle: 'showTitle',
        };
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
            if (isScrollable === void 0) { isScrollable = false; }
            if (legendPosition === void 0) { legendPosition = 0 /* Top */; }
            if (interactive)
                return new CartesianChartInteractiveLegend(legendParentElement);
            else
                return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
        }
        visuals.createLegend = createLegend;
        function getIconClass(iconType) {
            switch (iconType) {
                case 1 /* Circle */:
                    return 'icon circle';
                case 0 /* Box */:
                    return 'icon tall';
                case 2 /* Line */:
                    return 'icon short';
                default:
                    debug.assertFail('Invalid Chart type: ' + iconType);
            }
        }
        visuals.getIconClass = getIconClass;
        function getLabelMaxSize(currentViewport, numItems, hasTitle) {
            var viewportWidth = currentViewport.width;
            var smallTileWidth = 250;
            var mediumTileWidth = 490;
            var largeTileWidth = 750;
            var tileMargins = 20;
            var legendMarkerWidth = 28;
            var legendItems;
            if (numItems < 1)
                return '48px';
            if (viewportWidth <= smallTileWidth) {
                legendItems = hasTitle ? 4 : 3;
                //Max width based on minimum number of items design of 3 i.e. '48px' or 4 (with title) - '29px' max-width at least   
                return Math.floor((smallTileWidth - tileMargins - (legendMarkerWidth * legendItems)) / Math.min(numItems, legendItems)) + 'px';
            }
            if (viewportWidth <= mediumTileWidth) {
                legendItems = hasTitle ? 6 : 5;
                //Max width based on minimum number of items design of 5 i.e. '66px' or 6 (with title) - '50px' max-width at least  
                return Math.floor((mediumTileWidth - tileMargins - (legendMarkerWidth * legendItems)) / Math.min(numItems, legendItems)) + 'px';
            }
            if (viewportWidth <= largeTileWidth) {
                legendItems = hasTitle ? 8 : 7;
                //Max width based on minimum number of items design of 7 i.e. '76px' or 8 (with title) - '63px' max-width at least
                return Math.floor((largeTileWidth - tileMargins - (legendMarkerWidth * legendItems)) / Math.min(numItems, legendItems)) + 'px';
            }
            //Wide viewport
            legendItems = hasTitle ? 10 : 9;
            return Math.floor((viewportWidth - tileMargins - (legendMarkerWidth * legendItems)) / Math.min(numItems, legendItems)) + 'px';
        }
        visuals.getLabelMaxSize = getLabelMaxSize;
        var SVGLegend = (function () {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                this.svg = d3.select(element.get(0)).insert('svg', ':first-child');
                this.svg.style('display', 'inherit');
                this.svg.classed('legend', true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.interactivityService = interactivityService;
                this.element = element;
                this.changeOrientation(legendPosition);
                this.parentViewport = { height: 0, width: 0 };
                this.calculateViewport();
                this.updateLayout();
            }
            SVGLegend.prototype.updateLayout = function () {
                var viewport = this.viewport;
                var orientation = this.orientation;
                this.svg.attr({
                    'height': viewport.height || (orientation === 4 /* None */ ? 0 : this.parentViewport.height),
                    'width': viewport.width || (orientation === 4 /* None */ ? 0 : this.parentViewport.width)
                });
                this.svg.style({
                    'float': this.getFloat(),
                    'position': orientation === 1 /* Bottom */ ? 'absolute' : '',
                    'bottom': orientation === 1 /* Bottom */ ? '0px' : '',
                });
            };
            SVGLegend.prototype.calculateViewport = function () {
                switch (this.orientation) {
                    case 0 /* Top */:
                    case 1 /* Bottom */:
                        this.viewport = { height: SVGLegend.TopLegendHeight, width: 0 };
                        return;
                    case 2 /* Right */:
                    case 3 /* Left */:
                        this.viewport = { height: 0, width: this.parentViewport.width * SVGLegend.LegendMaxWidthFactor };
                        return;
                    case 4 /* None */:
                        this.viewport = { height: 0, width: 0 };
                }
            };
            SVGLegend.prototype.getFloat = function () {
                switch (this.orientation) {
                    case 2 /* Right */:
                        return 'right';
                    case 3 /* Left */:
                        return 'left';
                    default: return '';
                }
            };
            SVGLegend.prototype.accept = function (visitor, options) {
                visitor.visitLegend(options);
            };
            SVGLegend.prototype.getMargins = function () {
                return this.viewport;
            };
            SVGLegend.prototype.isVisible = function () {
                return this.orientation !== 4 /* None */;
            };
            SVGLegend.prototype.changeOrientation = function (orientation) {
                if (orientation) {
                    this.orientation = orientation;
                }
                else {
                    this.orientation = 0 /* Top */;
                }
                this.svg.attr('orientation', orientation);
            };
            SVGLegend.prototype.getOrientation = function () {
                return this.orientation;
            };
            SVGLegend.prototype.drawLegend = function (data, viewport) {
                var marker = jsCommon.PerformanceUtil.create('drawLegend');
                this.parentViewport = viewport;
                //var dataPoints = data.dataPoints;
                if (data.dataPoints.length === 0) {
                    this.changeOrientation(4 /* None */);
                }
                if (this.getOrientation() === 4 /* None */) {
                    data.dataPoints = [];
                }
                // Adding back the workaround for Legend Left/Right position for Map
                var mapControl = this.element.children(".mapControl");
                if (mapControl.length > 0 && !this.isTopOrBottom(this.orientation)) {
                    mapControl.css("display", "inline-block");
                }
                this.calculateViewport();
                var layout = this.calculateLayout(data);
                var titleLayout = layout.title;
                var titleData = titleLayout ? [titleLayout] : [];
                var legendTitle = this.svg.selectAll(SVGLegend.LegendTitle.selector).data(titleData);
                legendTitle.enter().append('text').style({
                    'font-size': SVGLegend.LegendTitleTextProperties.fontSize,
                    'font-family': SVGLegend.LegendTitleTextProperties.fontFamily
                }).classed(SVGLegend.LegendTitle.class, true);
                legendTitle.text(function (d) { return d.text; }).attr({
                    'x': function (d) { return d.x; },
                    'y': function (d) { return d.y; }
                });
                legendTitle.exit().remove();
                var dataPointsLayout = layout.dataPoints;
                var legendItems = this.svg.selectAll(SVGLegend.LegendItem.selector).data(dataPointsLayout, function (d) { return d.label + d.color; });
                var itemsEnter = legendItems.enter().append('g').classed(SVGLegend.LegendItem.class, true);
                itemsEnter.append('circle').classed(SVGLegend.LegendIcon.class, true);
                itemsEnter.append('title');
                itemsEnter.append('text').classed(SVGLegend.LegendText.class, true).style({
                    'font-size': SVGLegend.LegendTextProperties.fontSize,
                    'font-family': SVGLegend.LegendTextProperties.fontFamily
                });
                legendItems.select(SVGLegend.LegendIcon.selector).attr({
                    'cx': function (d, i) { return d.glyphPosition.x; },
                    'cy': function (d) { return d.glyphPosition.y; },
                    'r': SVGLegend.LegendIconRadius,
                }).style('fill', function (d) {
                    return d.color;
                });
                legendItems.select('title').text(function (d) { return d.tooltip; });
                legendItems.select(SVGLegend.LegendText.selector).attr({
                    'x': function (d) { return d.textPosition.x; },
                    'y': function (d) { return d.textPosition.y; },
                }).text(function (d) { return d.label; });
                if (this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
                    var behaviorOptions = {
                        datapoints: dataPointsLayout,
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                legendItems.exit().remove();
                this.updateLayout();
                marker.end();
            };
            SVGLegend.prototype.calculateTitleLayout = function (title) {
                var width = 0;
                var hasTitle = !jsCommon.StringExtensions.isNullOrEmpty(title);
                if (hasTitle) {
                    var properties = SVGLegend.LegendTextProperties;
                    var text = properties.text = title;
                    var isHorizontal = this.isTopOrBottom(this.orientation);
                    var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                    var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding + fixedHorizontalIconShift;
                    var maxHorizotalSpaceAvaliable = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                    var maxMeasureLength = isHorizontal ? SVGLegend.MaxTitleLength : maxHorizotalSpaceAvaliable;
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    if (width > maxMeasureLength) {
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxMeasureLength);
                        width = maxMeasureLength;
                    }
                    ;
                    if (isHorizontal)
                        width += SVGLegend.TitlePadding;
                    return {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width
                    };
                }
                return null;
            };
            /** Performs layout offline for optimal perfomance */
            SVGLegend.prototype.calculateLayout = function (data) {
                if (data.dataPoints.length === 0) {
                    return {
                        dataPoints: [],
                        title: null,
                    };
                }
                var dataPoints = data.dataPoints;
                var title = this.calculateTitleLayout(data.title);
                var copy = $.extend(true, [], dataPoints);
                if (this.isTopOrBottom(this.orientation))
                    return {
                        dataPoints: this.calculateHorizontalLayout(copy, title),
                        title: title
                    };
                return {
                    dataPoints: this.calculateVerticalLayout(copy, title),
                    title: title
                };
            };
            SVGLegend.prototype.calculateHorizontalLayout = function (dataPoints, title) {
                var fixedTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding;
                var fixedIconShift = 11;
                var fixedTextShift = fixedIconShift + 4;
                var totalSpaceOccupiedThusFar = 0;
                var iconTotalItemPadding = SVGLegend.LegendIconRadius * 2 + SVGLegend.TextAndIconPadding * 3;
                if (title) {
                    totalSpaceOccupiedThusFar = title.width;
                    title.y = fixedTextShift;
                }
                // This bit expands the max lengh if there are only a few items
                // so longer labels can potentially get more space, and not be
                // ellipsed. 
                var dataPointLength = dataPoints.length;
                var parentWidth = this.parentViewport.width;
                var maxTextLength = dataPointLength > 0 ? (((parentWidth - totalSpaceOccupiedThusFar) - (iconTotalItemPadding * dataPointLength)) / dataPointLength) | 0 : 0;
                maxTextLength = maxTextLength > SVGLegend.MaxTextLength ? maxTextLength : SVGLegend.MaxTextLength;
                for (var i = 0; i < dataPointLength; i++) {
                    var dp = dataPoints[i];
                    dp.glyphPosition = {
                        x: totalSpaceOccupiedThusFar + SVGLegend.LegendIconRadius,
                        y: fixedIconShift
                    };
                    dp.textPosition = {
                        x: totalSpaceOccupiedThusFar + fixedTextShift,
                        y: fixedTextShift
                    };
                    var properties = SVGLegend.LegendTextProperties;
                    properties.text = dp.label;
                    dp.tooltip = dp.label;
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var spaceTakenByItem = 0;
                    if (width < maxTextLength) {
                        spaceTakenByItem = iconTotalItemPadding + width;
                    }
                    else {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxTextLength);
                        dp.label = text;
                        spaceTakenByItem = iconTotalItemPadding + maxTextLength;
                    }
                    totalSpaceOccupiedThusFar += spaceTakenByItem;
                    if (totalSpaceOccupiedThusFar > parentWidth) {
                        dataPoints.length = i; // fast trim
                        break;
                    }
                }
                return dataPoints;
            };
            SVGLegend.prototype.calculateVerticalLayout = function (dataPoints, title) {
                var verticalLegendHeight = 20;
                var spaceNeededByTitle = 15;
                var totalSpaceOccupiedThusFar = verticalLegendHeight;
                var extraShiftForTextAlignmentToIcon = 4;
                var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding + fixedHorizontalIconShift;
                var maxHorizotalSpaceAvaliable = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                var maxHorizontalSpaceUsed = 0;
                var parentHeight = this.parentViewport.height;
                if (title) {
                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
                    title.x = SVGLegend.TextAndIconPadding;
                    title.y = spaceNeededByTitle;
                    maxHorizontalSpaceUsed = title.width || 0;
                }
                for (var i = 0, len = dataPoints.length; i < len; i++) {
                    var dp = dataPoints[i];
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: totalSpaceOccupiedThusFar
                    };
                    dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    var properties = SVGLegend.LegendTextProperties;
                    properties.text = dp.label;
                    dp.tooltip = dp.label;
                    // TODO: [PERF] Get rid of this extra measurement, and modify
                    // getTailoredTextToReturnWidth + Text
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    if (width > maxHorizontalSpaceUsed) {
                        maxHorizontalSpaceUsed = width;
                    }
                    if (width > maxHorizotalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxHorizotalSpaceAvaliable);
                        dp.label = text;
                    }
                    totalSpaceOccupiedThusFar += verticalLegendHeight;
                    if (totalSpaceOccupiedThusFar > parentHeight) {
                        dataPoints.length = i; // fast trim
                        break;
                    }
                }
                if ((maxHorizontalSpaceUsed + fixedHorizontalTextShift) < maxHorizotalSpaceAvaliable) {
                    this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth);
                }
                else {
                    this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor);
                }
                return dataPoints;
            };
            SVGLegend.prototype.isTopOrBottom = function (orientation) {
                switch (orientation) {
                    case 0 /* Top */:
                    case 1 /* Bottom */:
                        return true;
                    default:
                        return false;
                }
            };
            SVGLegend.prototype.reset = function () {
                // Intentionally left blank. 
            };
            SVGLegend.LegendIconRadius = 5;
            SVGLegend.MaxTextLength = 60;
            SVGLegend.MaxTitleLength = 80;
            SVGLegend.TextAndIconPadding = 5;
            SVGLegend.TitlePadding = 15;
            SVGLegend.LegendEdgeMariginWidth = 10;
            SVGLegend.LegendMaxWidthFactor = 0.3;
            SVGLegend.TopLegendHeight = 24;
            SVGLegend.LegendTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: '11px'
            };
            SVGLegend.LegendTitleTextProperties = {
                fontFamily: 'wf_segoe-ui_Semibold',
                fontSize: '11px'
            };
            SVGLegend.LegendItem = {
                class: 'legendItem',
                selector: '.legendItem'
            };
            SVGLegend.LegendText = {
                class: 'legendText',
                selector: '.legendText'
            };
            SVGLegend.LegendIcon = {
                class: 'legendIcon',
                selector: '.legendIcon'
            };
            SVGLegend.LegendTitle = {
                class: 'legendTitle',
                selector: '.legendTitle'
            };
            return SVGLegend;
        })();
        var CartesianChartInteractiveLegend = (function () {
            function CartesianChartInteractiveLegend(element) {
                this.element = element;
            }
            CartesianChartInteractiveLegend.getIconClass = function (chartType) {
                switch (chartType) {
                    case 1 /* Circle */:
                    case 0 /* Box */:
                    case 2 /* Line */:
                        return 'icon';
                    default:
                        debug.assertFail('Invalid Chart type: ' + chartType);
                }
            };
            CartesianChartInteractiveLegend.prototype.getMargins = function () {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            };
            CartesianChartInteractiveLegend.prototype.drawLegend = function (legendData) {
                debug.assertValue(legendData, 'legendData');
                var data = legendData.dataPoints;
                debug.assertValue(data, 'dataPoints');
                if (data.length < 1)
                    return;
                var legendContainerDiv = this.legendContainerDiv;
                if (!legendContainerDiv) {
                    if (!data.length)
                        return;
                    var divToPrepend = $('<div></div>').height(this.getMargins().height).addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                    // Prepending, as legend should always be on topmost visual.
                    this.element.prepend(divToPrepend);
                    this.legendContainerDiv = legendContainerDiv = d3.select(divToPrepend.get(0));
                }
                // Construct the legend title and items.
                this.drawTitle(data);
                this.drawLegendItems(data);
            };
            CartesianChartInteractiveLegend.prototype.reset = function () {
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.remove();
                    this.legendContainerDiv = null;
                }
            };
            CartesianChartInteractiveLegend.prototype.isVisible = function () {
                return true;
            };
            CartesianChartInteractiveLegend.prototype.changeOrientation = function (orientation) {
                // Not supported
            };
            CartesianChartInteractiveLegend.prototype.getOrientation = function () {
                return 0 /* Top */;
            };
            /**
             * Draw the legend title
             */
            CartesianChartInteractiveLegend.prototype.drawTitle = function (data) {
                debug.assert(data && data.length > 0, 'data is null or empty');
                var titleDiv = this.legendContainerDiv.selectAll('div.' + CartesianChartInteractiveLegend.LegendTitleClass);
                var item = titleDiv.data([data[0]]);
                // Enter
                var itemEnter = item.enter();
                var titleDivEnter = itemEnter.append('div').attr('class', CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter.filter(function (d) { return d.iconOnlyOnLabel; }).append('span').attr('class', CartesianChartInteractiveLegend.legendIconClass).html(CartesianChartInteractiveLegend.legendPlaceSelector);
                titleDivEnter.append('span');
                // Update
                item.filter(function (d) { return d.iconOnlyOnLabel; }).select('span.' + CartesianChartInteractiveLegend.legendIconClass).style(CartesianChartInteractiveLegend.legendColorCss, function (d) { return d.color; });
                item.select('span:last-child').text(function (d) { return d.category; });
            };
            /**
             * Draw the legend items
             */
            CartesianChartInteractiveLegend.prototype.drawLegendItems = function (data) {
                // Add Mesaures - the items of the category in the legend
                this.ensureLegendTableCreated();
                var dataPointsMatrix = CartesianChartInteractiveLegend.splitArrayToOddEven(data);
                var legendItemsContainer = this.legendContainerDiv.select('tbody').selectAll('tr').data(dataPointsMatrix);
                // trs is table rows. 
                // there are two table rows.
                // the order of insertion to the legend table is:
                // Even data points got inserted into the 1st line
                // Odd data points got inserted into the 2nd line
                // ----------------------------
                // | value0 | value 2 | value 4
                // ----------------------------
                // | value1 | value 3 | 
                // ----------------------------
                // 
                // Enter
                var legendItemsEnter = legendItemsContainer.enter();
                var rowEnter = legendItemsEnter.append('tr');
                var cellEnter = rowEnter.selectAll('td').data(function (d) { return d; }, function (d) { return d.label; }).enter().append('td').attr('class', CartesianChartInteractiveLegend.LegendItem);
                var cellSpanEnter = cellEnter.append('span');
                cellSpanEnter.filter(function (d) { return !d.iconOnlyOnLabel; }).append('span').html(CartesianChartInteractiveLegend.legendPlaceSelector).attr('class', CartesianChartInteractiveLegend.legendIconClass).style('color', function (d) { return d.color; }).attr('white-space', 'nowrap');
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemNameClass);
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemMeasureClass);
                // Update
                var legendCells = legendItemsContainer.selectAll('td').data(function (d) { return d; }, function (d) { return d.label; });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemNameClass).html(function (d) { return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label); });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function (d) { return '&nbsp;' + d.measure; });
                // Exit
                legendCells.exit().remove();
            };
            /**
             * Ensure legend table is created and set horizontal pan gestures on it
             */
            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function () {
                if (this.legendContainerDiv.select('div table').empty()) {
                    var legendTable = this.legendContainerDiv.append('div').append('table');
                    legendTable.style('table-layout', 'fixed').append('tbody');
                    // Setup Pan Gestures of the legend
                    this.setPanGestureOnLegend(legendTable);
                }
            };
            /**
             * Set Horizontal Pan gesture for the legend
             */
            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function (legendTable) {
                var viewportWidth = $(this.legendContainerDiv.select('div:nth-child(2)')[0]).width();
                var xscale = d3.scale.linear().domain([0, viewportWidth]).range([0, viewportWidth]);
                var zoom = d3.behavior.zoom().scaleExtent([1, 1]).x(xscale).on("zoom", function () {
                    // horizontal pan is valid only in case the legend items width are bigger than the viewport width
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate();
                        var tx = t[0];
                        var ty = t[1];
                        tx = Math.min(tx, 0);
                        tx = Math.max(tx, viewportWidth - $(legendTable[0]).width());
                        zoom.translate([tx, ty]);
                        legendTable.style("transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx);
                        });
                    }
                });
                legendTable.call(zoom);
            };
            /**
             * Split legend data points array into odd and even arrays
             * Even array will be the legend first line and Odd array will be the 2nd legend line
             */
            CartesianChartInteractiveLegend.splitArrayToOddEven = function (data) {
                var oddData = [];
                var evenData = [];
                for (var i = 0; i < data.length; ++i) {
                    if (i % 2 === 0) {
                        evenData.push(data[i]);
                    }
                    else {
                        oddData.push(data[i]);
                    }
                }
                return [evenData, oddData];
            };
            CartesianChartInteractiveLegend.LegendHeight = 65;
            CartesianChartInteractiveLegend.LegendContainerClass = 'interactive-legend';
            CartesianChartInteractiveLegend.LegendTitleClass = 'title';
            CartesianChartInteractiveLegend.LegendItem = 'item';
            CartesianChartInteractiveLegend.legendPlaceSelector = '\u25A0';
            CartesianChartInteractiveLegend.legendIconClass = 'icon';
            CartesianChartInteractiveLegend.legendColorCss = 'color';
            CartesianChartInteractiveLegend.legendItemNameClass = 'itemName';
            CartesianChartInteractiveLegend.legendItemMeasureClass = 'itemMeasure';
            return CartesianChartInteractiveLegend;
        })();
        var LegendData;
        (function (LegendData) {
            function update(legendData, legendObject) {
                debug.assertValue(legendData, 'legendData');
                debug.assertValue(legendObject, 'legendObject');
                if (legendObject[visuals.legendProps.show] == null) {
                    legendObject[visuals.legendProps.show] = true;
                }
                if (legendObject[visuals.legendProps.show] === false)
                    legendData.dataPoints = [];
                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null) {
                    legendObject[visuals.legendProps.position] = powerbi.legendPosition.top;
                }
                if (legendObject[visuals.legendProps.showTitle] === false)
                    legendData.title = "";
                else if (legendObject[visuals.legendProps.titleText] !== undefined) {
                    legendData.title = legendObject[visuals.legendProps.titleText];
                }
            }
            LegendData.update = update;
        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.mapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                },
                {
                    name: 'Series',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                },
                {
                    name: 'X',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ]
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                },
                {
                    name: 'Size',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                },
                {
                    name: 'Gradient',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                    },
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 } }
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                                { bind: { to: 'Gradient' } },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 2 } }
                },
            }],
            sorting: {
                custom: {},
            },
        };
        visuals.mapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MapServices = visuals.BI.Services.MapServices;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var MapOneD3DataPointRenderer = (function () {
            function MapOneD3DataPointRenderer() {
                this.values = [];
            }
            MapOneD3DataPointRenderer.prototype.init = function (mapControl) {
                this.mapControl = mapControl;
                var root = this.mapControl.getRootElement();
                root.setAttribute("drag-resize-disabled", "true"); // Enable panning within the maps in IE
                var svg = this.svg = d3.select(root).append('svg').style("position", "absolute"); // Absolute position so that the svg will overlap with the canvas.
                this.clearCatcher = visuals.appendClearCatcher(svg);
                this.bubbleGraphicsContext = svg.append("g").classed("mapBubbles", true);
                this.sliceGraphicsContext = svg.append("g").classed("mapSlices", true);
                this.sliceLayout = d3.layout.pie().sort(null).value(function (d) {
                    return d.value;
                });
                this.arc = d3.svg.arc();
                this.clearMaxDataPointRadius();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
            };
            MapOneD3DataPointRenderer.prototype.addDataPoint = function (dataPoint) {
                this.values.push(dataPoint);
            };
            MapOneD3DataPointRenderer.prototype.clearDataPoints = function () {
                this.values = [];
            };
            MapOneD3DataPointRenderer.prototype.getDataPointCount = function () {
                return this.values.length;
            };
            MapOneD3DataPointRenderer.prototype.getDataPointPadding = function () {
                return this.maxDataPointRadius * 2;
            };
            MapOneD3DataPointRenderer.prototype.clearMaxDataPointRadius = function () {
                this.maxDataPointRadius = 0;
            };
            MapOneD3DataPointRenderer.prototype.setMaxDataPointRadius = function (dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            };
            MapOneD3DataPointRenderer.prototype.beginDataPointUpdate = function (geocodingCategory, dataPointCount) {
                this.values.length = 0;
            };
            MapOneD3DataPointRenderer.prototype.getDefaultMap = function (geocodingCategory, dataPointCount) {
                this.values.length = 0;
            };
            MapOneD3DataPointRenderer.prototype.converter = function (viewPort, dataView, interactivityService, labelSettings) {
                var mapControl = this.mapControl;
                var widthOverTwo = viewPort.width / 2;
                var heightOverTwo = viewPort.height / 2;
                this.svg.style("width", viewPort.width.toString() + "px").style("height", viewPort.width.toString() + "px");
                var strokeWidth = 1;
                //update data label settings
                this.dataLabelsSettings.show = labelSettings.show;
                this.dataLabelsSettings.labelColor = labelSettings.labelColor;
                this.dataLabelsSettings.overrideDefaultColor = labelSettings.overrideDefaultColor;
                // See MapSeriesPresenter::GetDataPointRadius for the PV behavior
                var radiusScale = Math.min(viewPort.width, viewPort.height) / 384;
                this.clearMaxDataPointRadius();
                var bubbleData = [];
                var sliceData = [];
                var formatStringProp = visuals.mapProps.general.formatString;
                for (var i = 0, len = this.values.length; i < len; i++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var canvasDataPoint = this.values[i];
                    var categoryValue = canvasDataPoint.categoryValue;
                    var location = canvasDataPoint.cachedLocation;
                    if (location) {
                        var xy = mapControl.tryLocationToPixel(location);
                        var x = xy.x + widthOverTwo;
                        var y = xy.y + heightOverTwo;
                        var radius = canvasDataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var sliceCount = canvasDataPoint.seriesInfo.sizeValuesForGroup.length;
                        if (sliceCount === 1) {
                            var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                            var value = sizeValueForGroup.value;
                            var index = sizeValueForGroup.index;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                            var mapBubble = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                            bubbleData.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: mapBubble.fill,
                                stroke: mapBubble.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: tooltipInfo,
                                identity: visuals.SelectionId.createWithId(canvasDataPoint.categoryIdentity),
                                selected: false,
                                labelFill: labelSettings.overrideDefaultColor ? labelSettings.labelColor : mapBubble.fill,
                            });
                        }
                        else {
                            var slices = [];
                            for (var j = 0; j < sliceCount; ++j) {
                                var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[j];
                                var value = sizeValueForGroup.value;
                                var index = sizeValueForGroup.index;
                                var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                                var mapSlice = canvasDataPoint.seriesInfo.sizeValuesForGroup[j];
                                slices.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: mapSlice.fill,
                                    stroke: mapSlice.stroke,
                                    strokeWidth: strokeWidth,
                                    value: value,
                                    tooltipInfo: tooltipInfo,
                                    identity: visuals.SelectionId.createWithIds(canvasDataPoint.categoryIdentity, mapSlice.seriesId),
                                    selected: false,
                                    labelFill: labelSettings.labelColor,
                                });
                            }
                            if (interactivityService) {
                                interactivityService.applySelectionStateToData(slices);
                            }
                            sliceData.push(slices);
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(bubbleData);
                }
                return { bubbleData: bubbleData, sliceData: sliceData };
            };
            MapOneD3DataPointRenderer.prototype.updateInternal = function (data) {
                var arc = this.arc;
                var hasSelection = false;
                if (visuals.dataHasSelection(data.bubbleData))
                    hasSelection = true;
                if (!hasSelection) {
                    for (var i = 0, ilen = data.sliceData.length; i < ilen; i++) {
                        if (visuals.dataHasSelection(data.sliceData[i]))
                            hasSelection = true;
                    }
                }
                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function (d) { return d.identity.getKey(); });
                bubbles.enter().append("circle").classed("bubble", true);
                bubbles.attr("cx", function (d) { return d.x; }).attr("cy", function (d) { return d.y; }).attr("r", function (d) { return d.radius; }).style("fill", function (d) { return d.fill; }).style("stroke", function (d) { return d.stroke; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); }).style("strokeWidth", function (d) { return d.strokeWidth; }).style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); }).style("cursor", "default");
                bubbles.exit().remove();
                visuals.TooltipManager.addTooltip(bubbles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var sliceData = data.sliceData;
                var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                sliceContainers.enter().append("g").classed("sliceContainer", true);
                sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout;
                var slices = sliceContainers.selectAll(".slice").data(function (d) {
                    return sliceLayout(d);
                }, function (d) { return d.data.identity.getKey(); });
                slices.enter().append("path").classed("slice", true);
                slices.style("fill", function (t) { return t.data.fill; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); }).style("stroke", function (t) { return t.data.stroke; }).style("strokeWidth", function (t) { return t.data.strokeWidth; }).style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); }).style("cursor", "default").attr("transform", function (t) { return visuals.SVGUtil.translate(t.data.x, t.data.y); }).attr('d', function (t) {
                    return arc.innerRadius(0).outerRadius(function (t) { return t.data.radius; })(t);
                });
                slices.exit().remove();
                if (this.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getMapLabelLayout(this.dataLabelsSettings);
                    var dataPoints = [];
                    for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                        dataPoints.push(sliceData[i][0]);
                    }
                    for (var j = 0, jlen = data.bubbleData.length; j < jlen; j++) {
                        dataPoints.push(data.bubbleData[j]);
                    }
                    var viewPort = { height: this.mapControl.getHeight(), width: this.mapControl.getWidth() };
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.bubbleGraphicsContext, layout, viewPort);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(this.bubbleGraphicsContext);
                }
                visuals.TooltipManager.addTooltip(slices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                var allData = data.bubbleData.slice();
                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                    allData.push.apply(allData, sliceData[i]);
                }
                var behaviorOptions = {
                    bubbles: bubbles,
                    slices: this.sliceGraphicsContext.selectAll("path"),
                    clearCatcher: this.clearCatcher,
                    dataPoints: allData,
                };
                return behaviorOptions;
            };
            return MapOneD3DataPointRenderer;
        })();
        visuals.MapOneD3DataPointRenderer = MapOneD3DataPointRenderer;
        var MapShapeDataPointRenderer = (function () {
            function MapShapeDataPointRenderer() {
                this.values = [];
                this.dataPointCount = 0;
            }
            MapShapeDataPointRenderer.getFilledMapParams = function (category, dataCount) {
                switch (category) {
                    case visuals.BI.Services.GeocodingManager.CategoryTypes.Continent:
                    case visuals.BI.Services.GeocodingManager.CategoryTypes.CountryRegion:
                        if (dataCount < 10) {
                            return { level: 2, maxPolygons: 50, strokeWidth: 0 };
                        }
                        else if (dataCount < 30) {
                            return { level: 2, maxPolygons: 20, strokeWidth: 0 };
                        }
                        return { level: 1, maxPolygons: 3, strokeWidth: 0 };
                    default:
                        if (dataCount < 100) {
                            return { level: 1, maxPolygons: 5, strokeWidth: 6 };
                        }
                        if (dataCount < 200) {
                            return { level: 0, maxPolygons: 5, strokeWidth: 6 };
                        }
                        return { level: 0, maxPolygons: 5, strokeWidth: 0 };
                }
            };
            MapShapeDataPointRenderer.buildPaths = function (locations) {
                var paths = [];
                for (var i = 0; i < locations.length; i++) {
                    var location = locations[i];
                    var polygon = location.geographic;
                    if (polygon.length > 2) {
                        paths.push(location);
                    }
                }
                return paths;
            };
            MapShapeDataPointRenderer.prototype.init = function (mapControl) {
                this.mapControl = mapControl;
                this.polygonInfo = new powerbi.visuals.MapPolygonInfo();
                var root = this.mapControl.getRootElement();
                root.setAttribute('drag-resize-disabled', 'true'); // Enable panning within the maps in IE
                var svg = this.svg = d3.select(root).append('svg').style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
                this.clearCatcher = visuals.appendClearCatcher(svg);
                this.shapeGraphicsContext = svg.append('g').classed('mapShapes', true);
                this.clearMaxShapeDimension();
            };
            MapShapeDataPointRenderer.prototype.beginDataPointUpdate = function (geocodingCategory, dataPointCount) {
                this.geocodingCategory = geocodingCategory;
                this.dataPointCount = dataPointCount;
                this.values = [];
            };
            MapShapeDataPointRenderer.prototype.addDataPoint = function (dataPoint) {
                this.values.push(dataPoint);
            };
            MapShapeDataPointRenderer.prototype.clearDataPoints = function () {
                this.values = [];
            };
            MapShapeDataPointRenderer.prototype.getDataPointCount = function () {
                return this.dataPointCount;
            };
            MapShapeDataPointRenderer.prototype.converter = function (viewport, dataView, interactivityService) {
                this.viewport = viewport;
                this.clearMaxShapeDimension();
                this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.width.toString() + "px");
                var strokeWidth = 1;
                var shapeData = [];
                var formatStringProp = visuals.mapProps.general.formatString;
                for (var categoryIndex = 0, categoryCount = this.values.length; categoryIndex < categoryCount; categoryIndex++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var canvasDataPoint = this.values[categoryIndex];
                    var categoryValue = canvasDataPoint.categoryValue;
                    var location = canvasDataPoint.cachedLocation;
                    if (location) {
                        var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                        var value = sizeValueForGroup.value;
                        var index = sizeValueForGroup.index;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                        var paths = canvasDataPoint.paths;
                        var identity = visuals.SelectionId.createWithId(canvasDataPoint.categoryIdentity);
                        var idKey = identity.getKey();
                        for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                            var path = paths[pathIndex];
                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                            shapeData.push({
                                path: path.absoluteString,
                                fill: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].fill,
                                stroke: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: tooltipInfo,
                                identity: identity,
                                selected: false,
                                key: JSON.stringify({ id: idKey, pIdx: pathIndex }),
                            });
                        }
                    }
                }
                if (interactivityService)
                    interactivityService.applySelectionStateToData(shapeData);
                return { shapeData: shapeData };
            };
            MapShapeDataPointRenderer.prototype.updateInternal = function (data) {
                if (!this.viewport)
                    return;
                var viewport = this.viewport;
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                var hasSelection = visuals.dataHasSelection(data.shapeData);
                var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function (d) { return d.key; });
                shapes.enter().append("polygon").classed("shape", true).attr("points", function (d) {
                    return d.path;
                });
                shapes.style("fill", function (d) { return d.fill; }).style("stroke", function (d) { return d.stroke; }).style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); }).style("strokeWidth", function (d) { return d.strokeWidth; }).style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); }).style("cursor", "default");
                shapes.exit().remove();
                visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var behaviorOptions = {
                    shapes: shapes,
                    clearCatcher: this.clearCatcher,
                    dataPoints: data.shapeData,
                };
                return behaviorOptions;
            };
            MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function () {
                this.maxShapeDimension = 0;
            };
            MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function (width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
                this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            };
            MapShapeDataPointRenderer.prototype.getDataPointPadding = function () {
                return 12;
            };
            return MapShapeDataPointRenderer;
        })();
        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
        var Map = (function () {
            function Map(options) {
                if (options.filledMap) {
                    this.dataPointRenderer = new MapShapeDataPointRenderer();
                    this.enableGeoShaping = true;
                }
                else {
                    this.dataPointRenderer = new MapOneD3DataPointRenderer();
                    this.enableGeoShaping = false;
                }
            }
            Map.prototype.init = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                var element = this.element = options.element;
                this.pendingGeocodingRender = false;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService);
                this.legendHeight = 0;
                this.legendData = { dataPoints: [] };
                this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
                this.host = options.host;
                this.resetBounds();
                jsCommon.ensureMap(function () {
                    Microsoft.Maps.loadModule('Microsoft.Maps.Overlays.Style', {
                        callback: function () {
                            _this.initialize(element[0]);
                        }
                    });
                });
            };
            Map.prototype.addDataPoint = function (dataPoint) {
                var location = dataPoint.cachedLocation;
                this.updateBounds(location.latitude, location.longitude);
                this.dataPointRenderer.addDataPoint(dataPoint);
                this.scheduleRedraw();
            };
            Map.prototype.scheduleRedraw = function () {
                var _this = this;
                if (!this.pendingGeocodingRender && this.mapControl) {
                    this.pendingGeocodingRender = true;
                    setTimeout(function () {
                        _this.updateInternal();
                        _this.pendingGeocodingRender = false;
                    }, 1000);
                }
            };
            Map.prototype.enqueueGeoCode = function (dataPoint) {
                var _this = this;
                visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location) {
                        dataPoint.cachedLocation = location;
                        _this.addDataPoint(dataPoint);
                    }
                });
            };
            Map.prototype.enqueueGeoCodeAndGeoShape = function (dataPoint, params) {
                var _this = this;
                visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location) {
                        dataPoint.cachedLocation = location;
                        _this.enqueueGeoShape(dataPoint, params);
                    }
                });
            };
            Map.prototype.enqueueGeoShape = function (dataPoint, params) {
                var _this = this;
                debug.assertValue(dataPoint.cachedLocation, "cachedLocation");
                visuals.BI.Services.GeocodingManager.geocodeBoundary(dataPoint.cachedLocation.latitude, dataPoint.cachedLocation.longitude, this.geocodingCategory, params.level, params.maxPolygons).then(function (result) {
                    var paths;
                    if (result.locations.length === 0 || result.locations[0].geographic) {
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    else {
                        visuals.BI.Services.MapServices.calcGeoData(result);
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    dataPoint.paths = paths;
                    _this.addDataPoint(dataPoint);
                });
            };
            Map.prototype.getOptimumLevelOfDetail = function (width, height) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (dataPointCount === 0)
                    return MapServices.MinLevelOfDetail;
                var threshold = this.dataPointRenderer.getDataPointPadding();
                for (var levelOfDetail = MapServices.MaxLevelOfDetail; levelOfDetail >= MapServices.MinLevelOfDetail; levelOfDetail--) {
                    var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                    var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
                        // if we have less than 2 data points we should not zoom in "too much"
                        if (dataPointCount < 2)
                            levelOfDetail = Math.min(MapServices.MaxAutoZoomLevel, levelOfDetail);
                        return levelOfDetail;
                    }
                }
                return MapServices.MinLevelOfDetail;
            };
            Map.prototype.getViewCenter = function (levelOfDetail) {
                var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                return MapServices.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2.0, (maxXminY.y + minXmaxY.y) / 2.0, levelOfDetail);
            };
            Map.prototype.resetBounds = function () {
                this.minLongitude = MapServices.MaxAllowedLongitude;
                this.maxLongitude = MapServices.MinAllowedLongitude;
                this.minLatitude = MapServices.MaxAllowedLatitude;
                this.maxLatitude = MapServices.MinAllowedLatitude;
            };
            Map.prototype.updateBounds = function (latitude, longitude) {
                if (longitude < this.minLongitude) {
                    this.minLongitude = longitude;
                }
                if (longitude > this.maxLongitude) {
                    this.maxLongitude = longitude;
                }
                if (latitude < this.minLatitude) {
                    this.minLatitude = latitude;
                }
                if (latitude > this.maxLatitude) {
                    this.maxLatitude = latitude;
                }
            };
            Map.legendObject = function (dataView) {
                return dataView && dataView.metadata && dataView.metadata.objects && dataView.metadata.objects['legend'];
            };
            Map.isLegendHidden = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject != null && legendObject[visuals.legendProps.show] === false;
            };
            Map.legendPosition = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
            };
            Map.isShowLegendTitle = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.showTitle];
            };
            Map.prototype.legendTitle = function () {
                var legendObject = Map.legendObject(this.dataView);
                return (legendObject && legendObject[visuals.legendProps.titleText]) || this.legendData.title;
            };
            Map.prototype.renderLegend = function (legendData) {
                var hideLegend = Map.isLegendHidden(this.dataView);
                var showTitle = Map.isShowLegendTitle(this.dataView);
                var title = this.legendTitle();
                // Update the legendData based on the hide flag.  Cartesian passes in no-datapoints. OnResize reuses the legendData, so this can't mutate.
                var clonedLegendData = {
                    dataPoints: hideLegend ? [] : legendData.dataPoints,
                    grouped: legendData.grouped,
                    title: showTitle ? title : ""
                };
                // Update the orientation to match what's in the dataView
                var targetOrientation = Map.legendPosition(this.dataView);
                if (targetOrientation !== undefined && this.legend.getOrientation() !== targetOrientation) {
                    this.legend.changeOrientation(targetOrientation);
                }
                else {
                    this.legend.changeOrientation(0 /* Top */);
                }
                this.legend.drawLegend(clonedLegendData, this.currentViewport);
            };
            // public for UnitTest
            Map.calculateGroupSizes = function (categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                var categoryCount = categorical.values[0].values.length;
                var seriesCount = grouped.length;
                for (var i = 0, len = categoryCount; i < len; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) {
                        for (var j = 0; j < seriesCount; ++j) {
                            var value = grouped[j].values[sizeMeasureIndex].values[i];
                            if (value) {
                                if (groupTotal === null) {
                                    groupTotal = value;
                                }
                                else {
                                    groupTotal += value;
                                }
                            }
                        }
                    }
                    groupSizeTotals.push(groupTotal);
                    if (groupTotal) {
                        if (!currentValueScale) {
                            currentValueScale = {
                                min: groupTotal,
                                max: groupTotal
                            };
                        }
                        else {
                            currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
                            currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
                        }
                    }
                }
                return currentValueScale;
            };
            // public for UnitTest
            Map.createMapDataPoint = function (group, value, seriesInfo, radius, colors, categoryIdentity) {
                if (seriesInfo && seriesInfo.sizeValuesForGroup && seriesInfo.sizeValuesForGroup.length > 0) {
                    // Not supporting Pies yet
                    var latitude = seriesInfo.latitude;
                    var longitude = seriesInfo.longitude;
                    var dp = {
                        geocodingQuery: group,
                        location: (latitude !== null && longitude !== null) ? new Microsoft.Maps.Location(latitude, longitude) : null,
                        value: value,
                        radius: radius,
                        seriesInfo: seriesInfo,
                        categoryIdentity: categoryIdentity,
                        categoryValue: group
                    };
                    if (dp.geocodingQuery === null && dp.location === null) {
                        // The user should be warned that the data isn't all shown.  Can't geocode null
                        return null;
                    }
                    // Update the location so the remaining code can rely upon the cachedLocation
                    dp.cachedLocation = dp.location;
                    return dp;
                }
                return null;
            };
            Map.calculateSeriesLegend = function (grouped, groupIndex, sizeMeasureIndex, colors, defaultDataPointColor, seriesSource) {
                var seriesCount = grouped.length;
                var legendData = [];
                var colorHelper = new visuals.ColorHelper(colors, visuals.mapProps.dataPoint.fill, defaultDataPointColor);
                for (var i = 0; i < seriesCount; ++i) {
                    var seriesValues = grouped[i];
                    var sizeValueForCategory;
                    var measureQueryName;
                    if (sizeMeasureIndex >= 0) {
                        var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                        sizeValueForCategory = sizeMeasure.values[groupIndex];
                        measureQueryName = sizeMeasure.source.queryName;
                    }
                    else {
                        sizeValueForCategory = null;
                        measureQueryName = '';
                    }
                    if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                        var identity = seriesValues.identity ? visuals.SelectionId.createWithId(seriesValues.identity) : visuals.SelectionId.createNull();
                        var color = seriesSource !== undefined ? colorHelper.getColorForSeriesValue(seriesValues.objects, seriesSource, seriesValues.name) : colorHelper.getColorForMeasure(seriesValues.objects, measureQueryName);
                        legendData.push({
                            color: color,
                            label: visuals.valueFormatter.format(seriesValues.name),
                            icon: 1 /* Circle */,
                            identity: identity,
                            selected: false
                        });
                    }
                }
                return legendData;
            };
            // public for UnitTest
            Map.calculateSeriesInfo = function (grouped, groupIndex, sizeMeasureIndex, longitudeMeasureIndex, latitudeMeasureIndex, colors, defaultDataPointColor, objectsDefinitions, seriesSource) {
                var latitude = null;
                var longitude = null;
                var sizeValuesForGroup = [];
                var seriesCount = grouped.length;
                var colorHelper = new visuals.ColorHelper(colors, visuals.mapProps.dataPoint.fill, defaultDataPointColor);
                for (var i = 0; i < seriesCount; ++i) {
                    var seriesValues = grouped[i];
                    var sizeValueForCategory;
                    var measureQueryName;
                    if (sizeMeasureIndex >= 0) {
                        var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                        sizeValueForCategory = sizeMeasure.values[groupIndex];
                        measureQueryName = sizeMeasure.source.queryName;
                    }
                    else {
                        sizeValueForCategory = null;
                        measureQueryName = '';
                    }
                    var objects = (objectsDefinitions && objectsDefinitions[groupIndex]) || (seriesValues && seriesValues.objects);
                    if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                        var seriesIdentity = grouped[i].identity;
                        var color = seriesSource !== undefined ? colorHelper.getColorForSeriesValue(objects, seriesSource, seriesValues.name) : colorHelper.getColorForMeasure(objects, measureQueryName);
                        var colorRgb = jsCommon.color.parseRgb(color);
                        var stroke = jsCommon.color.rgbToHexString(jsCommon.color.darken(colorRgb, Map.StrokeDarkenColorValue));
                        var fill = jsCommon.color.rgbWithAlphaString(colorRgb, 0.6);
                        sizeValuesForGroup.push({
                            value: sizeValueForCategory,
                            index: i,
                            fill: fill,
                            stroke: stroke,
                            seriesId: seriesIdentity,
                        });
                    }
                    latitude = Map.getOptionalMeasure(seriesValues, latitudeMeasureIndex, groupIndex, latitude);
                    longitude = Map.getOptionalMeasure(seriesValues, longitudeMeasureIndex, groupIndex, longitude);
                }
                return {
                    sizeValuesForGroup: sizeValuesForGroup,
                    latitude: latitude,
                    longitude: longitude
                };
            };
            Map.getOptionalMeasure = function (seriesValues, measureIndex, groupIndex, defaultValue) {
                if (measureIndex >= 0) {
                    var value = seriesValues.values[measureIndex].values[groupIndex];
                    if (value != null)
                        return value;
                }
                return defaultValue;
            };
            // public for UnitTest
            Map.calculateRadius = function (range, rangeDiff, value) {
                var radius = 6;
                if (rangeDiff !== 0) {
                    radius = (14 * ((value - range.min) / rangeDiff)) + 6;
                }
                return radius;
            };
            // public for UnitTest
            Map.getGeocodingCategory = function (categorical, geoTaggingAnalyzerService) {
                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                    // Check categoryString for manually specified information in the model
                    var type = categorical.categories[0].source.type;
                    if (type && type.categoryString) {
                        return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                    }
                    // Check the category name
                    var categoryName = categorical.categories[0].source.displayName;
                    var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                    if (geotaggedResult)
                        return geotaggedResult;
                    // Checking roles for VRM backwards compatibility
                    var roles = categorical.categories[0].source.roles;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var i = 0, len = roleNames.length; i < len; ++i) {
                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                            if (typeFromRoleName)
                                return typeFromRoleName;
                        }
                    }
                }
                return undefined;
            };
            // public for UnitTest
            Map.hasSizeField = function (values, defaultIndexIfNoRole) {
                if (ArrayExtensions.isUndefinedOrEmpty(values))
                    return false;
                for (var i = 0, ilen = values.length; i < ilen; i++) {
                    var roles = values[i].source.roles;
                    // case for Power Q&A since Power Q&A does not assign role to measures.
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric)
                        return true;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
                            var role = roleNames[j];
                            if (role === "Size")
                                return true;
                        }
                    }
                }
                return false;
            };
            // public for UnitTest
            Map.createDefaultValueColumns = function (categorical) {
                var categoryValues = [];
                if (categorical.categories && categorical.categories.length > 0) {
                    for (var i = 0, len = categorical.categories[0].values.length; i < len; i++)
                        categoryValues.push(1);
                }
                var source = {
                    displayName: "col",
                    isMeasure: true,
                    queryName: '',
                    roles: { "Size": true },
                    type: powerbi.ValueType.fromDescriptor({ numeric: true }),
                    isAutoGeneratedColumn: true
                };
                var categoricalValues = [{
                    source: source,
                    values: categoryValues,
                }];
                var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(categorical);
                var hasGradient = gradientMeasureIndex >= 0;
                if (hasGradient) {
                    // Add existing gradient field if exists
                    var gradientColumn = categorical.values[gradientMeasureIndex];
                    categoricalValues.push(gradientColumn);
                }
                return powerbi.data.DataViewTransform.createValueColumns(categoricalValues);
            };
            Map.shouldEnumerateDataPoints = function (dataView, usesSizeForGradient) {
                var hasSeries = visuals.DataRoleHelper.hasRoleInDataView(dataView, 'Series');
                var gradientRole = usesSizeForGradient ? 'Size' : 'Gradient';
                var hasGradientRole = visuals.DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                return hasSeries || !hasGradientRole;
            };
            Map.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        if (Map.shouldEnumerateDataPoints(this.dataView, this.enableGeoShaping))
                            return this.enumerateDataPoints();
                        break;
                    case 'categoryLabels':
                        return visuals.dataLabelUtils.enumerateCategoryLabels(this.dataLabelsSettings, true);
                    case 'legend':
                        return Map.enumerateLegend(this.dataView, this.legend, this.legendTitle());
                }
            };
            Map.prototype.enumerateDataPoints = function () {
                var data = this.legendData;
                var instances = [];
                var hasDynamicSeries = this.hasDynamicSeries;
                var showAllDataPoints = this.showAllDataPoints;
                var seriesLength = data.dataPoints.length;
                instances.push({
                    objectName: 'dataPoint',
                    selector: null,
                    properties: {
                        defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColor(0).value } }
                    },
                });
                var showAllDataPoints = showAllDataPoints !== undefined ? showAllDataPoints : seriesLength > 1;
                instances.push({
                    objectName: 'dataPoint',
                    selector: null,
                    properties: {
                        showAllDataPoints: showAllDataPoints
                    },
                });
                if (!showAllDataPoints)
                    return instances;
                if (hasDynamicSeries) {
                    for (var i = 0; i < data.dataPoints.length; i++) {
                        var dataPoint = data.dataPoints[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: dataPoint.label,
                            selector: dataPoint.identity.getSelector(),
                            properties: {
                                fill: { solid: { color: dataPoint.color } }
                            },
                        });
                    }
                }
                else {
                    //TODO: better way of getting this data
                    var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.interactivityService, this.dataLabelsSettings);
                    var bubbleData = mapData.bubbleData;
                    for (var i = 0; i < bubbleData.length; i++) {
                        var bubbleDataPoint = bubbleData[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: bubbleDataPoint.labeltext,
                            selector: bubbleDataPoint.identity.getSelector(),
                            properties: {
                                fill: { solid: { color: jsCommon.color.rgbaStringToHexString(bubbleDataPoint.fill) } }
                            },
                        });
                    }
                }
                return instances;
            };
            Map.enumerateLegend = function (dataView, legend, legendTitle) {
                return [{
                    selector: null,
                    properties: {
                        show: !Map.isLegendHidden(dataView),
                        position: visuals.LegendPosition[legend.getOrientation()],
                        showTitle: Map.isShowLegendTitle(dataView),
                        titleText: legendTitle
                    },
                    objectName: 'legend'
                }];
            };
            Map.prototype.onDataChanged = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                var dataView = options.dataViews[0];
                this.dataView = dataView;
                var enableGeoShaping = this.enableGeoShaping;
                //Revert Back 
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                this.defaultDataPointColor = null;
                this.showAllDataPoints = null;
                if (dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor);
                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints);
                        var labelsObj = objects['categoryLabels'];
                        if (labelsObj) {
                            this.dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? labelsObj['show'] : this.dataLabelsSettings.show;
                            if (labelsObj['color'] !== undefined) {
                                this.dataLabelsSettings.labelColor = labelsObj['color'].solid.color;
                                this.dataLabelsSettings.overrideDefaultColor = true;
                            }
                        }
                    }
                    var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
                    if (warnings && warnings.length > 0)
                        this.host.setWarnings(warnings);
                    var categorical = dataView.categorical;
                    if (categorical && categorical.categories && categorical.categories.length > 0) {
                        this.resetBounds();
                        var grouped;
                        if (Map.hasSizeField(categorical.values, 0)) {
                            grouped = categorical.values.grouped();
                        }
                        else {
                            var valueColumns = Map.createDefaultValueColumns(categorical);
                            categorical.values = valueColumns;
                            grouped = [{ values: valueColumns }];
                        }
                        var hasDynamicSeries = !!categorical.values.source;
                        this.hasDynamicSeries = hasDynamicSeries;
                        var seriesSource;
                        if (hasDynamicSeries) {
                            seriesSource = categorical.values.identityFields;
                        }
                        else if (categorical.values.length > 0) {
                            seriesSource = categorical.categories[0].identityFields;
                        }
                        var sizeIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size", 0);
                        var longIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                        var latIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                        var groupSizeTotals = [];
                        this.valueScale = null; // Clear scale
                        this.valueScale = Map.calculateGroupSizes(categorical, grouped, groupSizeTotals, sizeIndex, this.valueScale);
                        this.geocodingCategory = Map.getGeocodingCategory(categorical, this.geoTaggingAnalyzerService);
                        var scaleDiff = this.valueScale ? this.valueScale.max - this.valueScale.min : 0;
                        jsCommon.ensureMap(function () {
                            var groupValues = categorical.categories[0].values;
                            var categoryIdentities = dataView.categorical.categories[0].identity;
                            _this.dataPointRenderer.beginDataPointUpdate(_this.geocodingCategory, groupValues.length);
                            var objectDefinitions = dataView.categorical.categories[0].objects;
                            for (var i = 0, ilen = groupValues.length; i < ilen; i++) {
                                var group = groupValues[i];
                                var value = groupSizeTotals[i];
                                var seriesInfo = Map.calculateSeriesInfo(grouped, i, sizeIndex, longIndex, latIndex, _this.colors, _this.defaultDataPointColor, objectDefinitions, seriesSource);
                                var radius = Map.calculateRadius(_this.valueScale, scaleDiff, value);
                                var params;
                                if (enableGeoShaping) {
                                    params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, groupValues.length);
                                }
                                var dp = Map.createMapDataPoint(group, value, seriesInfo, radius, _this.colors, categoryIdentities ? categoryIdentities[i] : undefined);
                                if (dp) {
                                    if (!dp.location) {
                                        if (enableGeoShaping)
                                            _this.enqueueGeoCodeAndGeoShape(dp, params);
                                        else
                                            _this.enqueueGeoCode(dp);
                                    }
                                    else if (enableGeoShaping && !dp.paths) {
                                        _this.enqueueGeoShape(dp, params);
                                    }
                                    else {
                                        _this.addDataPoint(dp);
                                    }
                                }
                            }
                            var legendDataPoints = Map.calculateSeriesLegend(grouped, i, sizeIndex, _this.colors, _this.defaultDataPointColor, seriesSource);
                            if (legendDataPoints.length === 1)
                                legendDataPoints = [];
                            var dvValues = categorical.values;
                            var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                            _this.legendData = { title: title, dataPoints: legendDataPoints };
                            _this.renderLegend(_this.legendData);
                        });
                    }
                    else {
                        this.clearDataPoints();
                    }
                }
                else {
                    this.clearDataPoints();
                }
                this.scheduleRedraw();
            };
            /** Public for UnitTests */
            Map.showLocationMissingWarningIfNecessary = function (dataView) {
                var metadata = dataView.metadata;
                if (metadata && metadata.columns) {
                    var columns = metadata.columns;
                    var foundLocation = false;
                    for (var i = 0; i < columns.length; i++) {
                        if (visuals.DataRoleHelper.hasRole(columns[i], 'Category')) {
                            // Found location
                            foundLocation = true;
                        }
                    }
                    if (!foundLocation) {
                        return [new visuals.NoMapLocationWarning()];
                    }
                }
                return null;
            };
            Map.prototype.onResizing = function (viewport, duration) {
                if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
                    this.currentViewport = viewport;
                    this.renderLegend(this.legendData);
                    this.updateInternal();
                }
            };
            Map.prototype.initialize = function (container) {
                var _this = this;
                var mapOptions = {
                    credentials: visuals.BI.Services.GeocodingManager.Settings.BingKey,
                    showMapTypeSelector: false,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    mapTypeId: Microsoft.Maps.MapTypeId.road,
                    customizeOverlays: true,
                    showDashboard: false,
                    showScalebar: false,
                    disableKeyboardInput: true,
                };
                var divQuery = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                this.mapControl = new Microsoft.Maps.Map(divQuery[0], mapOptions);
                Microsoft.Maps.Events.addHandler(this.mapControl, "viewchange", function () {
                    _this.onViewChanged();
                });
                this.dataPointRenderer.init(this.mapControl);
                if (!this.pendingGeocodingRender) {
                    this.updateInternal();
                }
            };
            Map.prototype.onViewChanged = function () {
                this.updateOffsets();
            };
            Map.prototype.getMapViewPort = function () {
                var currentViewport = this.currentViewport;
                var legendMargins = this.legend.getMargins();
                var mapViewport = {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height,
                };
                return mapViewport;
            };
            Map.prototype.updateInternal = function () {
                if (this.mapControl) {
                    var legendHeight = this.legend.getMargins().height;
                    if (legendHeight <= 1)
                        this.legendData = { dataPoints: [] };
                    var mapDiv = this.element.children(Map.MapContainer.selector);
                    var mapViewport = this.getMapViewPort();
                    mapDiv.height(mapViewport.height);
                    mapDiv.width(mapViewport.width);
                    // With the risk of double drawing, if the position updates to nearly the same, the map control won't call viewchange, so explicitly update the points
                    this.updateOffsets();
                    // Set zoom level after we rendered that map as we need the max size of the bubbles/ pie slices to calculate it
                    var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
                    var center = this.getViewCenter(levelOfDetail);
                    this.mapControl.setView({ center: center, zoom: levelOfDetail, animate: true });
                }
            };
            Map.prototype.updateOffsets = function () {
                var dataView = this.dataView;
                var data;
                if (dataView && dataView.categorical) {
                    // currentViewport may not exist in UnitTests
                    var viewPort = this.getMapViewPort();
                    data = this.dataPointRenderer.converter(viewPort, this.dataView, this.interactivityService, this.dataLabelsSettings);
                }
                else {
                    data = {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: []
                    };
                }
                var behaviorOptions = this.dataPointRenderer.updateInternal(data);
                if (this.interactivityService && behaviorOptions) {
                    this.interactivityService.apply(this, behaviorOptions);
                }
            };
            Map.prototype.accept = function (visitor, options) {
                visitor.visitMap(options);
            };
            Map.prototype.onClearSelection = function () {
                this.interactivityService.clearSelection();
                this.updateOffsets();
            };
            Map.prototype.clearDataPoints = function () {
                this.dataPointRenderer.clearDataPoints();
            };
            Map.MapContainer = {
                cssClass: 'visual mapControl',
                selector: '.visual.mapControl'
            };
            Map.StrokeDarkenColorValue = 255 * 0.25;
            return Map;
        })();
        visuals.Map = Map;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MultiRowCard = (function () {
            function MultiRowCard() {
                this.isCardWrapped = false;
                this.isInteractivityOverflowHidden = false;
            }
            MultiRowCard.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.options = options;
                this.style = options.style;
                var viewport = this.currentViewport = options.viewport;
                var interactivity = this.interactivity = options.interactivity;
                if (interactivity && interactivity.overflow === 'hidden')
                    this.isInteractivityOverflowHidden = true;
                this.settings = MultiRowCard.DefaultStyle;
                var multiRowCardDiv = $('<div/>').addClass(MultiRowCard.multiRowCardClass);
                options.element.append(multiRowCardDiv);
                var element = this.element = multiRowCardDiv;
                element.css('height', this.getPixelString(viewport.height));
                this.initializeCardRowSelection();
            };
            MultiRowCard.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                }
                var resetScrollbarPosition = options.operationKind !== 1 /* Append */;
                this.updateInternal(resetScrollbarPosition);
                this.waitingForData = false;
            };
            MultiRowCard.prototype.onResizing = function (viewport, duration) {
                var viewport = this.currentViewport = viewport;
                this.element.css('height', this.getPixelString(viewport.height));
                this.updateInternal();
            };
            MultiRowCard.converter = function (dataView, columnCount, maxCards, isDashboardVisual) {
                if (isDashboardVisual === void 0) { isDashboardVisual = false; }
                var details = [];
                var tableDataRows = dataView.table.rows;
                var columnMetadata = dataView.table.columns;
                for (var i = 0, len = maxCards; i < len; i++) {
                    var row = tableDataRows[i];
                    var isValuePromoted = undefined;
                    var title = undefined;
                    var cardData = [];
                    for (var j = 0; j < columnCount; j++) {
                        var column = columnMetadata[j];
                        var columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp));
                        // The columnDetail represents column name. In card the column name is shown as details
                        var columnDetail = columnMetadata[j].displayName;
                        //Title is shown only on Canvas and only if there is one Category field.
                        if (!isDashboardVisual && !column.type.numeric) {
                            if (isValuePromoted === undefined) {
                                isValuePromoted = true;
                                title = columnCaption;
                            }
                            else if (isValuePromoted) {
                                isValuePromoted = false;
                            }
                        }
                        cardData.push({
                            caption: columnCaption,
                            details: columnDetail,
                        });
                    }
                    details.push({
                        title: isValuePromoted ? title : undefined,
                        cardItemsData: isValuePromoted ? cardData.filter(function (d) { return d.caption !== title; }) : cardData
                    });
                }
                return details;
            };
            MultiRowCard.prototype.updateInternal = function (resetScrollbarPosition) {
                if (resetScrollbarPosition === void 0) { resetScrollbarPosition = false; }
                var dataView = this.dataView;
                if (!(dataView && dataView.metadata && dataView.table && dataView.table.rows && dataView.table.rows.length > 0 && dataView.table.columns && dataView.table.columns.length > 0)) {
                    this.listView.empty();
                    return;
                }
                this.setCardDimensions();
                var cardHeightTotal = this.cardHeightTotal;
                var dataModel = this.dataModel;
                debug.assertValue(cardHeightTotal, 'cardHeightTotal');
                debug.assert(cardHeightTotal > 0, 'cardHeightTotal should be more than 0');
                this.listView.viewport(this.currentViewport).rowHeight(cardHeightTotal).data(dataModel, function (d) { return dataModel.indexOf(d); }).render(true, resetScrollbarPosition);
            };
            MultiRowCard.prototype.initializeCardRowSelection = function () {
                var _this = this;
                var settings = this.settings;
                var cardHeightTotal = this.cardHeightTotal;
                var rowHeight = this.cardHeight;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var rowEnter = function (rowSelection) {
                    var cardRow = rowSelection.append("div").style({
                        'color': settings.card.color,
                        'overflow-y': 'hidden',
                        'box-sizing': 'border-box',
                    }).classed(MultiRowCard.Card.class, true);
                    // The card top padding is not needed when card items are wrapped as top padding is added to each carditemcontainer when wrapped
                    if (isDashboardVisual) {
                        cardRow.style('padding-top', _this.isCardWrapped ? '0px' : _this.getPixelString(settings.card.topPadding));
                    }
                    else {
                        cardRow.style({
                            'border-left': _this.getPixelString(settings.card.leftBorderWidth) + " " + settings.card.borderStyle,
                            'border-left-color': settings.card.leftBorderColor,
                            'padding-left': _this.getPixelString(settings.card.leftPadding)
                        });
                        if (_this.cardHasTitle) {
                            cardRow.append("div").classed(MultiRowCard.Title.class, true).style({
                                'height': _this.getPixelString(settings.title.height),
                                'margin-bottom': _this.isCardWrapped ? '0px' : _this.getPixelString(settings.title.marginBottom),
                            });
                        }
                    }
                    var cardItem = cardRow.selectAll(MultiRowCard.CardItemContainer.selector).data(function (d) { return d.cardItemsData; }).enter().append('div').classed(MultiRowCard.CardItemContainer.class, true).style({
                        'box-sizing': 'border-box',
                        'height': _this.getPixelString(_this.cardItemContainerHeight),
                        'margin-right': _this.isSingleValueCard ? '0px' : _this.getPixelString(settings.cardItemContainer.marginRight),
                        'float': 'left',
                        // If card is wrapped, padding is added to the itemcontainer as top padding so we don't have to add the bottom padding to the title
                        'padding-top': _this.isCardWrapped ? (isDashboardVisual ? _this.getPixelString(settings.cardItemContainer.topPadding) : _this.getPixelString(settings.cardItemContainer.topPaddingCanvas)) : '0px'
                    });
                    cardItem.append('div').classed(MultiRowCard.Caption.class, true).style({
                        'height': _this.getPixelString(settings.caption.height),
                        'font-size': _this.getPixelString(settings.caption.fontSize),
                        'color': settings.caption.color,
                        'text-align': 'left',
                        'white-space': 'nowrap',
                        'text-overflow': 'ellipsis',
                        'overflow': 'hidden'
                    });
                    cardItem.append('div').classed(MultiRowCard.Details.class, true).style({
                        'height': _this.getPixelString(settings.details.height),
                        'font-size': _this.getPixelString(settings.details.fontSize),
                        'color': settings.details.color,
                        'text-align': 'left',
                        'white-space': 'nowrap',
                        'text-overflow': 'ellipsis',
                        'overflow': 'hidden'
                    });
                };
                var rowUpdate = function (rowSelection) {
                    rowHeight = _this.cardHeight;
                    if (!isDashboardVisual && _this.cardHasTitle)
                        rowSelection.selectAll(MultiRowCard.Title.selector).text(function (d) { return d.title; });
                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector).style({
                        'height': _this.getPixelString(rowHeight),
                        'width': _this.getPixelString(_this.cardWidth)
                    });
                    var cardItemContainerWidth = _this.isSingleValueCard ? _this.columnWidth : _this.columnWidth - settings.cardItemContainer.marginRight;
                    cardSelection.selectAll(MultiRowCard.CardItemContainer.selector).style("width", _this.getPixelString(cardItemContainerWidth));
                    cardSelection.selectAll(MultiRowCard.Caption.selector).text(function (d) { return d.caption; });
                    cardSelection.selectAll(MultiRowCard.Details.selector).text(function (d) { return d.details; });
                    // The last card styling is different in the dashboard 
                    if (isDashboardVisual) {
                        var dataModel = _this.dataModel;
                        if (dataModel && dataModel.length > 0)
                            cardSelection = cardSelection.filter(function (d) { return d !== dataModel[dataModel.length - 1]; });
                        cardSelection.style({
                            'border-bottom-style': settings.card.borderStyle,
                            'border-bottom-width': _this.getPixelString(settings.card.bottomBorderWidth),
                            'border-bottom-color': settings.card.borderColor,
                            'padding-bottom': _this.getPixelString(settings.card.bottomPadding),
                        });
                    }
                    cardSelection.style('margin-bottom', isDashboardVisual ? '0px' : (_this.isSingleRowCard ? '0px' : _this.getPixelString(settings.card.marginBottom)));
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: cardHeightTotal,
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return _this.onLoadMoreData(); },
                    viewport: this.currentViewport,
                    baseContainer: d3.select(this.element.get(0))
                };
                this.listView = visuals.ListViewFactory.createHTMLListView(listViewOptions);
            };
            /**
            * This contains the card column wrapping logic
            * Determines how many columns can be shown per each row inside a Card
            * To place the fields evenly along the card, the width of each card item is calculated based on the available viewport width
            */
            MultiRowCard.prototype.setCardDimensions = function () {
                var dataView = this.dataView;
                debug.assertValue(dataView, 'dataView');
                var columnMetadata = dataView.table.columns;
                var tableRows = dataView.table.rows;
                var viewport = this.currentViewport;
                var settings = this.settings;
                var cardRowColumnCount = 0;
                var maxCardColumns = cardRowColumnCount = columnMetadata.length;
                var viewportWidth = viewport.width;
                this.cardHasTitle = false;
                if (this.isInteractivityOverflowHidden) {
                    if (viewportWidth <= MultiRowCard.SmallTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsSmallTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsSmallTile, maxCardColumns);
                    }
                    else if (viewportWidth <= MultiRowCard.MediumTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsMediumTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsMediumTile, maxCardColumns);
                    }
                    else if (viewportWidth <= MultiRowCard.LargeTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsLargeTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsLargeTile, maxCardColumns);
                    }
                    this.calculateCardDimensions(viewport, cardRowColumnCount, maxCardColumns, tableRows.length);
                    this.dataModel = MultiRowCard.converter(dataView, maxCardColumns, this.maxCardsDisplayed, this.isInteractivityOverflowHidden);
                }
                else {
                    var dataModel = this.dataModel = MultiRowCard.converter(dataView, maxCardColumns, tableRows.length);
                    maxCardColumns = 0;
                    if (dataModel && dataModel.length > 0) {
                        maxCardColumns = dataModel[0].cardItemsData ? dataModel[0].cardItemsData.length : 0;
                        this.cardHasTitle = dataModel[0].title !== undefined;
                        this.isSingleRowCard = dataModel.length === 1 ? true : false;
                    }
                    this.calculateCardDimensions(viewport, maxCardColumns, maxCardColumns, dataModel.length);
                    if (this.cardHasTitle) {
                        var cardHeight = this.cardHeight += settings.title.height + (this.isCardWrapped ? 0 : settings.title.marginBottom);
                        this.cardHeightTotal = this.getTotalCardHeight(cardHeight);
                    }
                }
            };
            MultiRowCard.prototype.calculateCardDimensions = function (viewport, cardRowColumnCount, maxCardColumns, maxCards) {
                var settings = this.settings;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var cardWidth = viewport.width - settings.scrollbar.padding;
                var cardRowColumnCountDisplayed = cardRowColumnCount;
                var cardItemContainerHeight = settings.caption.height + settings.details.height;
                var isCardWrapped = false;
                if (!isDashboardVisual)
                    cardWidth -= (settings.card.leftBorderWidth + settings.card.leftPadding);
                var columnWidth = cardWidth / cardRowColumnCount;
                if (cardRowColumnCount === maxCardColumns) {
                    columnWidth = Math.max(columnWidth, settings.cardItemContainer.maxWidth);
                    columnWidth = Math.min(columnWidth, cardWidth);
                    cardRowColumnCountDisplayed = Math.floor(cardWidth / columnWidth);
                }
                this.isSingleValueCard = cardRowColumnCountDisplayed === 1;
                var totalRowsDisplayed = Math.ceil(maxCardColumns / cardRowColumnCountDisplayed);
                if (totalRowsDisplayed > 1) {
                    cardItemContainerHeight += (isDashboardVisual ? settings.cardItemContainer.topPadding : settings.cardItemContainer.topPaddingCanvas);
                    columnWidth = cardWidth / cardRowColumnCountDisplayed;
                    isCardWrapped = true;
                }
                var cardHeight = Math.ceil(totalRowsDisplayed * cardItemContainerHeight);
                if (isDashboardVisual) {
                    cardHeight += settings.card.bottomBorderWidth + settings.card.bottomPadding + settings.card.topPadding;
                }
                var cardHeightTotal = cardHeight;
                if (isDashboardVisual) {
                    maxCards = Math.min(Math.floor(viewport.height / cardHeight), maxCards);
                }
                else {
                    cardHeightTotal = this.getTotalCardHeight(cardHeight);
                    cardWidth += settings.card.leftBorderWidth + settings.card.leftPadding;
                }
                this.cardHeight = cardHeight;
                this.columnWidth = columnWidth;
                this.cardWidth = cardWidth;
                this.cardHeightTotal = cardHeightTotal;
                this.maxCardsDisplayed = maxCards;
                this.cardItemContainerHeight = cardItemContainerHeight;
                this.isCardWrapped = isCardWrapped;
            };
            MultiRowCard.prototype.getPixelString = function (value) {
                return value + "px";
            };
            MultiRowCard.prototype.onLoadMoreData = function () {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.options.host.loadMoreData();
                    this.waitingForData = true;
                }
            };
            MultiRowCard.prototype.getTotalCardHeight = function (cardHeight) {
                return cardHeight + (this.isSingleRowCard ? 0 : this.settings.card.marginBottom);
            };
            // Public for testability
            MultiRowCard.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            MultiRowCard.multiRowCardClass = 'multiRowCard';
            MultiRowCard.Card = {
                class: 'card',
                selector: '.card'
            };
            MultiRowCard.Title = {
                class: 'title',
                selector: '.title'
            };
            MultiRowCard.CardItemContainer = {
                class: 'cardItemContainer',
                selector: '.cardItemContainer'
            };
            MultiRowCard.Caption = {
                class: 'caption',
                selector: '.caption'
            };
            MultiRowCard.Details = {
                class: 'details',
                selector: '.details'
            };
            MultiRowCard.SmallTileWidth = 250;
            MultiRowCard.MediumTileWidth = 490;
            MultiRowCard.LargeTileWidth = 750;
            /** Cards have specific styling so defined inline styles and also to support theming and improve performance */
            MultiRowCard.DefaultStyle = {
                card: {
                    bottomBorderWidth: 1,
                    leftBorderWidth: 3,
                    borderStyle: 'solid',
                    leftBorderColor: '#A6A6A6',
                    borderColor: '#C8C8C8',
                    bottomPadding: 5,
                    leftPadding: 10,
                    topPadding: 5,
                    color: '#767676',
                    marginBottom: 20
                },
                title: {
                    height: 37,
                    marginBottom: 5,
                },
                cardItemContainer: {
                    marginRight: 20,
                    maxWidth: 100,
                    topPadding: 5,
                    topPaddingCanvas: 7
                },
                caption: {
                    height: 20,
                    fontSize: 14,
                    color: '#333333'
                },
                details: {
                    height: 16,
                    fontSize: 12,
                    color: '#A6A6A6'
                },
                scrollbar: {
                    padding: 8
                },
                cardItems: {
                    maxItemsSmallTile: 4,
                    maxItemsMediumTile: 6,
                    maxItemsLargeTile: 6
                },
                cardRowColumns: {
                    maxRowColumnsSmallTile: 2,
                    maxRowColumnsMediumTile: 3,
                    maxRowColumnsLargeTile: 6
                },
                cards: {
                    maxCardsSmallTile: 1,
                    maxCardsMediumTile: 3,
                    maxCardsLargeTile: 8
                }
            };
            MultiRowCard.capabilities = {
                dataRoles: [
                    {
                        name: 'Values',
                        kind: 2 /* GroupingOrMeasure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
                    }
                ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                        },
                    }
                },
                dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
                suppressDefaultTitle: true,
            };
            return MultiRowCard;
        })();
        visuals.MultiRowCard = MultiRowCard;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Represents a rich text box that supports view & edit mode. */
        var RichTextbox = (function () {
            function RichTextbox() {
            }
            RichTextbox.prototype.init = function (options) {
                this.element = options.element;
                this.host = options.host;
                this.viewPort = options.viewport;
                this.element.addClass('richtextbox');
                this.element.css({
                    'font-family': RichText.defaultFont,
                    'font-size': RichText.defaultFontSize,
                });
                this.readOnly = (this.host.getViewMode() === 0 /* View */);
                this.paragraphs = [];
                this.refreshView();
            };
            RichTextbox.prototype.onResizing = function (viewport, duration) {
                this.viewPort = viewport;
                this.updateSize();
            };
            RichTextbox.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                this.paragraphs = [];
                if (dataViews && dataViews.length > 0) {
                    var objects = dataViews[0].metadata.objects;
                    if (objects && objects.general)
                        this.paragraphs = objects.general.paragraphs;
                }
                this.refreshView();
            };
            RichTextbox.prototype.destroy = function () {
            };
            RichTextbox.prototype.onViewModeChanged = function (viewMode) {
                this.readOnly = (viewMode === 0 /* View */);
                this.refreshView();
            };
            RichTextbox.prototype.setSelection = function (start, end) {
                debug.assertValue(this.editor, 'editor');
                if (this.editor)
                    this.editor.setSelection(start, end);
            };
            RichTextbox.prototype.refreshView = function () {
                var _this = this;
                if (this.readOnly) {
                    // Showing just HTML, no editor.
                    // If we are in view-mode and we have an editor, we can remove it (after saving).
                    if (this.editor) {
                        this.editor.formatUrls();
                        this.saveContents();
                        this.editor = null;
                    }
                    this.element.empty();
                    this.element.append(RichTextbox.convertParagraphsToHtml(this.paragraphs));
                }
                else {
                    // Showing the Quill editor.
                    // If we are in edit-mode and we don't have an editor we need to create it.
                    if (!this.editor) {
                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host);
                        this.editor.textChanged = function (delta, source) { return _this.saveContents(); };
                        this.element.empty();
                        this.element.append(this.editor.getElement());
                    }
                    this.editor.setContents(RichTextbox.convertParagraphsToOps(this.paragraphs));
                }
                this.updateSize();
            };
            RichTextbox.prototype.saveContents = function () {
                // It's possible to get here via a throttled text-changed event after a view-mode change has occured and
                // we are now in view mode. Since we save changes on view-mode change it is safe to ignore this call.
                if (!this.editor)
                    return;
                var contents = this.editor.getContents();
                this.paragraphs = RichTextbox.convertDeltaToParagraphs(contents);
                var changes = [{
                    objectName: 'general',
                    properties: {
                        paragraphs: this.paragraphs
                    },
                    selector: null,
                }];
                this.host.persistProperties(changes);
            };
            RichTextbox.prototype.updateSize = function () {
                if (this.editor)
                    this.editor.resize(this.viewPort);
            };
            RichTextbox.convertDeltaToParagraphs = function (contents) {
                var paragraphs = [];
                var paragraph = { textRuns: [] };
                for (var i = 0, len = contents.ops.length; i < len; i++) {
                    var insertOp = contents.ops[i];
                    debug.assertValue(insertOp, "operation should be an insert");
                    if (typeof insertOp.insert === "string") {
                        // string insert values represent text.
                        var text = insertOp.insert;
                        var attributes = insertOp.attributes;
                        if (attributes && attributes.align) {
                            // Sometimes horizontal alignment is set after the first "insert" of the paragraph, which is likely a bug
                            // in Quill. In any case we should never see different horizontal alignments in a single paragraph.
                            debug.assert(paragraph.horizontalTextAlignment === undefined || paragraph.horizontalTextAlignment === attributes.align, 'paragraph should not have more than one horizontal alignment');
                            paragraph.horizontalTextAlignment = attributes.align;
                        }
                        // Quill gives us back text runs that may have \n's in them. We want to create a new paragraph for each \n we see.
                        var start = 0;
                        var end = 0;
                        var newParagraph;
                        do {
                            end = text.indexOf('\n', start);
                            if (end < 0) {
                                newParagraph = false;
                                end = text.length;
                            }
                            else {
                                newParagraph = true;
                            }
                            if (end - start > 0) {
                                var span = text.substring(start, end);
                                var textRun = { value: span };
                                if (attributes) {
                                    if (attributes.link !== undefined)
                                        textRun.url = attributes.link;
                                    var textStyle = RichTextbox.convertFormatAttributesToTextStyle(attributes);
                                    if (textStyle)
                                        textRun.textStyle = textStyle;
                                }
                                paragraph.textRuns.push(textRun);
                            }
                            // If we actually saw a '\n' then create a new paragraph
                            if (newParagraph) {
                                if (paragraph.textRuns.length === 0)
                                    paragraph.textRuns.push({ value: '' });
                                paragraphs.push(paragraph);
                                paragraph = { textRuns: [] };
                            }
                            start = end + 1;
                        } while (start < text.length);
                    }
                    else {
                        // numeric insert values represent embeds.
                        debug.assertFail("embeds not supported");
                    }
                }
                if (paragraph.textRuns.length > 0) {
                    // Quill appears to always insert an extra '\n' at the end of the text, skip it
                    if (paragraph.textRuns[0].value.length > 0)
                        paragraphs.push(paragraph);
                }
                return paragraphs;
            };
            RichTextbox.convertParagraphsToHtml = function (paragraphs) {
                var $paragraphs = $();
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    var isParagraphEmpty = true;
                    var $paragraph = $('<div>');
                    if (paragraphDef.horizontalTextAlignment)
                        $paragraph.css('text-align', paragraphDef.horizontalTextAlignment);
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var $textRun = $('<span>');
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            var css = {};
                            if (styleDef.fontFamily) {
                                css['font-family'] = RichText.getFontFamily(styleDef.fontFamily);
                            }
                            if (styleDef.fontSize) {
                                css['font-size'] = styleDef.fontSize;
                            }
                            if (styleDef.fontStyle) {
                                css['font-style'] = styleDef.fontStyle;
                            }
                            if (styleDef.fontWeight) {
                                css['font-weight'] = styleDef.fontWeight;
                            }
                            if (styleDef.textDecoration) {
                                css['text-decoration'] = styleDef.textDecoration;
                            }
                            $textRun.css(css);
                        }
                        var text = textRunDef.value;
                        if (!jsCommon.StringExtensions.isNullOrEmpty(text))
                            isParagraphEmpty = false;
                        if (textRunDef.url !== undefined) {
                            var $link = $('<a>').attr('href', textRunDef.url).attr('target', '_blank').text(text);
                            $textRun.append($link);
                        }
                        else {
                            $textRun.text(text);
                        }
                        $paragraph.append($textRun);
                    }
                    // If the entire paragraph is empty we need to make sure we enforce a line-break.
                    if (isParagraphEmpty)
                        $paragraph.append($('<br>'));
                    $paragraphs = $paragraphs.add($paragraph);
                }
                return $paragraphs;
            };
            RichTextbox.convertParagraphsToOps = function (paragraphs) {
                var ops = [];
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var formats = {};
                        if (paragraphDef.horizontalTextAlignment)
                            formats.align = paragraphDef.horizontalTextAlignment;
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                formats.font = RichText.getFontFamily(styleDef.fontFamily);
                            }
                            if (styleDef.fontSize) {
                                formats.size = styleDef.fontSize;
                            }
                            formats.italic = (styleDef.fontStyle === 'italic');
                            formats.bold = (styleDef.fontWeight === 'bold');
                            formats.underline = (styleDef.textDecoration === 'underline');
                        }
                        var text = textRunDef.value;
                        var op = {
                            insert: text,
                            attributes: formats,
                        };
                        ops.push(op);
                        // The last text run of the paragraph needs to end with '\n' to get Quill to handle the text alignment correctly.
                        if (textRunIndex === (jlen - 1) && !jsCommon.StringExtensions.endsWith(text, '\n')) {
                            ops.push({
                                insert: '\n',
                                attributes: formats,
                            });
                        }
                    }
                }
                return ops;
            };
            RichTextbox.convertFormatAttributesToTextStyle = function (attributes) {
                var style = {};
                // NOTE: Align is taken care of when converting to paragraphs.
                if (attributes.bold) {
                    style.fontWeight = 'bold';
                }
                if (attributes.font) {
                    // TODO: "Heading"?
                    style.fontFamily = attributes.font;
                }
                if (attributes.italic) {
                    style.fontStyle = 'italic';
                }
                if (attributes.size) {
                    style.fontSize = attributes.size;
                }
                if (attributes.underline) {
                    style.textDecoration = 'underline';
                }
                /*
                TODO:
                if (attributes.background) {
                }
                if (attributes.color) {
                }
                */
                return style;
            };
            RichTextbox.capabilities = {
                objects: {
                    general: {
                        properties: {
                            paragraphs: {
                                type: {}
                            }
                        }
                    }
                },
                suppressDefaultTitle: true,
            };
            return RichTextbox;
        })();
        visuals.RichTextbox = RichTextbox;
        var RichText;
        (function (RichText) {
            // These fonts are embedded using CSS, or are aliases to other fonts.
            var fontMap = {
                'Segoe (Bold)': 'wf_segoe-ui_bold',
                'Segoe UI': 'wf_segoe-ui_normal',
                'Segoe UI Light': 'wf_segoe-ui_light',
                'Heading': 'wf_segoe-ui_light',
                'Body': 'wf_segoe-ui_normal',
            };
            var fonts = [
                'Arial',
                'Arial Black',
                'Arial Unicode MS',
                'Calibri',
                'Cambria',
                'Cambria Math',
                'Candara',
                'Comic Sans MS',
                'Consolas',
                'Constantia',
                'Corbel',
                'Courier New',
                'Georgia',
                'Lucida Sans Unicode',
                'Segoe (Bold)',
                'Segoe UI',
                'Segoe UI Light',
                'Symbol',
                'Tahoma',
                'Times New Roman',
                'Trebuchet MS',
                'Verdana',
                'Wingdings',
                'Wingdings 2',
                'Wingdings 3',
            ].map(function (font) { return { label: font, value: getFontFamily(font) }; });
            RichText.defaultFont = getFontFamily('Segoe UI Light');
            var fontSizes = [
                '8',
                '9',
                '10',
                '10.5',
                '11',
                '12',
                '14',
                '16',
                '18',
                '20',
                '24',
                '28',
                '32',
                '36',
                '40',
                '42',
                '44',
                '54',
                '60',
                '66',
                '72',
                '80',
                '88',
                '96'
            ].map(function (size) { return { label: size, value: size + 'px' }; });
            RichText.defaultFontSize = '14px';
            var textAlignments = [
                'Left',
                'Center',
                'Right',
            ].map(function (alignment) { return { label: alignment, value: alignment.toLowerCase() }; });
            function getFontFamily(font) {
                var family = fontMap[font];
                return (family !== undefined) ? family : font;
            }
            RichText.getFontFamily = getFontFamily;
            var QuillWrapper = (function () {
                /*
                 * JavaScript and CSS resources are typically resolved asynchronously. This means we potentially defer certain
                 * events which typically occur synchronously until resources are loaded. Setting the global loadQuillResources
                 * flag to true will override this behavior and cause the wrapper to assume these resources are already loaded
                 * and not try to load them asynchronously (e.g. for use in unit tests).
                 */
                function QuillWrapper(readOnly, host) {
                    var _this = this;
                    this.QuillPackage = {
                        javaScriptFiles: QuillWrapper.quillJsFiles,
                        cssFiles: QuillWrapper.quillCssFiles,
                    };
                    this.textChanged = function (d, s) {
                    };
                    this.host = host;
                    this.$container = $('<div>');
                    this.readOnly = readOnly;
                    this.localizationProvider = {
                        get: function (stringId) { return _this.host.getLocalizedString(stringId); }
                    };
                    if (QuillWrapper.loadQuillResources) {
                        // Defer creation of the editor until after resources are loaded.
                        this.initialized = false;
                        this.dependenciesLoaded = $.Deferred();
                        this.dependenciesLoaded.done(function () {
                            _this.rebuildQuillEditor();
                            _this.initialized = true;
                        });
                        jsCommon.requires(this.QuillPackage, function () { return _this.dependenciesLoaded.resolve(); });
                    }
                    else {
                        this.rebuildQuillEditor();
                        this.initialized = true;
                    }
                }
                QuillWrapper.prototype.getElement = function () {
                    return this.$container;
                };
                QuillWrapper.prototype.getToolbar = function () {
                    return this.$toolbarDiv;
                };
                QuillWrapper.prototype.getContents = function () {
                    return this.editor.getContents();
                };
                QuillWrapper.prototype.setContents = function (contents) {
                    var _this = this;
                    // If we haven't loaded the editor yet, defer this call until we do
                    // TODO: prevent these from stacking up?
                    if (!this.initialized) {
                        this.dependenciesLoaded.done(function () { return _this.setContents(contents); });
                        return;
                    }
                    this.editor.setHTML('', 'api'); // Clear contents
                    if (contents)
                        this.editor.setContents(contents, 'api');
                    this.formatUrls();
                };
                QuillWrapper.prototype.resize = function (viewport) {
                    if (!this.initialized)
                        return;
                    this.$container.width(viewport.width);
                    this.$container.height(viewport.height);
                };
                QuillWrapper.prototype.setReadOnly = function (readOnly) {
                    var readOnlyChanged = readOnly !== this.readOnly;
                    this.readOnly = readOnly;
                    if (this.initialized && readOnlyChanged) {
                        this.rebuildQuillEditor();
                    }
                };
                QuillWrapper.prototype.formatUrls = function () {
                    var text = this.editor.getText();
                    var urlRegex = /http[s]?:\/\/(\S)+/gi;
                    // Remove existing links, then find and format all urls in the text.
                    // TODO: This can be a bit expensive, maybe include a cap here for text with many urls?
                    this.editor.formatText(0, text.length, 'link', false, 'api');
                    var matches;
                    while ((matches = urlRegex.exec(text)) !== null) {
                        var url = matches[0];
                        var start = matches.index;
                        var end = urlRegex.lastIndex;
                        this.editor.formatText(start, end, 'link', url, 'api');
                    }
                };
                QuillWrapper.prototype.setSelection = function (start, end) {
                    this.editor.setSelection(start, end, 'api');
                };
                QuillWrapper.prototype.getSelection = function () {
                    return this.editor.getSelection();
                };
                QuillWrapper.prototype.rebuildQuillEditor = function () {
                    var _this = this;
                    // Preserve contents if we already have an editor.
                    var contents = null;
                    if (this.editor) {
                        this.editor.removeAllListeners();
                        contents = this.editor.getContents();
                    }
                    this.$container.empty();
                    // Prevent canvas from handling keyboard shortcuts like ctrl+a that the browser will handle.
                    this.$container.keydown(function (e) { return e.stopPropagation(); });
                    var $editorDiv = this.$editorDiv = $('<div>');
                    // HACK: Quill does not apply the correct default styling if you clear all the content and add new content.
                    $editorDiv.css('font-family', RichText.defaultFont);
                    $editorDiv.css('font-size', RichText.defaultFontSize);
                    var configs = {
                        readOnly: this.readOnly,
                        formats: ['bold', 'italic', 'underline', 'font', 'size', 'link', 'align',],
                    };
                    this.editor = new Quill($editorDiv.get(0), configs);
                    // If not readonly we add a toolbar and disable drag/resize
                    if (!this.readOnly) {
                        var $toolbarDiv = this.$toolbarDiv;
                        if (!$toolbarDiv) {
                            var toolbar = new Toolbar.Toolbar(this.editor, this.localizationProvider);
                            this.$toolbarDiv = $toolbarDiv = toolbar.$container;
                        }
                        $toolbarDiv.addClass('unselectable');
                        this.host.setToolbar($toolbarDiv);
                        this.editor.addModule('toolbar', { container: $toolbarDiv.get(0) });
                        // Disable this so we can select text in the editor.
                        $editorDiv.attr('drag-resize-disabled', 'true');
                    }
                    this.$container.append($editorDiv);
                    if (contents)
                        this.setContents(contents);
                    // Throttle text-changed events to not more frequent than once per 200ms
                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                    this.editor.on('text-change', function (delta, source) {
                        if (source !== 'api')
                            textChangeThrottler.run(function () { return _this.onTextChanged(delta, source); });
                    });
                    // TODO: Actually, probably want something that continually defers until you stop typing, this is probably fine for now though.
                    var formatUrlThrottler = new jsCommon.ThrottleUtility(QuillWrapper.formatUrlThrottle);
                    this.editor.on('text-change', function (delta, source) {
                        if (source !== 'api')
                            formatUrlThrottler.run(function () { return _this.formatUrls(); });
                    });
                    /*
                        Webkit browsers have a bug with regard to focus on div elements
                        with the contenteditable attribute:
    
                        https://bugs.webkit.org/show_bug.cgi?id=38696
    
                        When we blur our rich text box editor the focus remains with the selection
                        instead of the focused element. This allows the user to continue typing as
                        if focus remains within the RichTextbox.
    
                        To fix this issue we add an event listener to the contenteditable div
                        which listens for the 'blur' event and will properly blur our quill
                        editor as well.
    
                        http://quilljs.com/docs/api/#quillprototypesetselection
    
                        Verified in Chrome 43.0.2357.130 m
    
                        In IE10+ the setSelection method explicitly sets focus to the body which
                        causes a bug where the user must click twice when attempting to interact
                        with a <select> element. To prevent this issue we explicitly do not call
                        setSelection to blur if the user is changing focus to a <select> element.
                    */
                    this.editor.root.addEventListener('blur', function (event) {
                        var target = (event.relatedTarget || document.activeElement);
                        if (target && target.tagName === 'SELECT') {
                            return;
                        }
                        _this.setSelection(null, null);
                    }, false);
                    try {
                        this.editor.focus();
                    }
                    catch (e) {
                    }
                };
                QuillWrapper.prototype.onTextChanged = function (delta, source) {
                    this.textChanged(delta, source);
                };
                QuillWrapper.textChangeThrottle = 200; // ms
                QuillWrapper.formatUrlThrottle = 1000; // ms
                QuillWrapper.loadQuillResources = true;
                // TODO: How to choose between minified/unminified?
                // TODO: Consider loading this from the CDN.
                QuillWrapper.quillJsFiles = [powerbi.build + '/externals/quill.min.js'];
                QuillWrapper.quillCssFiles = [powerbi.build + '/externals/quill.base.css'];
                return QuillWrapper;
            })();
            RichText.QuillWrapper = QuillWrapper;
            var Toolbar;
            (function (_Toolbar) {
                function setSelectValue($select, value) {
                    $select.val(value);
                    // NOTE: The 'change' event is not raised when the value of the SELECT element is changed programatically,
                    // and Quill uses it's own, non-JQuery, method to hook up to the 'change' event, therefore, we need to dispatch
                    // this event manually on the SELECT element.
                    var evt = document.createEvent('UIEvent');
                    evt.initUIEvent('change', false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                _Toolbar.setSelectValue = setSelectValue;
                function formatGroup() {
                    return span().addClass('ql-format-group').attr('drag-resize-disabled', 'true');
                }
                function label(text) {
                    return $('<label>').text(text);
                }
                function div() {
                    return $('<div>');
                }
                function span() {
                    return $('<span>');
                }
                var Toolbar = (function () {
                    function Toolbar(editor, localizationProvider) {
                        this.localizationProvider = localizationProvider;
                        var fontPicker = this.picker('Font', fonts, 'font', RichText.defaultFont, 
                        // Show the fonts in their own font face.
                        function ($option, option) {
                            $option.css('font-family', option.value);
                            return $option;
                        });
                        this.$container = div().addClass('toolbar ql-toolbar').append(formatGroup().append(label(localizationProvider.get('RichTextbox_Font_Label'))).append(fontPicker).append(this.picker('Size', fontSizes, 'size', RichText.defaultFontSize))).append(formatGroup().append(this.formatButton(this.getLocalizationString('Bold'), 'bold')).append(this.formatButton(this.getLocalizationString('Italic'), 'italic')).append(this.formatButton(this.getLocalizationString('Underline'), 'underline'))).append(formatGroup().append(this.toggleGroup('Text Alignment', textAlignments, 'align', 'Left')));
                    }
                    Toolbar.prototype.toggleGroup = function (title, list, format, defaultValue) {
                        var _this = this;
                        var $group = span().attr('localize-tooltip', this.getLocalizationString(title)).addClass('ql-toggle-group');
                        // Hidden selector that Quill will use to hook up change listeners.
                        var $select = this.selector(title, list, defaultValue).addClass('ql-picker ql-' + format).css('display', 'none');
                        var $buttons = list.map(function (option) {
                            var $button = _this.formatButton(_this.getLocalizationString(option.label)).attr('data-value', option.value).click(function (e) { return setSelectValue($select, option.value); });
                            return $button;
                        });
                        // Quill will change the value of the selector when the text selection changes, so we need to set the state of the buttons to match.
                        $select.change(function (e) {
                            var newValue = $select.val();
                            for (var i = 0; i < $buttons.length; i++) {
                                $buttons[i].toggleClass('ql-active', $buttons[i].attr('data-value') === newValue);
                            }
                        });
                        $group.append($select);
                        $group.append($buttons);
                        return $group;
                    };
                    Toolbar.prototype.picker = function (title, list, format, defaultValue, optionModifier) {
                        var $selector = this.selector(title, list, defaultValue, optionModifier).addClass('ql-picker ql-' + format);
                        return $selector;
                    };
                    Toolbar.prototype.selector = function (title, list, defaultValue, optionModifier) {
                        var $selector = $('<select>').attr('localize-tooltip', this.getLocalizationString(title));
                        for (var i = 0; i < list.length; i++) {
                            var option = list[i];
                            var $option = $('<option>').attr('value', option.value).text(option.label);
                            if (option.value === defaultValue)
                                $option.attr('selected', 'selected');
                            if (optionModifier !== undefined)
                                $option = optionModifier($option, option);
                            $selector.append($option);
                        }
                        return $selector;
                    };
                    Toolbar.prototype.formatButton = function (tooltip, format) {
                        var $button = span().addClass('ql-format-button');
                        if (tooltip != null)
                            $button.attr('localize-tooltip', tooltip);
                        if (format != null)
                            $button.addClass('ql-' + format);
                        // Swallow this so that mouse down on a button does not steal selection from the editor.
                        $button.on('selectstart', function () { return false; });
                        return $button;
                    };
                    Toolbar.prototype.getLocalizationString = function (title) {
                        return 'RichTextbox_' + title + '_ToolTip';
                    };
                    return Toolbar;
                })();
                _Toolbar.Toolbar = Toolbar;
            })(Toolbar || (Toolbar = {}));
        })(RichText = visuals.RichText || (visuals.RichText = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: 'dataPoint',
                    propertyName: 'defaultColor'
                },
                fill: {
                    objectName: 'dataPoint',
                    propertyName: 'fill'
                },
            },
        };
        var CheerMeter = (function () {
            function CheerMeter() {
                this.isFirstTime = true;
            }
            CheerMeter.converter = function (dataView) {
                var catValues = dataView.categorical.categories[0].values;
                var values = dataView.categorical.values[0].values;
                var objects = dataView.categorical.categories[0].objects;
                var color1 = powerbi.DataViewObjects.getFillColor(objects[0], visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var color2 = powerbi.DataViewObjects.getFillColor(objects[1], visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2
                    }
                };
                return data;
            };
            CheerMeter.prototype.init = function (options) {
                var svg = this.svg = d3.select(options.element.get(0)).append('svg');
                this.textOne = svg.append('text').style('font-family', CheerMeter.DefaultFontFamily);
                this.textTwo = svg.append('text').style('font-family', CheerMeter.DefaultFontFamily);
            };
            CheerMeter.prototype.onResizing = function (viewport, duration) {
            };
            CheerMeter.prototype.onDataChanged = function (options) {
            };
            CheerMeter.prototype.update = function (options) {
                var data = CheerMeter.converter(options.dataViews[0]);
                this.draw(data, options.duration, options.viewport);
            };
            CheerMeter.prototype.getRecomendedFontProperties = function (text1, text2, parentViewport) {
                var textProperties = {
                    fontSize: '',
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                };
                var min = 1;
                var max = 1000;
                var i;
                var maxWidth = parentViewport.width;
                var width = 0;
                while (min <= max) {
                    i = (min + max) / 2 | 0;
                    textProperties.fontSize = i + 'px';
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (maxWidth > width)
                        min = i + 1;
                    else if (maxWidth < width)
                        max = i - 1;
                    else
                        break;
                }
                textProperties.fontSize = i + 'px';
                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (width > maxWidth) {
                    i--;
                    textProperties.fontSize = i + 'px';
                }
                return textProperties;
            };
            CheerMeter.prototype.calculateLayout = function (data, viewport) {
                var text1 = data.teamA.name;
                var text2 = data.teamB.name;
                var avaliableViewport = { height: viewport.height, width: viewport.width - CheerMeter.PaddingBetweenText };
                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                recomendedFontProperties.text = text2;
                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                var padding = ((viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2) | 0;
                debug.assert(padding > 0, 'padding');
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = (powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties)) | 0;
                var max = 100;
                var availableHeight = viewport.height - offsetHeight;
                var y1 = (((max - data.teamA.value) / max) * availableHeight + offsetHeight / 2) | 0;
                var y2 = (((max - data.teamB.value) / max) * availableHeight + offsetHeight / 2) | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            };
            CheerMeter.prototype.ensureStartState = function (layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = false;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        'x': layout.x1,
                        'y': startY
                    });
                    this.textTwo.attr({
                        'x': layout.x2,
                        'y': startY
                    });
                }
            };
            CheerMeter.prototype.draw = function (data, duration, viewport) {
                var easeName = 'back';
                var textOne = this.textOne;
                var textTwo = this.textTwo;
                this.svg.attr({
                    'height': viewport.height,
                    'width': viewport.width
                }).style('background-color', CheerMeter.DefaultBackgroundColor);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport);
                textOne.style('font-size', layout.fontSize).style('fill', data.teamA.color).text(data.teamA.name);
                textTwo.style('fill', data.teamB.color).style('font-size', layout.fontSize).text(data.teamB.name);
                textOne.transition().duration(duration).ease(easeName).attr({
                    y: layout.y1,
                    x: layout.x1
                });
                textTwo.transition().duration(duration).ease(easeName).attr({
                    y: layout.y2,
                    x: layout.x2
                });
            };
            CheerMeter.prototype.destroy = function () {
                this.svg = null;
                this.textOne = this.textTwo = null;
            };
            CheerMeter.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: 0 /* Grouping */,
                    },
                    {
                        name: 'Y',
                        kind: 1 /* Measure */,
                    },
                ],
                dataViewMappings: [{
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                    },
                }],
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
            };
            CheerMeter.DefaultFontFamily = 'cursive';
            CheerMeter.DefaultFontColor = 'rgb(165, 172, 175)';
            CheerMeter.DefaultBackgroundColor = '#243C18';
            CheerMeter.PaddingBetweenText = 15;
            return CheerMeter;
        })();
        visuals.CheerMeter = CheerMeter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scatterChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                },
                {
                    name: 'Series',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                },
                {
                    name: 'X',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                },
                {
                    name: 'Size',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                },
                {
                    name: 'Gradient',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                }
            ],
            objects: {
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            type: { numeric: true }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            type: { numeric: true }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { formatting: { yAxisPosition: true } }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            type: { numeric: true }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            type: { numeric: true }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                    },
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 } },
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                        dataReductionAlgorithm: { sample: {} }
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                                { bind: { to: 'Gradient' } },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 2 } }
                },
            }],
            sorting: {
                custom: {},
            },
        };
        visuals.scatterChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ScatterChart = (function () {
            function ScatterChart(options) {
                this.interactivityService = options.interactivityService;
            }
            ScatterChart.prototype.init = function (options) {
                this.options = options;
                var element = this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.host = options.host;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                element.addClass(ScatterChart.ClassName);
                var svg = this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsG = svg.append('g').classed(ScatterChart.MainGraphicsContextClassName, true);
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.dataLabelsContext = this.mainGraphicsG.append('g').classed(ScatterChart.DataLabelsContextClassName, true);
            };
            ScatterChart.converter = function (dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities;
                var dataViewCategorical = dataView.categorical;
                var dataViewMetadata = dataView.metadata;
                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                    categoryValues = dataViewCategorical.categories[0].values;
                    categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
                    categoryIdentities = dataViewCategorical.categories[0].identity;
                    categoryObjects = dataViewCategorical.categories[0].objects;
                }
                else {
                    categoryValues = [null];
                }
                var categories = dataViewCategorical.categories;
                var dataValues = dataViewCategorical.values;
                var hasDynamicSeries = !!dataValues.source;
                var grouped = dataValues.grouped();
                var dvSource = dataValues.source;
                var scatterMetadata = ScatterChart.getMetadata(grouped, dvSource);
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects['categoryLabels'];
                    if (labelsObj) {
                        dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? labelsObj['show'] : dataLabelsSettings.show;
                        dataLabelsSettings.precision = (labelsObj['labelsPrecision'] !== undefined) ? +labelsObj['labelsPrecision'] : dataLabelsSettings.precision;
                        if (labelsObj['color'] !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj['color'].solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                    }
                }
                var dataPoints = ScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor);
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                }
                var legendItems = hasDynamicSeries ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor) : [];
                var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                if (!legendTitle) {
                    legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "";
                }
                var legendData = { title: legendTitle, dataPoints: legendItems };
                var sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.x = null;
                }
                if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.y = null;
                }
                return {
                    xCol: scatterMetadata.cols.x,
                    yCol: scatterMetadata.cols.y,
                    dataPoints: dataPoints,
                    legendData: legendData,
                    axesLabels: scatterMetadata.axesLabels,
                    hasSelection: false,
                    selectedIds: [],
                    size: scatterMetadata.cols.size,
                    sizeRange: sizeRange,
                    dataLabelsSettings: dataLabelsSettings,
                    defaultDataPointColor: defaultDataPointColor,
                    hasDynamicSeries: hasDynamicSeries,
                    showAllDataPoints: showAllDataPoints,
                };
            };
            ScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
                var result = {};
                if (dataViewValueGroups) {
                    dataViewValueGroups.forEach(function (group) {
                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                        var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        if (result.min == null || result.min > currentRange.min) {
                            result.min = currentRange.min;
                        }
                        if (result.max == null || result.max < currentRange.max) {
                            result.max = currentRange.max;
                        }
                    });
                }
                return result;
            };
            ScatterChart.createDataPoints = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, defaultDataPointColor) {
                var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                    var categoryValue = categoryValues[categoryIdx];
                    for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                        var grouping = grouped[seriesIdx];
                        var seriesValues = grouping.values;
                        var measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);
                        var measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);
                        var measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);
                        var xVal = measureX && measureX.values ? measureX.values[categoryIdx] : null;
                        var yVal = measureY && measureY.values ? measureY.values[categoryIdx] : 0;
                        var size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;
                        var hasNullValue = (xVal == null) || (yVal == null);
                        if (hasNullValue)
                            continue;
                        var color;
                        if (hasDynamicSeries) {
                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        }
                        else {
                            // If we have no Size measure then use a blank query name
                            var measureSource = (measureSize != null) ? measureSize.source.queryName : '';
                            color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                        }
                        var identity = visuals.SelectionId.createWithIds(categoryIdentities ? categoryIdentities[categoryIdx] : undefined, hasDynamicSeries ? grouping.identity : undefined);
                        var seriesData = [];
                        if (dataValueSource) {
                            // Dynamic series
                            seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
                        }
                        if (measureX) {
                            seriesData.push({ value: xVal, metadata: measureX });
                        }
                        if (measureY) {
                            seriesData.push({ value: yVal, metadata: measureY });
                        }
                        if (measureSize && measureSize.values && measureSize.values.length > 0) {
                            seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
                        }
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categories, categoryValue, null, null, seriesData);
                        var dataPoint = {
                            x: xVal,
                            y: yVal,
                            size: size,
                            radius: { sizeMeasure: measureSize, index: categoryIdx },
                            fill: color,
                            category: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                            selected: false,
                            identity: identity,
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.overrideDefaultColor ? labelSettings.labelColor : color,
                        };
                        dataPoints.push(dataPoint);
                    }
                }
                return dataPoints;
            };
            ScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                var grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                var legendItems = [];
                for (var i = 0, len = grouped.length; i < len; i++) {
                    var grouping = grouped[i];
                    var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    legendItems.push({
                        color: color,
                        icon: 1 /* Circle */,
                        label: visuals.valueFormatter.format(grouping.name, formatString),
                        identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return legendItems;
            };
            ScatterChart.getBubbleRadius = function (radiusData, sizeRange, viewPort) {
                var actualSizeDataRange = null;
                var bubblePixelAreaSizeRange = null;
                var measureSize = radiusData.sizeMeasure;
                if (!measureSize)
                    return ScatterChart.BubbleRadius;
                var minSize = sizeRange.min ? sizeRange.min : 0;
                var maxSize = sizeRange.max ? sizeRange.max : 0;
                var min = Math.min(minSize, 0);
                var max = Math.max(maxSize, 0);
                actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                };
                bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewPort, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange);
                if (measureSize.values) {
                    var sizeValue = measureSize.values[radiusData.index];
                    if (sizeValue != null) {
                        return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                    }
                }
                return ScatterChart.BubbleRadius;
            };
            ScatterChart.getMeasureValue = function (measureIndex, seriesValues) {
                if (measureIndex >= 0)
                    return seriesValues[measureIndex];
                return null;
            };
            ScatterChart.getMetadata = function (grouped, source) {
                var xIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
                var yIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
                var sizeIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
                var xCol;
                var yCol;
                var sizeCol;
                var xAxisLabel = "";
                var yAxisLabel = "";
                if (grouped && grouped.length) {
                    var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                    if (!(xIndex >= 0))
                        xIndex = ScatterChart.getDefaultMeasureIndex(measureCount, yIndex, sizeIndex);
                    if (!(yIndex >= 0))
                        yIndex = ScatterChart.getDefaultMeasureIndex(measureCount, xIndex, sizeIndex);
                    if (!(sizeIndex >= 0))
                        sizeIndex = ScatterChart.getDefaultMeasureIndex(measureCount, xIndex, yIndex);
                    if (xIndex >= 0) {
                        xCol = firstGroup.values[xIndex].source;
                        xAxisLabel = firstGroup.values[xIndex].source.displayName;
                    }
                    if (yIndex >= 0) {
                        yCol = firstGroup.values[yIndex].source;
                        yAxisLabel = firstGroup.values[yIndex].source.displayName;
                    }
                    if (sizeIndex >= 0) {
                        sizeCol = firstGroup.values[sizeIndex].source;
                    }
                }
                return {
                    idx: {
                        x: xIndex,
                        y: yIndex,
                        size: sizeIndex,
                    },
                    cols: {
                        x: xCol,
                        y: yCol,
                        size: sizeCol,
                    },
                    axesLabels: {
                        x: xAxisLabel,
                        y: yAxisLabel
                    }
                };
            };
            ScatterChart.getDefaultMeasureIndex = function (count, usedIndex, usedIndex2) {
                for (var i = 0; i < count; i++) {
                    if (i !== usedIndex && i !== usedIndex2)
                        return i;
                }
            };
            ScatterChart.prototype.setData = function (dataViews) {
                this.data = {
                    xCol: undefined,
                    yCol: undefined,
                    dataPoints: [],
                    legendData: { dataPoints: [] },
                    axesLabels: { x: '', y: '' },
                    selectedIds: [],
                    sizeRange: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    defaultDataPointColor: null,
                    hasDynamicSeries: false,
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, true);
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, true);
                        this.dataView = dataView;
                        if (dataView.categorical && dataView.categorical.values) {
                            this.data = ScatterChart.converter(dataView, this.currentViewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);
                        }
                    }
                }
            };
            ScatterChart.prototype.calculateLegend = function () {
                return this.data.legendData;
            };
            ScatterChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            ScatterChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                        if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
                            return this.enumerateDataPoints();
                    case 'categoryAxis':
                        return [{
                            selector: null,
                            properties: {
                                showAxisTitle: !this.categoryAxisProperties || this.categoryAxisProperties["showAxisTitle"] == null ? true : this.categoryAxisProperties["showAxisTitle"]
                            },
                            objectName: 'categoryAxis'
                        }];
                    case 'valueAxis':
                        return [{
                            selector: null,
                            properties: {
                                showAxisTitle: !this.valueAxisProperties || this.valueAxisProperties["showAxisTitle"] == null ? true : this.valueAxisProperties["showAxisTitle"]
                            },
                            objectName: 'valueAxis'
                        }];
                    case 'categoryLabels':
                        return (this.data) ? visuals.dataLabelUtils.enumerateCategoryLabels(this.data.dataLabelsSettings, true) : visuals.dataLabelUtils.enumerateCategoryLabels(null, true);
                }
            };
            ScatterChart.prototype.enumerateDataPoints = function () {
                var data = this.data;
                if (!data)
                    return;
                var instances = [], seriesCount = data.dataPoints.length;
                if (data.hasDynamicSeries) {
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColor(0).value } }
                        },
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesCount > 1;
                    instances.push({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        },
                    });
                    if (!showAllDataPoints)
                        return instances;
                }
                if (data.legendData.dataPoints.length === 0) {
                    for (var i = 0; i < seriesCount; i++) {
                        var seriesDataPoints = data.dataPoints[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: seriesDataPoints.category,
                            selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), true),
                            properties: {
                                fill: { solid: { color: seriesDataPoints.fill } }
                            },
                        });
                    }
                }
                else {
                    var legendDataPointLength = data.legendData.dataPoints.length;
                    for (var i = 0; i < legendDataPointLength; i++) {
                        var series = data.legendData.dataPoints[i];
                        instances.push({
                            objectName: 'dataPoint',
                            displayName: series.label,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.color } }
                            },
                        });
                    }
                }
                return instances;
            };
            ScatterChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                var dataPoints = data.dataPoints;
                var viewport = this.currentViewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var minY = 0, maxY = 10, minX = 0, maxX = 10;
                if (dataPoints.length > 0) {
                    minY = d3.min(dataPoints, function (d) { return d.y; });
                    maxY = d3.max(dataPoints, function (d) { return d.y; });
                    minX = d3.min(dataPoints, function (d) { return d.x; });
                    maxX = d3.max(dataPoints, function (d) { return d.x; });
                }
                var xDomain = [minX, maxX];
                var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedXDomain,
                    metaDataColumn: data.xCol,
                    formatStringProp: visuals.scatterChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true //scatter doesn't have a categorical axis, but this is needed for the pane to react correctly to the x-axis toggle one/off
                });
                this.xAxisProperties.axis.tickSize(-height, 0);
                this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: data.yCol,
                    formatStringProp: visuals.scatterChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                });
                this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ScatterChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ScatterChart.prototype.render = function (duration) {
                if (!this.data)
                    return;
                var data = this.data;
                var dataPoints = this.data.dataPoints;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = visuals.dataHasSelection(dataPoints);
                this.mainGraphicsContext.attr('width', width).attr('height', height);
                var sortedData = dataPoints.sort(function (a, b) {
                    return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;
                });
                var scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);
                if (this.data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getScatterChartLabelLayout(xScale, yScale, this.data.dataLabelsSettings, viewport, data.sizeRange);
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsContext, layout, this.currentViewport);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsContext);
                }
                if (this.interactivityService) {
                    var options = {
                        host: this.cartesianVisualHost,
                        root: this.svg,
                        dataPointsSelection: scatterMarkers,
                        mainContext: this.mainGraphicsContext,
                        data: this.data,
                        visualInitOptions: this.options,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0)),
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, options);
                }
                visuals.TooltipManager.addTooltip(scatterMarkers, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            ScatterChart.prototype.drawScatterMarkers = function (scatterData, hasSelection, sizeRange, duration) {
                var _this = this;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var markers = this.mainGraphicsContext.selectAll(ScatterChart.DotClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });
                markers.enter().append(ScatterChart.ScatterChartCircleTagName).classed(ScatterChart.DotClasses.class, true);
                markers.style({
                    'stroke-opacity': function (d) { return ScatterChart.getBubbleOpacity(d, hasSelection); },
                    'stroke-width': '1px',
                    'stroke': function (d) { return d.fill; },
                    'fill': function (d) { return d.fill; },
                    'fill-opacity': function (d) { return d.size != null ? ScatterChart.getBubbleOpacity(d, hasSelection) : 0; },
                }).transition().duration(duration).attr({
                    r: function (d) { return ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.currentViewport); },
                    cx: function (d) { return xScale(d.x); },
                    cy: function (d) { return yScale(d.y); },
                });
                markers.exit().remove();
                return markers;
            };
            ScatterChart.getBubblePixelAreaSizeRange = function (viewPort, minSizeRange, maxSizeRange) {
                var ratio = 1.0;
                if (viewPort.height > 0 && viewPort.width > 0) {
                    var minSize = Math.min(viewPort.height, viewPort.width);
                    ratio = (minSize * minSize) / ScatterChart.AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio);
                var maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            };
            ScatterChart.project = function (value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
                    return (ScatterChart.rangeContains(actualSizeDataRange, value)) ? bubblePixelAreaSizeRange.minRange : null;
                }
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            };
            ScatterChart.projectSizeToPixels = function (size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    // Project value on the required range of bubble area sizes
                    projectedSize = bubblePixelAreaSizeRange.maxRange;
                    if (actualSizeDataRange.delta !== 0) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
                }
                return Math.round(projectedSize);
            };
            ScatterChart.rangeContains = function (range, value) {
                return range.minRange <= value && value <= range.maxRange;
            };
            ScatterChart.getBubbleOpacity = function (d, hasSelection) {
                if (hasSelection && !d.selected) {
                    return ScatterChart.DimmedBubbleOpacity;
                }
                return ScatterChart.DefaultBubbleOpacity;
            };
            ScatterChart.prototype.accept = function (visitor, options) {
                visitor.visitScatterChart(options);
            };
            ScatterChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            ScatterChart.prototype.getSupportedCategoryAxisType = function () {
                return powerbi.axisType.scalar;
            };
            ScatterChart.ScatterChartCircleTagName = 'circle';
            ScatterChart.BubbleRadius = 3 * 2;
            ScatterChart.DefaultBubbleOpacity = 0.85;
            ScatterChart.DimmedBubbleOpacity = 0.4;
            // Chart Area and size range values as defined by PV charts
            ScatterChart.AreaOf300By300Chart = 90000;
            ScatterChart.MinSizeRange = 200;
            ScatterChart.MaxSizeRange = 3000;
            ScatterChart.ClassName = 'scatterChart';
            ScatterChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            ScatterChart.DataLabelsContextClassName = 'dataLabelsContext';
            ScatterChart.DotClasses = {
                class: 'dot',
                selector: '.dot'
            };
            return ScatterChart;
        })();
        visuals.ScatterChart = ScatterChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.slicerCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
                }
            ],
            dataViewMappings: [{
                conditions: [{ 'Values': { max: 1 } }],
                categorical: {
                    categories: {
                        for: { in: 'Values' },
                        dataReductionAlgorithm: { window: {} }
                    }
                }
            }],
            objects: {
                general: {
                    properties: {
                        selected: {
                            type: { bool: true }
                        },
                        filter: {
                            type: { filter: {} },
                            rule: {
                                output: {
                                    property: 'selected',
                                    selector: ['Values'],
                                }
                            }
                        },
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    }
                }
            },
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
        };
        visuals.slicerProps = {
            selectedPropertyIdentifier: {
                objectName: 'general',
                propertyName: 'selected'
            },
            filterPropertyIdentifier: {
                objectName: 'general',
                propertyName: 'filter'
            },
            formatString: {
                objectName: 'general',
                propertyName: 'formatString'
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Slicer = (function () {
            function Slicer() {
            }
            Slicer.converter = function (dataView) {
                var slicerData;
                if (dataView) {
                    var dataViewCategorical = dataView.categorical;
                    if (dataViewCategorical && dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var categories = dataViewCategorical.categories[0];
                        var categoryValuesLen = categories && categories.values ? categories.values.length : 0;
                        var slicerDataPoints = [];
                        // Pass over the values to see if there's a positive or negative selection
                        var hasSelection = undefined;
                        for (var idx = 0; idx < categoryValuesLen; idx++) {
                            var selected = visuals.WebInteractivityService.isSelected(visuals.slicerProps.selectedPropertyIdentifier, categories, idx);
                            if (selected !== undefined) {
                                hasSelection = selected;
                                break;
                            }
                        }
                        for (var idx = 0; idx < categoryValuesLen; idx++) {
                            var categoryIdentity = categories.identity ? categories.identity[idx] : null;
                            var selectedCategory = visuals.WebInteractivityService.isSelected(visuals.slicerProps.selectedPropertyIdentifier, categories, idx);
                            if (selectedCategory === undefined && hasSelection !== undefined) {
                                selectedCategory = !hasSelection;
                            }
                            slicerDataPoints.push({
                                value: categories.values[idx],
                                mouseOver: false,
                                mouseOut: true,
                                identity: visuals.SelectionId.createWithId(categoryIdentity),
                                selected: selectedCategory
                            });
                        }
                        slicerData = {
                            categorySourceName: categories.source.displayName,
                            formatString: visuals.valueFormatter.getFormatString(categories.source, visuals.slicerProps.formatString),
                            slicerDataPoints: slicerDataPoints
                        };
                    }
                }
                return slicerData;
            };
            Slicer.prototype.init = function (options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.hostServices = options.host;
                var settings = this.settings = options.settings;
                if (!settings || !settings.slicerSettings) {
                    settings = this.settings = options.settings = {
                        slicerSettings: Slicer.DefaultStyleProperties
                    };
                }
                this.initContainer();
            };
            Slicer.prototype.onDataChanged = function (options) {
                var dataViews = options.dataViews;
                debug.assertValue(dataViews, 'dataViews');
                var existingDataView = this.dataView;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                }
                var resetScrollbarPosition = options.operationKind !== 1 /* Append */ && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                this.updateInternal(resetScrollbarPosition);
                this.waitingForData = false;
            };
            Slicer.prototype.onResizing = function (finalViewport, duration) {
                this.currentViewport = finalViewport;
                var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                this.slicerBody.style({
                    'height': visuals.SVGUtil.convertToPixelString(slicerViewport.height),
                    'width': visuals.SVGUtil.convertToPixelString(slicerViewport.width),
                });
                this.slicerHeader.select(Slicer.HeaderText.selector).style("width", this.getSlicerHeaderTextWidth());
                this.updateInternal();
            };
            Slicer.prototype.accept = function (visitor, options) {
                visitor.visitSlicer(options);
            };
            Slicer.prototype.updateInternal = function (resetScrollbarPosition) {
                if (resetScrollbarPosition === void 0) { resetScrollbarPosition = false; }
                var data = this.slicerData = Slicer.converter(this.dataView);
                if (!data) {
                    this.listView.empty();
                    return;
                }
                this.listView.viewport(this.getSlicerBodyViewport(this.currentViewport)).rowHeight(this.getRowHeight()).data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }).render(true, resetScrollbarPosition);
            };
            Slicer.prototype.initContainer = function () {
                var _this = this;
                var settings = this.settings.slicerSettings;
                var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);
                this.slicerContainer = d3.select(this.element.get(0)).classed(Slicer.Container.class, true);
                this.slicerHeader = this.slicerContainer.append("div").classed(Slicer.Header.class, true).style('height', visuals.SVGUtil.convertToPixelString(settings.header.height));
                this.slicerHeader.append("div").classed(Slicer.HeaderText.class, true).style({
                    'margin-left': visuals.SVGUtil.convertToPixelString(settings.headerText.marginLeft),
                    'margin-top': visuals.SVGUtil.convertToPixelString(settings.headerText.marginTop),
                    'width': this.getSlicerHeaderTextWidth(),
                });
                this.slicerHeader.append("span").classed(Slicer.Clear.class, true).attr('title', this.hostServices.getLocalizedString(Slicer.clearTextKey));
                this.slicerBody = this.slicerContainer.append("div").classed(Slicer.Body.class, true).style({
                    'height': visuals.SVGUtil.convertToPixelString(slicerBodyViewport.height),
                    'width': visuals.SVGUtil.convertToPixelString(slicerBodyViewport.width)
                });
                var rowEnter = function (rowSelection) {
                    var labelWidth = visuals.SVGUtil.convertToPixelString(_this.currentViewport.width - (settings.slicerItemContainer.marginLeft + settings.slicerText.marginLeft));
                    var listItemElement = rowSelection.append("li").classed(Slicer.ItemContainer.class, true).style({
                        'height': visuals.SVGUtil.convertToPixelString(settings.slicerItemContainer.height),
                        'margin-left': visuals.SVGUtil.convertToPixelString(settings.slicerItemContainer.marginLeft),
                    });
                    var labelElement = listItemElement.append("label").classed(Slicer.Input.class, true);
                    labelElement.append("input").attr('type', 'checkbox');
                    labelElement.append("span").classed(Slicer.LabelText.class, true).style('width', labelWidth);
                };
                var rowUpdate = function (rowSelection) {
                    var formatString;
                    if (_this.slicerData) {
                        _this.slicerHeader.select(Slicer.HeaderText.selector).text(_this.slicerData.categorySourceName);
                        formatString = _this.slicerData.formatString;
                    }
                    var slicerText = rowSelection.selectAll(Slicer.LabelText.selector);
                    slicerText.text(function (d) { return visuals.valueFormatter.format(d.value, formatString); });
                    if (_this.interactivityService && _this.slicerData && _this.slicerBody) {
                        var slicerBody = _this.slicerBody.attr('width', _this.currentViewport.width);
                        var slicerItemContainers = slicerBody.selectAll(Slicer.ItemContainer.selector);
                        var slicerItemLabels = slicerBody.selectAll(Slicer.LabelText.selector);
                        var slicerItemInputs = slicerBody.selectAll(Slicer.Input.selector);
                        var slicerClear = _this.slicerHeader.select(Slicer.Clear.selector);
                        var behaviorOptions = {
                            datapoints: _this.slicerData.slicerDataPoints,
                            slicerItemContainers: slicerItemContainers,
                            slicerItemLabels: slicerItemLabels,
                            slicerItemInputs: slicerItemInputs,
                            slicerClear: slicerClear,
                        };
                        _this.interactivityService.apply(_this, behaviorOptions);
                    }
                    rowSelection.select(Slicer.Input.selector).select('input').property('checked', function (d) { return d.selected; });
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: this.getRowHeight(),
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return _this.onLoadMoreData(); },
                    viewport: this.getSlicerBodyViewport(this.currentViewport),
                    baseContainer: this.slicerBody
                };
                this.listView = visuals.ListViewFactory.createHTMLListView(listViewOptions);
            };
            Slicer.prototype.onLoadMoreData = function () {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Slicer.prototype.getSlicerBodyViewport = function (currentViewport) {
                var settings = this.settings.slicerSettings;
                var slicerBodyHeight = currentViewport.height - (settings.header.height + 1);
                return {
                    height: slicerBodyHeight,
                    width: currentViewport.width
                };
            };
            Slicer.prototype.getSlicerHeaderTextWidth = function () {
                var slicerSettings = this.settings.slicerSettings;
                return visuals.SVGUtil.convertToPixelString(this.currentViewport.width - (slicerSettings.headerText.marginLeft + slicerSettings.clear.width + slicerSettings.clear.totalMargin));
            };
            Slicer.prototype.getRowHeight = function () {
                var slicerItemSettings = this.settings.slicerSettings.slicerItemContainer;
                return slicerItemSettings.height;
            };
            Slicer.clearTextKey = 'Slicer_Clear';
            Slicer.Container = {
                class: 'slicerContainer',
                selector: '.slicerContainer'
            };
            Slicer.Header = {
                class: 'slicerHeader',
                selector: '.slicerHeader'
            };
            Slicer.HeaderText = {
                class: 'headerText',
                selector: '.headerText'
            };
            Slicer.Body = {
                class: 'slicerBody',
                selector: '.slicerBody'
            };
            Slicer.ItemContainer = {
                class: 'slicerItemContainer',
                selector: '.slicerItemContainer'
            };
            Slicer.LabelText = {
                class: 'slicerText',
                selector: '.slicerText'
            };
            Slicer.Input = {
                class: 'slicerCheckbox',
                selector: '.slicerCheckbox'
            };
            Slicer.Clear = {
                class: 'clear',
                selector: '.clear'
            };
            Slicer.DefaultStyleProperties = {
                header: {
                    height: 22,
                },
                headerText: {
                    marginLeft: 8,
                    marginTop: 0,
                },
                slicerText: {
                    color: '#666666',
                    hoverColor: '#212121',
                    selectionColor: '#212121',
                    marginLeft: 8,
                },
                slicerItemContainer: {
                    height: 24,
                    // The margin is assigned in the less file. This is needed for the height calculations.
                    marginTop: 5,
                    marginLeft: 8
                },
                clear: {
                    width: 11,
                    // The margins are assigned in the less file. This is needed for the width calculations.
                    totalMargin: 10
                }
            };
            return Slicer;
        })();
        visuals.Slicer = Slicer;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TableHierarchyNavigator = (function () {
            function TableHierarchyNavigator(tableDataView, formatter) {
                debug.assertValue(tableDataView, 'tableDataView');
                debug.assertValue(formatter, 'formatter');
                this.tableDataView = tableDataView;
                this.formatter = formatter;
            }
            /** Returns the depth of a hierarchy. */
            TableHierarchyNavigator.prototype.getDepth = function (hierarchy) {
                return 1;
            };
            /** Returns the leaf count of a hierarchy. */
            TableHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                return hierarchy.length;
            };
            /** Returns the leaf member of a hierarchy at a specified index. */
            TableHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                return hierarchy[index];
            };
            /** Returns the specified hierarchy member parent. */
            TableHierarchyNavigator.prototype.getParent = function (item) {
                return null;
            };
            /** Returns the index of the hierarchy member relative to its parent. */
            TableHierarchyNavigator.prototype.getIndex = function (item) {
                if (this.isRow(item))
                    return item.index;
                return this.getColumnIndex(item);
            };
            TableHierarchyNavigator.prototype.isRow = function (item) {
                var row = item;
                return row.index !== undefined && row.values !== undefined;
            };
            TableHierarchyNavigator.prototype.getColumnIndex = function (item) {
                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
            };
            /** Checks whether a hierarchy member is a leaf. */
            TableHierarchyNavigator.prototype.isLeaf = function (item) {
                return true;
            };
            TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function (cornerItem) {
                return false;
            };
            TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (cornerItem) {
                return true;
            };
            /** Checks whether a hierarchy member is the last item within its parent. */
            TableHierarchyNavigator.prototype.isLastItem = function (item, items) {
                return false;
            };
            /** Gets the children members of a hierarchy member. */
            TableHierarchyNavigator.prototype.getChildren = function (item) {
                return null;
            };
            /** Gets the members count in a specified collection. */
            TableHierarchyNavigator.prototype.getCount = function (items) {
                return items.length;
            };
            /** Gets the member at the specified index. */
            TableHierarchyNavigator.prototype.getAt = function (items, index) {
                return items[index];
            };
            /** Gets the hierarchy member level. */
            TableHierarchyNavigator.prototype.getLevel = function (item) {
                return 0;
            };
            /** Returns the intersection between a row and a column item. */
            TableHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                var value;
                var isTotal = false;
                var isBottomMost = false;
                var columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                var totalRow = rowItem;
                if (totalRow.totalCells != null) {
                    isTotal = true;
                    value = totalRow.totalCells[columnIndex];
                }
                else {
                    var bottomRow = this.tableDataView.visualRows[this.tableDataView.visualRows.length - 1];
                    isBottomMost = bottomRow === rowItem;
                    value = rowItem.values[columnIndex];
                }
                var formattedValue = this.formatter(value, visuals.valueFormatter.getFormatString(columnItem, Table.formatStringProp));
                return {
                    value: formattedValue,
                    isMeasure: columnItem.isMeasure,
                    isTotal: isTotal,
                    isBottomMost: isBottomMost,
                    showUrl: visuals.UrlHelper.isValidUrl(columnItem, formattedValue)
                };
            };
            /** Returns the corner cell between a row and a column level. */
            TableHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                return null;
            };
            TableHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                return (item1 === item2);
            };
            TableHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                return (item1 === item2);
            };
            TableHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                // Should not be called as we don't return any corner items for table
                return true;
            };
            TableHierarchyNavigator.prototype.update = function (table) {
                this.tableDataView = table;
            };
            TableHierarchyNavigator.getIndex = function (items, item) {
                for (var index = 0, len = items.length; index < len; index++) {
                    // For cases when the item was re-created during the DataTransformation phase,
                    // we check for the item's index to verify equality.
                    var arrayItem = items[index];
                    if (arrayItem.index != null && item.index != null && arrayItem.index === item.index) {
                        return index;
                    }
                    else {
                        if (item === items[index])
                            return index;
                    }
                }
                return -1;
            };
            return TableHierarchyNavigator;
        })();
        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
        // Public for testability
        var TableBinder = (function () {
            function TableBinder(options) {
                this.options = options;
            }
            TableBinder.prototype.onStartRenderingSession = function () {
            };
            TableBinder.prototype.onEndRenderingSession = function () {
            };
            // Row Header
            TableBinder.prototype.bindRowHeader = function (item, cell) {
                this.ensureHeight(item, cell);
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
            };
            TableBinder.prototype.unbindRowHeader = function (item, cell) {
            };
            // Column Header
            TableBinder.prototype.bindColumnHeader = function (item, cell) {
                var _this = this;
                cell.extension.setContainerStyle(TableBinder.columnHeaderClassName);
                cell.extension.disableDragResize();
                cell.extension.contentHost.textContent = item.displayName;
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName);
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            TableBinder.prototype.unbindColumnHeader = function (item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = '';
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            // Body Cell
            TableBinder.prototype.bindBodyCell = function (item, cell) {
                if (item.showUrl)
                    visuals.controls.internal.TablixUtils.appendATagToBodyCell(item.value, cell);
                else
                    cell.extension.contentHost.textContent = item.value;
                var classNames = item.isTotal ? TableBinder.footerClassName : item.isBottomMost ? TableBinder.lastRowClassName : TableBinder.rowClassName;
                if (item.isMeasure)
                    classNames += ' ' + TableBinder.numericCellClassName;
                cell.extension.setContainerStyle(classNames);
            };
            TableBinder.prototype.unbindBodyCell = function (item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = '';
            };
            // Corner Cell
            TableBinder.prototype.bindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.unbindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            // Measurement Helper
            TableBinder.prototype.getHeaderLabel = function (item) {
                return item.displayName;
            };
            TableBinder.prototype.getCellContent = function (item) {
                return item;
            };
            TableBinder.prototype.hasRowGroups = function () {
                return false;
            };
            TableBinder.prototype.ensureHeight = function (item, cell) {
                if (!item.values)
                    return;
                var count = item.values.length;
                if (count === 0)
                    return;
                var allValuesEmpty = true;
                for (var i = 0; i < count; i++) {
                    if (item.values[i]) {
                        allValuesEmpty = false;
                        break;
                    }
                }
                // In order to maintain the height of the row when the values are null or empty
                // we set the innerHTML to be a nonBreakingSpace. The nonBreakingSpace does not
                // show up in the visual because for actual cell content we use the textContent property instead.
                if (allValuesEmpty)
                    cell.extension.contentHost.innerHTML = TableBinder.nonBreakingSpace;
            };
            TableBinder.columnHeaderClassName = 'bi-table-column-header';
            TableBinder.rowClassName = 'bi-table-row';
            TableBinder.lastRowClassName = 'bi-table-last-row';
            TableBinder.footerClassName = 'bi-table-footer';
            TableBinder.numericCellClassName = 'bi-table-cell-numeric';
            TableBinder.nonBreakingSpace = '&nbsp;';
            return TableBinder;
        })();
        visuals.TableBinder = TableBinder;
        var Table = (function () {
            function Table() {
                this.lastAllowHeaderResize = true;
            }
            Table.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
                    return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = Table.shouldShowTotals(objects) ? 1 /* Before */ : 0 /* None */;
            };
            Table.getSortableRoles = function () {
                return ['Values'];
            };
            Table.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatRaw;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.getLocalizedString = options.host.getLocalizedString;
                this.hostServices = options.host;
            };
            /*Public for testability*/
            Table.converter = function (table) {
                debug.assertValue(table, 'table');
                debug.assertValue(table.rows, 'table.rows');
                var visualTable = powerbi.Prototype.inherit(table);
                visualTable.visualRows = [];
                for (var i = 0; i < table.rows.length; i++) {
                    var visualRow = {
                        index: i,
                        values: table.rows[i]
                    };
                    visualTable.visualRows.push(visualRow);
                }
                return visualTable;
            };
            Table.prototype.onResizing = function (finalViewport, duration) {
                this.updateViewport(finalViewport);
            };
            Table.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                    if (options.operationKind === 1 /* Append */) {
                        var visualTable = Table.converter(this.dataView.table);
                        this.hierarchyNavigator.update(visualTable);
                        this.tablixControl.updateModels(false, visualTable.visualRows);
                        this.refreshControl(false);
                    }
                    else {
                        this.updateInternal(this.dataView);
                    }
                }
                this.waitingForData = false;
            };
            Table.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Table.prototype.refreshControl = function (clear) {
                if (this.element.visible() || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Table.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Table.prototype.createControl = function (dataNavigator) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var tableBinderOptions = {
                    onBindRowHeader: function (item) { return _this.onBindRowHeader(item); },
                    onColumnHeaderClick: function (queryName) { return _this.onColumnHeaderClick(queryName); },
                };
                var tableBinder = new TableBinder(tableBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */ ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
                // Create Host element
                var tablixContainer = document.createElement('div');
                tablixContainer.className = "tablixContainer";
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: false,
                    layoutKind: layoutKind,
                };
                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
            };
            Table.prototype.updateInternal = function (dataView) {
                var _this = this;
                var visualTable = Table.converter(dataView.table);
                if (!this.tablixControl) {
                    var dataNavigator = new TableHierarchyNavigator(visualTable, this.formatter);
                    this.hierarchyNavigator = dataNavigator;
                    // Create the control
                    this.tablixControl = this.createControl(dataNavigator);
                }
                else {
                    this.hierarchyNavigator.update(visualTable);
                }
                this.verifyHeaderResize();
                // Update models before the viewport to make sure column widths are computed correctly
                this.tablixControl.updateModels(true, visualTable.visualRows, visualTable.columns);
                var totals = this.createTotalsRow(dataView);
                this.tablixControl.rowDimension.setFooter(totals);
                this.tablixControl.viewport = this.currentViewport;
                // Render
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(true);
                }, 0);
            };
            Table.prototype.createTotalsRow = function (dataView) {
                if (!this.shouldShowTotals(dataView))
                    return null;
                var totals = dataView.table.totals;
                if (!totals || totals.length === 0)
                    return null;
                var totalRow = [];
                var columns = dataView.table.columns;
                for (var i = 0, len = columns.length; i < len; ++i) {
                    var column = columns[i];
                    var totalValue = totals[column.index];
                    if (totalValue != null) {
                        totalRow.push(totalValue);
                    }
                    else {
                        // If the first column is a non-measure column, we put 'Total' as the text similar to PV.
                        // Note that if the first column is a measure column we don't render any Total text at
                        // all, once again similar to PV.
                        totalRow.push((i === 0) ? this.getLocalizedString('TableTotalLabel') : '');
                    }
                }
                return { totalCells: totalRow };
            };
            Table.prototype.shouldShowTotals = function (dataView) {
                var objects = dataView.metadata.objects;
                return Table.shouldShowTotals(objects);
            };
            Table.shouldShowTotals = function (objects) {
                if (objects && objects.general)
                    return objects.general.totals !== false;
                // Totals are enabled by default
                return true;
            };
            Table.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Table.prototype.onColumnHeaderClick = function (queryName) {
                var sortDescriptors = [{
                    queryName: queryName,
                }];
                var args = {
                    sortDescriptors: sortDescriptors
                };
                this.hostServices.onCustomSort(args);
            };
            /* Public for testability */
            Table.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
            };
            Table.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
                // we are resilient here when we do not have data view.
                if (this.dataView && options.objectName === 'general') {
                    instances.push({
                        selector: null,
                        properties: {
                            totals: this.shouldShowTotals(this.dataView),
                        },
                        objectName: options.objectName
                    });
                }
                return instances;
            };
            Table.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Table.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Table.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            Table.preferredLoadMoreThreshold = 0.8;
            Table.capabilities = {
                dataRoles: [{
                    name: 'Values',
                    kind: 2 /* GroupingOrMeasure */
                }],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                            totals: {
                                type: { bool: true },
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Totals')
                            }
                        },
                    }
                },
                dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: { count: 100 } }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
                sorting: {
                    custom: {},
                },
                suppressDefaultTitle: true,
            };
            return Table;
        })();
        visuals.Table = Table;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var RoleNames = {
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
        };
        /** Factory method used by unit tests */
        function createMatrixHierarchyNavigator(matrix, formatter) {
            return new MatrixHierarchyNavigator(matrix, formatter);
        }
        visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
        var MatrixHierarchyNavigator = (function () {
            function MatrixHierarchyNavigator(matrix, formatter) {
                this.matrix = matrix;
                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows);
                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns);
                this.formatter = formatter;
                this.update();
            }
            /** Returns the data view matrix. */
            MatrixHierarchyNavigator.prototype.getDataViewMatrix = function () {
                return this.matrix;
            };
            /** Returns the depth of a hierarchy. */
            MatrixHierarchyNavigator.prototype.getDepth = function (hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return Math.max(matrixHierarchy.levels.length, 1);
                debug.assertFail('Hierarchy cannot be found');
                return 0;
            };
            /** Returns the leaf count of a hierarchy. */
            MatrixHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes.length;
                debug.assertFail('Hierarchy cannot be found');
                return 0;
            };
            /** Returns the leaf member of a hierarchy at a specified index. */
            MatrixHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes[index];
                return null;
            };
            /** Returns the leaf index of the visual node. */
            MatrixHierarchyNavigator.prototype.getLeafIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.leafIndex;
            };
            /** Returns the specified hierarchy member parent. */
            MatrixHierarchyNavigator.prototype.getParent = function (item) {
                debug.assertValue(item, 'item');
                // Return null for outermost nodes
                if (item.level === 0)
                    return null;
                return item.parent;
            };
            /** Returns the index of the hierarchy member relative to its parent. */
            MatrixHierarchyNavigator.prototype.getIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.index;
            };
            /** Checks whether a hierarchy member is a leaf. */
            MatrixHierarchyNavigator.prototype.isLeaf = function (item) {
                debug.assertValue(item, 'item');
                return !item.children || item.children.length === 0;
            };
            MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function (item) {
                return true;
            };
            MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (item) {
                return false;
            };
            /** Checks whether a hierarchy member is the last item within its parent. */
            MatrixHierarchyNavigator.prototype.isLastItem = function (item, items) {
                debug.assertValue(item, 'item');
                return items[items.length - 1] === item;
            };
            /** Gets the children members of a hierarchy member. */
            MatrixHierarchyNavigator.prototype.getChildren = function (item) {
                debug.assertValue(item, 'item');
                return item.children;
            };
            /** Gets the members count in a specified collection. */
            MatrixHierarchyNavigator.prototype.getCount = function (items) {
                debug.assertValue(items, 'items');
                return items.length;
            };
            /** Gets the member at the specified index. */
            MatrixHierarchyNavigator.prototype.getAt = function (items, index) {
                debug.assertValue(items, 'items');
                return items[index];
            };
            /** Gets the hierarchy member level. */
            MatrixHierarchyNavigator.prototype.getLevel = function (item) {
                debug.assertValue(item, 'item');
                return item.level;
            };
            /** Returns the intersection between a row and a column item. */
            MatrixHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                debug.assertValue(rowItem, 'rowItem');
                debug.assertValue(columnItem, 'columnItem');
                var isSubtotalItem = rowItem.isSubtotal === true || columnItem.isSubtotal === true;
                if (!rowItem.values)
                    return {
                        content: '',
                        isSubtotal: isSubtotalItem,
                    };
                var intersection = (rowItem.values[columnItem.leafIndex]);
                if (!intersection)
                    return {
                        content: '',
                        isSubtotal: isSubtotalItem,
                    };
                var formatString = visuals.valueFormatter.getFormatString(this.matrix.valueSources[intersection.valueSourceIndex ? intersection.valueSourceIndex : 0], Matrix.formatStringProp);
                var formattedValue = this.formatter(intersection.value, formatString);
                return {
                    content: formattedValue,
                    isSubtotal: isSubtotalItem,
                };
            };
            /** Returns the corner cell between a row and a column level. */
            MatrixHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                debug.assert(rowLevel >= 0, 'rowLevel');
                debug.assert(columnLevel >= 0, 'columnLevel');
                var columnLevels = this.columnHierarchy.levels;
                var rowLevels = this.rowHierarchy.levels;
                if (columnLevel === columnLevels.length - 1 || columnLevels.length === 0) {
                    var levelSource = rowLevels[rowLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: true,
                            isRowHeaderLeaf: rowLevel === rowLevels.length - 1,
                        };
                }
                if (rowLevel === rowLevels.length - 1) {
                    var levelSource = columnLevels[columnLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: false,
                            isRowHeaderLeaf: true,
                        };
                }
                return {
                    metadata: null,
                    isColumnHeaderLeaf: false,
                    isRowHeaderLeaf: false,
                };
            };
            MatrixHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                return (item1 === item2);
            };
            MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                return (item1 === item2);
            };
            MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                return (item1 === item2);
            };
            /** Implementation for MatrixDataAdapter interface */
            MatrixHierarchyNavigator.prototype.update = function (dataViewMatrix) {
                if (dataViewMatrix) {
                    this.matrix = dataViewMatrix;
                    this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows);
                    this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns);
                }
                this.updateHierarchy(this.rowHierarchy);
                this.updateHierarchy(this.columnHierarchy);
                MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy);
            };
            /** Implementation for MatrixDataAdapter interface */
            MatrixHierarchyNavigator.prototype.updateRows = function () {
                this.updateHierarchy(this.rowHierarchy);
            };
            MatrixHierarchyNavigator.wrapMatrixHierarchy = function (hierarchy) {
                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                matrixHierarchy.leafNodes = [];
                return matrixHierarchy;
            };
            MatrixHierarchyNavigator.prototype.updateHierarchy = function (hierarchy) {
                if (hierarchy.leafNodes.length > 0)
                    hierarchy.leafNodes.length = 0;
                if (hierarchy.root.children)
                    this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
            };
            MatrixHierarchyNavigator.prototype.updateRecursive = function (hierarchy, nodes, parent, cache) {
                var level;
                for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                    var node = nodes[i];
                    if (parent)
                        node.parent = parent;
                    if (!level)
                        level = hierarchy.levels[node.level];
                    if (level) {
                        var source = level.sources[node.levelSourceIndex ? node.levelSourceIndex : 0];
                        var formatString = visuals.valueFormatter.getFormatString(source, Matrix.formatStringProp);
                        if (formatString)
                            node.name = this.formatter(node.value, formatString);
                    }
                    node.index = i;
                    if (node.children && node.children.length > 0) {
                        this.updateRecursive(hierarchy, node.children, node, cache);
                    }
                    else {
                        node.leafIndex = cache.length;
                        cache.push(node);
                    }
                }
            };
            MatrixHierarchyNavigator.updateStaticColumnHeaders = function (columnHierarchy) {
                var columnLeafNodes = columnHierarchy.leafNodes;
                if (columnLeafNodes && columnLeafNodes.length > 0) {
                    var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources;
                    for (var i = 0, ilen = columnLeafNodes.length; i < ilen; i++) {
                        var columnLeafNode = columnLeafNodes[i];
                        // Static leaf may need to get label from it's definition
                        if (!columnLeafNode.identity && columnLeafNode.value === undefined) {
                            // We make distincion between null and undefined. Null can be considered as legit value, undefined means we need to fall back to metadata
                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                            if (source)
                                columnLeafNode.name = source.displayName;
                        }
                    }
                }
            };
            MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function (rootNodes) {
                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes)
                    return this.rowHierarchy;
                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                if (columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes)
                    return this.columnHierarchy;
                return null;
            };
            return MatrixHierarchyNavigator;
        })();
        var MatrixBinder = (function () {
            function MatrixBinder(hierarchyNavigator, options) {
                // We pass the hierarchy navigator in here because it is the object that will
                // survive data changes and gets updated with the latest data view.
                this.hierarchyNavigator = hierarchyNavigator;
                this.options = options;
            }
            MatrixBinder.prototype.onStartRenderingSession = function () {
            };
            MatrixBinder.prototype.onEndRenderingSession = function () {
            };
            // Row Header
            MatrixBinder.prototype.bindRowHeader = function (item, cell) {
                var styleClasses;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    if (!item.identity)
                        styleClasses = MatrixBinder.rowHeaderStaticLeafClassName;
                    else
                        styleClasses = MatrixBinder.rowHeaderLeafClassName;
                }
                else
                    styleClasses = MatrixBinder.headerClassName;
                if (item.isSubtotal)
                    styleClasses += ' ' + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                this.bindHeader(item, cell, this.getRowHeaderMetadata(item));
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
            };
            MatrixBinder.prototype.unbindRowHeader = function (item, cell) {
                cell.extension.clearContainerStyle();
                visuals.controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
            };
            // Column Header
            MatrixBinder.prototype.bindColumnHeader = function (item, cell) {
                var styleClasses;
                var overwriteTotalLabel = false;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    styleClasses = MatrixBinder.columnHeaderLeafClassName;
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    if (sortableHeaderColumnMetadata) {
                        this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell);
                    }
                    // Overwrite only if the there are subtotal siblings (like in the multimeasure case), which means ALL siblings are subtotals.
                    if (item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal)
                        overwriteTotalLabel = true;
                }
                else {
                    styleClasses = MatrixBinder.headerClassName;
                }
                if (item.isSubtotal)
                    styleClasses += ' ' + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                cell.extension.disableDragResize();
                this.bindHeader(item, cell, this.getColumnHeaderMetadata(item), overwriteTotalLabel);
            };
            MatrixBinder.prototype.unbindColumnHeader = function (item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = '';
                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                if (sortableHeaderColumnMetadata) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            // Body Cell
            MatrixBinder.prototype.bindBodyCell = function (item, cell) {
                var styleClasses = MatrixBinder.bodyCellClassName;
                if (item.isSubtotal)
                    styleClasses += ' ' + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                cell.extension.contentHost.textContent = item.content;
            };
            MatrixBinder.prototype.unbindBodyCell = function (item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = '';
            };
            MatrixBinder.prototype.registerColumnHeaderClickHandler = function (columnMetadata, cell) {
                var _this = this;
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName);
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function (cell) {
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            // Corner Cell
            MatrixBinder.prototype.bindCornerCell = function (item, cell) {
                var styleClasses;
                if (item.isColumnHeaderLeaf) {
                    styleClasses = MatrixBinder.columnHeaderLeafClassName;
                    var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                    if (cornerHeaderMetadata)
                        this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell);
                }
                if (item.isRowHeaderLeaf) {
                    if (styleClasses)
                        styleClasses += ' ';
                    else
                        styleClasses = '';
                    styleClasses += MatrixBinder.rowHeaderLeafClassName;
                }
                if (styleClasses)
                    cell.extension.setContainerStyle(styleClasses);
                else
                    cell.extension.setContainerStyle(MatrixBinder.headerClassName);
                cell.extension.disableDragResize();
                cell.extension.contentHost.textContent = item.metadata ? item.metadata.displayName : '';
            };
            MatrixBinder.prototype.unbindCornerCell = function (item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = '';
                if (item.isColumnHeaderLeaf) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            MatrixBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
            };
            // Measurement Helper
            MatrixBinder.prototype.getHeaderLabel = function (item) {
                return MatrixBinder.getNodeLabel(item);
            };
            MatrixBinder.prototype.getCellContent = function (item) {
                return item.content;
            };
            MatrixBinder.prototype.hasRowGroups = function () {
                // Figure out whether we have a static row header, i.e., not row groups
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return false;
                return true;
            };
            MatrixBinder.getNodeLabel = function (node) {
                // Return formatted value
                if (node.name)
                    return node.name;
                // Return unformatted value (fallback case)
                if (node.value != null)
                    return node.value.toString();
                return '';
            };
            MatrixBinder.prototype.bindHeader = function (item, cell, metadata, overwriteSubtotalLabel) {
                if (item.isSubtotal && !overwriteSubtotalLabel) {
                    cell.extension.contentHost.textContent = this.options.totalLabel;
                    return;
                }
                var value = MatrixBinder.getNodeLabel(item);
                if (!value) {
                    // just to maintain the height of the row in case all realized cells are nulls
                    cell.extension.contentHost.innerHTML = MatrixBinder.nonBreakingSpace;
                    return;
                }
                if (metadata && visuals.UrlHelper.isValidUrl(metadata, value)) {
                    visuals.controls.internal.TablixUtils.appendATagToBodyCell(item.value, cell);
                }
                else
                    cell.extension.contentHost.textContent = value;
            };
            /** Returns the column metadata of the column that needs to be sorted for the specified matrix corner node.
                Returns null if the specified corner node does not represent a sortable header. */
            MatrixBinder.prototype.getSortableCornerColumnMetadata = function (item) {
                if (!item.isColumnHeaderLeaf)
                    return null;
                return item.metadata;
            };
            MatrixBinder.prototype.getRowHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows)
                    return;
                return this.getHierarchyMetadata(dataView.rows, item.level);
            };
            MatrixBinder.prototype.getColumnHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.columns)
                    return;
                return this.getHierarchyMetadata(dataView.columns, item.level);
            };
            MatrixBinder.prototype.getHierarchyMetadata = function (hierarchy, level) {
                if (!hierarchy || !hierarchy.levels || hierarchy.levels.length < level)
                    return;
                var levelInfo = hierarchy.levels[level];
                if (!levelInfo || !levelInfo.sources || levelInfo.sources.length === 0)
                    return;
                // This assumes the source will always be the first item in the array of sources.
                return levelInfo.sources[0];
            };
            /** Returns the column metadata of the column that needs to be sorted for the specified header node.
                Returns null if the specified header node does not represent a sortable header. */
            MatrixBinder.prototype.getSortableHeaderColumnMetadata = function (item) {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                // If there are no row groups, sorting is not supported (as it does not make sense).
                if (!dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return null;
                // Note that the measures establish a level as well, so need to subtract 1
                var columnGroupCount = dataView.columns ? dataView.columns.levels.length - 1 : 0;
                var valueIndex = -1;
                if (columnGroupCount === 0) {
                    // Matrices without column groups, support sorting on all columns (which are then measure columns).
                    valueIndex = item.levelSourceIndex;
                }
                else if (item.isSubtotal) {
                    // Matrices with column groups support sorting only on the column grand total.
                    var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
                    if (isMultiMeasure) {
                        // In the multi-measure case we need to check if the parent's level is 0 in order
                        // to determine whether this is the column grand total.  The cells are layed out such
                        // that the clickable cells are at the innermost level, but the parent for the column
                        // grand total will have level 0.
                        if (item.parent && item.parent.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                    else {
                        // In the single-measure case we can directly check the level of the subtotal to
                        // detect the column grand total (at level 0).
                        if (item.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                }
                if (valueIndex !== -1) {
                    // NOTE: if the valueIndex is undefined it implicitly means that it is 0 based on the 
                    //       visual node contract
                    valueIndex = valueIndex ? valueIndex : 0;
                    return dataView.valueSources[valueIndex];
                }
                return null;
            };
            MatrixBinder.headerClassName = "bi-tablix-header";
            MatrixBinder.columnHeaderLeafClassName = "bi-tablix-column-header-leaf";
            MatrixBinder.rowHeaderLeafClassName = "bi-tablix-row-header-leaf";
            MatrixBinder.rowHeaderStaticLeafClassName = "bi-tablix-row-header-static-leaf";
            MatrixBinder.bodyCellClassName = "bi-matrix-body-cell";
            MatrixBinder.totalClassName = "total";
            MatrixBinder.nonBreakingSpace = '&nbsp;';
            return MatrixBinder;
        })();
        visuals.MatrixBinder = MatrixBinder;
        var Matrix = (function () {
            function Matrix() {
                this.lastAllowHeaderResize = true;
            }
            Matrix.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                var objects = dataViewMapping.metadata.objects;
                dataViewMatrix.rows.for.in.subtotalType = Matrix.shouldShowRowSubtotals(objects) ? 2 /* After */ : 0 /* None */;
                dataViewMatrix.columns.for.in.subtotalType = Matrix.shouldShowColumnSubtotals(objects) ? 2 /* After */ : 0 /* None */;
            };
            Matrix.getSortableRoles = function () {
                return ['Rows', 'Values'];
            };
            Matrix.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatRaw;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.hostServices = options.host;
            };
            Matrix.prototype.onResizing = function (finalViewport, duration) {
                this.updateViewport(finalViewport);
            };
            Matrix.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                if (options.dataViews && options.dataViews.length > 0) {
                    this.dataView = options.dataViews[0];
                    if (options.operationKind === 1 /* Append */) {
                        this.hierarchyNavigator.updateRows();
                        this.refreshControl(false);
                    }
                    else {
                        this.updateInternal();
                    }
                }
                this.waitingForData = false;
            };
            Matrix.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Matrix.prototype.refreshControl = function (clear) {
                if (this.element.visible() || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Matrix.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Matrix.prototype.createControl = function (matrixNavigator) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var matrixBinderOptions = {
                    onBindRowHeader: function (item) {
                        _this.onBindRowHeader(item);
                    },
                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                    onColumnHeaderClick: function (queryName) { return _this.onColumnHeaderClick(queryName); },
                };
                var matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */ ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder);
                var tablixContainer = document.createElement('div');
                tablixContainer.className = "tablixContainer";
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: false,
                };
                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
            };
            Matrix.prototype.updateInternal = function () {
                var _this = this;
                var dataView = this.dataView;
                if (!this.tablixControl) {
                    var matrixNavigator = createMatrixHierarchyNavigator(dataView.matrix, this.formatter);
                    this.hierarchyNavigator = matrixNavigator;
                    // Create the control
                    this.tablixControl = this.createControl(matrixNavigator);
                }
                else {
                    this.hierarchyNavigator.update(dataView.matrix);
                }
                this.verifyHeaderResize();
                // Update models before the viewport to make sure column widths are computed correctly
                this.tablixControl.updateModels(true, dataView.matrix.rows.root.children, dataView.matrix.columns.root.children);
                this.tablixControl.viewport = this.currentViewport;
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(true);
                }, 0);
            };
            Matrix.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Matrix.prototype.onColumnHeaderClick = function (queryName) {
                var sortDescriptors = [{
                    queryName: queryName,
                }];
                var args = {
                    sortDescriptors: sortDescriptors
                };
                this.hostServices.onCustomSort(args);
            };
            /* Public for testability */
            Matrix.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
            };
            Matrix.shouldShowRowSubtotals = function (objects) {
                if (objects && objects.general)
                    return objects.general.rowSubtotals !== false;
                // By default, totals are enabled
                return true;
            };
            Matrix.shouldShowColumnSubtotals = function (objects) {
                if (objects && objects.general)
                    return objects.general.columnSubtotals !== false;
                // By default, totals are enabled
                return true;
            };
            Matrix.prototype.getMatrixDataViewObjects = function () {
                if (this.dataView && this.dataView.metadata && this.dataView.metadata.objects)
                    return this.dataView.metadata.objects;
            };
            Matrix.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                if (options.objectName === 'general') {
                    var objects = this.getMatrixDataViewObjects();
                    instances.push({
                        selector: null,
                        properties: {
                            rowSubtotals: Matrix.shouldShowRowSubtotals(objects),
                            columnSubtotals: Matrix.shouldShowColumnSubtotals(objects)
                        },
                        objectName: options.objectName
                    });
                }
                return instances;
            };
            Matrix.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Matrix.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Matrix.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            Matrix.preferredLoadMoreThreshold = 0.8;
            // DEVNOTE: public only for testing
            Matrix.TotalLabel = 'TableTotalLabel';
            Matrix.capabilities = {
                dataRoles: [
                    {
                        name: RoleNames.rows,
                        kind: 0 /* Grouping */
                    },
                    {
                        name: RoleNames.columns,
                        kind: 0 /* Grouping */
                    },
                    {
                        name: RoleNames.values,
                        kind: 1 /* Measure */
                    }
                ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                            rowSubtotals: {
                                type: { bool: true },
                                displayName: powerbi.data.createDisplayNameGetter('Visual_RowTotals')
                            },
                            columnSubtotals: {
                                type: { bool: true },
                                displayName: powerbi.data.createDisplayNameGetter('Visual_ColumnTotals')
                            }
                        },
                    }
                },
                dataViewMappings: [{
                    conditions: [
                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Rows' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { window: { count: 100 } }
                        },
                        columns: {
                            for: { in: 'Columns' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { top: { count: 100 } }
                        },
                        values: {
                            for: { in: 'Values' }
                        }
                    }
                }],
                filterMappings: {
                    measureFilter: {
                        targetRoles: [RoleNames.rows]
                    }
                },
                sorting: {
                    custom: {},
                },
                suppressDefaultTitle: true,
            };
            return Matrix;
        })();
        visuals.Matrix = Matrix;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Textbox = (function () {
            function Textbox() {
            }
            Textbox.translateFontFamily = function (fontFamily) {
                // TODO support themes.
                return fontFamily === "Heading" ? "Segoe UI Light" : fontFamily;
            };
            Textbox.prototype.init = function (options) {
                this.element = options.element;
            };
            Textbox.prototype.onResizing = function (viewport, duration) {
            };
            Textbox.prototype.onDataChanged = function (options) {
                this.element.empty();
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general)
                    return;
                var paragraphs = objects.general.paragraphs;
                if (!paragraphs)
                    return;
                var textboxDiv = $("<div class='textbox'></div>");
                for (var i = 0, len = paragraphs.length; i < len; ++i) {
                    var paraDef = paragraphs[i];
                    var paraDiv = $("<div />");
                    if (paraDef.horizontalTextAlignment) {
                        paraDiv.css('textAlign', paraDef.horizontalTextAlignment);
                    }
                    for (var j = 0, jlen = paraDef.textRuns.length; j < jlen; ++j) {
                        var textRunDef = paraDef.textRuns[j];
                        var textRunSpan = $("<span/>");
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                textRunSpan.css('fontFamily', Textbox.translateFontFamily(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                textRunSpan.css('fontSize', styleDef.fontSize);
                            }
                            if (styleDef.fontStyle) {
                                textRunSpan.css('fontStyle', styleDef.fontStyle);
                            }
                            if (styleDef.fontWeight) {
                                textRunSpan.css('fontWeight', styleDef.fontWeight);
                            }
                            if (styleDef.textDecoration) {
                                textRunSpan.css('textDecoration', styleDef.textDecoration);
                            }
                        }
                        textRunSpan.text(textRunDef.value);
                        textRunSpan.appendTo(paraDiv);
                    }
                    paraDiv.appendTo(textboxDiv);
                }
                textboxDiv.appendTo(this.element);
            };
            Textbox.capabilities = {
                objects: {
                    general: {
                        properties: {
                            paragraphs: {
                                type: {}
                            }
                        }
                    }
                },
                suppressDefaultTitle: true,
            };
            return Textbox;
        })();
        visuals.Textbox = Textbox;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.treemapCapabilities = {
            dataRoles: [
                {
                    name: 'Group',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                },
                {
                    name: 'Details',
                    kind: 0 /* Grouping */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                },
                {
                    name: 'Values',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                },
                {
                    name: 'Gradient',
                    kind: 1 /* Measure */,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: {
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Group'],
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true, mainShow: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Group': { max: 1 }, 'Details': { max: 0 }, 'Gradient': { max: 1 } },
                    { 'Group': { max: 1 }, 'Details': { min: 1, max: 1 }, 'Values': { max: 1 }, 'Gradient': { max: 0 } }
                ],
                categorical: {
                    categories: {
                        for: { in: 'Group' },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: 'Details',
                            select: [{ bind: { to: 'Values' } }, { bind: { to: 'Gradient' } }],
                            dataReductionAlgorithm: { top: {} }
                        }
                    },
                    rowCount: { preferred: { min: 2 } }
                }
            }],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
                },
            },
        };
        visuals.treemapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CssConstants = jsCommon.CssConstants;
        var StringExtensions = jsCommon.StringExtensions;
        /** Renders an interactive treemap visual from categorical data */
        var Treemap = (function () {
            function Treemap(options) {
                if (options && options.animator) {
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                }
            }
            Treemap.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute').classed(Treemap.ClassName, true);
                this.shapeGraphicsContext = this.svg.append('g').classed(Treemap.ShapesClassName, true);
                this.labelGraphicsContext = this.svg.append('g').classed(Treemap.LabelsClassName, true);
                this.element = element;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.style = options.style;
                this.treemap = d3.layout.treemap().sticky(false).sort(function (a, b) { return a.size - b.size; }).value(function (d) { return d.size; }).round(false);
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.colors = this.style.colorPalette.dataColors;
                this.hostService = options.host;
            };
            /** Public for testing purposes */
            Treemap.converter = function (dataView, colors, labelSettings, interactivityService, legendObjectProperties) {
                var rootNode = {
                    key: "root",
                    name: "root",
                    children: [],
                    selected: false,
                    highlightMultiplier: 0,
                    identity: visuals.SelectionId.createNull(),
                    color: undefined,
                };
                var allNodes = [];
                var hasHighlights;
                var legendDataPoints = [];
                var legendTitle = "";
                var legendData = { title: legendTitle, dataPoints: legendDataPoints };
                var colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill);
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects['labels'];
                    if (labelsObj) {
                        labelSettings.show = (labelsObj.show !== undefined) ? labelsObj.show : labelSettings.show;
                        labelSettings.labelColor = (labelsObj.color !== undefined) ? labelsObj.color.solid.color : labelSettings.labelColor;
                    }
                }
                if (dataView && dataView.categorical && dataView.categorical.values) {
                    var data = dataView.categorical;
                    var valueColumns = data.values;
                    hasHighlights = !!(valueColumns.length > 0 && valueColumns[0].highlights);
                    var formatStringProp = visuals.treemapProps.general.formatString;
                    var result = Treemap.getValuesFromCategoricalDataView(data, hasHighlights);
                    var values = result.values;
                    var highlights = result.highlights;
                    if (result.highlightsOverflow) {
                        hasHighlights = false;
                        values = highlights;
                    }
                    var grouped = valueColumns.grouped();
                    var isMultiSeries = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    var hasDynamicSeries = !!valueColumns.source;
                    if ((data.categories == null) && values) {
                        for (var i = 0, ilen = values[0].length; i < ilen; i++) {
                            var value = values[0][i];
                            if (!Treemap.checkValueForShape(value))
                                continue;
                            var valueColumn = valueColumns[i];
                            var nodeName = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, valueColumns, formatStringProp);
                            var identity = hasDynamicSeries ? visuals.SelectionId.createWithId(valueColumns[i].identity) : visuals.SelectionId.createWithMeasure(valueColumns[i].source.queryName);
                            var key = identity.getKey();
                            var color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueColumn.objects && valueColumn.objects[0], data.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source)) : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
                            var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                            var categorical = dataView.categorical;
                            var valueIndex = i;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, nodeName, categorical.values, value, null, valueIndex);
                            var highlightedTooltipInfo;
                            if (highlightedValue !== undefined) {
                                highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, nodeName, categorical.values, value, null, valueIndex, highlightedValue);
                            }
                            var node = {
                                key: key,
                                name: nodeName,
                                size: value,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                            };
                            if (hasHighlights && highlights) {
                                node.highlightMultiplier = value ? highlights[0][i] / value : 0;
                            }
                            rootNode.children.push(node);
                            allNodes.push(node);
                            legendDataPoints.push({
                                label: nodeName,
                                color: color,
                                icon: 0 /* Box */,
                                identity: identity,
                                selected: false
                            });
                        }
                    }
                    else if (data.categories && data.categories.length > 0) {
                        // Create the first level from categories
                        var categoryColumn = data.categories[0];
                        var valueColumnCount = valueColumns.length;
                        legendTitle = categoryColumn.source ? categoryColumn.source.displayName : "";
                        for (var i = 0, ilen = values.length; i < ilen; i++) {
                            var categoryIdentity = categoryColumn.identity ? categoryColumn.identity[i] : undefined;
                            var identity = categoryIdentity ? visuals.SelectionId.createWithId(categoryIdentity) : visuals.SelectionId.createNull();
                            var key = identity.getKey();
                            var objects = categoryColumn.objects && categoryColumn.objects[i];
                            var color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[i]);
                            var categoryValue = visuals.valueFormatter.format(categoryColumn.values[i], visuals.valueFormatter.getFormatString(categoryColumn.values[i], formatStringProp));
                            var value = values[i][0];
                            var highlightedValue = hasHighlights && highlights ? highlights[i][0] : undefined;
                            var categorical = dataView.categorical;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value);
                            var highlightedTooltipInfo;
                            if (highlightedValue !== undefined) {
                                highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlightedValue);
                            }
                            var node = {
                                key: key,
                                name: categoryValue,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                            };
                            legendDataPoints.push({
                                label: categoryValue,
                                color: color,
                                icon: 0 /* Box */,
                                identity: identity,
                                selected: false
                            });
                            var total = 0;
                            var highlightTotal = 0; // Used if omitting second level
                            // Do not add second level if it's one and only one data point per shape and it's not a group value
                            // e.g. Category/Series group plus only one Value field
                            var omitSecondLevel = valueColumnCount === 1 && (valueColumns[0].source.groupName == null);
                            var currentValues = values[i];
                            for (var j = 0, jlen = currentValues.length; j < jlen; j++) {
                                var valueColumn = valueColumns[j];
                                var value = currentValues[j];
                                var highlight;
                                if (!Treemap.checkValueForShape(value))
                                    continue;
                                total += value;
                                if (hasHighlights) {
                                    highlight = highlights[i][j];
                                    highlightTotal += highlight;
                                }
                                if (!omitSecondLevel) {
                                    var childName = null;
                                    // Create key to ensure shape uniqueness
                                    var childKey = {
                                        parentId: node.key,
                                        nodeId: undefined
                                    };
                                    if (isMultiSeries) {
                                        // Measure: use name and index
                                        childKey.nodeId = { name: childName, index: j };
                                        childName = valueColumn.source.displayName;
                                    }
                                    else {
                                        // Series group instance
                                        childKey.nodeId = valueColumn.identity.key;
                                        childName = valueColumn.source.groupName;
                                    }
                                    var childIdentity = visuals.SelectionId.createWithIdsAndMeasure(categoryIdentity, hasDynamicSeries ? valueColumn.identity : undefined, isMultiSeries ? valueColumn.source.queryName : undefined);
                                    var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                                    var categorical = dataView.categorical;
                                    var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, j);
                                    var highlightedTooltipInfo;
                                    if (highlightedValue !== undefined) {
                                        highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, j, highlightedValue);
                                    }
                                    var childNode = {
                                        key: childIdentity.getKey(),
                                        name: childName,
                                        size: value,
                                        color: color,
                                        selected: false,
                                        identity: childIdentity,
                                        tooltipInfo: tooltipInfo,
                                        highlightedTooltipInfo: highlightedTooltipInfo,
                                    };
                                    if (hasHighlights)
                                        childNode.highlightMultiplier = value ? highlight / value : 0;
                                    if (node.children == null)
                                        node.children = [];
                                    node.children.push(childNode);
                                    allNodes.push(childNode);
                                }
                            }
                            if (Treemap.checkValueForShape(total)) {
                                node.size = total;
                                rootNode.children.push(node);
                                allNodes.push(node);
                            }
                            if (hasHighlights)
                                node.highlightMultiplier = total ? highlightTotal / total : 0;
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(allNodes);
                }
                legendData = { title: legendTitle, dataPoints: legendDataPoints };
                return { root: rootNode, hasHighlights: hasHighlights, legendData: legendData, dataLabelsSettings: labelSettings, legendObjectProperties: legendObjectProperties };
            };
            Treemap.getValuesFromCategoricalDataView = function (data, hasHighlights) {
                var valueColumns = data.values;
                var categoryValueCount;
                if (valueColumns && (data.categories == null)) {
                    categoryValueCount = 1; // We only get the first value out of each valueColumn since we don't have a category
                }
                else if (valueColumns && data.categories && data.categories.length > 0) {
                    categoryValueCount = data.categories[0].values.length;
                }
                var values = [];
                var highlights = [];
                for (var i = 0; i < categoryValueCount; i++) {
                    values.push([]);
                    if (hasHighlights)
                        highlights.push([]);
                }
                var highlightsOverflow;
                for (var j = 0; j < valueColumns.length; j++) {
                    var valueColumn = valueColumns[j];
                    for (var i = 0; i < categoryValueCount; i++) {
                        var value = valueColumn.values[i];
                        values[i].push(value);
                        if (hasHighlights) {
                            var highlight = valueColumn.highlights[i];
                            if (!highlight)
                                highlight = 0;
                            highlights[i].push(highlight);
                            if (highlight > value)
                                highlightsOverflow = true;
                        }
                    }
                }
                return {
                    values: values,
                    highlights: hasHighlights ? highlights : undefined,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : undefined
                };
            };
            Treemap.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                var labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                var legendObjectProperties = null;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    var dataView = dataViews[0];
                    var dataViewMetadata = dataView.metadata;
                    var objects;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                    if (objects) {
                        legendObjectProperties = objects['legend'];
                    }
                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, legendObjectProperties);
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0)
                        this.hostService.setWarnings(warnings);
                }
                else {
                    var rootNode = {
                        key: "root",
                        name: "root",
                        children: [],
                        selected: false,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: undefined,
                    };
                    var legendData = { title: "", dataPoints: [] };
                    var treeMapData = {
                        root: rootNode,
                        hasHighlights: false,
                        legendData: legendData,
                        dataLabelsSettings: labelSettings,
                    };
                    this.data = treeMapData;
                }
                var duration = options.duration == null ? (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0) : options.duration;
                this.updateInternal(!!duration, duration);
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onDataChanged = function (options) {
                this.update({
                    duration: options.duration || (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0),
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onResizing = function (viewport, duration) {
                this.update({
                    duration: duration || 0,
                    dataViews: this.dataViews,
                    viewport: viewport
                });
            };
            Treemap.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            Treemap.prototype.enumerateObjectInstances = function (options) {
                var data = this.data;
                if (!data)
                    return;
                var objectName = options.objectName;
                switch (objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole)
                            return this.enumerateDataPoints(data);
                        break;
                    case 'legend':
                        return this.enumerateLegend(data);
                    case 'labels':
                        return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false);
                }
            };
            Treemap.prototype.enumerateDataPoints = function (data) {
                var rootChildren = data.root.children;
                if (_.isEmpty(rootChildren))
                    return;
                var instances = [];
                for (var y = 0; y < rootChildren.length; y++) {
                    var treemapNode = rootChildren[y];
                    instances.push({
                        displayName: treemapNode.name,
                        selector: treemapNode.identity.getSelector(),
                        properties: {
                            fill: { solid: { color: treemapNode.color } }
                        },
                        objectName: 'dataPoint'
                    });
                }
                return instances;
            };
            Treemap.prototype.enumerateLegend = function (data) {
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title);
                return [{
                    selector: null,
                    objectName: 'legend',
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText
                    }
                }];
            };
            Treemap.checkValueForShape = function (value) {
                if (!value)
                    return false;
                return value > 0;
            };
            Treemap.prototype.calculateTreemapSize = function () {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            };
            Treemap.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.calculateTreemapSize();
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.isMajorLabel = function (node) {
                return node.depth === 1;
            };
            Treemap.hasChildrenWithIdentity = function (node) {
                var children = node.children;
                if (!children)
                    return false;
                var count = children.length;
                if (count === 0)
                    return false;
                for (var i = count - 1; i >= 0; i--) {
                    if (children[i].identity.hasIdentity())
                        return true;
                }
                return false;
            };
            Treemap.canDisplayLabel = function (node) {
                // Only display labels for level 1 and 2
                if (node.depth < 1 || node.depth > 2)
                    return false;
                if (StringExtensions.isNullOrEmpty(node.name))
                    return false;
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                var isMajorLabel = Treemap.isMajorLabel(node);
                var minTextWidth = isMajorLabel ? Treemap.MinTextWidthForMajorLabel : Treemap.MinTextWidthForMinorLabel;
                // Check if the room is enough for text with or without ellipse
                if (availableWidth < minTextWidth)
                    return false;
                var textHeight = isMajorLabel ? Treemap.MajorLabelTextSize : Treemap.MinorLabelTextSize;
                var textHeightWithMargin = textHeight + Treemap.TextMargin * 2;
                // Check if the shape is high enough for label
                if (node.dy < textHeightWithMargin)
                    return false;
                if (node.depth === 2) {
                    var parent = node.parent;
                    var roomTop = Math.max(parent.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2, node.y);
                    // Parent's label needs the room
                    if (node.y + node.dy - roomTop < textHeightWithMargin)
                        return false;
                }
                return true;
            };
            Treemap.createLabelForShape = function (node) {
                var baseTextProperties = Treemap.isMajorLabel(node) ? Treemap.MajorLabelTextProperties : Treemap.MinorLabelTextProperties;
                var textProperties = {
                    text: node.name,
                    fontFamily: baseTextProperties.fontFamily,
                    fontSize: baseTextProperties.fontSize
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, node.dx - Treemap.TextMargin * 2);
            };
            Treemap.getFill = function (d, isHighlightRect) {
                // NOTE: only painted shapes will catch click event. We either paint children or their parent but not both.
                // If it's a leaf with no category, parent will be painted instead (and support interactivity)
                if (d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect)
                    return CssConstants.noneValue;
                // If it's not a leaf and it has children with a category, children will be painted
                if (Treemap.hasChildrenWithIdentity(d))
                    return CssConstants.noneValue;
                return d.color;
            };
            Treemap.getFillOpacity = function (d, hasSelection, hasHighlights, isHighlightRect) {
                if (hasHighlights) {
                    if (isHighlightRect)
                        return null;
                    return Treemap.DimmedShapeOpacity.toString();
                }
                if (!hasSelection || d.selected)
                    return null;
                // Parent node is selected (as an optimization, we only check below level 1 because root node cannot be selected anyway)
                if (d.depth > 1 && d.parent.selected)
                    return null;
                // It's a parent node with interactive children, fall back to default opacity
                if (Treemap.hasChildrenWithIdentity(d))
                    return null;
                return Treemap.DimmedShapeOpacity.toString();
            };
            Treemap.prototype.updateInternal = function (useAnimation, duration) {
                if (useAnimation === void 0) { useAnimation = true; }
                if (duration === void 0) { duration = 0; }
                var data = this.data;
                var hasHighlights = data && data.hasHighlights;
                var labelSettings = data ? data.dataLabelsSettings : null;
                if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend) && this.data) {
                    this.renderLegend();
                }
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap.size([viewport.width, viewport.height]);
                // Shapes are drawn for all nodes
                var nodes = (data && data.root) ? this.treemap.nodes(data.root) : [];
                // Highlight shapes are drawn only for nodes with non-null/undefed highlightMultipliers that have no children
                var highlightNodes = nodes.filter(function (value) { return value.highlightMultiplier != null && (!value.children || value.children.length === 0); });
                // Labels are drawn only for nodes that can display labels
                var labeledNodes = labelSettings.show ? nodes.filter(function (d) { return Treemap.canDisplayLabel(d); }) : [];
                var shapes;
                var highlightShapes;
                var labels;
                var result;
                if (this.animator && useAnimation) {
                    var options = {
                        viewModel: data,
                        nodes: nodes,
                        highlightNodes: highlightNodes,
                        labeledNodes: labeledNodes,
                        shapeGraphicsContext: this.shapeGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        interactivityService: this.interactivityService,
                    };
                    result = this.animator.animate(options);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    labels = result.labels;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    var hasSelection = nodes.some(function (value) { return value.selected; });
                    var shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights);
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights);
                    labels = Treemap.drawDefaultLabels(this.labelGraphicsContext, labeledNodes, labelSettings);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        labels: labels,
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        nodes: nodes,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo; });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.prototype.renderLegend = function () {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.currentViewport);
                }
                else {
                    // TODO: Draw should be the only API. Visuals should only call that with orientation, props, etc 
                    // instead of managing state. Will follow up with another change.
                    this.legend.changeOrientation(0 /* Top */);
                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
                }
            };
            Treemap.prototype.accept = function (visitor, options) {
                visitor.visitTreemap(options);
            };
            Treemap.getNodeClass = function (d, highlight) {
                var nodeClass;
                switch (d.depth) {
                    case 1:
                        nodeClass = Treemap.ParentGroupClassName;
                        break;
                    case 2:
                        nodeClass = Treemap.NodeGroupClassName;
                        break;
                    case 0:
                        nodeClass = Treemap.RootNodeClassName;
                        break;
                    default:
                        debug.assertFail('Treemap only supports 2 levels maxiumum');
                }
                nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
                return nodeClass;
            };
            Treemap.createTreemapShapeLayout = function (isHighlightRect) {
                if (isHighlightRect === void 0) { isHighlightRect = false; }
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0); },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1)); },
                };
            };
            Treemap.createTreemapZeroShapeLayout = function () {
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + d.dy; },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return 0; },
                };
            };
            Treemap.drawDefaultShapes = function (context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + Treemap.TreemapNodeClassName).data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect').attr('class', Treemap.layout.shapeClass);
                shapes.style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); }).style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); }).attr(Treemap.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            Treemap.drawDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + Treemap.HighlightNodeClassName).data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect').attr('class', Treemap.layout.highlightShapeClass);
                highlightShapes.style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); }).style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); }).attr(Treemap.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            Treemap.drawDefaultLabels = function (context, nodes, labelSettings) {
                var labels = context.selectAll('text').data(nodes, function (d) { return d.key; });
                labels.enter().append('text').attr('class', Treemap.layout.labelClass);
                labels.attr(Treemap.layout.labelLayout).text(Treemap.layout.labelText).style('fill', function () { return labelSettings.labelColor; });
                labels.exit().remove();
                return labels;
            };
            Treemap.DimmedShapeOpacity = 0.4;
            Treemap.ClassName = 'treemap';
            Treemap.LabelsClassName = "labels";
            Treemap.MajorLabelClassName = 'majorLabel';
            Treemap.MinorLabelClassName = 'minorLabel';
            Treemap.ShapesClassName = "shapes";
            Treemap.TreemapNodeClassName = "treemapNode";
            Treemap.RootNodeClassName = 'rootNode';
            Treemap.ParentGroupClassName = 'parentGroup';
            Treemap.NodeGroupClassName = 'nodeGroup';
            Treemap.HighlightNodeClassName = 'treemapNodeHighlight';
            Treemap.TextMargin = 5;
            Treemap.MinorLabelTextSize = 10;
            Treemap.MinTextWidthForMinorLabel = 18;
            Treemap.MinorLabelTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: Treemap.MinorLabelTextSize + 'px'
            };
            Treemap.MajorLabelTextSize = 12;
            Treemap.MinTextWidthForMajorLabel = 22;
            Treemap.MajorLabelTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: Treemap.MajorLabelTextSize + 'px'
            };
            Treemap.layout = {
                shapeClass: function (d) { return Treemap.getNodeClass(d, false); },
                shapeLayout: Treemap.createTreemapShapeLayout(false),
                highlightShapeClass: function (d) { return Treemap.getNodeClass(d, true); },
                highlightShapeLayout: Treemap.createTreemapShapeLayout(true),
                zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                labelClass: function (d) { return Treemap.isMajorLabel(d) ? Treemap.MajorLabelClassName : Treemap.MinorLabelClassName; },
                labelLayout: {
                    x: function (d) { return d.x + Treemap.TextMargin; },
                    y: function (d) {
                        if (Treemap.isMajorLabel(d))
                            return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize;
                        return d.y + d.dy - Treemap.TextMargin;
                    },
                },
                labelText: function (d) { return Treemap.createLabelForShape(d); },
            };
            return Treemap;
        })();
        visuals.Treemap = Treemap;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Card = (function (_super) {
            __extends(Card, _super);
            function Card(options) {
                _super.call(this, Card.cardClassName);
                this.isScrollable = false;
                if (options && options.isScrollable)
                    this.isScrollable = options.isScrollable;
            }
            Card.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.animationOptions = options.animation;
                // Card should use WholeUnit display unit system unless otherwise specified
                var settings = this.convertSettings(options.settings);
                this.displayUnitSystemType = (!settings || !settings.DisplayUnitSystemType) ? 2 /* WholeUnits */ : settings.DisplayUnitSystemType;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0)).append('svg');
                this.graphicsContext = svg.append('g');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportProperties();
                if (this.isScrollable) {
                    svg.attr('class', Card.cardClassName);
                    this.labelContext = svg.append('g');
                }
            };
            Card.prototype.clear = function (valueOnly) {
                if (valueOnly === void 0) { valueOnly = false; }
                this.svg.select(Card.Value.selector).text('');
                if (!valueOnly)
                    this.svg.select(Card.Label.selector).text('');
                _super.prototype.clear.call(this);
            };
            Card.prototype.convertSettings = function (settings) {
                if (settings && settings.version === undefined) {
                    var cardSettings = powerbi.SettingsUtil.copyCommonSettings(settings);
                    return cardSettings;
                }
                return settings;
            };
            Card.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataView = options.dataViews[0];
                var value;
                if (dataView) {
                    this.getMetaDataColumn(dataView);
                    if (dataView.single) {
                        value = dataView.single.value;
                    }
                }
                this.updateInternal(value, options.duration);
            };
            Card.prototype.onResizing = function (viewport, duration) {
                this.currentViewport = viewport;
                this.updateViewportProperties();
                this.updateInternal(this.value, duration, true);
            };
            Card.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width).attr('height', viewport.height);
            };
            Card.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
            };
            Card.prototype.updateInternal = function (target, duration, forceUpdate) {
                if (duration === void 0) { duration = 0; }
                if (forceUpdate === void 0) { forceUpdate = false; }
                if (target == null) {
                    this.clear(true);
                    return;
                }
                var start = this.value;
                if (this.isScrollable) {
                    var label;
                    var metaDataColumn = this.metaDataColumn;
                    var labelStyles = Card.DefaultStyle.label;
                    var valueStyles = Card.DefaultStyle.value;
                    var formatter = visuals.valueFormatter.create({
                        format: this.getFormatString(metaDataColumn),
                        value: target,
                        displayUnitSystemType: this.displayUnitSystemType,
                        formatSingleValues: true,
                        allowFormatBeautification: true,
                    });
                    if (metaDataColumn)
                        label = metaDataColumn.displayName;
                    // using != null intentionally, this also checks for undefined.
                    if (target != null)
                        target = formatter.format(target);
                    var translateX = this.getTranslateX(this.currentViewport.width);
                    var translateY = (this.currentViewport.height - labelStyles.height - valueStyles.fontSize) / 2;
                    var valueElement = this.graphicsContext.attr('transform', visuals.SVGUtil.translate(translateX, this.getTranslateY(valueStyles.fontSize + translateY))).selectAll('text').data([target]);
                    valueElement.enter().append('text').attr('class', Card.Value.class);
                    valueElement.text(function (d) { return d; }).style({
                        'font-size': valueStyles.fontSize + 'px',
                        'fill': valueStyles.color,
                        'font-family': valueStyles.fontFamily,
                        'text-anchor': this.getTextAnchor()
                    });
                    valueElement.exit().remove();
                    var labelElement = this.labelContext.attr('transform', visuals.SVGUtil.translate(translateX, this.getTranslateY(valueStyles.fontSize + labelStyles.height + translateY))).selectAll('text').data([label]);
                    labelElement.enter().append('text').attr('class', Card.Label.class);
                    labelElement.text(function (d) { return d; }).style({
                        'font-size': labelStyles.fontSize + 'px',
                        'fill': labelStyles.color,
                        'text-anchor': this.getTextAnchor()
                    });
                    labelElement.exit().remove();
                }
                else {
                    this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate);
                }
                this.updateTooltip(target);
                this.value = target;
            };
            Card.prototype.updateTooltip = function (target) {
                if (!this.toolTip)
                    this.toolTip = this.graphicsContext.append("svg:title");
                this.toolTip.text(target);
            };
            Card.cardClassName = 'card';
            Card.Label = {
                class: 'label',
                selector: '.label'
            };
            Card.Value = {
                class: 'value',
                selector: '.value'
            };
            Card.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    fontSize: 16,
                    color: '#a6a6a6',
                    height: 26
                },
                value: {
                    fontSize: 37,
                    color: '#333333',
                    fontFamily: 'wf_segoe-ui_Semibold'
                }
            };
            Card.capabilities = {
                dataRoles: [
                    {
                        name: 'Values',
                        kind: 1 /* Measure */,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields')
                    }
                ],
                objects: visuals.AnimatedText.objectDescs,
                dataViewMappings: [{
                    conditions: [
                        { 'Values': { max: 1 } }
                    ],
                    single: { role: "Values" }
                }],
                suppressDefaultTitle: true,
            };
            return Card;
        })(visuals.AnimatedText);
        visuals.Card = Card;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var NoMapLocationWarning = (function () {
            function NoMapLocationWarning() {
            }
            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function () {
                    return 'NoMapLocation';
                },
                enumerable: true,
                configurable: true
            });
            NoMapLocationWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoMapLocationMessage';
                var titleKey = 'NoMapLocationKey';
                var detailKey = 'NoMapLocationValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return NoMapLocationWarning;
        })();
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var SmallSlicesCulledWarning = (function () {
            function SmallSlicesCulledWarning() {
            }
            Object.defineProperty(SmallSlicesCulledWarning.prototype, "code", {
                get: function () {
                    return 'SmallSlicesCulled';
                },
                enumerable: true,
                configurable: true
            });
            SmallSlicesCulledWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'DsrLimitWarning_TooMuchDataMessage';
                var titleKey = '';
                var detailKey = '';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return SmallSlicesCulledWarning;
        })();
        visuals.SmallSlicesCulledWarning = SmallSlicesCulledWarning;
        var NaNNotSupportedWarning = (function () {
            function NaNNotSupportedWarning() {
            }
            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NaNNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NaNNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_InfinityValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NaNNotSupportedWarning;
        })();
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = (function () {
            function InfinityValuesNotSupportedWarning() {
            }
            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'InfinityValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            InfinityValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_InfinityValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return InfinityValuesNotSupportedWarning;
        })();
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = (function () {
            function ValuesOutOfRangeWarning() {
            }
            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function () {
                    return 'ValuesOutOfRange';
                },
                enumerable: true,
                configurable: true
            });
            ValuesOutOfRangeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_VisualizationOutOfRange';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ValuesOutOfRangeWarning;
        })();
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.waterfallChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: 0 /* Grouping */,
                },
                {
                    name: 'Y',
                    kind: 1 /* Measure */,
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                            type: { text: true }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            type: { numeric: true }
                        },
                    }
                },
                sentimentColors: {
                    displayName: powerbi.data.createDisplayNameGetter('Waterfall_SentimentColors'),
                    properties: {
                        increaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_IncreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        decreaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_DecreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        totalFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_TotalLabel'),
                            type: { fill: { solid: { color: true } } }
                        }
                    },
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { formatting: { yAxisPosition: true } }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            type: { numeric: true }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            type: { numeric: true }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { formatting: { axisStyle: true } }
                        }
                    }
                },
            },
            dataViewMappings: [{
                conditions: [
                    { 'Category': { max: 1 }, 'Y': { max: 1 } },
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' }
                    },
                    values: {
                        select: [{ bind: { to: 'Y' } }]
                    },
                },
            }],
        };
        visuals.waterfallChartProps = {
            sentimentColors: {
                increaseFill: { objectName: 'sentimentColors', propertyName: 'increaseFill' },
                decreaseFill: { objectName: 'sentimentColors', propertyName: 'decreaseFill' },
                totalFill: { objectName: 'sentimentColors', propertyName: 'totalFill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WaterfallChart = (function () {
            function WaterfallChart(options) {
                this.isScrollable = options.isScrollable;
            }
            WaterfallChart.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.svg = options.svg;
                this.clearCatcher = this.svg.select('.clearCatcher');
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.element = options.element;
                this.colors = this.style.colorPalette.dataColors;
                this.element.addClass(WaterfallChart.WaterfallClassName);
                this.mainGraphicsSVG = this.svg.append('svg');
                this.mainGraphicsContext = this.mainGraphicsSVG.append('g').classed(WaterfallChart.MainGraphicsContextClassName, true);
                this.dataLabelsSVG = this.svg.append('g').classed(WaterfallChart.DataLabelsSVGClassName, true);
            };
            WaterfallChart.converter = function (dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, dataViewMetadata) {
                debug.assertValue(palette, 'palette');
                var formatStringProp = WaterfallChart.formatStringProp;
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, formatStringProp);
                var categories = categoryInfo.categories, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                var increaseColor = sentimentColors.increaseFill.solid.color;
                var decreaseColor = sentimentColors.decreaseFill.solid.color;
                var totalColor = sentimentColors.totalFill.solid.color;
                var legend = [
                    {
                        label: hostServices.getLocalizedString(WaterfallChart.IncreaseLabel),
                        color: increaseColor,
                        icon: 0 /* Box */,
                        identity: !_.isEmpty(categoryIdentities) ? visuals.SelectionId.createWithId(categoryIdentities[0]) : visuals.SelectionId.createNull(),
                        selected: false
                    },
                    {
                        label: hostServices.getLocalizedString(WaterfallChart.DecreaseLabel),
                        color: decreaseColor,
                        icon: 0 /* Box */,
                        identity: !_.isEmpty(categoryIdentities) ? visuals.SelectionId.createWithId(categoryIdentities[0]) : visuals.SelectionId.createNull(),
                        selected: false
                    }
                ];
                /**
                 * The position represents the starting point for each bar, for any value it is the sum of all previous values.
                 * Values > 0 are considered gains, values < 0 are losses.
                 */
                var pos = 0, posMin = 0, posMax = 0;
                var dataPoints = [];
                var valuesMetadata = null;
                // We only support a single series.
                if (dataView.values && dataView.values.length > 0) {
                    var column = dataView.values[0];
                    valuesMetadata = column.source;
                    for (var categoryIndex = 0, catLen = column.values.length; categoryIndex < catLen; categoryIndex++) {
                        var category = categories[categoryIndex];
                        var value = column.values[categoryIndex];
                        var identity = categoryIdentities ? visuals.SelectionId.createWithId(categoryIdentities[categoryIndex], false) : visuals.SelectionId.createNull();
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categories, category, dataView.values, value);
                        var color = value > 0 ? increaseColor : decreaseColor;
                        // TODO: convert dates to text?
                        // TODO: support partial highlights
                        dataPoints.push({
                            value: value,
                            position: pos,
                            color: color,
                            categoryValue: category,
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: dataLabelSettings.overrideDefaultColor ? dataLabelSettings.labelColor : color,
                        });
                        pos += value;
                        if (pos > posMax)
                            posMax = pos;
                        if (pos < posMin)
                            posMin = pos;
                    }
                }
                if (WaterfallChart.showTotal) {
                    var identity = visuals.SelectionId.createNull();
                    var categoryValue = hostServices.getLocalizedString(WaterfallChart.TotalLabel);
                    var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categories, categoryValue, dataView.values, pos);
                    dataPoints.push({
                        value: pos,
                        position: 0,
                        color: totalColor,
                        categoryValue: categoryValue,
                        categoryIndex: categoryIndex,
                        identity: identity,
                        seriesIndex: 0,
                        selected: false,
                        highlight: false,
                        key: identity.getKey(),
                        tooltipInfo: tooltipInfo,
                        labelFill: dataLabelSettings.overrideDefaultColor ? dataLabelSettings.labelColor : sentimentColors.totalFill.solid.color,
                    });
                    legend.push({
                        label: categoryValue,
                        color: totalColor,
                        icon: 0 /* Box */,
                        identity: identity,
                        selected: false
                    });
                }
                var hasSelection = false;
                if (interactivityService) {
                    if (interactivityService.applySelectionStateToData(dataPoints))
                        hasSelection = true;
                }
                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                var valuesMetadataArray = [];
                valuesMetadataArray.push(valuesMetadata);
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, valuesMetadataArray);
                return {
                    series: [{ data: dataPoints }],
                    categories: categories,
                    categoryMetadata: categoryMetadata,
                    valuesMetadata: valuesMetadata,
                    legend: { dataPoints: legend },
                    hasHighlights: false,
                    positionMin: posMin,
                    positionMax: posMax,
                    dataLabelsSettings: dataLabelSettings,
                    sentimentColors: sentimentColors,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                    hasSelection: hasSelection,
                };
            };
            WaterfallChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var sentimentColors = this.getSentimentColorsFromObjects(null);
                this.data = {
                    series: [{ data: [] }],
                    categories: [],
                    valuesMetadata: null,
                    legend: { dataPoints: [] },
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(),
                    sentimentColors: sentimentColors,
                    axesLabels: { x: null, y: null },
                    hasSelection: false,
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.metadata && dataView.metadata.objects) {
                            var objects = dataView.metadata.objects;
                            var labelsObj = objects['labels'];
                            if (labelsObj) {
                                if (labelsObj.show !== undefined)
                                    this.data.dataLabelsSettings.show = labelsObj.show;
                                if (labelsObj.color !== undefined) {
                                    this.data.dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                                    this.data.dataLabelsSettings.overrideDefaultColor = true;
                                }
                                if (labelsObj.labelDisplayUnits !== undefined) {
                                    this.data.dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                                }
                                if (labelsObj.labelPrecision !== undefined) {
                                    this.data.dataLabelsSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : 0;
                                }
                            }
                            this.data.dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                            sentimentColors = this.getSentimentColorsFromObjects(objects);
                        }
                        if (dataView.categorical) {
                            this.data = WaterfallChart.converter(dataView.categorical, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, dataView.metadata);
                        }
                    }
                }
            };
            WaterfallChart.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'sentimentColors':
                        return this.enumerateSentimentColors();
                    case 'labels':
                        return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true);
                }
            };
            WaterfallChart.prototype.enumerateSentimentColors = function () {
                var instances = [];
                var sentimentColors = this.data.sentimentColors;
                instances.push({
                    selector: null,
                    properties: {
                        increaseFill: sentimentColors.increaseFill,
                        decreaseFill: sentimentColors.decreaseFill,
                        totalFill: sentimentColors.totalFill
                    },
                    objectName: 'sentimentColors'
                });
                return instances;
            };
            WaterfallChart.prototype.calculateLegend = function () {
                // TODO: support interactive legend
                return this.data.legend;
            };
            WaterfallChart.prototype.hasLegend = function () {
                // Waterfall legend is more like a color-key, so just return true
                return true;
            };
            WaterfallChart.createClippedDataIfOverflowed = function (data, renderableDataCount) {
                var clipped = data;
                var dataPoints = data.series[0].data;
                if (data && renderableDataCount < dataPoints.length) {
                    clipped = powerbi.Prototype.inherit(data);
                    clipped.series = [{ data: dataPoints.slice(0, renderableDataCount) }];
                    clipped.categories = data.categories.slice(0, renderableDataCount);
                }
                return clipped;
            };
            WaterfallChart.prototype.calculateAxesProperties = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var data = this.clippedData = this.data;
                var categoryCount = WaterfallChart.showTotal ? data.categories.length + 1 : data.categories.length;
                /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
                 In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
                var preferredPlotArea = this.getPreferredPlotArea(false, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness);
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= (margin.left + margin.right);
                }
                preferredPlotArea.height -= (margin.top + margin.bottom);
                var cartesianLayout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: preferredPlotArea.width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable
                });
                // In the case that we have overflowed horizontally we want to clip the data and use that to calculate the axes on the dashboard.           
                if (!this.isScrollable) {
                    data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount);
                }
                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options);
                var yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options);
                var xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions);
                var yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions);
                var categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var formatter = visuals.valueFormatter.create(visuals.dataLabelUtils.getLabelFormatterOptions(this.data.dataLabelsSettings));
                this.layout = {
                    categoryCount: cartesianLayout.categoryCount,
                    categoryThickness: cartesianLayout.categoryThickness,
                    isScalar: cartesianLayout.isScalar,
                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                    categoryWidth: categoryWidth,
                    labelText: function (d) {
                        return visuals.dataLabelUtils.getLabelFormattedText(formatter.format(d.value));
                    },
                    labelLayout: {
                        y: function (d, i) {
                            return WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - visuals.dataLabelUtils.labelMargin;
                        },
                        x: function (d, i) {
                            return xAxisProperties.scale(d.categoryIndex) + (categoryWidth / 2);
                        },
                    },
                    filter: function (d) {
                        return (d != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; }
                    },
                };
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [xAxisProperties, yAxisProperties];
            };
            WaterfallChart.lookupXValue = function (data, index, type) {
                var dataPoints = data.series[0].data;
                var point = dataPoints[index];
                if (point && point.categoryValue) {
                    if (this.showTotal && index === dataPoints.length - 1)
                        return point.categoryValue;
                    else if (visuals.AxisHelper.isDateTime(type))
                        return new Date(point.categoryValue);
                    else
                        return point.categoryValue;
                }
                return index;
            };
            WaterfallChart.getXAxisCreationOptions = function (data, width, layout, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
                var domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, false, options.forcedXDomain);
                var categoryThickness = layout.categoryThickness;
                var outerPadding = categoryThickness * layout.outerPaddingRatio;
                return {
                    pixelSpan: width,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatStringProp: WaterfallChart.formatStringProp,
                    isScalar: false,
                    outerPadding: outerPadding,
                    categoryThickness: categoryThickness,
                    getValueFn: function (index, type) { return WaterfallChart.lookupXValue(data, index, type); },
                    forcedTickCount: options.forcedTickCount,
                    isCategoryAxis: true
                };
            };
            WaterfallChart.getYAxisCreationOptions = function (data, height, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [data.positionMin, data.positionMax]);
                return {
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    isScalar: true,
                    isVertical: true,
                    metaDataColumn: data.valuesMetadata,
                    formatStringProp: WaterfallChart.formatStringProp,
                    outerPadding: 0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                };
            };
            WaterfallChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar);
            };
            WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return false;
            };
            WaterfallChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            WaterfallChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = [{ data: data.series[0].data.slice(startIndex, endIndex) }];
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            WaterfallChart.prototype.createRects = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector);
                var cols = colsSelection.data(data, function (d) { return d.key; });
                cols.enter().append('rect').attr('class', function (d) { return WaterfallChart.CategoryValueClasses.class.concat(d.highlight ? 'highlight' : ''); });
                cols.exit().remove();
                return cols;
            };
            WaterfallChart.prototype.createConnectors = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector);
                var connectors = connectorSelection.data(data.slice(0, data.length - 1), function (d) { return d.key; });
                connectors.enter().append('line').classed(WaterfallChart.WaterfallConnectorClasses.class, true);
                connectors.exit().remove();
                return connectors;
            };
            WaterfallChart.prototype.render = function (duration) {
                var _this = this;
                var dataPoints = this.clippedData.series[0].data;
                var bars = this.createRects(dataPoints);
                var connectors = this.createConnectors(dataPoints);
                visuals.TooltipManager.addTooltip(bars, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var hasSelection = this.data.hasSelection;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight()).attr('width', this.getAvailableWidth());
                /**
                 * The y-value is always at the top of the rect. If the data value is negative then we can
                 * use the scaled position directly since we are drawing down. If the data value is positive
                 * we have to calculate the top of the rect and use that as the y-value. Since the y-value
                 * is always the top of the rect, height should always be positive.
                 */
                bars.style('fill', function (d) { return d.color; }).style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights); }).attr('width', this.layout.categoryWidth).attr('x', function (d) { return xScale(d.categoryIndex); }).attr('y', function (d) { return WaterfallChart.getRectTop(yScale, d.position, d.value); }).attr('height', function (d) { return y0 - yScale(Math.abs(d.value)); });
                connectors.attr({
                    'x1': function (d) { return xScale(d.categoryIndex); },
                    'y1': function (d) { return yScale(d.position + d.value); },
                    'x2': function (d) { return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth; },
                    'y2': function (d) { return yScale(d.position + d.value); },
                });
                if (this.data.dataLabelsSettings.show) {
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, this.layout, this.currentViewport);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        bars: bars,
                        datapoints: dataPoints,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            WaterfallChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            WaterfallChart.prototype.accept = function (visitor, options) {
                debug.assertValue(visitor, 'visitor');
                visitor.visitWaterfallChart(options);
            };
            WaterfallChart.prototype.getSupportedCategoryAxisType = function () {
                return powerbi.axisType.categorical;
            };
            WaterfallChart.getRectTop = function (scale, pos, value) {
                if (value < 0)
                    return scale(pos);
                else
                    return scale(pos) - (scale(0) - scale(value));
            };
            WaterfallChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            WaterfallChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            WaterfallChart.prototype.getSentimentColorsFromObjects = function (objects) {
                var defaultSentimentColors = this.colors.getSentimentColors();
                var increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value);
                var decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value);
                var totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                return {
                    increaseFill: { solid: { color: increaseColor } },
                    decreaseFill: { solid: { color: decreaseColor } },
                    totalFill: { solid: { color: totalColor } }
                };
            };
            WaterfallChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            WaterfallChart.WaterfallClassName = 'waterfallChart';
            WaterfallChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            WaterfallChart.DataLabelsSVGClassName = 'dataLabelsSVG';
            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel";
            WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel";
            WaterfallChart.TotalLabel = "Waterfall_TotalLabel";
            WaterfallChart.CategoryValueClasses = {
                class: 'column',
                selector: '.column'
            };
            WaterfallChart.WaterfallConnectorClasses = {
                class: 'waterfall-connector',
                selector: '.waterfall-connector'
            };
            WaterfallChart.defaultTotalColor = "#00b8aa";
            // TODO: There is an issue with showing the "total" column with dates. The logic to calculate
            // the way the axis should be shown is confused by the mix of dates and non-dates.
            WaterfallChart.showTotal = true;
            return WaterfallChart;
        })();
        visuals.WaterfallChart = WaterfallChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            // This file registers the built-in visualizations
            plugins.animatedNumber = {
                name: 'animatedNumber',
                capabilities: visuals.AnimatedNumber.capabilities,
                create: function () { return new visuals.AnimatedNumber(); }
            };
            plugins.areaChart = {
                name: 'areaChart',
                watermarkKey: 'area',
                capabilities: visuals.lineChartCapabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 1 /* Area */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.barChart = {
                name: 'barChart',
                watermarkKey: 'bar',
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function () { return new visuals.CartesianChart({ chartType: 5 /* StackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.card = {
                name: 'card',
                watermarkKey: 'card',
                capabilities: visuals.Card.capabilities,
                create: function () { return new visuals.Card(); }
            };
            plugins.multiRowCard = {
                name: 'multiRowCard',
                watermarkKey: 'multiRowCard',
                capabilities: visuals.MultiRowCard.capabilities,
                create: function () { return new visuals.MultiRowCard(); }
            };
            plugins.clusteredBarChart = {
                name: 'clusteredBarChart',
                watermarkKey: 'clusteredBar',
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function () { return new visuals.CartesianChart({ chartType: 4 /* ClusteredBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.clusteredColumnChart = {
                name: 'clusteredColumnChart',
                watermarkKey: 'clusteredColumn',
                capabilities: visuals.getColumnChartCapabilities(),
                create: function () { return new visuals.CartesianChart({ chartType: 2 /* ClusteredColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.columnChart = {
                name: 'columnChart',
                watermarkKey: 'column',
                capabilities: visuals.getColumnChartCapabilities(),
                create: function () { return new visuals.CartesianChart({ chartType: 3 /* StackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.comboChart = {
                name: 'comboChart',
                watermarkKey: 'combo',
                capabilities: visuals.ComboChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 9 /* ComboChart */ }); }
            };
            plugins.dataDotChart = {
                name: 'dataDotChart',
                capabilities: visuals.DataDotChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 10 /* DataDot */ }); }
            };
            plugins.dataDotClusteredColumnComboChart = {
                name: 'dataDotClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.ComboChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 14 /* DataDotClusteredColumnCombo */ }); }
            };
            plugins.dataDotStackedColumnComboChart = {
                name: 'dataDotStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.ComboChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 15 /* DataDotStackedColumnCombo */ }); }
            };
            plugins.donutChart = {
                name: 'donutChart',
                watermarkKey: 'donut',
                capabilities: visuals.donutChartCapabilities,
                create: function () { return new visuals.DonutChart(); }
            };
            plugins.funnel = {
                name: 'funnel',
                watermarkKey: 'funnel',
                capabilities: visuals.funnelChartCapabilities,
                create: function () { return new visuals.FunnelChart(); }
            };
            plugins.gauge = {
                name: 'gauge',
                watermarkKey: 'gauge',
                capabilities: visuals.Gauge.capabilities,
                create: function () { return new visuals.Gauge(); }
            };
            plugins.hundredPercentStackedBarChart = {
                name: 'hundredPercentStackedBarChart',
                watermarkKey: '100stackedbar',
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function () { return new visuals.CartesianChart({ chartType: 6 /* HundredPercentStackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.hundredPercentStackedColumnChart = {
                name: 'hundredPercentStackedColumnChart',
                watermarkKey: '100stackedcolumn',
                capabilities: visuals.getColumnChartCapabilities(),
                create: function () { return new visuals.CartesianChart({ chartType: 7 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.image = {
                name: 'image',
                capabilities: visuals.ImageVisual.capabilities,
                create: function () { return new visuals.ImageVisual(); }
            };
            plugins.lineChart = {
                name: 'lineChart',
                watermarkKey: 'line',
                capabilities: visuals.lineChartCapabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 0 /* Line */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.LineChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.lineStackedColumnComboChart = {
                name: 'lineStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.ComboChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 13 /* LineStackedColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.lineClusteredColumnComboChart = {
                name: 'lineClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.ComboChart.capabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 12 /* LineClusteredColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.map = {
                name: 'map',
                watermarkKey: 'map',
                capabilities: visuals.mapCapabilities,
                create: function () { return new visuals.Map({ filledMap: false }); }
            };
            plugins.filledMap = {
                name: 'filledMap',
                watermarkKey: 'map',
                capabilities: visuals.filledMapCapabilities,
                create: function () { return new visuals.Map({ filledMap: true }); }
            };
            plugins.treemap = {
                name: 'treemap',
                watermarkKey: 'tree',
                capabilities: visuals.treemapCapabilities,
                create: function () { return new visuals.Treemap(); }
            };
            plugins.pieChart = {
                name: 'pieChart',
                watermarkKey: 'pie',
                capabilities: visuals.donutChartCapabilities,
                create: function () { return new visuals.DonutChart({ sliceWidthRatio: 0 }); }
            };
            plugins.scatterChart = {
                name: 'scatterChart',
                watermarkKey: 'scatterplot',
                capabilities: visuals.scatterChartCapabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 8 /* Scatter */ }); }
            };
            plugins.table = {
                name: 'table',
                watermarkKey: 'table',
                capabilities: visuals.Table.capabilities,
                create: function () { return new visuals.Table(); },
                customizeQuery: visuals.Table.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Table.getSortableRoles(); },
            };
            plugins.matrix = {
                name: 'matrix',
                watermarkKey: 'matrix',
                capabilities: visuals.Matrix.capabilities,
                create: function () { return new visuals.Matrix(); },
                customizeQuery: visuals.Matrix.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Matrix.getSortableRoles(); },
            };
            plugins.slicer = {
                name: 'slicer',
                watermarkKey: 'slicer',
                capabilities: visuals.slicerCapabilities,
                create: function () { return new visuals.Slicer(); }
            };
            plugins.textbox = {
                name: 'textbox',
                capabilities: visuals.RichTextbox.capabilities,
                create: function () { return new visuals.RichTextbox(); }
            };
            plugins.waterfallChart = {
                name: 'waterfallChart',
                watermarkKey: 'waterfall',
                capabilities: visuals.waterfallChartCapabilities,
                create: function () { return new visuals.CartesianChart({ chartType: 11 /* Waterfall */ }); }
            };
            plugins.cheerMeter = {
                name: 'cheerMeter',
                capabilities: visuals.CheerMeter.capabilities,
                create: function () { return new visuals.CheerMeter(); }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company='Microsoft Corporation'>
//        Copyright (c) Microsoft Corporation.  All rights reserved. 
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TouchUtils = powerbi.visuals.controls.TouchUtils;
        var ScreenArea;
        (function (ScreenArea) {
            ScreenArea[ScreenArea["TopLeft"] = 0] = "TopLeft";
            ScreenArea[ScreenArea["TopRight"] = 1] = "TopRight";
            ScreenArea[ScreenArea["BottomRight"] = 2] = "BottomRight";
            ScreenArea[ScreenArea["BottomLeft"] = 3] = "BottomLeft";
        })(ScreenArea || (ScreenArea = {}));
        ;
        var ToolTipComponent = (function () {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions;
                this.isTooltipVisible = false;
                if (!tooltipOptions) {
                    this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions;
                }
            }
            // For tests only
            ToolTipComponent.prototype.isTooltipComponentVisible = function () {
                return this.isTooltipVisible;
            };
            // For tests only
            ToolTipComponent.prototype.setTestScreenSize = function (width, height) {
                this.customScreenWidth = width;
                this.customScreenHeight = height;
            };
            ToolTipComponent.prototype.show = function (tooltipData, clickedArea) {
                this.isTooltipVisible = true;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer();
                }
                this.setTooltipContent(tooltipData);
                this.tooltipContainer.style("visibility", "visible").transition().duration(0).style("opacity", this.tooltipOptions.opacity);
                this.setPosition(clickedArea);
            };
            ToolTipComponent.prototype.move = function (tooltipData, clickedArea) {
                if (this.isTooltipVisible) {
                    if (tooltipData) {
                        this.setTooltipContent(tooltipData);
                    }
                    this.setPosition(clickedArea);
                }
            };
            ToolTipComponent.prototype.hide = function () {
                if (this.isTooltipVisible) {
                    this.isTooltipVisible = false;
                    this.tooltipContainer.transition().duration(this.tooltipOptions.animationDuration).style("opacity", 0).each('end', function () {
                        this.style.visibility = "hidden";
                    });
                }
            };
            ToolTipComponent.prototype.createTooltipContainer = function () {
                var container = d3.select(ToolTipComponent.parentContainerSelector).append("div").attr("class", ToolTipComponent.containerClassName);
                container.append("div").attr("class", ToolTipComponent.arrowClassName);
                container.append("div").attr("class", ToolTipComponent.contentContainerClassName);
                return container;
            };
            ToolTipComponent.prototype.setTooltipContent = function (tooltipData) {
                var rowsSelector = "." + ToolTipComponent.tooltipRowClassName;
                var contentContainer = this.tooltipContainer.select("." + ToolTipComponent.contentContainerClassName);
                // Clear existing content
                contentContainer.selectAll(".tooltip-row").remove();
                var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData);
                var newRow = tooltipRow.enter().append("div").attr("class", ToolTipComponent.tooltipRowClassName);
                var newTitleCell = newRow.append("div").attr("class", ToolTipComponent.tooltipTitleCellClassName);
                var newValueCell = newRow.append("div").attr("class", ToolTipComponent.tooltipValueCellClassName);
                newTitleCell.text(function (d) {
                    return d.displayName;
                });
                newValueCell.text(function (d) {
                    return d.value;
                });
            };
            ToolTipComponent.prototype.getTooltipPosition = function (clickedArea, clickedScreenArea) {
                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                var centerPointOffset = Math.floor(clickedArea.width / 2);
                var offsetX = 0;
                var offsetY = 0;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var arrowOffset = 7;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                centerPoint.offset(offsetX, offsetY);
                return centerPoint;
            };
            ToolTipComponent.prototype.setPosition = function (clickedArea) {
                var clickedScreenArea = this.getClickedScreenArea(clickedArea);
                var tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                this.tooltipContainer.style({ "left": tooltipPosition.x + "px", "top": tooltipPosition.y + "px" });
                this.setArrowPosition(clickedArea, clickedScreenArea);
            };
            ToolTipComponent.prototype.setArrowPosition = function (clickedArea, clickedScreenArea) {
                var arrow = this.getArrowElement();
                var arrowClassName;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    arrowClassName = "top left";
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    arrowClassName = "top right";
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    arrowClassName = "bottom left";
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    arrowClassName = "bottom right";
                }
                arrow.attr('class', 'arrow').classed(arrowClassName, true);
            };
            ToolTipComponent.prototype.getArrowElement = function () {
                return this.tooltipContainer.select("." + ToolTipComponent.arrowClassName);
            };
            ToolTipComponent.prototype.getClickedScreenArea = function (clickedArea) {
                var screenWidth = this.customScreenWidth || window.innerWidth;
                var screenHeight = this.customScreenHeight || window.innerHeight;
                var centerPointOffset = clickedArea.width / 2;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var halfWidth = screenWidth / 2;
                var halfHeight = screenHeight / 2;
                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
                    return 0 /* TopLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
                    return 1 /* TopRight */;
                }
                else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
                    return 3 /* BottomLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
                    return 2 /* BottomRight */;
                }
            };
            ToolTipComponent.DefaultTooltipOptions = {
                opacity: 1,
                animationDuration: 250,
                offsetX: 10,
                offsetY: 10
            };
            ToolTipComponent.containerClassName = "tooltip-container";
            ToolTipComponent.contentContainerClassName = "tooltip-content-container";
            ToolTipComponent.arrowClassName = "arrow";
            ToolTipComponent.tooltipRowClassName = "tooltip-row";
            ToolTipComponent.tooltipTitleCellClassName = "tooltip-title-cell";
            ToolTipComponent.tooltipValueCellClassName = "tooltip-value-cell";
            ToolTipComponent.parentContainerSelector = "body";
            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
            return ToolTipComponent;
        })();
        visuals.ToolTipComponent = ToolTipComponent;
        var TooltipManager;
        (function (TooltipManager) {
            TooltipManager.ShowTooltips = true;
            TooltipManager.ToolTipInstance = new ToolTipComponent();
            var GlobalTooltipEventsAttached = false;
            var tooltipMouseOverDelay = 500;
            var tooltipTouchDelay = 500;
            var tooltipTimeoutId;
            var mouseCoordinates;
            function addTooltip(d3Selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                if (!TooltipManager.ShowTooltips) {
                    return;
                }
                debug.assertValue(d3Selection, "d3Selection");
                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                var touchStartEventName = getTouchStartEventName();
                var touchEndEventName = getTouchEndEventName();
                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
                // Mouse events
                d3Selection.on("mouseover", function (d, i) {
                    if (canDisplayTooltip(d3.event)) {
                        mouseCoordinates = getCoordinates(rootNode, true);
                        var elementCoordinates = getCoordinates(this, true);
                        var tooltipEvent = {
                            data: d,
                            index: i,
                            coordinates: mouseCoordinates,
                            elementCoordinates: elementCoordinates,
                            context: this,
                            isTouchEvent: false
                        };
                        clearTooltipTimeout();
                        tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipMouseOverDelay);
                    }
                });
                d3Selection.on("mouseout", function (d, i) {
                    clearTooltipTimeout();
                    hideTooltipEventHandler();
                });
                d3Selection.on("mousemove", function (d, i) {
                    if (canDisplayTooltip(d3.event)) {
                        mouseCoordinates = getCoordinates(rootNode, true);
                        var elementCoordinates = getCoordinates(this, true);
                        var tooltipEvent = {
                            data: d,
                            index: i,
                            coordinates: mouseCoordinates,
                            elementCoordinates: elementCoordinates,
                            context: this,
                            isTouchEvent: false
                        };
                        moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                    }
                });
                // Touch events
                if (!GlobalTooltipEventsAttached) {
                    // Add root container hide tooltip event
                    attachGlobalEvents(touchStartEventName);
                    GlobalTooltipEventsAttached = true;
                }
                d3Selection.on(touchStartEventName, function (d, i) {
                    stopEventPropogation(d3.event);
                    hideTooltipEventHandler();
                    var coordinates = getCoordinates(rootNode, isPointerEvent);
                    var elementCoordinates = getCoordinates(this, isPointerEvent);
                    var tooltipEvent = {
                        data: d,
                        index: i,
                        coordinates: coordinates,
                        elementCoordinates: elementCoordinates,
                        context: this,
                        isTouchEvent: true
                    };
                    clearTooltipTimeout();
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                });
                d3Selection.on(touchEndEventName, function (d, i) {
                    clearTooltipTimeout();
                });
            }
            TooltipManager.addTooltip = addTooltip;
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout(function () { return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate); }, delayInMs);
            }
            TooltipManager.showDelayedTooltip = showDelayedTooltip;
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            TooltipManager.setLocalizedStrings = setLocalizedStrings;
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = getTooltipInfoDelegate(tooltipEvent);
                if (tooltipInfo) {
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                var tooltipInfo;
                if (reloadTooltipDataOnMouseMove) {
                    tooltipInfo = getTooltipInfoDelegate(tooltipEvent);
                }
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipInfo, clickedArea);
            }
            ;
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            ;
            function clearTooltipTimeout() {
                if (tooltipTimeoutId) {
                    clearTimeout(tooltipTimeoutId);
                }
            }
            function stopEventPropogation(d3Event) {
                d3Event.preventDefault();
                d3Event.stopPropagation();
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = true;
                var mouseEvent = d3Event;
                if (mouseEvent.buttons !== undefined) {
                    // Check mouse buttons state
                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function getTouchStartEventName() {
                var eventName = "touchstart";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerdown";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerDown";
                }
                return eventName;
            }
            function getTouchEndEventName() {
                var eventName = "touchend";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerup";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerUp";
                }
                return eventName;
            }
            function getCoordinates(rootNode, isPointerEvent) {
                var coordinates;
                if (isPointerEvent) {
                    coordinates = d3.mouse(rootNode);
                }
                else {
                    var touchCoordinates = d3.touches(rootNode);
                    if (touchCoordinates && touchCoordinates.length > 0) {
                        coordinates = touchCoordinates[0];
                    }
                }
                return coordinates;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function (d, i) {
                    TooltipManager.ToolTipInstance.hide();
                });
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0;
                var pointX = x;
                var pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0);
                    pointY = Math.max(y - offset, 0);
                }
                return new TouchUtils.Rectangle(pointX, pointY, width, width);
            }
        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        (function (TooltipBuilder) {
            // TODO: implement options bag as input parameter
            function createTooltipInfo(formatStringProp, categories, categoryValue, values, value, seriesData, seriesIndex, highlightedValue) {
                var categorySource;
                var seriesSource = [];
                var valuesSource = undefined;
                seriesIndex = seriesIndex | 0;
                if (categories && categories.length > 0) {
                    categorySource = { value: categoryValue, metadata: categories[0].source };
                }
                if (values) {
                    if (categorySource && categorySource.metadata === values.source) {
                    }
                    else {
                        valuesSource = values.source;
                    }
                }
                if (seriesData) {
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        var singleSeriesData = seriesData[i];
                        if (categorySource && categorySource.metadata === singleSeriesData.metadata.source)
                            continue;
                        seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
                    }
                }
                else if (values && values.length > 0) {
                    var valueColumn = values[seriesIndex];
                    var autoGeneratedColumnMetadata = valueColumn && valueColumn.source ? valueColumn.source : null;
                    var isManuallyAddedField = autoGeneratedColumnMetadata && autoGeneratedColumnMetadata.isAutoGeneratedColumn;
                    if (!isManuallyAddedField) {
                        seriesSource = [{ value: value, highlightedValue: highlightedValue, metadata: valueColumn }];
                    }
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo;
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                debug.assertValue(seriesValues, "seriesSource");
                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
                debug.assertAnyValue(formatStringProp, 'formatStringProp');
                var items = [];
                if (categoryValue) {
                    var categoryFormattedValue = getFormattedValue(categoryValue.metadata, formatStringProp, categoryValue.value);
                    items.push({ displayName: categoryValue.metadata.displayName, value: categoryFormattedValue });
                }
                if (valuesSource) {
                    // Dynamic series value
                    var dynamicValue;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = getFormattedValue(dynamicValueMetadata, formatStringProp, dynamicValueMetadata.groupName);
                    }
                    items.push({ displayName: valuesSource.displayName, value: dynamicValue });
                }
                for (var i = 0; i < seriesValues.length; i++) {
                    var seriesData = seriesValues[i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source;
                        var value = seriesData.value;
                        var highlightedValue = seriesData.highlightedValue;
                        if (value || value === 0) {
                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                            items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
                        }
                        if (highlightedValue || highlightedValue === 0) {
                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({ displayName: displayName, value: formattedHighlightedValue });
                        }
                    }
                }
                return items;
            }
            function getFormattedValue(column, formatStringProp, value) {
                var formatString = getFormatStringFromColumn(column, formatStringProp);
                return visuals.valueFormatter.format(value, formatString);
            }
            function getFormatStringFromColumn(column, formatStringProp) {
                if (column) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                    return formatString || column.format;
                }
                return null;
            }
        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
//# sourceMappingURL=visuals.js.map