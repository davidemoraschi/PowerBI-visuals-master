/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable */
var powerBIAccessToken = "fooBarBaz";
/* tslint:enable */
var powerbitests;
(function (powerbitests) {
    var helpers;
    (function (helpers) {
        debug.assertFailFunction = function (message) {
            expect(message).toBe('DEBUG asserts should never happen.  There is a product or test bug.');
        };
        /** Suppresses debug asserts failing tests.  This is temporary and should be removed. */
        function suppressDebugAssertFailure() {
            debug.assertFailFunction = function (message) {
                // NOTE: This should fail test cases (asserts should never fire under normal test runs).
                console.error(message);
            };
        }
        helpers.suppressDebugAssertFailure = suppressDebugAssertFailure;
        helpers.SemanticQueryLatestVersion = 2 /* Version2 */;
        helpers.DataShapeBindingLatestVersion = 1 /* Version1 */;
        helpers.dataSets = {
            singleMeasureDataViewSource: '{"descriptor": {"Select": [{"Kind": 2, "Value": "M0"}]}, "dsr": {"DataShapes":[{"Id":"DS0","PrimaryHierarchy":[{"Id":"DM0","Instances":[{"Calculations":[{"Id":"M0","Value":"21852688.46698004D"}]}]}],"IsComplete":true}]}}',
            dataViewSourceWithErrors: '{"descriptor":{"Select":[{"Kind":1,"Depth":0,"Value":"G0"},{"Kind":2,"Value":"M0","Subtotal":["A0"],"Min":["A2"],"Max":["A1"]}],"Expressions":{"Primary":{"Groupings":[{"Keys":[{"Source":{"Entity":"DimDate","Property":"Month Name"},"Select":0},{"Source":{"Entity":"DimDate","Property":"Month Number"},"Calc":"K0"}]}]}}},"dsr":{"DataShapes":[{"Id":"DS0","odata.error":{"code":"rsDataShapeQueryTranslationError","message":{"lang":"da-DK","value":"Data Shape Query translation failed with error code: \'InvalidExpression\'. Check the report server logs for more information."},"azure:values":[{"timestamp":"2015-01-15T07:44:45.8135124Z"},{"details":"Microsoft.ReportingServices.DataShapeQueryTranslation.DataShapeQueryTranslationException: Data Shape Query translation failed with error code: \'InvalidExpression\'. Check the report server logs for more information."},{"helpLink":"http://go.microsoft.com/fwlink/?LinkId=20476&EvtSrc=Microsoft.ReportingServ…Error&ProdName=Microsoft%20SQL%20Server%20Reporting%20Services&ProdVer=1.0"},{"productInfo":{"productName":"change this","productVersion":"1.0","productLocaleId":127,"operatingSystem":"OsIndependent","countryLocaleId":1033}},{"moreInformation":{"odata.error":{"code":"System.Exception","message":{"lang":"da-DK","value":"For more information about this error navigate to the report server on the local server machine, or enable remote errors"},"azure:values":[{"details":"System.Exception: For more information about this error navigate to the report server on the local server machine, or enable remote errors"}]}}}]}}]}}',
        };
        function testDom(height, width) {
            var testhtml = '<div id="item" style="height: ' + height + 'px; width: ' + width + 'px;"></div>';
            setFixtures(testhtml);
            var element = $('#item');
            return element;
        }
        helpers.testDom = testDom;
        function isTranslateCloseTo(actualTranslate, expectedX, expectedY) {
            var splitChar = actualTranslate.indexOf(",") > 0 ? ',' : ' ';
            var translateValues = actualTranslate.substr(10, actualTranslate.lastIndexOf(')') - 10).split(splitChar);
            var actualX = parseInt(translateValues[0], 10);
            var actualY = parseInt(translateValues[1], 10);
            var deltaX = Math.abs(expectedX - actualX);
            var deltaY = Math.abs(expectedY - actualY);
            // Tolerance of 1
            return deltaX <= 1 && deltaY <= 1;
        }
        helpers.isTranslateCloseTo = isTranslateCloseTo;
        /** Returns a function that can be called to trigger a dragstart. */
        function getDragStartTriggerFunctionForD3(element) {
            var elem = element;
            if (elem.__ondragstart)
                return function (arg) { return elem.__ondragstart(arg); };
        }
        helpers.getDragStartTriggerFunctionForD3 = getDragStartTriggerFunctionForD3;
        /** Returns a function that can be called to trigger a click. */
        function getClickTriggerFunctionForD3(element) {
            var elem = element;
            if (elem.__onclick)
                return function (arg) { return elem.__onclick(arg); };
        }
        helpers.getClickTriggerFunctionForD3 = getClickTriggerFunctionForD3;
        /** Execute a dummy expect to avoid Jasmine warnings, since some tests only perform validation directly on the httpService via expectPOST etc. */
        function suppressJasmineMissingExpectWarning() {
            expect(true).toBe(true);
        }
        helpers.suppressJasmineMissingExpectWarning = suppressJasmineMissingExpectWarning;
        (function (ClickEventType) {
            ClickEventType[ClickEventType["Default"] = 0] = "Default";
            ClickEventType[ClickEventType["CtrlKey"] = 1] = "CtrlKey";
            ClickEventType[ClickEventType["AltKey"] = 2] = "AltKey";
            ClickEventType[ClickEventType["ShiftKey"] = 4] = "ShiftKey";
            ClickEventType[ClickEventType["MetaKey"] = 8] = "MetaKey";
        })(helpers.ClickEventType || (helpers.ClickEventType = {}));
        var ClickEventType = helpers.ClickEventType;
        // Defining a simulated click event (see http://stackoverflow.com/questions/9063383/how-to-invoke-click-event-programmaticaly-in-d3)
        jQuery.fn.d3Click = function (x, y, eventType) {
            var type = eventType || 0 /* Default */;
            this.each(function (i, e) {
                var evt = document.createEvent("MouseEvents");
                evt.initMouseEvent("click", true, true, window, 0, x, y, x, y, type & 1 /* CtrlKey */, type & 2 /* AltKey */, type & 4 /* ShiftKey */, type & 8 /* MetaKey */, 0, null); // relatedTarget
                e.dispatchEvent(evt);
            });
        };
        function deepCopy(object) {
            return JSON.parse(JSON.stringify(object));
        }
        helpers.deepCopy = deepCopy;
        function getLocalTimeFromUTCBase(utcYear, utcMonth, utcDay, utcHours, utcMinutes, utcSeconds) {
            // IMPORTANT: We need to dynamically calculate the UTC offset to use for our test date instead of hard-coding the offset so that:
            // i) It doesn't break when daylight savings changes the UTC offset
            // ii) The test works even if your machine is not in the US Pacific Time zone :)
            var baseDate = new Date(utcYear, utcMonth, utcDay, utcHours, utcMinutes, utcSeconds);
            var offsetMinutes = baseDate.getTimezoneOffset();
            var date = new Date();
            date.setTime(baseDate.getTime() - offsetMinutes * 60000);
            return date;
        }
        helpers.getLocalTimeFromUTCBase = getLocalTimeFromUTCBase;
        function isUndefined(value) {
            return typeof value === 'undefined';
        }
        helpers.isUndefined = isUndefined;
        (function (ContextMenuEntityButtonPosition) {
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["NewMeasure"] = 0] = "NewMeasure";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["NewColumn"] = 1] = "NewColumn";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Rename"] = 3] = "Rename";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Delete"] = 4] = "Delete";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Hide"] = 5] = "Hide";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["ViewHidden"] = 7] = "ViewHidden";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["UnhideAll"] = 8] = "UnhideAll";
        })(helpers.ContextMenuEntityButtonPosition || (helpers.ContextMenuEntityButtonPosition = {}));
        var ContextMenuEntityButtonPosition = helpers.ContextMenuEntityButtonPosition;
        (function (ContextMenuPropertyButtonPosition) {
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["AddFilter"] = 0] = "AddFilter";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["NewMeasure"] = 2] = "NewMeasure";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["NewColumn"] = 3] = "NewColumn";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Rename"] = 5] = "Rename";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Delete"] = 6] = "Delete";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Hide"] = 7] = "Hide";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["ViewHidden"] = 9] = "ViewHidden";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["UnhideAll"] = 10] = "UnhideAll";
        })(helpers.ContextMenuPropertyButtonPosition || (helpers.ContextMenuPropertyButtonPosition = {}));
        var ContextMenuPropertyButtonPosition = helpers.ContextMenuPropertyButtonPosition;
    })(helpers = powerbitests.helpers || (powerbitests.helpers = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var mocks;
    (function (mocks) {
        var SQExprBuilder = powerbi.data.SQExprBuilder;
        var BeautifiedFormat = {
            '0.00 %;-0.00 %;0.00 %': 'Percentage',
            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
        };
        var TelemetryCallbackMock = (function () {
            function TelemetryCallbackMock() {
            }
            TelemetryCallbackMock.prototype.target = function () {
                TelemetryCallbackMock.callbackCalls++;
            };
            TelemetryCallbackMock.callbackCalls = 0;
            return TelemetryCallbackMock;
        })();
        mocks.TelemetryCallbackMock = TelemetryCallbackMock;
        ;
        var AppInsightsV2Mock = (function () {
            function AppInsightsV2Mock() {
                this.trackPageViewTimes = 0;
                this.trackEventTimes = 0;
                this.trackEventLastActivityName = null;
                this.trackEventLastAdditionalData = {
                    id: null,
                    start: null,
                    end: null,
                    isInternalUser: null,
                    userId: null,
                    category: null,
                    sessionId: null,
                    client: null,
                    build: null,
                    cluster: null,
                };
            }
            AppInsightsV2Mock.prototype.trackPageView = function () {
                this.trackPageViewTimes++;
            };
            AppInsightsV2Mock.prototype.trackEvent = function (activityName, additionalData) {
                this.trackEventTimes++;
                this.trackEventLastActivityName = activityName;
                this.trackEventLastAdditionalData = additionalData;
            };
            return AppInsightsV2Mock;
        })();
        mocks.AppInsightsV2Mock = AppInsightsV2Mock;
        mocks.DefaultLoggerMockType = 1;
        var MockTimerPromiseFactory = (function () {
            function MockTimerPromiseFactory() {
            }
            MockTimerPromiseFactory.prototype.create = function (delayInMs) {
                if (!this.deferred) {
                    this.deferred = $.Deferred();
                }
                return this.deferred;
            };
            MockTimerPromiseFactory.prototype.resolveCurrent = function () {
                expect(this.deferred).toBeDefined();
                // Note: we need to read the current deferred field into a local var and null out the member before
                // we call resolve, just in case one of timer callbacks recursively creates another timer.
                var deferred = this.deferred;
                this.deferred = undefined;
                deferred.resolve();
            };
            MockTimerPromiseFactory.prototype.reject = function () {
                expect(this.deferred).toBeDefined();
                // Note: we need to read the current deferred field into a local var and null out the member before
                // we call reject, just in case one of timer callbacks recursively creates another timer.
                var deferred = this.deferred;
                this.deferred = undefined;
                deferred.reject();
            };
            MockTimerPromiseFactory.prototype.expectNoTimers = function () {
                expect(this.deferred).not.toBeDefined();
            };
            MockTimerPromiseFactory.prototype.hasPendingTimers = function () {
                return !!this.deferred;
            };
            return MockTimerPromiseFactory;
        })();
        mocks.MockTimerPromiseFactory = MockTimerPromiseFactory;
        function createVisualHostServices() {
            return {
                getLocalizedString: function (stringId) { return stringId; },
                onDragStart: function () {
                },
                canSelect: function () { return true; },
                onSelect: function () {
                },
                loadMoreData: function () {
                },
                persistProperties: function () {
                },
                onCustomSort: function (args) {
                },
                getViewMode: function () { return 0 /* View */; },
                setWarnings: function (warnings) {
                },
                setToolbar: function ($toolbar) {
                },
            };
        }
        mocks.createVisualHostServices = createVisualHostServices;
        function createLocalizationService() {
            return {
                currentLanguageLocale: "",
                getOptional: function (id) { return id; },
                ensureLocalization: function (action) {
                },
                format: function (id) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return id;
                },
                formatValue: function (arg) { return arg; },
            };
        }
        mocks.createLocalizationService = createLocalizationService;
        var MockTraceListener = (function () {
            function MockTraceListener() {
            }
            MockTraceListener.prototype.logTrace = function (trace) {
                this.trace = trace;
            };
            return MockTraceListener;
        })();
        mocks.MockTraceListener = MockTraceListener;
        function dataViewScopeIdentity(fakeValue) {
            var expr = constExpr(fakeValue);
            return powerbi.data.createDataViewScopeIdentity(expr);
        }
        mocks.dataViewScopeIdentity = dataViewScopeIdentity;
        function dataViewScopeIdentityWithEquality(keyExpr, fakeValue) {
            return powerbi.data.createDataViewScopeIdentity(powerbi.data.SQExprBuilder.equal(keyExpr, constExpr(fakeValue)));
        }
        mocks.dataViewScopeIdentityWithEquality = dataViewScopeIdentityWithEquality;
        function constExpr(fakeValue) {
            if (fakeValue === null)
                return SQExprBuilder.nullConstant();
            if (fakeValue === true || fakeValue === false)
                return SQExprBuilder.boolean(fakeValue);
            return (typeof (fakeValue) === 'number') ? powerbi.data.SQExprBuilder.double(fakeValue) : powerbi.data.SQExprBuilder.text(fakeValue);
        }
        var MockVisualWarning = (function () {
            function MockVisualWarning() {
                // Allow 'code' to be modified for testing.
                this.code = 'MockVisualWarning';
            }
            MockVisualWarning.prototype.getMessages = function (resourceProvider) {
                var details = {
                    message: MockVisualWarning.Message,
                    title: 'key',
                    detail: 'val',
                };
                return details;
            };
            MockVisualWarning.Message = 'Warning';
            return MockVisualWarning;
        })();
        mocks.MockVisualWarning = MockVisualWarning;
        function setLocale(localize) {
            debug.assertValue(localize, 'localize');
            setLocaleOptions(localize);
            setLocalizedStrings(localize);
        }
        mocks.setLocale = setLocale;
        function setLocaleOptions(localize) {
            var valueFormatterLocalizationOptions = createLocaleOptions(localize);
            powerbi.visuals.valueFormatter.setLocaleOptions(valueFormatterLocalizationOptions);
        }
        function setLocalizedStrings(localize) {
            var tooltipLocalizationOptions = createTooltipLocaleOptions(localize);
            powerbi.visuals.TooltipManager.setLocalizedStrings(tooltipLocalizationOptions);
        }
        function createLocaleOptions(localize) {
            return {
                null: localize.get('NullValue'),
                true: localize.get('BooleanTrue'),
                false: localize.get('BooleanFalse'),
                NaN: localize.get('NaNValue'),
                infinity: localize.get('InfinityValue'),
                negativeInfinity: localize.get('NegativeInfinityValue'),
                beautify: function (format) { return beautify(localize, format); },
                describe: function (exponent) { return describeUnit(localize, exponent); },
                restatementComma: powerbi.visuals.valueFormatter.getLocalizedString('RestatementComma'),
                restatementCompoundAnd: powerbi.visuals.valueFormatter.getLocalizedString('RestatementCompoundAnd'),
                restatementCompoundOr: powerbi.visuals.valueFormatter.getLocalizedString('RestatementCompoundOr'),
            };
        }
        function createTooltipLocaleOptions(localize) {
            return {
                highlightedValueDisplayName: localize.get(powerbi.visuals.ToolTipComponent.highlightedValueDisplayNameResorceKey)
            };
        }
        function beautify(localize, format) {
            var key = BeautifiedFormat[format];
            if (key)
                return localize.getOptional(key) || format;
            return format;
        }
        function describeUnit(localize, exponent) {
            var title = localize.getOptional("DisplayUnitSystem_E" + exponent + "_Title");
            var format = localize.getOptional("DisplayUnitSystem_E" + exponent + "_LabelFormat");
            if (title || format)
                return { title: title, format: format };
        }
    })(mocks = powerbitests.mocks || (powerbitests.mocks = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var tableDataViewHelper;
    (function (tableDataViewHelper) {
        var ValueType = powerbi.ValueType;
        (function (ColumnType) {
            ColumnType[ColumnType["Text"] = 0] = "Text";
            ColumnType[ColumnType["Numeric"] = 1] = "Numeric";
            ColumnType[ColumnType["NumericMeasure"] = 2] = "NumericMeasure";
        })(tableDataViewHelper.ColumnType || (tableDataViewHelper.ColumnType = {}));
        var ColumnType = tableDataViewHelper.ColumnType;
        /** Create a table which contains @columnCount number of columns */
        function getDataWithColumns(columnCount, numRows, objects) {
            if (numRows === void 0) { numRows = 1; }
            // Generate alternating column types
            var columnTypes = [];
            for (var i = 0; i < columnCount; ++i) {
                columnTypes.push(i % 2 === 0 ? 1 /* Numeric */ : 0 /* Text */);
            }
            return tableDataViewHelper.getDataWithColumnsOfType(columnTypes, false, numRows, objects);
        }
        tableDataViewHelper.getDataWithColumns = getDataWithColumns;
        /** Create a table which contains columns with the specified types */
        function getDataWithColumnsOfType(columnTypes, hasSubtotals, numRows, objects) {
            if (numRows === void 0) { numRows = 1; }
            var columns = [], rows = [], totals = [];
            for (var i = 0, len = columnTypes.length; i < len; ++i) {
                var isMeasure = columnTypes[i] === 2 /* NumericMeasure */;
                if (columnTypes[i] === 1 /* Numeric */ || isMeasure) {
                    columns.push({ displayName: 'numeric' + i, type: ValueType.fromDescriptor({ numeric: true }), isMeasure: isMeasure });
                    rows.push(i);
                    if (hasSubtotals)
                        totals.push(isMeasure ? i : null);
                }
                else {
                    columns.push({ displayName: 'text' + i, type: ValueType.fromDescriptor({ numeric: false }) });
                    rows.push('cell text ' + i);
                    if (hasSubtotals)
                        totals.push(null);
                }
            }
            var dataViewMetadata = {
                columns: columns,
                objects: objects,
            };
            var rowsArray = [];
            for (var i = 0; i < numRows; i++)
                rowsArray.push(rows);
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: rowsArray,
                    columns: dataViewMetadata.columns
                },
            };
            if (totals.length > 0)
                data.table.totals = totals;
            return data;
        }
        tableDataViewHelper.getDataWithColumnsOfType = getDataWithColumnsOfType;
        function dataViewObjectsTotals(totalsEnabled) {
            return {
                general: {
                    totals: totalsEnabled,
                }
            };
        }
        tableDataViewHelper.dataViewObjectsTotals = dataViewObjectsTotals;
    })(tableDataViewHelper = powerbitests.tableDataViewHelper || (powerbitests.tableDataViewHelper = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var tablixHelper;
    (function (tablixHelper) {
        var CssConstants = jsCommon.CssConstants;
        var DefaultWaitForRender = 100;
        ;
        ;
        /** Gets the specified cell of a 'new table' visual using 0-based indices. */
        function getTableCell(tableBody, coordinate) {
            var clickTargetSelector = '> tr:nth-child(' + (coordinate.row + 1) + ') > td:nth-child(' + (coordinate.col + 1) + ') > div';
            var textDivSelector = '> div';
            var clickTarget = $(clickTargetSelector, tableBody);
            expect(clickTarget).toBeInDOM();
            var textDiv = $(textDivSelector, clickTarget);
            expect(textDiv).toBeInDOM();
            return { cellCoordinate: coordinate, clickTarget: clickTarget, text: textDiv.text() };
        }
        tablixHelper.getTableCell = getTableCell;
        /** Renders the table based on the options passed in. */
        function renderNewTablix(element, options) {
            var viewport = options.viewport ? options.viewport : { height: element.height() + 200, width: element.width() + 200 };
            var data = options.data;
            var redraw = options.redraw ? options.redraw : false;
            var style = powerbi.visuals.visualStyles.create();
            element.width(viewport.width);
            element.css(CssConstants.minWidthProperty, viewport.width);
            element.css(CssConstants.maxWidthProperty, viewport.width);
            element.css(CssConstants.positionProperty, CssConstants.absoluteValue);
            var featureSwitches = {
                heatMap: true,
                scrollableVisuals: true,
            };
            var visualPluginService = powerbi.visuals.visualPluginFactory.createMinerva(featureSwitches);
            var sortCallback = options.onCustomSortCallback ? options.onCustomSortCallback : function (args) {
            };
            var hostService = {
                getLocalizedString: function (stringId) { return stringId; },
                onCustomSort: sortCallback,
                loadMoreData: function () {
                },
                getViewMode: function () { return 0 /* View */; }
            };
            if (options.formatCallback)
                spyOn(powerbi.visuals.valueFormatter, 'formatRaw').and.callFake(options.formatCallback);
            var v = visualPluginService.getPlugin(options.visualType).create();
            v.init({
                element: element,
                host: hostService,
                style: style,
                viewport: viewport,
                settings: options.settings,
                interactivity: {
                    selection: true,
                    overflow: options.isFixedSize ? 'hidden' : 'visible'
                }
            });
            v.onDataChanged({ dataViews: [data] });
            var promise = jsCommon.TimerPromiseFactory.instance.create(DefaultWaitForRender).then(function () {
                if (redraw)
                    v.onResizing({ height: viewport.height, width: viewport.width }, 0);
                return v;
            });
            return promise;
        }
        tablixHelper.renderNewTablix = renderNewTablix;
        /** Runs a table sort test by first creating the table based on the specified data, then
            validating the generated headers before executing a set of clicks and validating
            the recorded sort events. */
        function runTablixSortTest(element, done, visualType, data, expectedColumnHeaders, clicks, expectedSorts) {
            var actualSorts = [];
            var sortCallback = function (args) {
                actualSorts.push(args.sortDescriptors);
            };
            var renderTablixPromise = renderNewTablix(element, {
                visualType: visualType,
                data: data,
                onCustomSortCallback: sortCallback,
            });
            renderTablixPromise.then(function () {
                var tableBody = $('.tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody');
                expect(tableBody).toBeInDOM();
                // Validate column headers
                if (expectedColumnHeaders) {
                    for (var i = 0, len = expectedColumnHeaders.length; i < len; i++) {
                        var coordinate = expectedColumnHeaders[i];
                        var headerCell = getTableCell(tableBody, coordinate);
                        if (coordinate.expectedText)
                            expect(headerCell.text).toBe(coordinate.expectedText);
                    }
                }
                // Execute the clicks
                if (clicks) {
                    for (var i = 0, len = clicks.length; i < len; i++) {
                        var clickCoordinate = clicks[i];
                        var clickCell = getTableCell(tableBody, clickCoordinate);
                        if (clickCoordinate.expectedText)
                            expect(clickCell.text).toBe(clickCoordinate.expectedText);
                        clickCell.clickTarget.click();
                    }
                }
                // Validate the expected sorts
                if (expectedSorts) {
                    expect(expectedSorts.length).toBe(actualSorts.length);
                    for (var i = 0, len = expectedSorts.length; i < len; i++) {
                        var expectedSort = expectedSorts[i];
                        var actualSort = actualSorts[i];
                        expect(expectedSort.length).toBe(actualSort.length);
                        for (var j = 0, jlen = expectedSort.length; j < jlen; j++) {
                            var expectedField = expectedSort[j];
                            var actualField = actualSort[j];
                            expect(expectedField.queryName).toBe(actualField.queryName);
                            expect(expectedField.sortDirection).toBe(actualField.sortDirection);
                        }
                    }
                }
                done();
            });
        }
        tablixHelper.runTablixSortTest = runTablixSortTest;
        function validateMatrix(expectedValues, selector) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                expect(cells.height()).not.toBe(0);
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).text();
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual value " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateMatrix = validateMatrix;
        function validateTable(expectedValues, selector) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).text();
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual value " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                    if (cells.eq(j).height() <= 1)
                        addError(errorString, "Actual height " + cells.eq(j).height() + " in row " + i + " and column " + j + " is expected to be > 1.");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateTable = validateTable;
        function validateClassNames(expectedValues, selector, noMarginClass) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).attr('class');
                    expectedValues[i][j] = addNoMarginClass(expectedValues[i][j], noMarginClass);
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual class name " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateClassNames = validateClassNames;
        function addError(errorString, message) {
            if (!errorString)
                return message;
            return errorString + "\r\n" + message;
        }
        function addNoMarginClass(classNames, noMarginClass) {
            if (!classNames || classNames.length === 0)
                return noMarginClass;
            return classNames + ' ' + noMarginClass;
        }
    })(tablixHelper = powerbitests.tablixHelper || (powerbitests.tablixHelper = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:no-consecutive-blank-lines */
//==============================================================================
//          !!!!!!!!! AUTO GENERATED !!!!!!!!!
//
// This code was generated by t4 template in PowerBI project.
// To edit resources change the PowerBI.resx file in the PowerBI project.
//
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
//==============================================================================
var powerbi;
(function (powerbi) {
    var localization;
    (function (localization) {
        localization.defaultLocalizedStrings = {
            ContinueToPowerBI: 'Go back home',
            DashboardInvitationEmailSubject: '{0} has shared Power BI Dashboard \'{1}\' with you',
            DashboardInvitationEmailViewDashboardLink: 'Open',
            ExistingAccount: 'Have an account? {0}Sign In{1}',
            ClusterUriNotFound: 'Cluster URI not found. Please try again later.',
            Forbidden: 'You are not authorized to view this page.',
            GenericError: 'Something went wrong. <br/>Please try again later.',
            GenericErrorDescription: 'An unknown error occured. If you continue to see this error please provide the following information when requesting support.',
            PageDoesNotExist: 'Oops, we couldn\'t find the page you were looking for',
            PowerBILogoTxt: 'Microsoft Power BI Preview',
            PowerBILogoTxtNoPreview: 'Microsoft Power BI',
            SignUpButton: 'Sign up',
            SignUpDifferentEmail: 'Don\'t have an account? {0}Sign up{1}.',
            SignUpHeader: 'Welcome to Power BI Preview',
            SignUpHeaderNoPreview: 'Welcome to Power BI',
            SignUpTextLine1: 'Someone has shared a dashboard with you.',
            SignUpTextLine2: 'Sign up for a Microsoft Power BI account to see it.',
            SignInButton: 'Sign in',
            SignInDifferentEmail: 'Already a user? {0}Sign in{1}',
            SignInTextLine1: 'Someone has shared a dashboard with you.',
            SignInTextLine2: 'Sign in to see it.',
            Unauthorized: 'We do not recognize you. Did you enter your credentials right?',
            RequestAnInvite: 'Request an invite',
            UserNeedsInvitation: 'You need an invitation to use Power BI.',
            UserNotSignedUp: 'You’re not signed up yet.',
            DashboardInvitationEmailDefaultMessage: 'Here\'s the dashboard that {0} shared with you',
            DateAndTimeLabel: 'Date and Time:',
            TechnicalDetails: 'TECHNICAL DETAILS <br/>',
            ErrorDescription_UserAccountDisabled: 'This user account has been disabled.',
            ActivityIdLabel: 'ActivityId:',
            TopNav_PowerBILogoText: 'Power BI Preview',
            TopNav_PowerBILogoTextNoPreview: 'Power BI',
            TopNav_HelpMenu_GettingStarted: 'Getting started',
            TopNav_HelpMenu_ContactSupport: 'Contact support',
            TopNav_HelpMenu_Developers: 'Power BI for developers',
            TopNav_HelpMenu_Suggestions: 'What should we build next?',
            TopNav_HelpMenu_Topics: 'Help topics',
            TopNav_HelpMenu_About: 'About Power BI',
            TopNav_HelpMenu_AboutDialog_Close: 'Close',
            TopNav_HelpMenu_Community: 'Community',
            TopNav_HelpMenu_FeatureRequests: 'Feature Requests',
            TopNav_UserInfoMenu_SignOut: 'Sign out',
            TopNav_SettingsMenu_ASConnector: 'Analysis Services Connector Preview',
            TopNav_SettingsMenu_OnPremGateway: 'Power BI Personal Gateway Preview',
            TopNav_SettingsMenu_ASConnectorNoPreview: 'Analysis Services Connector',
            TopNav_SettingsMenu_OnPremGatewayNoPreview: 'Power BI Personal Gateway',
            TopNav_SettingsMenu_MobileDownload: 'Power BI for Mobile',
            TopNav_SettingsMenu_PowerBICompanion: 'Power BI Designer Preview',
            TopNav_SettingsMenu_PowerBICompanionNoPreview: 'Power BI Designer',
            TopNav_SettingsMenu_Download: 'DOWNLOAD',
            TopNav_SettingsMenu_PowerBISettings: 'Power BI Settings',
            TopNav_SettingsMenu_Office365Settings: 'Office 365 Settings',
            TopNav_SettingsMenu_ChangeTheme: 'Change Theme',
            TopNav_SettingsMenu_PurchasePowerBIPro: 'Purchase Power BI Pro',
            TopNav_SettingsMenu_PowerBI: 'Power BI',
            TopNav_SettingsMenu_PowerBIForO365: 'Power BI for Office 365',
            TopNav_SettingsMenu_Settings: 'Settings',
            TopNav_O365ApplicationLauncher_Error: 'Application launcher cannot be loaded at this time',
            TopNav_O365ApplicationLauncher_Loading: 'Loading ...',
            NullValue: '(Blank)',
            BooleanTrue: 'True',
            BooleanFalse: 'False',
            NavigationPane_OpenMenu: 'Open Menu',
            NavigationPane_SharedWithYou: 'Shared with you',
            NavigationPane_GetData: 'Get Data',
            NavigationPane_CreateDashboard: 'Create dashboard',
            NavigationPane_FilterContent: 'Filter content',
            NavigationPane_Minimize: 'Minimize the Navigator Pane',
            NavigationPane_Expand: 'Expand the Navigator Pane',
            NavigationPane_RefreshPublishError: 'Failed to publish or refresh',
            NavigationPane_PackagePublishErrorTitle: 'Failed to import data',
            NavigationPane_ReportPublishErrorTitle: 'Failed to publish report',
            NavigationPane_ModelPublishErrorTitle: 'Failed to publish dataset',
            NavigationPane_PackagePublishErrorContent: 'Do you want to delete the dataset and report?',
            NavigationPane_ReportPublishErrorContent: 'Do you want to delete the report?',
            NavigationPane_ModelPublishErrorContent: 'Do you want to delete the dataset?',
            NavigationPane_NoDashboardText: 'You have no dashboards',
            NavigationPane_NoReportText: 'You have no reports',
            NavigationPane_NoDatasetText: 'You have no datasets',
            NavigationPane_NoDashboardSearchResultText: 'No dashboards found',
            NavigationPane_NoReportSearchResultText: 'No reports found',
            NavigationPane_NoDatasetSearchResultText: 'No datasets found',
            Options_Menu: 'More Options',
            ReportAppBar_FileButton: 'FILE',
            ReportAppBar_SaveReportButton: 'SAVE',
            ReportAppBar_EditReportButton: 'EDIT REPORT',
            ReportAppBar_ShareButton: 'Share Dashboard',
            ReportAppBar_EditReportButtonSharedDisabled: 'You cannot edit a shared report',
            ReportAppBar_SaveToDashboard: 'Save',
            ReportAppBar_SaveToDashboardDescription: 'Save this report.',
            ReportAppBar_SaveAs: 'Save As',
            ReportAppBar_SaveAsDescription: 'Save a copy of this report.',
            ReportAppBar_SaveAsDialogTitle: 'Save Your Report',
            ReportAppBar_SaveAsDialogInstructions: 'Enter a name for your report:',
            ReportAppBar_ExportToPowerPoint: 'Export to Power Point',
            ReportAppBar_ExportToPowerPointDescription: 'Save this report as a Power Point presentation',
            ReportAppBar_ShareWithPeople: 'Share with People',
            ReportAppBar_ShareWithPeopleDescription: 'Invite other people to view and edit this report',
            ReportAppBar_Embed: 'Embed',
            ReportAppBar_EmbedDescription: 'Embed this report in your blog or website',
            ReportPaginator_Page: 'PAGE',
            ReportPaginator_PageOf: 'OF',
            ReportPaginator_EditingView: 'Editing View',
            ReportPaginator_ReadingView: 'Reading View',
            ReportContainer_UnsavedChangeWarningTitle: 'You have unsaved changes.',
            ReportContainer_UnsavedChangeWarningMessage: 'You might want to save them first.',
            ReportContainer_WindowUnload: 'You have unsaved changes. You might want to save them first.',
            ReportContainer_Dontsave: 'Don\'t Save',
            ReportContainer_Cancel: 'Cancel',
            ReportContainer_Save: 'Save',
            ReportNavigation_Thumbnails: 'Thumbnails',
            SettingsViewer_Title: 'Settings',
            SettingsDashboards_Title: 'Dashboards',
            SettingsGeneral_Title: 'General',
            SettingsGeneral_Privacy_Title: 'Privacy',
            SettingsPrivacy_Title: 'Privacy Settings',
            SettingsPrivacy_DataCollection_Title: 'Search Term Collection',
            SettingsPrivacy_DataCollection_Info: 'Help make Power BI better by sending search terms used in Power BI Q&A to Microsoft for product feedback and improvement.',
            SettingsPrivacy_DataCollection_LearnMore: 'Learn more',
            SettingsGeneral_Error_FailedToLoad: 'Failed to load settings',
            SettingsGeneral_Error_FailedToSave: 'Failed to update settings',
            SettingsDashboards_Error_FailedToLoadDashboards: 'Failed to load dashboards',
            SettingsDashboards_Error_FailedToSaveDashboards: 'Failed to update dashboard',
            SettingsDashboard_Title: 'Settings for {0}',
            SettingsDashboard_QnA_Title: 'Q&A',
            SettingsDashboard_QnA_Info1: 'Q&A allows users to find data and create charts using natural language for datasets used on a dashboard.',
            SettingsDashboard_QnA_Info2: 'Q&A capabilities are not available for datasets using direct connections to data that does not reside in Power BI.',
            SettingsDashboard_QnA_LearnMore: 'Learn more',
            SettingsDashboard_QnA_QnaEnabledMessage: 'Show the Q&A search box on this dashboard',
            SettingsDashboard_QnA_QnaUnavailableWarning: 'There are no datasets used on this dashboard for which Q&A is available.',
            SettingsDatasets_Title: 'Datasets',
            SettingsWorkbooks_Title: 'Workbooks',
            SettingsDataset_Title: 'Settings for ',
            SettingsDataset_Welcome_Before_Configuration: 'Before you can setup a refresh schedule, you\'ll need to configure a few things.',
            SettingsDataset_Install_OnPrem_Gateway: '1. Install the Power BI Personal Gateway on a computer that is always on.',
            SettingsDataset_OnPrem_Gateway_InstallNow: 'Install Now',
            SettingsDataset_OnPrem_Gateway_LearnMore: 'Learn More',
            SettingsDataset_OnPrem_Gateway_InstallPage: 'You can install the Gateway from: ',
            SettingsDataset_OnPrem_Gateway_InstallPage_EmailToYou: '. This link has been emailed to you.',
            SettingsDataset_Install_OnPrem_Gateway_Succeed: '1. The Gateway is installed and running on ',
            SettingsDataset_Provide_Credential: '2. Provide credentials in Manage Data Sources.',
            SettingsDataset_Provide_Credential_Valid: '2. Your data sources are valid.',
            SettingsDataset_SetScheduleRefresh: '3. Specify a schedule in Schedule Refresh.',
            SettingsDataset_SetScheduleRefresh_Done: '3. Your refresh schedule has been set.',
            SettingsDataset_Gateway_Title: 'Gateway',
            SettingsDataset_GatewayErrorMessage_NoGatewayInstalled: 'Please install the Gateway first.',
            SettingsDataset_Gateway_Location: 'The on-premise Gateway on ',
            SettingsDataset_Gateway_Location2: ' is online.',
            SettingsDataset_GatewayErrorMessage_GatewayOffline2: ' appears to be offline. Make sure ',
            SettingsDataset_GatewayErrorMessage_GatewayOffline3: ' is turned on and the service is running. Then try refreshing your report in PowerBI.com.',
            SettingsDataset_GatewayIsRunning: 'Gateway is running and connected on ',
            SettingsDataset_ScheduleRefresh_Title: 'Schedule Refresh',
            SettingsDataset_ScheduleRefresh_NextRefresh: 'Next refresh: ',
            SettingsDataset_ScheduleRefresh_EnableRefresh_Title: 'Keep your data up-to-date',
            SettingsDataset_ScheduleRefresh_EnableRefresh_Yes: 'Yes',
            SettingsDataset_ScheduleRefresh_EnableRefresh_No: 'No',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Title: 'Refresh frequency',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Daily: 'Daily',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Weekly: 'Weekly',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Monday: 'Monday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Tuesday: 'Tuesday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Wednesday: 'Wednesday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Thursday: 'Thursday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Friday: 'Friday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Saturday: 'Saturday',
            SettingsDataset_ScheduleRefresh_RefreshFrequency_Days_Sunday: 'Sunday',
            SettingsDataset_ScheduleRefresh_TimeWindow: 'Refresh between',
            SettingsDataset_ScheduleRefresh_TimeWindow_1: '12 AM - 6 AM',
            SettingsDataset_ScheduleRefresh_TimeWindow_2: '6 AM - 12 PM',
            SettingsDataset_ScheduleRefresh_TimeWindow_3: '12 PM - 6 PM',
            SettingsDataset_ScheduleRefresh_TimeWindow_4: '6 PM - 12 AM',
            SettingsDataset_ScheduleRefresh_TimeZone: 'Time Zone',
            SettingsDataset_ScheduleRefresh_TimeProWindow: 'Time',
            SettingsDataset_ScheduleRefresh_Timezone_Afghanistan_Standard_Time: '(UTC+04:30) Kabul',
            SettingsDataset_ScheduleRefresh_Timezone_Alaskan_Standard_Time: '(UTC-09:00) Alaska',
            SettingsDataset_ScheduleRefresh_Timezone_Arab_Standard_Time: '(UTC+03:00) Kuwait, Riyadh',
            SettingsDataset_ScheduleRefresh_Timezone_Arabian_Standard_Time: '(UTC+04:00) Abu Dhabi, Muscat',
            SettingsDataset_ScheduleRefresh_Timezone_Arabic_Standard_Time: '(UTC+03:00) Baghdad',
            SettingsDataset_ScheduleRefresh_Timezone_Argentina_Standard_Time: '(UTC-03:00) Buenos Aires',
            SettingsDataset_ScheduleRefresh_Timezone_Atlantic_Standard_Time: '(UTC-04:00) Atlantic Time (Canada)',
            SettingsDataset_ScheduleRefresh_Timezone_AUS_Central_Standard_Time: '(UTC+09:30) Darwin',
            SettingsDataset_ScheduleRefresh_Timezone_AUS_Eastern_Standard_Time: '(UTC+10:00) Canberra, Melbourne, Sydney',
            SettingsDataset_ScheduleRefresh_Timezone_Azerbaijan_Standard_Time: '(UTC+04:00) Baku',
            SettingsDataset_ScheduleRefresh_Timezone_Azores_Standard_Time: '(UTC-01:00) Azores',
            SettingsDataset_ScheduleRefresh_Timezone_Bangladesh_Standard_Time: '(UTC+06:00) Dhaka',
            SettingsDataset_ScheduleRefresh_Timezone_Cabo_Verde_Standard_Time: '(UTC-01:00) Cabo Verde Is.',
            SettingsDataset_ScheduleRefresh_Timezone_Canada_Central_Standard_Time: '(UTC-06:00) Saskatchewan',
            SettingsDataset_ScheduleRefresh_Timezone_Caucasus_Standard_Time: '(UTC+04:00) Yerevan',
            SettingsDataset_ScheduleRefresh_Timezone_Cen_Australia_Standard_Time: '(UTC+09:30) Adelaide',
            SettingsDataset_ScheduleRefresh_Timezone_Central_America_Standard_Time: '(UTC-06:00) Central America',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Asia_Standard_Time: '(UTC+06:00) Astana',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Brazilian_Standard_Time: '(UTC-04:00) Cuiaba',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Europe_Standard_Time: '(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague',
            SettingsDataset_ScheduleRefresh_Timezone_Central_European_Standard_Time: '(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Pacific_Standard_Time: '(UTC+11:00) Solomon Is., New Caledonia',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Standard_Time: '(UTC-06:00) Central Time (US and Canada)',
            SettingsDataset_ScheduleRefresh_Timezone_Central_Standard_Time_Mexico: '((UTC-06:00) Guadalajara, Mexico City, Monterrey',
            SettingsDataset_ScheduleRefresh_Timezone_China_Standard_Time: '(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi',
            SettingsDataset_ScheduleRefresh_Timezone_Dateline_Standard_Time: '(UTC-12:00) International Date Line West',
            SettingsDataset_ScheduleRefresh_Timezone_E_Africa_Standard_Time: '(UTC+03:00) Nairobi',
            SettingsDataset_ScheduleRefresh_Timezone_E_Australia_Standard_Time: '(UTC+10:00) Brisbane',
            SettingsDataset_ScheduleRefresh_Timezone_E_Europe_Standard_Time: '(UTC+02:00) Minsk',
            SettingsDataset_ScheduleRefresh_Timezone_E_South_America_Standard_Time: '(UTC-03:00) Brasilia',
            SettingsDataset_ScheduleRefresh_Timezone_Eastern_Standard_Time: '(UTC-05:00) Eastern Time (US and Canada)',
            SettingsDataset_ScheduleRefresh_Timezone_Egypt_Standard_Time: '(UTC+02:00) Cairo',
            SettingsDataset_ScheduleRefresh_Timezone_Ekaterinburg_Standard_Time: '(UTC+06:00) Ekaterinburg',
            SettingsDataset_ScheduleRefresh_Timezone_Fiji_Standard_Time: '(UTC+12:00) Fiji',
            SettingsDataset_ScheduleRefresh_Timezone_FLE_Standard_Time: '(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius',
            SettingsDataset_ScheduleRefresh_Timezone_Georgian_Standard_Time: '(UTC+04:00) Tbilisi',
            SettingsDataset_ScheduleRefresh_Timezone_GMT_Standard_Time: '(UTC) Dublin, Edinburgh, Lisbon, London',
            SettingsDataset_ScheduleRefresh_Timezone_Greenland_Standard_Time: '(UTC-03:00) Greenland',
            SettingsDataset_ScheduleRefresh_Timezone_Greenwich_Standard_Time: '(UTC) Monrovia, Reykjavik',
            SettingsDataset_ScheduleRefresh_Timezone_GTB_Standard_Time: '(UTC+02:00) Athens, Bucharest',
            SettingsDataset_ScheduleRefresh_Timezone_Hawaiian_Standard_Time: '(UTC-10:00) Hawaii',
            SettingsDataset_ScheduleRefresh_Timezone_India_Standard_Time: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi',
            SettingsDataset_ScheduleRefresh_Timezone_Iran_Standard_Time: '(UTC+03:30) Tehran',
            SettingsDataset_ScheduleRefresh_Timezone_Israel_Standard_Time: '(UTC+02:00) Jerusalem',
            SettingsDataset_ScheduleRefresh_Timezone_Jordan_Standard_Time: '(UTC+02:00) Amman',
            SettingsDataset_ScheduleRefresh_Timezone_Kaliningrad_Standard_Time: '(UTC+03:00) Kaliningrad',
            SettingsDataset_ScheduleRefresh_Timezone_Korea_Standard_Time: '(UTC+09:00) Seoul',
            SettingsDataset_ScheduleRefresh_Timezone_Magadan_Standard_Time: '(UTC+12:00) Magadan',
            SettingsDataset_ScheduleRefresh_Timezone_Mauritius_Standard_Time: '(UTC+04:00) Port Louis',
            SettingsDataset_ScheduleRefresh_Timezone_Mid_Atlantic_Standard_Time: '(UTC-02:00) Mid-Atlantic',
            SettingsDataset_ScheduleRefresh_Timezone_Middle_East_Standard_Time: '(UTC+02:00) Beirut',
            SettingsDataset_ScheduleRefresh_Timezone_Montevideo_Standard_Time: '(UTC-03:00) Montevideo',
            SettingsDataset_ScheduleRefresh_Timezone_Morocco_Standard_Time: '(UTC) Casablanca',
            SettingsDataset_ScheduleRefresh_Timezone_Mountain_Standard_Time: '(UTC-07:00) Mountain Time (US and Canada)',
            SettingsDataset_ScheduleRefresh_Timezone_Mountain_Standard_Time_Mexico: '(UTC-07:00) Chihuahua, La Paz, Mazatlan',
            SettingsDataset_ScheduleRefresh_Timezone_Myanmar_Standard_Time: '(UTC+06:30) Yangon (Rangoon)',
            SettingsDataset_ScheduleRefresh_Timezone_N_Central_Asia_Standard_Time: '(UTC+07:00) Novosibirsk',
            SettingsDataset_ScheduleRefresh_Timezone_Namibia_Standard_Time: '(UTC+01:00) Windhoek',
            SettingsDataset_ScheduleRefresh_Timezone_Nepal_Standard_Time: '(UTC+05:45) Kathmandu',
            SettingsDataset_ScheduleRefresh_Timezone_New_Zealand_Standard_Time: '(UTC+12:00) Auckland, Wellington',
            SettingsDataset_ScheduleRefresh_Timezone_Newfoundland_Standard_Time: '(UTC-03:30) Newfoundland',
            SettingsDataset_ScheduleRefresh_Timezone_North_Asia_East_Standard_Time: '(UTC+09:00) Irkutsk',
            SettingsDataset_ScheduleRefresh_Timezone_North_Asia_Standard_Time: '(UTC+08:00) Krasnoyarsk',
            SettingsDataset_ScheduleRefresh_Timezone_Pacific_SA_Standard_Time: '(UTC-04:00) Santiago',
            SettingsDataset_ScheduleRefresh_Timezone_Pacific_Standard_Time: '(UTC-08:00) Pacific Time (US and Canada)',
            SettingsDataset_ScheduleRefresh_Timezone_Pacific_Standard_Time_Mexico: '(UTC-08:00) Baja California',
            SettingsDataset_ScheduleRefresh_Timezone_Pakistan_Standard_Time: '(UTC+05:00) Islamabad, Karachi',
            SettingsDataset_ScheduleRefresh_Timezone_Paraguay_Standard_Time: '(UTC-04:00) Asuncion',
            SettingsDataset_ScheduleRefresh_Timezone_Romance_Standard_Time: '(UTC+01:00) Brussels, Copenhagen, Madrid, Paris',
            SettingsDataset_ScheduleRefresh_Timezone_Russian_Standard_Time: '(UTC+04:00) Moscow, St. Petersburg, Volgograd',
            SettingsDataset_ScheduleRefresh_Timezone_SA_Eastern_Standard_Time: '(UTC-03:00) Cayenne, Fortaleza',
            SettingsDataset_ScheduleRefresh_Timezone_SA_Pacific_Standard_Time: '(UTC-05:00) Bogota, Lima, Quito',
            SettingsDataset_ScheduleRefresh_Timezone_SA_Western_Standard_Time: '(UTC-04:00) Georgetown, La Paz, Manaus, San Juan',
            SettingsDataset_ScheduleRefresh_Timezone_Samoa_Standard_Time: '(UTC-11:00) Samoa',
            SettingsDataset_ScheduleRefresh_Timezone_SE_Asia_Standard_Time: '(UTC+07:00) Bangkok, Hanoi, Jakarta',
            SettingsDataset_ScheduleRefresh_Timezone_Singapore_Standard_Tim: '(UTC+08:00) Kuala Lumpur, Singapore',
            SettingsDataset_ScheduleRefresh_Timezone_South_Africa_Standard_Time: '(UTC+02:00) Harare, Pretoria',
            SettingsDataset_ScheduleRefresh_Timezone_Sri_Lanka_Standard_Time: '(UTC+05:30) Sri Jayawardenepura',
            SettingsDataset_ScheduleRefresh_Timezone_Syria_Standard_Time: '(UTC+02:00) Damascus',
            SettingsDataset_ScheduleRefresh_Timezone_Taipei_Standard_Time: '(UTC+08:00) Taipei',
            SettingsDataset_ScheduleRefresh_Timezone_Tasmania_Standard_Time: '(UTC+10:00) Hobart',
            SettingsDataset_ScheduleRefresh_Timezone_Tokyo_Standard_Time: '(UTC+09:00) Osaka, Sapporo, Tokyo',
            SettingsDataset_ScheduleRefresh_Timezone_Tonga_Standard_Time: '(UTC+13:00) Nuku\'alofa',
            SettingsDataset_ScheduleRefresh_Timezone_Turkey_Standard_Time: '(UTC+02:00) Istanbul',
            SettingsDataset_ScheduleRefresh_Timezone_Ulaanbaatar_Standard_Time: '(UTC+08:00) Ulaanbaatar',
            SettingsDataset_ScheduleRefresh_Timezone_US_Eastern_Standard_Time: '(UTC-05:00) Indiana (East)',
            SettingsDataset_ScheduleRefresh_Timezone_US_Mountain_Standard_Time: '(UTC-07:00) Arizona',
            SettingsDataset_ScheduleRefresh_Timezone_UTC: '(UTC) Coordinated Universal Time',
            SettingsDataset_ScheduleRefresh_Timezone_UTC_Plus_12: '(UTC+12:00) Coordinated Universal Time +12',
            SettingsDataset_ScheduleRefresh_Timezone_UTC_Minus_11: '(UTC-11:00) Coordinated Universal Time -11',
            SettingsDataset_ScheduleRefresh_Timezone_UTC_Minus_2: '(UTC-02:00) Coordinated Universal Time -02',
            SettingsDataset_ScheduleRefresh_Timezone_Venezuela_Standard_Time: '(UTC-04:30) Caracas',
            SettingsDataset_ScheduleRefresh_Timezone_Vladivostok_Standard_Time: '(UTC+11:00) Vladivostok',
            SettingsDataset_ScheduleRefresh_Timezone_W_Australia_Standard_Time: '(UTC+08:00) Perth',
            SettingsDataset_ScheduleRefresh_Timezone_W_Central_Africa_Standard_Time: '(UTC+01:00) West Central Africa',
            SettingsDataset_ScheduleRefresh_Timezone_W_Europe_Standard_Time: '(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna',
            SettingsDataset_ScheduleRefresh_Timezone_West_Asia_Standard_Time: '(UTC+05:00) Tashkent',
            SettingsDataset_ScheduleRefresh_Timezone_West_Pacific_Standard_Time: '(UTC+10:00) Guam, Port Moresby',
            SettingsDataset_ScheduleRefresh_Timezone_Yakutsk_Standard_Time: '(UTC+10:00) Yakutsk',
            SettingsDataset_ScheduleRefresh_AmPmWindows_Am: 'AM',
            SettingsDataset_ScheduleRefresh_AmPmWindows_Pm: 'PM',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_1: '1',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_10: '10',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_11: '11',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_12: '12',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_2: '2',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_3: '3',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_4: '4',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_5: '5',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_6: '6',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_7: '7',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_8: '8',
            SettingsDataset_ScheduleRefresh_TimeHourWindows_9: '9',
            SettingsDataset_ScheduleRefresh_TimeMinuteWindos_00: '00',
            SettingsDataset_ScheduleRefresh_TimeMinuteWindos_30: '30',
            SettingsDataset_Add_Refresh_Time: 'Add another time',
            SettingsDataset_DuplicateTime: 'Duplicate times are not allowed.',
            SettingsDataset_IncompleteTime: 'A complete time must be specified.',
            SettingsDataset_ScheduleRefresh_SendRefreshFailureEmail: 'Send refresh failure notification email to me',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_RefreshNotEnabled: 'Refresh Schedule not enabled',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_NextRefresh: 'Next refresh : ',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_LastRefreshFailed: 'Last refresh failed: ',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_LastRefreshSucceeded: 'Last refresh succeeded : ',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_LastPackagePublishFailed: 'Package publish failed',
            SettingsDataset_ScheduleRefresh_FlyoutMessage_RefreshFailed: 'The last refresh failed because we couldn’t connect to the data sources in your dataset. Make sure the data sources are configured correctly.',
            SettingsDataset_ManageDataSources_Title: 'Manage Data Sources',
            SettingsDataset_ManageDataSources_EditButtonText: 'Edit credentials',
            SettingsDataset_ApplyButtonText: 'Apply',
            SettingsDataset_DiscardButtonText: 'Discard',
            SettingsDataset_RefreshHistoryText: 'Refresh History',
            SettingsDataset_ShowDetails: 'Show details',
            SettingsDataset_HideDetails: 'Hide details',
            SettingsDataset_ManageDataSources_Warning_YouNeedToProvideCredentials: 'Your data source cannot be kept up to date because the credentials are incorrect.',
            SettingsDataset_Notification_RefreshScheduleUpdated_Title: ' refresh schedule updated',
            SettingsDataset_Notification_RefreshScheduleUpdated_Message_Part1: 'Your updates to the ',
            SettingsDataset_Notification_RefreshScheduleUpdated_Message_Part2: ' Refresh Schedule have been applied',
            SettingsDataset_Notification_RefreshScheduleCannotBeUpdated_Title: ' refresh schedule cannot be updated',
            SettingsDataset_Notification_RefreshScheduleCannotBeUpdated_Message: 'When \'Refresh frequency\' is \'Weekly\' you have to select at least one day.',
            SettingsDataset_Notification_RefreshScheduleCannotBeUpdatedTimeFormat_Message: 'Please verify all refresh times are valid.',
            SettingsDataset_Notification_DatasourceUpdated_Title: ' Data Source Updated',
            SettingsDataset_Notification_DatasourceUpdated_Message_Part1: 'Your updates to the ',
            SettingsDataset_Notification_DatasourceUpdated_Message_Part2: ' data source have been applied',
            SettingsDataset_Notification_RefreshNow_Scheduled_Title: '',
            SettingsDataset_Notification_RefreshNow_Scheduled_Message: ' dataset will be refreshed soon',
            SettingsDataset_Notification_RefreshNow_NotScheduled_Title: '',
            SettingsDataset_Notification_RefreshNow_NotScheduled_Message_Part1: 'We couldn’t schedule refresh for ',
            SettingsDataset_Notification_RefreshNow_NotScheduled_Message_Part2: '. Be sure to check your refresh settings.',
            SettingsDataset_AreYouSureYouWantToLeaveThisDataset_Title: 'Are you sure you want to leave this Dataset',
            SettingsDataset_AreYouSureYouWantToLeaveThisWorkbook_Title: 'Are you sure you want to leave this Workbook',
            SettingsDataset_AreYouSureYouWantToLeaveThisDataset_Message: 'Your changes will be lost!',
            SettingsDataset_DisableEntireRefreshPageErrorMessage_ModelNotSupported: 'We don’t support scheduled refresh for this dataset.',
            SettingsDataset_DisableEntireRefreshPageErrorMessage_DataSourcesNotSupported: 'You cannot schedule refresh for this dataset because it gets data from sources that currently don’t support refresh.',
            SettingsDataset_Error_FailedToLoadModelForRefresh: 'Failed to load model for Refresh',
            SettingsDataset_Error_FailedToLoadDatasets: 'Failed to load datasets',
            SettingsDataset_Error_FailedToLoadDatasources: 'Failed to load Datasources',
            SettingsDataset_Error_FailedToTestConnection: 'Failed to test connection',
            SettingsDataset_Error_FailedToRetrieveGateway: 'Failed to retrieve gateway',
            SettingsDataset_Error_FailedToLoadRefreshHistory: 'Failed to load refresh history',
            SettingsDataset_Error_DatasourceCredentialsIncorrectTitle: 'You cannot refresh yet because you need to provide valid credentials for your data sources in the dataset.',
            SettingsDataset_Error_DatasourceCredentialsIncorrect: 'You can update the credentials for the data sources in the Manage Data Sources section on the Schedule Refresh settings page.',
            SettingsDataset_Error_GatewayOfflineTitle: 'You cannot refresh yet because your Personal Gateway is offline',
            SettingsDataset_Error_GatewayOffline: 'Make sure the computer where the Gateway is installed is turned on and the Gateway is running.  Also make sure the credentials provided in the Manage Data Sources section in the refresh settings are up-to-date.',
            SettingsDataset_Error_GatewayNotExistTitle: 'You cannot refresh now because your on-premise gateway is not installed.',
            SettingsDataset_Error_GatewayNotExist: 'An on-premise gateways is not found. Please install the Gateway before refreshing the model.',
            SettingsDataset_Error_FailedDuringTestConnection: 'Failed during TestConnection call',
            SettingsDataset_Error_FailedToSaveRefreshSettings: 'Failed to Update Refresh Schedule',
            SettingsDataset_Error_InvalidDataFromServer_RefreshSettings_ExecutionTimeNull: 'We received invalid data from server: RefreshSchedule.ExecutionTime is NULL. Assumed default value (0)',
            SettingsDataset_Error_InvalidDataFromServer_RefreshSettings_ExecutionTimeInvalidHour: 'We received invalid data from server: RefreshSchedule.ExecutionTime.Hour < 0 or > 23. Assumed default value (0)',
            SettingsDataset_Error_InvalidDataFromServer_RefreshSettings_ExecutionTimesHourlyInvalidJsonFormat: 'We received invalid data from server: RefreshSchedule.executionTimesHourly has invalid format',
            SettingsDataset_Error_InvalidDataFromServer_RefreshSettings_ExecutionTimesHourlyInvalidHour: 'We received invalid data from server: RefreshSchedule.executionTimesHourly.Hour < 0 or > 23. Assumed default value (0)',
            SettingsDataset_Error_InvalidDataFromServer_RefreshSettings_ExecutionTimesHourlyInvalidMinute: 'We received invalid data from server: RefreshSchedule.executionTimesHourly.Minute < 0 or > 59. Assumed default value (0)',
            SettingsDataset_Error_InvalidDataFromServer_NextRefreshOrLastRefreshNaN: 'We received invalid data from server: NextRefresh or LastRefresh is NaN. Assumed default value (0)',
            SettingsDataset_TakeOverButton_CancelTakeOver: 'Cancel Takeover',
            SettingsDataset_TakeOverButton_TakeOver: 'Take Over',
            SettingsDataset_TakeOverStatusText_Before: 'This schedule has been set by {0}. Would you like to take over the schedule?',
            SettingsDataset_TakeOverStatusText_After: 'You have chosen to take over this schedule.',
            SettingsDataset_TakeOverDetailsText: 'Changes will take affect once the schedule has been applied. You can cancel out at any time.',
            DatasetParametersDialog_NextButtonText: 'Next',
            DatasetParametersDialog_CancelButtonText: 'Cancel',
            DatasetParametersDialog_HelpButtonText: 'Help',
            DatasetParametersDialog_Configure: 'Configure',
            DatasetParametersDialog_ValidationError: 'Parameter validation failed, please make sure all parameters are valid.',
            DatasetParametersDialog_Error_FailedToUpdateModelParameters: 'Failed to update model parameters',
            HistoryDialog_Title: 'Refresh History',
            HistoryDialog_TableHeader_Type: 'Type',
            HistoryDialog_TableHeader_Start: 'Start',
            HistoryDialog_TableHeader_End: 'End',
            HistoryDialog_TableHeader_Status: 'Status',
            HistoryDialog_TableHeader_FailMessage: 'Fail Message',
            HistoryDialog_TableHeader_Details: 'Details',
            HistoryDialog_RefreshType_Scheduled: 'Scheduled',
            HistoryDialog_RefreshType_OnDemand: 'On demand',
            HistoryDialog_RefreshStatus_Completed: 'Completed',
            HistoryDialog_RefreshStatus_Failed: 'Failed',
            HistoryDialog_RefreshStatus_InProgress: 'In Progress',
            HistoryDialog_RefreshDetail_Show: 'Show',
            HistoryDialog_RefreshDetail_Hide: 'Hide',
            HistoryDialog_CloseButtonText: 'Close',
            AuthDialog_ApplyButtonText: 'Apply',
            AuthDialog_CancelButtonText: 'Cancel',
            AuthDialog_Configure: 'Configure',
            AuthDialog_FieldName_Authentication: 'Authentication Method:',
            AuthDialog_FieldName_Username: 'Username',
            AuthDialog_FieldName_Password: 'Password',
            AuthDialog_FieldName_AccountKey: 'Account key',
            AuthDialog_LinkText_GetYourMarketplaceAccountKey: 'Get your marketplace account key',
            AuthDialog_LinkText_SignUpForWindowsAzureMarketplace: 'Sign up for windows azure marketplace',
            AuthDialog_DisablePopupBlocker_OAuth: 'Ensure pop-ups are not being blocked by your browser',
            AuthDialog_LinkText_SignIn: 'Sign In',
            AuthDialog_LinkText_Edit: 'Edit',
            AuthDialog_LinkMessage_YouAreSignedIn: 'You are signed in',
            AuthDialog_Error_LoginFailed: 'Login failed.',
            AuthDialog_Error_FailedToUpdateDatasource: 'Failed to update the datasource',
            Dashboard_AddFeaturedQuestion: 'Add Featured Question...',
            DashboardTaskPane_Title: 'Welcome to Power BI',
            ContentProvider_Title: 'Bring your own data',
            ContentProvider_GetConfigurationFailed: 'Failed to retrieve configuration page for content provider.',
            ContentProvider_LoadingConfigurationPage: 'Loading configuration page',
            DashboardContainer_Ok: 'OK',
            TileEditor_PaneTitle_Details: 'Tile Details',
            TileEditor_PaneSubtitle_Title: 'Tile Title',
            TileEditor_EmptyTitleWarning: 'Title cannot be empty',
            TileEditor_EmptySubtitleWarning: 'Subtitle cannot be empty',
            TileEditor_SetCustomLink: 'Set custom link',
            TileEditor_UseDefaultText: 'Restore Default',
            TileEditor_UpdateFailed: 'Failed to update tile',
            TileHeadings_By: 'by {0}',
            ListJoin_Separator: ', ',
            TileEditor_Action_Url_WarningInvalidUrl: 'Please provide a valid URL beginning with http:// or https://',
            TileEditor_ApplyButtonText: 'Apply',
            TileEditor_DiscardButtonText: 'Discard',
            UploadExcel_BrowserPopUpDisabled: 'Browser pop-up is disabled. Please verify browser settings.',
            UploadExcel_Cancel: 'Cancel',
            UploadExcel_ConfigureFileFailed: 'Failed to configure selected file',
            UploadExcel_Error_WorkbookAlreadyExists: 'Workbook already exists',
            UploadExcel_ConfirmButtonText: 'upload',
            UploadExcel_DropBox: 'DropBox',
            UploadExcel_DropboxSignIn: 'Sign in to access your files',
            UploadExcel_Description: 'Add Excel data to your dashboard',
            UploadExcel_GetAuthEndpointFailed: 'Unable to retrieve authorization endpoint',
            UploadExcel_GetUserPropertiesFailed: 'Failed to retrieve user properties',
            UploadExcel_GetFileMetadataFailed: 'Failed to retrieve file metadata',
            UploadExcel_GetServicePropertiesFailed: 'Failed to retrieve service properties',
            UploadExcel_LocalBrowse: 'Browse',
            UploadExcel_LocalDevice: 'upload from device',
            UploadExcel_LoadingFiles: 'Loading files ...',
            UploadExcel_Connect: 'Connect',
            UploadExcel_ChooseFormatDescription: 'Choose how to connect to your Excel workbook',
            UploadExcel_ChooseFormat_Or: 'or',
            UploadExcel_ChooseFormat_ViewExcel: 'Connect, Manage and View Excel in Power BI',
            UploadExcel_ChooseFormat_ViewExcelDescription: 'Connect to your workbook and see it exactly as it is in Excel Online -- charts, PivotTables, worksheets, Power View sheets, and all.',
            UploadExcel_ChooseFormat_ImportData: 'Connect Power BI to data in Excel',
            UploadExcel_ChooseFormat_ImportDataDescription: 'Connect to the data in your workbook on OneDrive so you can create Power BI reports and dashboards for it. Data is automatically refreshed from OneDrive.',
            UploadExcel_ChooseFormat_Get: 'Connect',
            UploadExcel_Connecting_Toast: 'Connecting to your Excel workbook...',
            UploadExcel_Success_Toast: 'Your Excel workbook is ready in your list of reports.',
            UploadExcel_Success_Toast_MetaText: 'Take a look: {0}',
            UploadExcel_OfflineAccessRequest: 'Please provide offline access to the document',
            UploadExcel_OneDrive: 'OneDrive - Personal',
            UploadExcel_OneDriveDescription: 'Use OneDrive to access your files from anywhere and share with anyone.',
            UploadExcel_OneDriveFileName: 'Name',
            UploadExcel_OneDriveFileModifiedDate: 'Modified Date',
            UploadExcel_OneDriveFileSize: 'Size',
            UploadExcel_OneDriveSignIn: 'Sign in',
            UploadExcel_OneDriveSignOut: 'Sign out',
            UploadExcel_OneDrivePersonal: 'OneDrive - Personal',
            UploadExcel_OneDrivePro: 'OneDrive for Business',
            UploadExcel_OneDriveProDescription: 'Save your work files to OneDrive for Business so they\'re always with you.',
            UploadExcel_OneDriveProNoSharePointError: 'It looks like you don\'t have OneDrive for Business. Try using OneDrive - Personal.',
            UploadExcel_OneDriveProNoPowerBiForO365Error: 'In order to use Power BI with OneDrive for Business you need to sign up for Power BI for Office 365.',
            UploadExcel_OneDriveProNoPowerBiForO365Error2: 'If you have already signed up for Power BI for Office 365 please try again in 1 hour.',
            UploadExcel_OneDriveProConnecting: 'Connecting ...',
            UploadExcel_OneDriveProSignUp: 'Sign up',
            UploadExcel_OneDriveProSignUpForPowerBIForOffice365: 'Sign up for Power BI for Office 365',
            UploadExcel_OneDriveBusiness: 'OneDrive - Business',
            UploadExcel_NoOneDriveEmail: 'Unspecified account address',
            UploadExcel_ProcessingInProgress: 'Processing selected file, please wait ...',
            UploadExcel_ProgressDescriptionLoading: 'Loading ...',
            UploadExcel_PublishInProgress: 'Publishing selected file, please wait ...',
            UploadExcel_PublishWorkbookCanceled: 'Excel workbook publishing has been canceled',
            UploadExcel_PublishWorkbookFailed: 'Failed to publish Excel workbook',
            UploadExcel_ResolveAccessTokenFailed: 'Failed to resolve access token',
            UploadExcel_Title: 'Excel Workbook',
            UploadExcel_TitleUpload: 'Excel Workbook Upload',
            UploadExcel_UploadLimit: 'Only Excel workbooks up to 250 MB are supported.',
            UploadExcel_UploadLimit_ViewExcelMode: 'Power BI supports workbooks up to 250 MB, and the non-model part of the workbook must be less than 10MB. Get tips for ways to reduce workbook size.',
            UploadExcel_UnsupportedFileType: 'Only Excel 2007 or newer workbooks are supported',
            UploadExcel_WatermarkDescription: 'Drop file here',
            UploadExcel_Computer: 'Computer',
            UploadExcel_PlaceholderText: 'Choose file',
            ReportOptStatus_Idle: '',
            ReportOptStatus_Saving: 'SAVING...',
            ReportOptStatus_Saved: 'SAVED',
            ReportOptStatus_SaveFailed: 'FAILED',
            ReportOptStatus_Default: '',
            Landing_DashboardConnectionsButtonText: 'CONNECTIONS: ',
            Landing_DashboardConnectionsTitleText: 'Dashboard Connections',
            Landing_DashboardConnectionsLastUpdatedText: 'Last updated: ',
            Landing_DashboardConnectionsNoDataAvailableText: 'No Data Connection Available',
            ModalDialog_Save: 'Save',
            ModalDialog_Send: 'Send',
            ModalDialog_Cancel: 'Cancel',
            PowerViewError_Reload: 'Reload',
            PowerViewError_Close: 'Close',
            PowerViewError_DefaultTitle: 'oops, something went wrong',
            RenameService_Success: 'Rename Successful',
            RenameService_Error: 'Unable to rename tile group',
            RenameService_Reason: 'Could not contact service',
            ErrorBar_ConnectionErrorText: 'Connection Error',
            ErrorBar_FixItText: 'Fix it',
            ErrorBar_YesText: 'YES',
            ErrorBar_NoText: 'NO',
            ExternalContentViewer_BackToDashboard: 'Back to Dashboard',
            ExternalContentViewer_Title: 'Get data',
            ExternalContentViewer_GiveFeedback: 'Suggest a data source',
            ExternalContentViewer_UploadInProgress: 'Upload in Progress',
            ExternalContentViewer_Upload: 'Uploading your file to Power BI...',
            ExternalContentViewer_Cancel: 'Cancel',
            ShareView_Invite: 'Invite',
            ShareView_SharedWith: 'Shared With',
            ActivityPane_Tooltip: 'Activity Pane',
            ActivityPane_ConnectAction: 'Connect',
            ActivityPane_ShareAction: 'Share Dashboard',
            ActivityPane_SettingsAction: 'Settings',
            ActivityPane_AddTileAction: 'Add Tile',
            DashboardTaskPane_ReportsSectionHeader: 'Reports',
            DashboardTaskPane_DateSourcesSectionHeader: 'Data Sources',
            DashboardContextMenu_Open: 'OPEN',
            DashboardContextMenu_Explore: 'EXPLORE',
            DashboardContextMenu_ManageRefresh: 'SCHEDULE REFRESH',
            DashboardContextMenu_RefreshNow: 'REFRESH NOW',
            DashboardContextMenu_Rename: 'RENAME',
            DashboardContextMenu_Remove: 'REMOVE',
            DashboardContextMenu_Delete: 'DELETE',
            DashboardContextMenu_Settings: 'SETTINGS',
            DashboardContextMenu_Share: 'SHARE',
            DashboardContextMenu_Export: 'EXPORT',
            DashboardContextMenu_AllPermissionMessage: 'You can access, edit and reshare this dashboard',
            DashboardContextMenu_NonePermissionMessage: 'You don\'t have any permission on this dashboard',
            DashboardContextMenu_ReadPermissionMessage: 'You can access this dashboard',
            DashboardContextMenu_ReadResharePermissionMessage: 'You can access and reshare this dashboard',
            DashboardContextMenu_ReadWritePermissionMessage: 'You can access and edit this dashboard',
            DashboardContextMenu_ReSharePermissionMessage: 'You can reshare this dashboard',
            DashboardContextMenu_WritePermissionMessage: 'You can edit this dashboard',
            DashboardContextMenu_UnknownPermissionMessage: 'Cannot identify your permission on this dashboard',
            Model_FailToDeleteModelMessage: 'We failed to delete the dataset. Please try again later.',
            Model_FailToRenameModelMessage: 'We failed to rename the dataset. Please try again later.',
            Model_NoPermissionToDeleteMessage: 'You don\'t have permission to delete this dataset.',
            Model_NoPermissionToRenameMessage: 'You don\'t have permission to rename this dataset.',
            Report_NoPermissionToDeleteMessage: 'You don\'t have permission to delete this report.',
            Workbook_NoPermissionToRemoveMessage: 'You don\'t have permission to remove this workbook.',
            Report_NoPermissionToRenameMessage: 'You don\'t have permission to rename this report.',
            Workbook_NoPermissionToRenameMessage: 'You don\'t have permission to rename this workbook.',
            Report_FailToDeleteReportMessage: 'We failed to delete the report. Please try again later.',
            Workbook_FailToRemoveMessage: 'We failed to remove the workbook. Please try again later.',
            Report_FailToRenameReportMessage: 'We failed to rename the report. Please try again later.',
            Workbook_FailToRenameWorkbookMessage: 'We failed to rename the workbook. Please try again later.',
            Dashboard_FailToCreateDashboardMessage: 'We failed to create the dashboard. Please try again later.',
            Dashboard_FailToDeleteDashboardMessage: 'We failed to delete the dashboard. Please try again later.',
            Dashboard_FailToExportDashboardMessage: 'We failed to export the dashboard. Please try again later.',
            Dashboard_FailToRenameDashboardMessage: 'We failed to rename the dashboard. Please try again later.',
            Dashboard_FailToRemoveDashboardMessage: 'We failed to remove the dashboard. Please try again later.',
            DashboardDoesNotExistMessage: 'It may have been deleted or you may not have access to view it.',
            DashboardDoesNotExistTitle: 'Sorry, we couldn\'t find that dashboard',
            NotificationMessage_ExportingPackage: 'Exporting package',
            DashboardReadOnlyExportWarning_Message: 'This dashboard is read only, export is not allowed.',
            Dashboard_DeleteConfirmationMessage: 'Are you sure you want to permanently delete this dashboard?',
            Dashboard_DeleteConfirmationTitle: 'Delete Dashboard',
            Dashboard_RemoveConfirmationTitle: 'Remove Dashboard',
            Dashboard_RemoveConfirmationMessage: 'Are you sure you want to remove this dashboard?',
            Report_DeleteConfirmationMessage: 'Are you sure you want to permanently delete this report?',
            Workbook_RemoveConfirmationMessage: 'Are you sure you want to permanently remove this workbook?',
            Report_DeleteConfirmationTitle: 'Delete Report',
            Workbook_RemoveConfirmationTitle: 'Remove Workbook',
            Report_ExitOnDeletionConfirmationMessage: 'Another user has deleted this report.',
            Report_ExitOnDeletionConfirmationTitle: 'Report deleted',
            Report_ExitOnDeletionConfirmationButtonText: 'Close report',
            Model_DeleteConfirmationMessage: 'Are you sure you want to permanently delete this dataset?',
            Model_DeleteConfirmationTitle: 'Delete Dataset',
            Tile_LoadingText: 'LOADING...',
            Tile_ErrorText: 'We can’t load the content of this tile now. Please try again later.',
            PinTile_Error: 'Sorry, can\'t pin this visualization yet',
            PinTile_Error_DefaultDetails: 'We\'re working on this feature. Please send us any other feedback about Power BI.',
            PinTile_Success: 'Pinned to Dashboard',
            PinTile_Success_DefaultDetails: 'The visualization has been pinned to your dashboard.',
            SaveReport_Success: 'Report successfully saved.',
            SaveReport_Success_DefaultDetails: 'This report has been saved.',
            SaveReport_Error: 'An error occured during save.',
            SaveReport_Error_DefaultDetails: 'This report currently cannot be saved.',
            DashboardReadOnlyWarning_Title: 'Warning',
            DashboardReadOnlyWarning_Message: 'This dashboard is read only, your changes will not be saved.',
            BingSearchMetricsContentProvider_EnterUrl: 'Please enter a URL.',
            BingSearchMetricsContentProvider_SelectVisual: 'Please select at least one visual.',
            BingSearchMetricsContentProvider_Title: 'Bing Search Metrics',
            BingSearchMetricsContentProvider_Description: 'Track and explore search trends from Bing for the topics, search terms, or websites that matter most to you.',
            BingSearchMetricsContentProvider_UrlPrompt: 'Get metrics for URL:',
            BingSearchMetricsContentProvider_AddButtonText: 'Add',
            BingNewsContentProvider_EnterSearchTerm: 'Bing News Search:',
            BingNewsContentProvider_NoSearchTerm: 'Please enter a search term.',
            BingNewsContentProvider_AddButtonText: 'Add',
            BingNewsContentProvider_Title: 'Bing News',
            BingNewsContentProvider_Description: 'Track the latest news headlines on your dashboard with Bing News and stay up to date with news for the topics that matter most to you. Provide the search terms for topics you want to track and add a news tiles to the currently selected dashboard. Clicking on the listed news headlines opens the original articles so you can read further.',
            BingNewsTile_NoResults: 'We didn\'t find any results',
            AdditionalErrorInfo_RequestIdText: 'Request Id',
            AdditionalErrorInfo_ActivityIdText: 'Activity Id',
            AdditionalErrorInfo_TimestampText: 'Time',
            AdditionalErrorInfo_ErrorCodeText: 'Status Code',
            AdditionalErrorInfo_VersionText: 'Version',
            AdditionalErrorInfo_ClusterUriText: 'Cluster URI',
            AdditionalErrorInfo_ecsCorrelationId: 'ecsCorrelationId',
            ErrorMessage_FailedLoadGroup: 'Failed to load group content',
            ErrorMessage_FailedLoadDashboards: 'Failed to load all dashboards',
            ErrorMessage_FailedLoadContentProviders: 'Failed to load content providers',
            ErrorTitle_FailedToStorePackage: 'We couldn\'t import data from ',
            ErrorMessage_FailedToStorePackageExcel: 'Your data might not be formatted properly. You\'ll need to edit your workbook in Excel and then import it again.',
            ErrorMessage_FailedToGetPackageModels: 'Failed to store the data for new tile',
            ErrorMessage_DefaultTitle: 'oops, something went wrong',
            ErrorMessage_FailedToOpenExcelFile: 'This is not an Excel file or it is a password protected Excel file. If that\'s the case, try removing the password and uploading the file again.',
            ErrorMessage_NoConnectorAssociatedWithModel: 'This workbook connects to an Analysis Services server, but the server has not yet been connected to Power BI. Contact your administrator to configure a Analysis Services Connector to connect the server and Power BI.',
            ErrorTitle_FailedToStorePackageExcel: 'We couldn\'t find any data in your Excel workbook',
            NotificationMessage_ImportingPackage: 'Importing data',
            NotificationMessage_ImportingMashUpPackage: 'Connecting to data sources, please stay on this page',
            NotificationMessage_RetrievingAggregatedDataSourcesFromModel: 'Retrieving data sources, please stay on this page',
            NotificationMessage_NewDashboardCreatedTitle: 'Your new dashboard is ready',
            NotificationMessage_NewDashboardCreatedLinkDescription: 'Take a look',
            DisplayUnitSystem_E3_LabelFormat: '{0}K',
            DisplayUnitSystem_E3_Title: 'Thousands',
            DisplayUnitSystem_E6_LabelFormat: '{0}M',
            DisplayUnitSystem_E6_Title: 'Millions',
            DisplayUnitSystem_E9_LabelFormat: '{0}bn',
            DisplayUnitSystem_E9_Title: 'Billions',
            DisplayUnitSystem_E12_LabelFormat: '{0}T',
            DisplayUnitSystem_E12_Title: 'Trillions',
            Percentage: '#,0.##%',
            Percentage1: '#,0.#%',
            ResyncSessionTile_Warning: 'Warning',
            ResyncSessionToPreviousState_WarningMessage: 'We were unable to restore your session to the latest state. We have restored your session to a previously saved state.',
            NewDashboard_Placeholder: 'New Dashboard',
            NewDashboard_AddDashboardLabelText: 'Add Dashboard',
            DashboardName_InvalidNameNotificationTitle: 'Dashboard name invalid',
            DashboardName_EmptyWhitespaceErrorMessage: 'Dashboard name cannot be empty or whitespaces.',
            DashboardName_DuplicatedNameErrorMessage: 'Duplicate name exists.',
            SalesforceContentProvider_Landing_Title: 'Salesforce',
            SalesforceContentProvider_Landing_Description_Top1: 'With the Salesforce connector, you import and analyze your Salesforce data in Power BI. After connecting to your Salesforce account, you import a variety of data to explore and monitor in your Power BI dashboards.',
            SalesforceContentProvider_Landing_Description_Top2: 'Based on the persona you select, Power BI automatically creates a dashboard with customized visualizations of your data. This dashboard provides immediate insights into your data.',
            SalesforceContentProvider_Landing_Description_Bottom: 'You can also customize the dashboard, adding metrics that are important to you. All of your Salesforce data is updated automatically, ensuring you have the latest information available.',
            SalesforceContentProvider_Landing_MetricsHeading: 'Sample metrics include:',
            SalesforceContentProvider_Landing_Metrics_OpportunitiesValue: 'Value of opportunities in each stage',
            SalesforceContentProvider_Landing_Metrics_OpportunitiesCount: 'Number of open opportunities',
            SalesforceContentProvider_Landing_Metrics_Accounts: 'Top accounts by the total amount',
            SalesforceContentProvider_Landing_More1: 'More about',
            SalesforceContentProvider_Landing_More2: ' connecting to Salesforce data',
            SalesforceContentProvider_Landing_ConnectButton: 'Connect',
            SalesforceContentProvider_Landing_Error_BrowserPopUpDisabled: 'Browser pop-up is disabled. Please verify browser settings.',
            SalesforceContentProvider_Landing_Error_GetAuthEndpointFailed: 'Unable to resolve Salesforce authentication endpoint. Please try again later.',
            SalesforceContentProvider_Landing_Error_ConfigurationOptionsUnavailable: 'Unable to log in to Salesforce with provided credentials. Please make sure your Salesforce account allows API access and try again.',
            SalesforceContentProvider_Configuration_Title: 'Import from Salesforce',
            SalesforceContentProvider_Configuration_Type_Templates: 'Dashboards',
            SalesforceContentProvider_Configuration_Type_Reports: 'Reports',
            SalesforceContentProvider_Configuration_OKButtonText: 'OK',
            SalesforceContentProvider_Configuration_CancelButtonText: 'Cancel',
            SalesforceContentProvider_Configuration_ConnectButton: 'Connect',
            SalesforceContentProvider_Configuration_Dashboards_Title: 'Select an out of box dashboard customized by persona:',
            SalesforceContentProvider_Configuration_Embedded_Title: 'Salesforce',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Title: 'Select an out of box dashboard designed to get the most of your Salesforce data',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Title: 'Preview',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Description_SalesManager: 'Sales Manager Dashboard contains lots of info that may be relevant to you if you were a sales manager. Included tiles:',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Description_SalesRep: 'Sales Rep Dashboard contains lots of info that may be relevant to you if you were a sales representative. Included tiles:',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Metric_SaleOverTime: 'Sale over time',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Metric_CustomerRepsInLocation: 'Customer Reps in Location',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_Preview_Metric_TrendingSales: 'Trending Sales',
            SalesforceContentProvider_Configuration_Embedded_Reports_Title: 'Choose any Salesforce reports you would like to import into PowerBI.com.',
            SalesforceContentProvider_Configuration_Embedded_Reports_DateTime_Never: 'Never',
            SalesforceContentProvider_Configuration_Dashboards_SalesManager: 'Sales Manager Dashboard',
            SalesforceContentProvider_Configuration_Dashboards_SalesRep: 'Sales Rep Dashboard',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_SalesManager: 'Sales Manager',
            SalesforceContentProvider_Configuration_Embedded_Dashboards_SalesRep: 'Sales Rep',
            SalesforceContentProvider_Configuration_Reports_NameHeader: 'Name',
            SalesforceContentProvider_Configuration_Reports_LastViewedHeader: 'Last Viewed',
            SalesforceContentProvider_Configuration_Reports_LastEditied: 'Last Edited',
            SalesforceContentProvider_Configuration_Reports_Loading: 'Loading your Salesforce reports...',
            SalesforceContentProvider_Configuration_Reports_NoneAvailable: 'We didn’t find any reports in your Salesforce account. Please add some and then try again.',
            SalesforceContentProvider_Configuration_ReportsSelectionInfo_Single: 'You\'ve selected {0} report.',
            SalesforceContentProvider_Configuration_ReportsSelectionInfo_Multiple: 'You\'ve selected {0} reports.',
            SalesforceContentProvider_Configuration_Error_UnableToAccessSalesforceAccount: 'Sorry, we weren\'t able to access your account. Please contact your administrator.',
            SalesforceContentProvider_Configuration_Error_ReportsLoadFailedGeneric: 'Sorry, something went wrong while retrieving the list of your reports. Please try again later.',
            SalesforceContentProvider_Configuration_Error_Unknown: 'Sorry, something went wrong. Please try again later.',
            MashUpContentProvider_Title: 'MashUp Content Provider',
            MashUpContentProvider_Description: 'Third party content providers for PowerBI.',
            MashUpContentProvider_ImportButtonText: 'Connect',
            MashUpContentProvider_Error_MissingModelFromPackage: 'Missing model from the package',
            MashUpContentProvider_RetailSalesSample_Title: 'Retail Sales Sample',
            MashUpContentProvider_RetailSalesSample_Description1: 'This industry sample dashboard and underlying report analyzes retail sales data of items sold across multiple stores and districts. The metrics compare this year\'s performance to last year\'s in these areas: sales, units, gross margin, and variance, as well as new store analysis. This is real data that has been anonymized.',
            MashUpContentProvider_Sample_Usage: 'How to use this sample',
            MashUpContentProvider_Sample_DataReportDashboard: 'This sample contains a dashboard, a report, and data.',
            MashUpContentProvider_NFL2014SeasonRecap_Description1: 'Explore statistics from National Football League regular season and playoff games for the 2014 season. Statistics and key measures are provided game by game for each team and player, with additional data for fan attendance, game day weather, and player backgrounds. ',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted: 'To get you started with the data, the sample provides these reports:',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted1: 'Team weekly scoring recap with statistical leaders',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted2: 'Game by game recap',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted3: 'Passing, rushing, receiving, and defensive stat recaps',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted4: 'Outcomes against the spread',
            MashUpContentProvider_NFL2014SeasonRecap_GetStarted5: 'Player demographics',
            MashUpContentProvider_NFL2014SeasonRecap_ExploreFurtherDesc1: 'Want to explore the data further? Go ahead! Ever wondered… ',
            MashUpContentProvider_NFL2014SeasonRecap_ExploreFurther1: 'Which draft round produced the players who scored most touchdowns in the playoffs?',
            MashUpContentProvider_NFL2014SeasonRecap_ExploreFurther2: 'How colleges rank based on the number of snaps their former players were on the field for?',
            MashUpContentProvider_NFL2014SeasonRecap_ExploreFurther3: 'The average QB rating for quarterbacks playing in domed stadiums, when favored? ',
            MashUpContentProvider_NFL2014SeasonRecap_ExploreFurtherDesc2: 'If so, then this data set is for you. The answers to these and many other questions are waiting in this data.',
            MashUpContentProvider_NFL2014SeasonRecap_Description2: 'This copy of the sample is yours to experiment with. You can always connect to the sample again for a fresh copy.',
            MashUpContentProvider_Sample_Click: 'Click ',
            MashUpContentProvider_Sample_Connect: 'Connect ',
            MashUpContentProvider_Sample_ConnectSuffix: 'above to get started. Power BI automatically creates a dashboard with visualizations based on the sample data.',
            MashUpContentProvider_Sample_InDashboard: 'In the dashboard:',
            MashUpContentProvider_Sample_InDashboard1: 'Try typing natural-language questions to explore the data. Pin the resulting visualizations and metrics to your dashboard.',
            MashUpContentProvider_Sample_InDashboard2: 'Click a tile to explore the underlying data and reports.',
            MashUpContentProvider_Sample_InReport: 'In the report:',
            MashUpContentProvider_Sample_Report1: 'Change visualizations from one type to another.',
            MashUpContentProvider_Sample_Report2: 'Move visualizations and add new ones.',
            MashUpContentProvider_Sample_Report3: 'Pin interesting visualizations to the dashboard. ',
            MashUpContentProvider_Sample_Report4: 'See what insights you can discover in the data.',
            MashUpContentProvider_Sample_Description3: 'This copy of the sample is yours to experiment with. You can always connect to the sample again for another copy.',
            MashUpContentProvider_Sample_More: 'About the sample',
            MashUpContentProvider_Sample_LearnMore: 'More about the specifics of this sample',
            MashUpContentProvider_Sample_LearnMoreDescription: 'and how you can enhance it.',
            MashUpContentProvider_GitHub_Description1: 'Visualize different types of repository activity in Power BI by connecting to your GitHub data. You get a Power BI dashboard and reports with insights about how many commits, who contributes most, and at what time of day. Use the dashboard and reports provided, or customize them to highlight the information you care about most.',
            MashUpContentProvider_GitHub_Description2: 'The data in Power BI is updated daily from GitHub according to a schedule that you control.',
            MashUpContentProvider_GitHub_More1: 'More about',
            MashUpContentProvider_GitHub_More2: ' connecting to GitHub Data',
            MashUpContentProvider_GoogleAnalytics_Description1: 'Visualize data from your Google Analytics account directly in Power BI. Connect using your Google credentials and immediately gain insights from the sites that you’re tracking, such as the site traffic over the last 30 days or the days of the week your site is most popular. Data from the last 180 days is included and will automatically refresh each day. Existing reports provide a view of trends over time and can be customized based on the metrics important to you.',
            MashUpContentProvider_Marketo_Description1: 'Bring rich marketing analytics directly into Power BI by connecting to Marketo. Extend the power of your Power BI dashboards with reports that provide rich insights into your buyer profiles, marketing campaign success rates, email engagement, and more. Use the dashboard and reports provided, or customize them to highlight the information you care about most.',
            MashUpContentProvider_Marketo_Description2: 'The data in Power BI is automatically updated from Marketo, so you always see the latest data.',
            MashUpContentProvider_Marketo_More1: 'More about',
            MashUpContentProvider_Marketo_More2: ' connecting to Marketo Data',
            MashUpContentProvider_QuickBooks_Description1: 'Get insights into your business by connecting Power BI with QuickBooks Online.  Connect Power BI to QuickBooks Online using you QuickBooks Online admin credentials to get a dashboard with insights to your business cash flow, profitability, customers, and more.  Use the default dashboard and reports, or customize them to highlight the information you care most about.',
            MashUpContentProvider_QuickBooks_Description2: 'The data that appears in Power BI will be updated daily from QuickBooks Online based on the schedule that you set.',
            MashUpContentProvider_QuickBooks_Description3: 'With the current version of the Power BI and QuickBooks Online integration, one QuickBooks Online admin user can connect and create the Power BI dashboard, which can then be shared with other Power BI users.',
            MashUpContentProvider_QuickBooks_More1: 'More about',
            MashUpContentProvider_QuickBooks_More2: ' connecting to QuickBooks Online data',
            MashUpContentProvider_Zendesk_Description1: 'Analyze your Zendesk data in Power BI by connecting with your Zendesk admin account credentials. Power BI creates a dashboard with reports that provide insights about your ticket volumes and agent performance. Use the dashboard and reports provided, or customize them to highlight the information you care about most.',
            MashUpContentProvider_Zendesk_Description2: 'Your data in the Zendesk service is transmitted to Power BI so that you can perform business analytics. This data is updated daily from Zendesk according to a schedule that you control.',
            MashUpContentProvider_Zendesk_More1: 'More about',
            MashUpContentProvider_Zendesk_More2: ' connecting to Zendesk data',
            MashUpContentProvider_VisualStudioOnline_Description1: 'Visualize your source code activity in Power BI by connecting to Microsoft Visual Studio Online. The default dashboard and report provide at-a-glance views of git, pull request, and version control activity across the projects you configure for your account.  You can customize the dashboard and report to highlight the deeper insights you care about most.',
            MashUpContentProvider_VisualStudioOnline_Description2: 'The data that appears in Power BI will be updated from Microsoft Visual Studio Online according to a schedule that you control.',
            MashUpContentProvider_VisualStudioOnline_More1: 'More about',
            MashUpContentProvider_VisualStudioOnline_More2: ' connecting to Visual Studio Online data',
            MashUpContentProvider_Sage_Description1: 'The Sage One Accounting application allows you to import and analyze your financial and sales data in Power BI. After connecting to your Sage One account, you\'ll be able to import your data and view your company\'s performance using flexible Power BI dashboards. You’ll have immediate insight into your data to make informed business decisions.',
            MashUpContentProvider_Sage_Description2: 'Customize the dashboards to include metrics that provide you with the information you need for your business, then slice, dice and analyze the data any way you like using the variety of tools available in Power BI. All your latest Sage One Accounting information will be updated automatically, ensuring you always have your finger on the pulse.',
            MashUpContentProvider_Sage_Title: 'Sample metrics include:',
            MashUpContentProvider_Sage_Top4Sales: 'Top 5 Items by Sales',
            MashUpContentProvider_Sage_Top5Customers: 'Top 5 Customers by Sales',
            MashUpContentProvider_Sage_AndMore: 'And More.',
            MashUpContentProvider_Sage_More1: 'More about',
            MashUpContentProvider_Sage_More2: ' connecting to Sage data',
            MashUpContentProvider_SendGrid_Description1: 'With the SendGrid connector, monitor all your important email metrics in one dashboard using Power BI. After you connect with your SendGrid credentials, Power BI imports your email metrics into a single dashboard. From there, you can customize your dashboard and drill down for greater detail.',
            MashUpContentProvider_SendGrid_Description2: 'With SendGrid advanced statistics enabled, you can monitor your most important metrics at a glance and measure user engagement for the emails you send.',
            MashUpContentProvider_SendGrid_Title: 'Sample metrics include:',
            MashUpContentProvider_SendGrid_AggregatedStats: 'Trend data for specified periods of time including requests, delivered, opens, clicks, unsubscribes, bounces, and spam reports',
            MashUpContentProvider_SendGrid_EmailMetricsByCategory: 'By client, device, ISP, and browser',
            MashUpContentProvider_SendGrid_EmailMetricsByGeography: 'By geographical location including country, state, and city',
            MashUpContentProvider_SendGrid_EmailMetricsByISP: 'By email category (for example, user alerts, welcome emails, confirmations, or newsletters)',
            MashUpContentProvider_SendGrid_More1: 'More about',
            MashUpContentProvider_SendGrid_More2: ' connecting to SendGrid data',
            MashUpContentProvider_DynamicCRM_Description1: 'Connect to your Microsoft Dynamics CRM account for immediate access to insights about your opportunities, accounts, and more. This connector is designed specifically for sales managers, providing details on sales performance, pipeline, and activities. The dashboard and report are built on top of a fully featured model, so you can explore and analyze your data as you need. Automatic refresh ensures you always see the latest data.',
            MashUpContentProvider_DynamicCRM_More1: 'More about',
            MashUpContentProvider_DynamicCRM_More2: ' connecting to Microsoft Dynamics CRM data',
            MashUpContentProvider_DynamicMarketing_Description1: 'Use the Microsoft Dynamics Marketing Content Pack for Power BI to quickly build your marketing performance analytics. The content pack is designed specifically for marketing managers who focus on demand generation. Its components draw directly from your marketing database to provide reports on topics that include: marketing contacts and companies; territory analysis; campaign ownership and ROMI; lead pipeline, scoring and generation over time; segment analysis; and the performance of landing pages, marketing emails and tracked web pages. The reports and dashboards are built on top of a model that focuses on demand generation. The out-of-box reports and dashboards give you a great starting point for exploring and analyzing your marketing data.',
            MashUpContentProvider_PBIExecutionReview_Title: 'PowerBI Execution Review',
            MashUpContentProvider_PBIExecutionReview_Description1: 'Power BI enables your organization to publish sources of data that are relevant to your business. This sample includes a collection of data, reports and a dashboard.',
            MashUpContentProvider_PBIExecutionReview_Description2: 'Click on the Connect button to get started. You will see a new dashboard automatically created with a collection of visuals based on the sample data. From the dashboard, you can click on a tile to explore the underlying data and reports. You will also be able to pin interesting visuals to the dashboard, that you can continue to monitor. Additionally you can use natural language to explore the data and pin interesting visuals and metrics to your dashboard.',
            MashUpContentProvider_MSITNTA_Title: 'IT New Technology Adoption',
            MashUpContentProvider_MSITNTA_Description1: 'Connect to Microsoft’s organizational data to gain insights into Microsoft IT Applications’ adoption of latest technologies across the portfolio of solutions Microsoft employees use. You will get a dashboard with a report backed by data from an on premise SQL Server Analysis Services instance.  You will be able to customize the dashboard adding metrics that are important to you.',
            MashUpContentProvider_MSITNTA_Support: 'Questions on data and reports: ntacore@microsoft.com',
            MashUpContentProvider_WinUserVoice_Title: 'Windows UserVoice',
            MashUpContentProvider_WinUserVoice_Description1: 'Windows and Windows Phone UserVoice are feedback portals where Windows and Windows Phone users can submit feature suggestions, vote and/comment on those suggestions, and be heard! Through the portals, engineering teams can identify innovative features that our users crave.',
            MashUpContentProvider_WinUserVoice_Description2: 'Connect to Microsoft’s organizational data of Windows and Windows Phone UserVoice feedback to get a quick and up-to-date view of the total users, total suggestions and total votes for both Windows UserVoice and Windows Phone UserVoice. You will get a dashboard with a report backed by data from an on premise SQL Server Analysis Services instance.  The reports include top categories for both portals, and trends in suggestions, votes and comments, during a given period of time. You will be able to customize the dashboard adding metrics that are important to you.',
            MashUpContentProvider_WinUserVoice_Support: 'Questions on data and reports: winuservoice@microsoft.com',
            MashUpContentProvider_DCU_Title: 'Digital Crimes Unit',
            MashUpContentProvider_DCU_Description1: 'The Digital Crimes Unit (DCU) is an international legal and technical team working with partners, to help create a safe digital world. The DCU operates in conjunction with Internet Service Providers and Computer Emergency Response Teams to disrupt botnets from cybercriminals. These botnets can be involved in activities ranging from e-mail spam and click fraud to financial fraud and privacy invasion. After Microsoft disrupts these botnets, affected devices continue to call into Digital Crimes Unit allowing reporting and to notify those still affected by malware.',
            MashUpContentProvider_DCU_Description2: 'Connect to Microsoft’s organizational data to gain insights into the summary of calls that are made to the DCU every day by devices still affected by several of the botnets that the Digital Crimes Unit has disrupted. You will get a dashboard with a report backed by data from an on premise SQL Server Analysis Services instance.  You will be able to customize the dashboard adding metrics that are important to you.',
            MashUpContentProvider_DCU_Support: 'Questions on data and reports: DCU_BI_Status@microsoft.com',
            MashUpContentProvider_HR_Title: 'People View',
            MashUpContentProvider_HR_Description1: 'Connect to Microsoft’s organizational data to gain insights into Headcount, Average Directs and Anniversaries. You will get a dashboard with a report backed by data from an on premise SQL Server Analysis Services instance.  You will be able to customize the reports and dashboard adding metrics that are important to your group.',
            MashUpContentProvider_HR_Support: 'Questions on data and reports: hrreport@microsoft.com',
            MashUpContentProvider_OrgApps_Legal: 'This dataset is based on Microsoft confidential information and cannot be shared with external non-Microsoft parties under any circumstances',
            DashboardInvitationInvalid: 'This invitation is invalid',
            DashboardInvitationRevoked: 'The dashboard owner has removed access to this dashboard',
            DashboardInvitationExpired: 'This invitation has expired',
            DashboardInvitationRemoteTenant: 'The data for the invitation is not currently available',
            DashboardInvitationUnverifiedEmail: 'This invitation was not intended for the current signed in user. Only the intended recipient can access this dashboard',
            DashboardInvitationInvalidTenant: 'This invitation contains dashboards, reports or data outside your organization which cannot be viewed',
            DashboardInvitationInvalidParameters: 'Invalid parameters specified',
            DashboardInvitationInvalidRequest: 'There was an error processing the invitation',
            DashboardInvitationErrorTitle: 'You do not have access to this dashboard',
            Sharing_WrongEmailAddresses: 'Invalid list of email addresses. Please correct them',
            Sharing_EmailAddressExceeded: 'You can only share to {{maxEmails}} contacts at a time, please remove some',
            Sharing_NoEmailAddressSpecified: 'Please specify one or more e-mail addresses',
            Sharing_InvalidEntry: 'Invalid entry',
            Sharing_MessageSizeExceeded: 'Message is too long',
            Sharing_FailedToLoadInvitedUsers: 'Failed to load invited users',
            Sharing_FailedToLoadUsers: 'Failed to load dashboard users',
            Sharing_FailedToInvitedUsers: 'Failed to send email to invite users',
            Sharing_FailedToCancelInvitation: 'Failed to cancel invite',
            Sharing_FailedToDeleteDashboardUser: 'Failed to delete dashboard user',
            Sharing_Status: 'Status',
            Sharing_Success: 'Success!',
            Sharing_Failure: 'Failure',
            Sharing_EditDashboardUsersSuccess: 'Your changes were successfully saved',
            Sharing_SendEmailSuccess: 'Your dashboard has been shared successfully.',
            Sharing_UsersCanReshare: 'Allow recipients to share your dashboard',
            Sharing_CancelInvite: 'Cancel Invite',
            Sharing_StopSharing: 'Stop Sharing',
            Sharing_InviteWillBeCancelled: 'Invite will be cancelled',
            Sharing_UserDeleted: 'Sharing will be removed',
            Sharing_Owner: 'Owner',
            Sharing_DashboardOwner: 'Dashboard owner is ',
            Sharing_OnlyWithYou: 'Not shared with anyone',
            Sharing_SharedWith: 'Shared with ',
            Sharing_EmailText: 'Check out this dashboard I created to track our data.',
            Sharing_EnterEmailText: 'Enter email addresses separated by ; or ,',
            Sharing_UsersCannotReshare: 'You do not have sufficient permissions to share this dashboard',
            Sharing_SharedWithNOthers: ' and {{numberOthers}} others',
            Sharing_FailedToEditPermissions: 'Unable to edit permissions',
            Sharing_PermissionDisplay_CanView: 'Can view',
            Sharing_PermissionDisplay_CanEdit: 'Can edit',
            Sharing_PermissionOptions_StopSharing: 'Stop sharing',
            Sharing_PermissionOptions_DisableReshares: 'Disable reshares',
            Sharing_PermissionOptions_EnableReshares: 'Enable reshares',
            Sharing_EmailDomainNotInTenant: 'One or more e-mail addresses are outside your organization: {{invalidDomains}}',
            Sharing_DataAccessNotification: 'Recipients will have access to the same data and reports as you have in this dashboard.',
            Sharing_DataAccessNotificationLink: 'Learn more',
            Publish_SuccessMessage: 'The content pack "{0}" has been published to the organization content gallery.',
            Publish_Success: 'Success!',
            Publish_Failure: 'Failure',
            ActivityPane_ErrorMessage_FailedLoadPaneContent: 'Failed to load activity pane data.',
            ActivityPane_ConnectionOptionsText: 'Connection Options',
            ActivityPane_Explore: 'EXPLORE',
            ActivityPane_CuratedContentReportTitle: 'REPORTS',
            ActivityPane_CuratedContentDashboardTitle: 'DASHBOARDS',
            ActivityPane_CuratedContentTileTitle: 'TILES',
            ConnectionsSettingsDialog_Title_Text: 'Connection Settings',
            ConnectionsSettingsDialog_Load_Content_Error_Text: 'An error occured during getting data for connection settings dialog.',
            ConnectionsSettingsDialog_Refresh_Settings_Title_Text: 'Refresh Settings',
            ConnectionsSettingsDialog_Refresh_Settings_Last_Updated_Title_Text: 'Last updated: ',
            ConnectionsSettingsDialog_Delete_Connection_Title_Text: 'Delete Connection',
            ConnectionsSettingsDialog_Delete_Connection_Content_Text: 'Deleteing a connection cannot be undone.',
            ConnectionsSettingsDialog_Delete_Connection_Link_Text: 'Delete Connection',
            ConnectionsSettingsDialog_Delete_Done_Button_Text: 'Done',
            ConnectionsSettingsDialog_Delete_Confirmation_Text: 'Are you sure you want to delete this connection?',
            ConnectionsSettingsDialog_Delete_Error_Text: 'An error happened during deleting the package.',
            TableTotalLabel: 'Total',
            ExpiredTokenError_Title: 'Session has expired',
            ExpiredTokenError_Text: 'Your login session has expired. Please refresh the page.',
            ExcelContentProvider_Landing_Title: 'Excel Workbook',
            ExcelContentProvider_Landing_Description: 'Unlocking the insights stored in your Excel workbooks couldn\'t be easier. By either directly uploading or connecting Power BI to your OneDrive account, you can begin to track your most important metrics on an interactive, real-time dashboard. Data is automatically refreshed from OneDrive, ensuring you have the latest information as you make decisions and take actions.',
            ExcelContentProvider_Landing_SupportedObjectsHeading: 'Supported Excel objects:',
            ExcelContentProvider_Landing_Supported_1: 'Worksheet tables',
            ExcelContentProvider_Landing_Supported_2: 'Excel Data Model tables',
            ExcelContentProvider_Landing_Supported_3: 'Power View sheets',
            ExcelContentProvider_Landing_WorksWellHeading: 'Works well with:',
            ExcelContentProvider_Landing_WorksWell_1: 'Excel 2007 workbooks and later (.xlsx and .xlsm files)',
            ExcelContentProvider_Landing_DownloadSample_1: 'Need a workbook to try?',
            ExcelContentProvider_Landing_DownloadSample_2: 'Download this one',
            ExcelContentProvider_Landing_LearnMore1: 'More about',
            ExcelContentProvider_Landing_LearnMore2: ' connecting to Excel data',
            ExcelContentProvider_Landing_ConnectButton: 'Connect',
            QnAVisualization_ModelDetailsTitle: 'Showing data from',
            QnAVisualization_ModelDetailsExploreLink: 'explore more...',
            ModalDialogButtonText_Yes: 'Yes',
            ModalDialogButtonText_No: 'No',
            PowerBICompanionProvider_Landing_Title: 'Power BI Designer File',
            PowerBICompanionContentProvider_Landing_Description1: 'Upload reports and data created with Power BI Designer. With the Designer app, you unleash the full power of Power BI: easily create reports based on data from a wide range of data sources, shape and combine the data to fit your needs, and create stunning visualizations to make your data speak for itself.',
            PowerBICompanionContentProvider_Landing_Description2: 'If you haven\'t tried it yet, ',
            PowerBICompanionContentProvider_Landing_Description3: 'download Power BI Designer today',
            PowerBICompanionContentProvider_Landing_Description4: ' and bring your Power BI reports and dashboards to the next level.',
            PowerBICompanionContentProvider_Landing_PowerBIDesignerData_1: 'More about',
            PowerBICompanionContentProvider_Landing_PowerBIDesignerData_2: ' connecting to Power BI Designer data',
            PowerBICompanionContentProvider_Landing_ConnectButton: 'Connect',
            UploadPowerBICompanion_YourComputer: 'Computer',
            UploadPowerBICompanion_Connect: 'Connect',
            UploadPowerBICompanion_Cancel: 'Cancel',
            UploadPowerBICompanion_LocalBrowse: 'Browse',
            UploadPowerBICompanion_PlaceholderText: 'Choose file',
            UploadPowerBICompanion_UnsupportedFileType: 'Only .pbix files are supported',
            UploadPowerBICompanion_PublishInProgress: 'Publishing selected file, please wait ...',
            UploadPowerBICompanion_PublishFileCanceled: '.pbix file publishing has been canceled',
            UploadPowerBICompanion_PublishFileFailed: 'Failed to publish .pbix file',
            UploadPowerBICompanion_UploadLimit: 'Only .pbix files up to 250 MB are supported.',
            UploadPowerBICompanion_TitleUpload: '.pbix file Upload',
            QnAVisualization_ModelsListDescription: 'Here\'s the data used on this dashboard. To ask questions about this data try starting with words that appear in the data (such as column names or row values). Or, open any of the data sources to explore on your own...',
            QnAVisualization_NoModelMessage: 'It looks like you haven\'t added any data to this dashboard.',
            QnAVisualization_NoSupportedModelMessage: 'You\'re connected to data sources that are not supported by Q&A. Open any of the data sources to explore on your own...',
            QnAVisualization_NoModelDescription1: 'Get data',
            QnAVisualization_NoModelDescription2: 'or add tiles to this dashboard from data sources you\'ve already connected to and Q&A will allow you to ask questions about this data.',
            QnAVisualization_DataSources: 'Data sources',
            AddDashboard_ToolTip: 'Add a dashboard',
            SettingsGroupsNames_General: 'General',
            SettingsGroupsNames_Dashboards: 'Dashboards',
            SettingsGroupsNames_Datasets: 'Datasets',
            SettingsGroupsNames_Workbooks: 'Workbooks',
            QnaTextBoxPlaceholder: 'Ask a question about the data on this dashboard',
            QnaTextBoxLoadingPlaceholder: 'LOADING...',
            InterpretRetryMaxCountExceededMessageText: 'There was a timeout executing your query. Please try again later.',
            WorkbooksLoadingTimeoutTitle: 'Please wait',
            WorkbooksLoadingTimeoutText: 'Contacting Power BI Q&A service...',
            UtteranceFeedbackTooltip: 'Help improve Q&A',
            UtteranceFeedbackDialogTitle: 'Q&A Feedback',
            UtteranceFeedbackDialogPrompt: 'Please rate how well Q&A helped find data to answer your question.',
            UtteranceFeedbackResultBad: 'Way Off',
            UtteranceFeedbackResultMedium: 'Got Close',
            UtteranceFeedbackResultGood: 'Great',
            PackageOperationBlocked: 'We can’t perform this operation right now because another delete or refresh is in progress. Try again later.',
            PackageRefreshUnknownFailure: 'There was an unknown error while refreshing your data.',
            DataRefreshBlocked: 'We cannot refresh your workbook right now. Try again after five minutes.',
            RefreshingData: 'Refreshing data',
            PreparingForRefresh: 'Preparing for refresh',
            TutorialPopup_GetStarted: 'Get started',
            TutorialPopup_GotIt: 'Got it',
            TutorialPopup_WelcomeButtonLabel: 'Get Data',
            TutorialPopup_WelcomeTitle: 'Welcome to Power BI',
            TutorialPopup_WelcomeText: 'You\'re on your way to exploring your data and monitoring what matters. \\n Let\'s start by getting some data.',
            TutorialPopup_WelcomeTutorialLinkText: 'View a Tutorial',
            TutorialPopup_WelcomeLearnMoreText: 'Want to learn more first?',
            TutorialPopup_FindContentTitle: 'Find your content',
            TutorialPopup_FindContentText: 'Notice that your new dashboards, reports and datasets show up in this pane. Click one to take a look.',
            TutorialPopup_ConnectDataTitle: 'Connect to your data',
            TutorialPopup_ConnectDataText: 'Start by connecting your own data to Power BI. Click Get Data and select your source.',
            TutorialPopup_PinVisualTitle: 'Pin to the dashboard',
            TutorialPopup_PinVisualText: 'Want to monitor this chart? Click this button to pin the chart to your dashboard so you can easily monitor it.',
            TutorialPopup_CreateFirstChartTitle: 'Create your first chart',
            TutorialPopup_CreateFirstChartText: 'Drag a field onto the screen to start building a new chart.',
            TutorialPopup_CustomizeChartTitle: 'Customize your chart',
            TutorialPopup_CustomizeChartText: 'Drag fields to or from these buckets to customize your chart.',
            Role_DisplayName_Axis: 'Axis',
            Role_DisplayName_Category: 'Category',
            Role_DisplayName_Color: 'Color',
            Role_DisplayName_Columns: 'Columns',
            Role_DisplayName_Details: 'Details',
            Role_DisplayName_Field: 'Field',
            Role_DisplayName_Fields: 'Fields',
            Role_DisplayName_Group: 'Group',
            Role_DisplayName_Latitude: 'Latitude',
            Role_DisplayName_Legend: 'Legend',
            Role_DisplayName_Location: 'Location',
            Role_DisplayName_Longitude: 'Longitude',
            Role_DisplayName_MaxValue: 'Maximum Value',
            Role_DisplayName_MinValue: 'Minimum Value',
            Role_DisplayName_Rows: 'Rows',
            Role_DisplayName_Series: 'Series',
            Role_DisplayName_Size: 'Size',
            Role_DisplayName_Slices: 'Slices',
            Role_DisplayName_TargetValue: 'Target Value',
            Role_DisplayName_Value: 'Value',
            Role_DisplayName_Values: 'Values',
            Role_DisplayName_X: 'X Axis',
            Role_DisplayName_Y: 'Y Axis',
            Role_DisplayName_Y2: 'Y2',
            Aggregate_Sum: 'Sum',
            Aggregate_Avg: 'Average',
            Aggregate_Min: 'Minimum',
            Aggregate_Max: 'Maximum',
            Aggregate_CountNonNull: 'Count',
            Aggregate_Count: 'Count (Distinct)',
            FieldWell_Remove: 'Remove Field',
            FieldWell_RemoveAggregate: 'Do Not Summarize',
            DisplayName_Sum: 'Sum of {0}',
            DisplayName_Avg: 'Average of {0}',
            DisplayName_Count: 'Count of {0}',
            DisplayName_Min: 'Min of {0}',
            DisplayName_Max: 'Max of {0}',
            DisplayName_CountNonNull: 'Count of {0}',
            TaskPane_Fields: 'Fields',
            TaskPane_Format: 'Format',
            VisualizationPane_Title: 'Visualizations',
            VisualizationPane_Filters: 'Filters',
            VisualizationPane_Section_Fields: 'Fields',
            VisualizationPane_Section_Format: 'Format',
            VisualizationPane_Watermark: 'Drag data fields here',
            AnalysisServerContentProvider_Title: 'SQL Server Analysis Services Servers in your organization',
            AnalysisServerContentProvider_Description: 'With Power BI, you can create dynamic reports and mashups with data and metrics you already have in your on-premises SQL Server Analysis Services solutions. To get started, click Connect, select a server, then select a data model.',
            AnalysisServerContentProvider_SupportedObjectsHeading: 'Supported Analysis Services Servers: ',
            AnalysisServerContentProvider_Landing_Supported_1: 'SQL Server 2012 and later Analysis Services Tabular models',
            AnalysisServerContentProvider_Landing_More_1: 'More about',
            AnalysisServerContentProvider_Landing_More_2: ' connecting to Analysis Services data',
            AnalysisServerContentProvider_ConnectButtonText: 'Connect',
            AnalysisServer_ResourceName: 'Name',
            AnalysisServer_ResourceDescription: 'Description',
            AnalysisServer_ServerName: 'Server Name',
            AnalysisServer_PublishedBy: 'Published By',
            AnalysisServer_PublishedDate: 'Published Date',
            AnalysisServer_DatabaseName: 'Name',
            AnalysisServer_DatabaseType: 'Type',
            AnalysisServer_ResourceDatabaseType_Model: 'Model',
            AnalysisServer_ResourceDatabaseType_Perspective: 'Perspective',
            AnalysisServer_Loading: 'Loading...',
            AnalysisServer_LoadResourcesFailed: 'Could not load list of resources.',
            AnalysisServer_LoadDatabasesFailed: 'Could not load list of databases.',
            AnalysisServer_ResourcesEmpty: 'No resources found.',
            AnalysisServer_DatabasesEmpty: 'No databases found.',
            LearnMore_Title: 'Learn to add your own data',
            LearnMore_Designer_Title: 'Excel + Power BI Designer',
            LearnMore_Designer_Description: 'Is Excel your go-to tool for working with data? Leverage your Excel expertise and investments by uploading your Excel workbooks to Power BI. Don\'t have the latest version of Excel? Download the optional, dedicated Power BI Designer to begin building your reports for Power BI.',
            LearnMore_Excel1: 'More about',
            LearnMore_Excel2: ' Excel 2013',
            LearnMore_PowerBI_Designer1: 'More about',
            LearnMore_PowerBI_Designer2: ' Power BI Designer',
            LearnMore_OrganizationalData_Title: 'Organizational Data',
            LearnMore_OrganizationalData_Description: 'Are you looking for your organization\'s data? With Power BI you can securely and easily connect to a wide range of data sources like SQL Server and SQL Server Analysis Services tabular models, both on premises and in the cloud.',
            LearnMore_OrganizationalData_Link1: 'More about',
            LearnMore_OrganizationalData_Link2: ' Organizational Data',
            LearnMore_DataAnywhere_Title: 'Data From Anywhere',
            LearnMore_DataAnywhere_Description: 'Are you a developer? Do you want to partner with us to extend Power BI to your data source? Use our developer APIs and tools to connect to your data sources with Power BI.',
            LearnMore_PowerBI_Developer_Center: 'Power BI Developer Center',
            LearnMore_DataAnywhere_Link1: 'More about',
            LearnMore_DataAnywhere_Link2: ' Data From Anywhere',
            AnalysisServer_CustomErrorTechnicalDetails: 'Technical details:',
            AnalysisServer_CustomErrorTechnicalDetails_ActivityId: 'Activity Id: {0}',
            AnalysisServer_CustomErrorTechnicalDetails_RequestId: 'Request Id: {0}',
            AnalysisServer_CustomErrorTechnicalDetails_Date: 'Date: {0}',
            AnalysisServer_CustomErrorTechnicalDetails_ErrorText: 'Error Text: {0}',
            AnalysisServer_CustomErrorTechnicalDetails_ClusterUriText: 'Cluster URI: {0}',
            CollapsibleSectionControl_Title_More: 'More',
            CollapsibleSectionControl_Title_Less: 'Less',
            PinTile_SaveReportFirstDialog_CancelButtonText: 'Cancel',
            PinTile_SaveReportFirstDialog_Message: 'We\'ll need to point this tile to a report that has been saved at least once so it exists in our system.',
            PinTile_SaveReportFirstDialog_SaveButtonText: 'Save, then pin',
            PinTile_SaveReportFirstDialog_Title: 'Please save before pinning',
            Tile_LoseReportConnection: 'Looks like the report no longer exists.',
            OAuth_Security_Error: 'You need to use SSL (HTTPS) when you use OAuth 2.0 authentication.',
            ErrorDescription_StillSettingUpAccount: 'We are still setting up your account. Please refresh the page in a few minutes. If this persists, please {0}contact us{1}.',
            ErrorTitle_StillSettingUpAccount: 'Almost there',
            FieldListMenuItem_AddFilter: 'Add Filter',
            FieldListMenuItem_Rename: 'Rename',
            FieldListMenuItem_Delete: 'Delete',
            FieldListMenuItem_Hide: 'Hide',
            FieldListMenuItem_ViewHidden: 'View Hidden',
            FieldListMenuItem_UnHideAll: 'Unhide All',
            Field_Tooltip: '\'{0}\'[{1}]',
            AdvancedFilter_ApplyFilter: 'Apply Filter',
            AdvancedFilter_Description: 'Show items when the value:',
            FilterOperator_Is: 'is',
            FilterOperator_GreaterThan: 'is greater than',
            FilterOperator_GreaterThanOrEqual: 'is greater than or equal to',
            FilterOperator_LessThan: 'is less than',
            FilterOperator_LessThanOrEqual: 'is less than or equal to',
            FilterOperator_IsNot: 'is not',
            Logical_And_Operator: 'And',
            Logical_Or_Operator: 'Or',
            FilterPane_Page: 'Page Level Filters',
            FilterPane_Visual: 'Visual Level Filters',
            FilterPane_Advanced: 'Advanced Filtering',
            TileEditor_DeleteTile: 'Delete Tile',
            QueryFailed: 'Query Failed',
            VisualContainer_UnableToFindVisualKey: 'Visual not supported.',
            NavigationPane_DashboardsTitle: 'Dashboards',
            NavigationPane_DatasetsTitle: 'Datasets',
            NavigationPane_ReportsTitle: 'Reports',
            PowerBI_Landing_Title: 'Power BI',
            ShareView_ShareButtonText: 'Share',
            ShareView_ShareDashboard: 'Share Dashboard',
            ExplorationContainer_FailedToLoadReport: 'Unable to load report',
            ExplorationContainer_FailedToLoadReport_DefaultDetails: 'The requested report failed to load',
            FilterRestatement_All: '(All)',
            FilterRestatement_CompoundAnd: '{0} and {1}',
            FilterRestatement_CompoundOr: '{0} or {1}',
            FilterRestatement_Equal: 'is {0}',
            FilterRestatement_GreaterThan: 'is greater than {0}',
            FilterRestatement_GreaterThan_DT: 'is after {0}',
            FilterRestatement_GreaterThanOrEqual: 'is greater than or equal to {0}',
            FilterRestatement_GreaterThanOrEqual_DT: 'is on or after {0}',
            FilterRestatement_LessThan: 'is less than {0}',
            FilterRestatement_LessThan_DT: 'is before {0}',
            FilterRestatement_LessThanOrEqual: 'is less than or equal to {0}',
            FilterRestatement_LessThanOrEqual_DT: 'is on or before {0}',
            FilterRestatement_NotEqual: 'is not {0}',
            FilterOperator_Contains: 'contains',
            FilterOperator_DoesNotContain: 'does not contain',
            FilterOperator_DoesNotStartWith: 'does not start with',
            FilterOperator_GreaterThanOrEqual_DT: 'is on or after',
            FilterOperator_GreaterThan_DT: 'is after',
            FilterOperator_IsBlank: 'is blank',
            FilterOperator_IsNotBlank: 'is not blank',
            FilterOperator_LessThanOrEqual_DT: 'is on or before',
            FilterOperator_LessThan_DT: 'is before',
            FilterOperator_StartsWith: 'starts with',
            FilterRestatement_Contains: 'contains \'{0}\'',
            FilterRestatement_DoesNotContain: 'does not contain \'{0}\'',
            FilterRestatement_DoesNotStartWith: 'does not start with \'{0}\'',
            FilterRestatement_StartWith: 'starts with \'{0}\'',
            ErrorDialogOption_FailedToStorePackageExcel: 'Learn how to solve this problem',
            ExternalContentViewer_Search: 'Search',
            FilterPane_ClearFilter: 'Clear filter',
            FilterPane_DeleteFilter: 'Delete filter',
            ExplorationContainer_FailedToSaveReport: 'Unable to save the report',
            ExplorationContainer_FailedToSaveReportDefaultDetails: 'The server failed to save the report',
            MobileLandingPage_ContinueToPbiCom: 'continue to powerbi.com',
            MobileLandingPage_DownloadApp: 'Download the app',
            MobileLandingPage_SubTitle: 'Bring your data to life',
            MobileLandingPage_Title: 'Power BI',
            DataSourceSupport_LearnMore: 'Learn More',
            DataSourceSupport_LearnMoreMessage: 'about data sources that currently support refresh.',
            OnPremises_Admin_Error: 'Power BI can\'t connect to the On-Premises Analysis Services Server {0}. The administrator of the server provided the following message : {1}.',
            ServerError_OnPremises_Admin_Error: 'Power BI can\'t connect to the On-Premises Analysis Services Server {resourceName}. The administrator of the server provided the following message : {adminMessage}.',
            ServerError_HRESULT_0x82040136: 'SQL Server Analysis Services Connector appears to be offline(error code: 0x82040136). Please contact your Server Administrator.',
            ServerError_HRESULT_0x82070BC4: 'SQL Server Analysis Services Connector appears to be offline(error code: 0x82070BC4). Please contact your Server Administrator.',
            ServerError_HRESULT_0x82031772: 'SQL Server Analysis Services Connector is unable to connect to the Analysis Server. Please make sure that the password in the Connector is up to date and the Analysis Server is running.',
            FilterRestatement_Comma: '{0}, {1}',
            QnAVisualization_EmptyResultTitleText: 'Sorry, I wasn\'t able to find a good answer.',
            Visualization_NoData: 'This result returned no data.',
            SettingsDataset_DisableEntireRefreshPageErrorMessage_OnPremAnalysisServicesScheduleInfo: 'This dataset connects to a SQL Server Analysis Services Tabular database & is always up-to-date. You do not have to schedule a refresh on this dataset.',
            SettingsDataset_DisableEntireRefreshPageErrorMessage_SalesforceScheduleRefreshInfo: 'Your Salesforce dataset is updated daily. You do not need to schedule a periodic refresh for this dataset.',
            ExplorationContainer_FailedToLoadModel: 'Unable to Load the Model',
            ExplorationContainer_FailedToLoadModel_DefaultDetails: 'Unable to retrieve the model information at this time',
            Dataset_Mashup_Desc_DynamicsCRM_0: 'Dynamics CRM OData Service URL',
            Dataset_Mashup_Desc_DynamicsMarketing_0: 'Dynamics Marketing OData Service URL (case sensitive)',
            Dataset_Mashup_Desc_GitHub_0: 'Owner or organization of the GitHub repository',
            Dataset_Mashup_Desc_GitHub_1: 'GitHub repository name',
            Dataset_Mashup_Desc_GoogleAnalytics_0: 'Account Name (case sensitive) configured for your Google Analytics account',
            Dataset_Mashup_Desc_GoogleAnalytics_1: 'Property Name (case sensitive)',
            Dataset_Mashup_Desc_GoogleAnalytics_2: 'View Name (case sensitive)',
            Dataset_Mashup_Desc_Zendesk_0: 'Enter the web address for your account',
            Dataset_Mashup_Name_DynamicsCRM_0: 'Service URL',
            Dataset_Mashup_Name_DynamicsMarketing_0: 'Service URL',
            Dataset_Mashup_Name_GitHub_0: 'Repository Owner',
            Dataset_Mashup_Name_GitHub_1: 'Repository',
            Dataset_Mashup_Name_GoogleAnalytics_0: 'Account',
            Dataset_Mashup_Name_GoogleAnalytics_1: 'Property',
            Dataset_Mashup_Name_GoogleAnalytics_2: 'View',
            Dataset_Mashup_Name_Zendesk_0: 'Zendesk URL',
            ServerError_HRESULT_0x82030FA4: 'User name and password provided to the SQL Server Analysis Services Connector is no longer correct.',
            ServerError_HRESULT_0x82031774: 'SQL Server Analysis Services Connector is unable to connect to the Analysis Server instance. Please make sure the Analysis Server instance is up and running.',
            ServerError_OnPremisesNoConnectorError: 'Power BI service requires SQL Server Analysis Services Connector installed on-premises in order to be able to access the server {resourceName}.',
            ServerError_OnPremisesTechnicalDetailsOpenConnectionError: 'Power BI service is unable to connect to SQL Server Analysis Services Connector. Please make sure the Connector is up and running.',
            ServerError_OnPremisesTechnicalDetailsConnectorError: 'Connector Error Message',
            ServerError_OnPremisesTechnicalDetailsConnectorErrorCode: 'Connector Error Code',
            ServerError_OnPremisesTechnicalDetailsDataSourceError: 'Analysis Services Error',
            PBIDesigner_ContentProvider_LandingTitle: 'Power BI Designer',
            DatasetParametersDialog_HelpMessage: 'Need help entering this information? ',
            DatasetParametersDialog_LearnMore: 'Learn More',
            ErrorDialogOption_FailedToStorePackage: 'Learn More',
            ErrorMessage_FailedToStorePackage: 'Make sure you\'re entering the information correctly.',
            SR_GatewayOffline_Details: 'Ensure that the computer on which the gateway is installed is turned on and the gateway is running',
            SR_GatewayOffline_Heading: '! {0} failed to refresh. Your gateway on {1} is offline or can not be reached.',
            SR_Failure_Subject: 'Refresh failed: {0} has failed to refresh',
            SR_Failure_DebugClusterName: 'Cluster Name: {0}',
            SR_Failure_DebugCorrelationId: 'Correlation ID: {0}',
            SR_Failure_DebugStartTimeStamp: 'Refresh Start Time: {0}',
            SR_Failure_NextRefreshTime: 'Next refresh for {0} is scheduled for {1}.',
            SR_Failure_DebugEndTimeStamp: 'Refresh End Time: {0}',
            Explore_Section_Page: 'Page {0}',
            MashUpContentProvider_Sample_Origin: 'This sample is part of a series that illustrates how you can use Power BI with business-oriented data, reports, and dashboards. This is real data from Obvience (',
            MashUpContentProvider_Sample_OriginSuffix: ') that has been anonymized.',
            MashUpContentProvider_SupplierQualityAnalysisSample_Description1: 'This industry sample dashboard and underlying report focus on one of the typical supply chain challenges — supplier quality analysis. Two primary metrics are at play in this analysis: total number of defects and the total downtime that these defects caused. This sample has two main objectives:',
            MashUpContentProvider_SupplierQualityAnalysisSample_Description2: 'Understand who the best and worst suppliers are, with respect to quality.',
            MashUpContentProvider_SupplierQualityAnalysisSample_Description3: 'Identify which plants do a better job finding and rejecting defects, to minimize downtime.',
            MashUpContentProvider_SupplierQualityAnalysisSample_Title: 'Supplier Quality Analysis Sample',
            MashUpContentProvider_CustomerProfitabilitySample_Description1: 'This industry sample dashboard and underlying report analyze a company that manufactures marketing materials.  This dashboard was created by a CFO to see key metrics about her 5 business unit managers (aka executives), products, customers, and gross margins (GM). At a glance she can see what factors are impacting profitability.',
            MashUpContentProvider_HumanResourcesSample_Description1: 'This industry sample dashboard and underlying report analyze HR information. The HR department has the same reporting model across different companies, even when they differ by industry or size. This sample looks at new hires, active employees, and employees who left and tries to uncover any trends in the hiring strategy. Our main objectives are to understand:',
            MashUpContentProvider_HumanResourcesSample_Description2: 'Who we hire.',
            MashUpContentProvider_HumanResourcesSample_Description3: 'Biases in our hiring strategy.',
            MashUpContentProvider_HumanResourcesSample_Description4: 'Trends in voluntary separations.',
            MashUpContentProvider_ITSpendAnalysisSampleSample_Description1: 'This industry sample dashboard and underlying report analyze the planned vs. actual costs of the IT department of a company. This comparison helps us understand how well the company planned for the year and allows us to investigate areas with huge deviations from the plan. The company in this example goes through a yearly planning cycle, and then quarterly it produces a new Latest Estimate (LE) to help analyze changes in IT spend over the fiscal year.',
            MashUpContentProvider_OpportunityTrackingSample_Description1: 'This industry sample dashboard and underlying report analyze a software company that has 2 sales channels: direct and partner.  The Sales Manager created this dashboard to track opportunities and revenue by region, deal size, and channel. The Sales Manager relies on 2 measures of revenue:',
            MashUpContentProvider_OpportunityTrackingSample_Description2: 'Revenue – this is a salesperson’s estimate of what the company’s revenue will be.',
            MashUpContentProvider_OpportunityTrackingSample_Description3: 'Factored Revenue – this is calculated as Revenue X Probability % and is generally accepted as being a more-accurate predictor of actual sales revenue.  Probability is determined by the deal’s current Sales Stage.',
            MashUpContentProvider_ProcurementAnalysisSample_Description1: 'This industry sample dashboard and underlying report analyze a manufacturing company’s spending on vendors by category and location, and lets us explore the following areas:',
            MashUpContentProvider_ProcurementAnalysisSample_Description2: 'Who the top vendors are',
            MashUpContentProvider_ProcurementAnalysisSample_Description3: 'What categories we spend most on',
            MashUpContentProvider_ProcurementAnalysisSample_Description4: 'Which vendors give us the highest discount and when',
            MashUpContentProvider_SalesAndMarketingSample_Description1: 'This industry sample dashboard and underlying report analyze a manufacturing company named VanArsdel Ltd.  This dashboard was created by the VanArsdel Chief Marketing Officer (CMO) to keep an eye on the industry and his company’s market share, product volume, sales, and sentiment.',
            FeedbackTicket_Message: 'Microsoft uses third-party services to deliver a great feedback experience. By clicking Next, you agree to the {{startLink}} UserVoice Terms of Service and Privacy Policy {{endLink}} and Microsoft will contact you by email associated with your organizational account',
            PowerBI_Build_Version_Text: 'Version',
            PowerBI_Copyright_Text: 'Microsoft Corporation {{year}}. All rights reserved.',
            SupportTicket_Message: 'Microsoft uses third-party services to deliver a great support experience. By clicking Next, you agree to the {{startLink}} UserVoice Terms of Service and Privacy Policy {{endLink}} and Microsoft will contact you by email associated with your organizational account',
            Sort_SortBy: 'Sort By',
            Remove_visual: 'Remove',
            VisualTitle_By_Template: '{0} by {1}',
            VisualTitle_And_Template: '{0} and {1}',
            BarChart_ToolTip: 'Bar Chart',
            Card_ToolTip: 'Card',
            ClusteredBarChart_ToolTip: 'Clustered Bar Chart',
            ClusteredColumnChart_ToolTip: 'Clustered Column Chart',
            ColumnChart_ToolTip: 'Column Chart',
            Funnel_ToolTip: 'Funnel',
            Gauge_ToolTip: 'Gauge',
            HundredPercentStackedBarChart_ToolTip: '100% Stacked Bar Chart',
            HundredPercentStackedColumnChart_ToolTip: '100% Stacked Column Chart',
            LineChart_ToolTip: 'Line Chart',
            Map_ToolTip: 'Map',
            Matrix_ToolTip: 'Matrix',
            MultiRowCard_ToolTip: 'Multi Row Card',
            PieChart_ToolTip: 'Pie Chart',
            ScatterChart_ToolTip: 'Scatter Chart',
            Table_ToolTip: 'Table',
            Treemap_ToolTip: 'Treemap',
            Delete_ToolTip: 'Delete',
            Remove_ToolTip: 'Remove Visual',
            PinVisual_ToolTip: 'Pin Visual',
            ShowConversionOptions_ToolTip: 'Show Conversion Options',
            Sort_ToolTip: 'Sort',
            NavigationPane_GroupsTitle_HasGroups: 'GROUPS',
            NavigationPane_CreateGroup: 'Create Group',
            NavigationPane_NoGroupText: 'You have no groups',
            Waterfall_TotalLabel: 'Total',
            Visual_DataPoint: 'Data Points Colors',
            GeotaggingString_Address: 'Address',
            GeotaggingString_Addresses: 'Addresses',
            GeotaggingString_Cities: 'Cities',
            GeotaggingString_City: 'City',
            GeotaggingString_Code: 'Code',
            GeotaggingString_Continent: 'Continent',
            GeotaggingString_Continents: 'Continents',
            GeotaggingString_Counties: 'Counties',
            GeotaggingString_Countries: 'Countries',
            GeotaggingString_Country: 'Country',
            GeotaggingString_County: 'County',
            GeotaggingString_Latitude: 'Latitude',
            GeotaggingString_Longitude: 'Longitude',
            GeotaggingString_Place: 'Place',
            GeotaggingString_Places: 'Places',
            GeotaggingString_Post: 'Post',
            GeotaggingString_Province: 'Province',
            GeotaggingString_Provinces: 'Provinces',
            GeotaggingString_State: 'State',
            GeotaggingString_States: 'States',
            GeotaggingString_Street: 'Street',
            GeotaggingString_Streets: 'Streets',
            GeotaggingString_Town: 'Town',
            GeotaggingString_Towns: 'Towns',
            GeotaggingString_Village: 'Village',
            GeotaggingString_Villages: 'Villages',
            GeotaggingString_Zip: 'Zip',
            GeotaggingString_Latitude_Short: 'Lat',
            GeotaggingString_Longitude_Short: 'Lon',
            GeotaggingString_PostalCode: 'Postal Code',
            GeotaggingString_PostalCodes: 'Postal Codes',
            GeotaggingString_ZipCode: 'Zip Code',
            GeotaggingString_ZipCodes: 'Zip Codes',
            GeotaggingString_Territories: 'Territories',
            GeotaggingString_Territory: 'Territory',
            Visual_Legend: 'Legend',
            Visual_CategoryAxis: 'Category Axis',
            Visual_CategoryAxis_Scalar: 'Scalar Axis',
            Visual_Fill: 'Fill',
            Visual_LegendPosition: 'Legend Position',
            Visual_Show: 'Show',
            NavigationPane_Groups_MyWorkspace: 'My Workspace',
            NavigationPane_GroupIconTitle: 'Group',
            Landing_DefaultReportName: 'Untitled',
            Slicer_ToolTip: 'Slicer',
            WaterfallChart_ToolTip: 'Waterfall Chart',
            SqlAzureDbContentProvider_DatabaseName: 'Database:',
            SqlAzureDbContentProvider_Description1: 'Azure SQL Database is a fully managed relational database-as-a-service that makes tier-1 capabilities easily accessible. SQL Database supports massive scale-out, predictable performance, flexible manageability and includes built-in high availability and self-management for near-zero maintenance.',
            SqlAzureDbContentProvider_Description2: 'With Power BI, you can create dynamic reports, mashups with data and metrics you already have in your Azure SQL Database. To get started, we need some information to connect to your database.',
            SqlAzureDbContentProvider_Description3: 'NOTE: To allow Power BI to connect to your Azure SQL Database, please make sure firewall rules for the database are configured to "Allow access to Azure services".',
            SqlAzureDbContentProvider_Description4: 'More about',
            SqlAzureDbContentProvider_Error1: 'Please enter Server.',
            SqlAzureDbContentProvider_Error2: 'Please enter Database.',
            SqlAzureDbContentProvider_Error3: 'Please enter User.',
            SqlAzureDbContentProvider_Error4: 'Please enter Password.',
            SqlAzureDbContentProvider_Landing_ConnectButton: 'Connect',
            SqlAzureDbContentProvider_Password: 'Password:',
            SqlAzureDbContentProvider_ServerName: 'Server:',
            SqlAzureDbContentProvider_Title: 'Azure SQL Database',
            SqlAzureDbContentProvider_UserName: 'User:',
            SqlAzurePdwContentProvider_DatabaseName: 'Database:',
            SqlAzurePdwContentProvider_Description1: 'Drive immediate insight from all of your data using the elastic scale SQL Data Warehouse with Direct Connect. Seamlessly combine a petabyte or more of relational data with non-relational Hadoop data using Polybase for a full view of your data. To get started, simply click Connect.',
            SqlAzurePdwContentProvider_Description3: 'More about',
            SqlAzurePdwContentProvider_Description2: 'With Power BI, you can create dynamic reports, mashups with data and metrics you already have in your Azure SQL Data Warehouse. To get started, we need some information to connect to your database.',
            SqlAzurePdwContentProvider_Error1: 'Please enter Server.',
            SqlAzurePdwContentProvider_Error2: 'Please enter Database.',
            SqlAzurePdwContentProvider_Error3: 'Please enter User.',
            SqlAzurePdwContentProvider_Error4: 'Please enter Password.',
            SqlAzurePdwContentProvider_Password: 'Password:',
            SqlAzurePdwContentProvider_ServerName: 'Server:',
            SqlAzurePdwContentProvider_Title: 'Azure SQL Data Warehouse',
            SqlAzurePdwContentProvider_UserName: 'User:',
            SqlAzurePdwontentProvider_Landing_ConnectButton: 'Connect',
            ComboChart_ToolTip: 'Combo Chart',
            Role_ComboChart_Category: 'Shared Axis',
            Role_ComboChart_Series: 'Column Series',
            Role_ComboChart_Y: 'Column Values',
            Role_ComboChart_Y2: 'Line Values',
            Dataset_Mashup_Desc_Marketo_0: 'Marketo REST API endpoint',
            Dataset_Mashup_Name_Marketo_0: 'Endpoint',
            TopNav_Download: 'Download',
            TopNav_Feedback: 'Feedback',
            TopNav_Help: 'Help & Support',
            Tooltip_HighlightedValueDisplayName: 'Highlighted',
            ReportAppBar_SwitchModeButton: 'PRESENTATION MODE',
            SqlAzureDbContentProvider_Description5: 'direct connect with Azure SQL Database',
            SqlAzurePdwContentProvider_Description4: 'direct connect with Azure SQL Data Warehouse',
            MashupContentProvider_SQLDBAuditing_More2: ' connecting to SQL Database Auditing data',
            MashupContentProvider_Moreabout: 'More about',
            MashUpContentProvider_SQLDBAuditing_Description1: 'Azure SQL Database Auditing',
            MashUpContentProvider_SQLDBAuditing_Description2: ' tracks database events and writes audited events to an audit log in your Azure Storage account. Auditing is generally available for Basic, Standard, and Premium service tiers.',
            MashUpContentProvider_SQLDBAuditing_Description3: 'This content pack can help maintain regulatory compliance, understand database activity, and gain insight into discrepancies and anomalies that could indicate business concerns or suspected security violations.',
            MashUpContentProvider_SQLDBAuditing_Description4: 'The content pack imports data from all tables that contain “AuditLogs” in their name and append it to a single data model table named “AuditLogs”.',
            MashUpContentProvider_Twilio_Description1: 'Visualize data from your Twilio account directly in Power BI. Connect using your Twilio credentials and immediately gain insights from your Twilio usage, such as your calls and messages over time, your most active Twilio phone numbers, amount of messages and calls sent and received and many more. A full dashboard will be created for you to monitor your data as well as a rich report to further explore your data.',
            MashUpContentProvider_Twilio_More2: ' connecting to Twilio data',
            Publish_ChooseContentPackAccess: 'Choose who will have access to this content pack:',
            Publish_ContentPack: 'Publish Content Packs',
            Publish_ContentPackCancelButton: 'Cancel',
            Publish_ContentPackName: 'Name',
            Publish_ContentPackPublishButton: 'Publish',
            Publish_ContentPackPublishedTo: 'Published To',
            Publish_CreateContentPack: 'Create Content Pack',
            Publish_DataAccessNotification: 'The content pack will be available in your organization\'s content gallery.',
            Publish_DataAccessNotificationLink: 'Learn more',
            Publish_DeleteContentPack: 'Delete',
            Publish_Description: 'Description',
            Publish_EditContentPack: 'Edit',
            Publish_Group: 'Specific Groups',
            Publish_Organization: 'My Entire Organization',
            Publish_Title: 'Title',
            Publish_ViewContentPack: 'View Content Packs',
            TopNav_SettingsMenu_CreateContentPack: 'Create Content Pack',
            Publish_DescriptionText: 'This is the People View content pack created for anyone in the company and get business insights. If you need help, contact hrbisupport.com.',
            Publish_EnterTitleText: 'People View',
            Publish_Dashboards: 'Dashboards',
            TopNav_Settings: 'Settings',
            Publish_Datasets: 'Datasets',
            Publish_ImageText: 'Image:',
            Publish_ItemsToPublish: 'Select items to publish',
            Publish_Reports: 'Reports',
            Publish_UpdateContentPackInfo: 'You\'ve made changes to a dashboard or report from this content pack that\'s published to \'My Entire Organization\'. In order for others to see your changes, click here to update',
            Publish_UploadImage: 'Upload',
            Publish_UploadText: 'an image or company logo',
            Publish_UseDefaultImage: 'Use Default',
            Publish_GroupsText: 'Enter group names separated by ; or ,',
            GroupNavigationPaneContextMenuItem_Calendar: 'Calendar',
            GroupNavigationPaneContextMenuItem_Conversations: 'Conversations',
            GroupNavigationPaneContextMenuItem_EditGroup: 'Edit Group',
            GroupNavigationPaneContextMenuItem_Files: 'Files',
            GroupNavigationPaneContextMenuItem_LeaveGroup: 'Leave Group',
            GroupNavigationPaneContextMenuItem_Members: 'Members',
            GroupNavigationPaneContextMenuItem_Notebook: 'Notebook',
            GroupNavigationPaneContextMenuItem_Subscribe: 'Subscribe',
            Groups_LessButtonText: 'Less',
            Groups_MoreButtonText: 'More',
            NotificationMessage_ImportingPackage_AdditionalMessage: 'This could take a little while.',
            GetData_Connect: 'Connect',
            GetData_SelectAFileFromYourOneDrivePersonalAccount: 'Select a file from your OneDrive Personal account',
            GetData_SignInToYourOneDrivePersonalAccount: 'Sign in to your OneDrive personal account',
            GetData_Cancel: 'Cancel',
            GetData_Uploading: 'Uploading',
            GetData_SalesforceEmbeddedConfigurationDescription: 'Get the most from your Salesforce data by letting Power BI build a custom dashboard. You also have the option to import your Salesforce reports.',
            GetData_SelectADashboardBasedOnYourRoleInYourOrganization: 'Select a dashboard based on your role in your organization.',
            GetData_SelectYourSalesforceData: 'Select Your Salesforce Data',
            GetData_SignInToYourSalesforceAccount: 'Sign in to your Salesforce account',
            GetData_ConnectTo: 'Connect to',
            GetData_DataInPowerBIFollowThePromptsBelow: 'data in Power BI, follow the prompts below.',
            GetData_LearnMore: 'Learn More',
            GetDataSeeMoreOptions: 'See more options.',
            GetData_LearnToAddTileCategoryDescription: 'Select your role within your organization to learn more about getting your data into Power BI.',
            GetData_ToStartUsingYour: 'To start using your',
            MashUpContentProvider_AppFigures_Description1: 'Connect and explore your appFigures data in Power BI. The out of box dashboard allows you to monitor and explore data about all your apps in a single place. For each app you can track the number of downloads, including how they’re being rated and which countries are using your app. You can also track in-app purchases and ad clicks, to fully understand the revenue from your apps.',
            MashUpContentProvider_AppFigures_More2: ' connecting to appFigures data',
            GetData_ChooseDataSource: 'Choose a Data Source',
            GetData_ConnectYourData: 'Connect Your Data',
            GetData_Dashboard: 'Dashboard',
            GetData_Files: 'Files',
            GetData_FilesDesc: 'Import data from Excel workbooks or Power BI Designer files.',
            GetData_Get: 'Get',
            GetData_HelpfulLinks: 'Explore other options:',
            GetData_AddYourContent: 'Add Your Content',
            GetData_MyOrganization: 'My Organization',
            GetData_Or: 'or',
            GetData_Samples: 'Samples',
            GetData_Services: 'Services',
            GetData_ServicesDesc: 'Connect to online services you use and we’ll create dashboards and reports for you.',
            GetData_ViewTutorial: 'Tutorial',
            GetData_WelcomeDescLine1: 'You’re on your way to exploring your data and monitoring what matters.',
            GetData_WelcomeDescLine2: 'Let\'s start by getting some data.',
            GetData_WelcomeTitle: 'Welcome to Power BI',
            GetData_MyOrganizationDesc: 'Get content that other people in your organization have published.',
            GetData_ConnectData: 'Connect your data',
            GetData_NeedHelpConnecting: 'Need help connecting?',
            GetData_BigDataAndMore: 'Databases & More',
            GetData_LearnToAddData: 'Learn to Add Data',
            GetData_SubmitAnIdea: 'Submit an Idea',
            GetData_DontSeeWhatYoureLookingFor: 'Don\'t see what you\'re looking for?',
            GetData_ConnectToPartner: 'Connect to a partner',
            GetData_ConnectToPartnerBlurb: 'Don’t see the data you care most about in Power BI? We have a global network of Power BI partners ready to help. ',
            GetData_MyWorkspace: 'My Workspace',
            GetData_GetData: 'Get Data',
            GetData_MsftDigitalCrimesUnit: 'The Digital Crimes Unit is an international legal and technical team working with partners, to help create a safe digital world. The DCU operates in conjunction with Internet Service Providers and Computer Emergency Response Teams to disrupt botnets from cybercriminals. These botnets can be involved in activities ranging from e-mail spam and click fraud to financial fraud and privacy invasion. This dashboard shows a summary of the calls that are made every day by devices still affected by several of the botnets that the Digital Crimes Unit has disrupted.',
            GetData_AzureSqlDatabaseWithLiveConnect: 'Azure SQL Database is a fully managed relational database-as-a-service that makes tier-1 capabilities easily accessible. SQL Database supports massive scale-out, predictable performance, flexible manageability and includes built-in high availability and self-management for near-zero maintenance. With Power BI, you can create dynamic reports, mashups with data and metrics you already have in your Azure SQL Database.',
            GetData_AzureSqlDatawarehouseLiveConnect: 'Gain immediate insights from your data using the elastic scale SQL Data Warehouse with direct connect. Seamlessly combine a petabyte or more of relational data with non-relational Hadoop data using Polybase for a full view of your data. To get started, simply click Connect.',
            GetData_BingNews: 'Track the latest news headlines on your dashboard with Bing News and stay up to date with news for the topics that matter most to you. Provide the search terms for topics you want to track and add a news tiles to the currently selected dashboard. Clicking on the listed news headlines opens the original articles so you can read further.',
            GetData_GitHub: 'Visualize different types of repository activity in Power BI by connecting to your GitHub data. With the GitHub content pack, you get a Power BI dashboard and reports with insights about how many commits, who contributes most, and at what time of day. Use the dashboard and reports as provided, or customize them to highlight the information you care about most.<br/><br/>The data in Power BI is updated daily from GitHub according to a schedule that you control.',
            GetData_GoogleAnalytics: 'Visualize data from your Google Analytics account directly in Power BI. Gain insights from the sites that you’re tracking, such as the site traffic over the last 30 days, or the days of the week when your site is most popular. The content pack includes data from the last 180 days. Use the reports that Power BI creates as is, or customize them for the metrics important to you.',
            GetData_HideDetails: 'Hide details.',
            GetData_Marketo: 'Bring rich marketing analytics directly into Power BI with the Marketo content pack. Your Marketo dashboards and reports in Power BI provide rich insights into your buyer profiles, marketing campaign success rates, email engagement, and more. Use the dashboard and reports as provided, or customize them to highlight the information you care about most.',
            GetData_MicrosoftDynamicsCrm: 'Connect to your Microsoft Dynamics CRM account for access to insights about your opportunities, accounts, and more. This content pack is designed specifically for sales managers, providing details on sales performance, pipeline, and activities. The dashboard and report are built on top of a fully featured model, so you can explore and analyze your data as you need.',
            GetData_MicrosoftDynamicsMarketing: 'With the Microsoft Dynamics Marketing content pack for Power BI, quickly build your marketing performance analytics. The content pack is designed specifically for marketing managers who focus on demand generation. Its components draw directly from your marketing database to provide reports on marketing contacts, lead pipeline, segment analysis, and more. Power BI automatically creates reports and dashboards that give you a great starting point for exploring and analyzing your marketing data.',
            GetData_MsftItNewTechnologyAdoption: 'This dashboard and report provides a glimpse into the complexity of adopting the latest technologies across more than 50k servers across the world, managed by IT to run the Application Portfolios that Microsoft employees use every day. These technologies span OnPrem, Azure (IaaS & PaaS), Cloud SaaS, Marketplaces, and modern UIs (across phones, tablets, and the browser). You can explore the data model and add your own analytic charts while you explore for insights. The data refreshes daily.',
            GetData_MsftPeopleView: 'People View provides a collection of data, reports and a dashboard around people at Microsoft, including such topics as Headcount, Average Directs and Anniversaries. From the dashboard, you can explore the underlying data model and add new interesting visuals while you gain deeper insights. The data refreshes daily.',
            GetData_MsftWindowsUservoice: 'This dashboard provides a quick and up-to-date view of the total users, suggestions and votes for both Windows and Windows Phone UserVoice.  It also lists the top categories, trends in suggestions, votes and comments, during any given period of time.  The data refreshes daily.  This is for internal Microsoft use only and cannot be shared outside of Microsoft without written approval from OSG. For more information, please contact winuservoice@microsoft.com.',
            GetData_QuickbooksOnline: 'Get insights into your business by connecting to QuickBooks Online with this Power BI content pack. With your QuickBooks Online admin credentials, Power BI automatically creates a dashboard with insights into your business cash flow, profitability, customers, and more. Use the default dashboard and reports, or customize them to highlight the information you care about most.',
            GetData_Salesforce: 'Import and analyze your Salesforce data in Power BI. After connecting to your Salesforce account, you import a variety of data to explore and monitor in your Power BI dashboards. Based on the persona you select, Power BI automatically creates a dashboard with customized visualizations of your data.',
            GetData_SeeDetails: 'See details.',
            GetData_Sendgrid: 'With the SendGrid content pack, monitor all your important email metrics in one dashboard using Power BI. Drill into detailed reports that you can customize as needed. With SendGrid advanced statistics enabled, monitor your most important metrics at a glance and measure user engagement for the emails you send.',
            GetData_SqlServerAnalysisServices: 'With Power BI, you can create dynamic reports and mashups with data and metrics you already have in your on-premises SQL Server Analysis Services solutions. To get started, click Connect, select a server, then select a data model.<br/><br/>Supported Analysis Services Servers:<br/>	- SQL Server 2012 and later Analysis Services Tabular models',
            GetData_VisualStudioOnline: 'Visualize your source code activity in Power BI by connecting to Microsoft Visual Studio Online. The Power BI content pack automatically creates a dashboard and report with at-a-glance views of Git, pull request, and version control activity across the projects you configure for your account.  You can customize the dashboard and report to highlight the deeper insights you care about most.<br/><br/>The data that appears in Power BI will be updated from Microsoft Visual Studio Online according to a schedule that you control.',
            GetData_Zendesk: 'Analyze your Zendesk data in Power BI with the Zendesk content pack. Connect with your Zendesk admin account credentials, and Power BI creates a dashboard with reports that provide insights about your ticket volumes and agent performance. Use the dashboard and reports provided, or customize them to highlight the information you care about most.',
            GetData_Appfigures: 'Connect and explore your appFigures data in Power BI. The appFigures content pack automatically creates a dashboard where you can monitor and explore data about all your apps in a single place. For each app you can track the number of downloads, including how they’re being rated and which countries are using your app. You can also track in-app purchases and ad clicks, to fully understand the revenue from your apps.',
            GetData_SqlDbAuditing: 'Azure SQL Database Auditing tracks database events and writes audited events to an audit log in your Azure Storage account. The Power BI content pack reports over the audit log data, and can help you maintain regulatory compliance and understand database activity. Gain insights into discrepancies and anomalies that could indicate business concerns or suspected security violations,  using the dashboard and reports that Power BI creates automatically.',
            GetData_Twilio: 'Visualize data from your Twilio account directly in Power BI. Connect using your Twilio credentials and immediately gain insights from your Twilio usage, such as your calls and messages over time, your most active Twilio phone numbers, amount of messages and calls sent and received and much more. The Power BI content pack creates a full dashboard for you to monitor your data, plus a rich report to explore your data further.',
            GetData_NoSearchResultsFound: 'No search results found.',
            GetData_CustomerProfitabilitySample: 'This industry sample dashboard and underlying report analyze a company that manufactures marketing materials. This dashboard was created by a CFO to see key metrics about her 5 business unit managers (aka executives), products, customers, and gross margins (GM). At a glance she can see what factors are impacting profitability. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_HumanResourcesSample: 'This industry sample dashboard and underlying report analyze HR information. The HR department has the same reporting model across different companies, even when they differ by industry or size. This sample looks at new hires, active employees, and employees who left and tries to uncover any trends in the hiring strategy. Our main objectives are to understand who we hire, biases in our hiring strategy, and trends in voluntary separations. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_ITSpendAnalysisSample: 'This industry sample dashboard and underlying report analyze the planned vs. actual costs of the IT department of a company. This comparison helps us understand how well the company planned for the year and allows us to investigate areas with huge deviations from the plan. The company in this example goes through a yearly planning cycle, and then quarterly it produces a new Latest Estimate (LE) to help analyze changes in IT spend over the fiscal year. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_OpportunityAnalysisSample: 'This industry sample dashboard and underlying report analyze a software company that has 2 sales channels: direct and partner. The Sales Manager created this dashboard to track opportunities and revenue by region, deal size, and channel. The Sales Manager relies on 2 measures of revenue, revenue and factored revenue. Revenue is a salesperson’s estimate of what the company’s revenue will be. Factored Revenue is calculated as Revenue X Probability % and is generally accepted as being a more-accurate predictor of actual sales revenue. Probability is determined by the deal’s current Sales Stage. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_ProcurementAnalysisSample: 'This industry sample dashboard and underlying report analyze a manufacturing company’s spending on vendors by category and location, and lets us explore the following areas: who the top vendors are, what categories we spend most on, which vendors give us the highest discount, and when those discounts occur. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_Retail_Analysis_Sample: 'This industry sample dashboard and underlying report analyzes retail sales data of items sold across multiple stores and districts. The metrics compare this year\'s performance to last year\'s in sales, units, gross margin, and variance, as well as new store analysis. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_SalesAndMarketingSample: 'This industry sample dashboard and underlying report analyze a manufacturing company named VanArsdel Ltd. This dashboard was created by the VanArsdel Chief Marketing Officer (CMO) to keep an eye on the industry and his company’s market share, product volume, sales, and sentiment. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            GetData_SupplierQualityAnalysisSample: 'This industry sample dashboard and underlying report focus on one of the typical supply chain challenges — supplier quality analysis. Two primary metrics are at play in this analysis: total number of defects and the total downtime that these defects caused. This sample has two main objectives. The first is to understand who the best and worst suppliers are, with respect to quality. The second is to identify which plants do a better job finding and rejecting defects, to minimize downtime. This is real data from obviEnce (www.obvience.com) that has been anonymized.',
            ToggleSwitchOff: 'Off',
            ToggleSwitchOn: 'On',
            NavigationPane_GroupsTitle_CreateGroup: 'CREATE A GROUP',
            Visual_DisplayUnits: 'Display Units',
            Visual_LabelsFill: 'Color',
            Visual_DataPointsLabels: 'Data Points Labels',
            Visual_Precision: 'Precision',
            Visual_Position: 'Position',
            Role_DisplayName_Gradient: 'Gradient',
            Visual_Gradient: 'Gradient',
            Visual_Axis_End: 'End',
            Visual_Axis_Intersection: 'Intersection',
            Visual_Axis_Start: 'Start',
            Visual_Axis_Style: 'Style',
            Visual_Axis_Title: 'Title',
            Visual_Axis_Type: 'Type',
            Visual_Axis_Scalar: 'Continuous',
            Visual_Axis_Categorical: 'Categorical',
            Visual_CategoryLabels: 'Category Labels',
            Visual_Axis_ShowBoth: 'Show Both',
            Visual_Axis_ShowTitleOnly: 'Show title only',
            Visual_Background: 'Background',
            Visual_Background_Color: 'Color',
            Visual_Background_Transparency: 'Transparency',
            Visual_DataPoint_Show_All: 'Show All',
            Visual_LegendShowTitle: 'Title',
            Visual_LegendTitleText: 'Text',
            Visual_RevertToDefault: 'Revert To Default',
            Visual_Title: 'Title',
            Visual_Title_Alignment: 'Alignment',
            Visual_Title_BackgroundColor: 'Background Color',
            Visual_Title_FontColor: 'Font Color',
            Visual_Title_Text: 'Text',
            Visual_XAxis: 'X-Axis',
            Visual_YAxis: 'Y-Axis',
            Visual_YAxis_ColumnTitle: 'Y-Axis (Column)',
            Visual_YAxis_LineTitle: 'Y-Axis (Line)',
            Visual_YAxis_Position: 'Position',
            Visual_YAxis_ShowSecondery: 'Show Secondery',
            ColorPicker_CustomColor: 'Custom color',
            ColorPicker_RecentColors: 'Recent Colors',
            ColorPicker_RevertToDefault: 'Revert to default',
            ColorPicker_ThemeColors: 'Theme Colors',
            ColorWheel_Cancel: 'Cancel',
            Publish_ContentPackActions: 'Actions',
            Publish_ContentPackDatePublished: 'Date Published',
            Publish_ViewContentPacks: 'View Content Packs',
            TopNav_SettingsMenu_ViewContentPack: 'View Content Pack',
            TaskPane_Toggle: 'Toggle Task Pane',
            VisualizationPane_Toggle: 'Toggle Visualization Pane',
            MashUpContentProvider_MailChimp_Description1: 'Use MailChimp’s analytics to quickly identify trends within your campaigns, reports, and individual subscribers. Find out who your most engaged subscribers are, which countries open the most campaigns, or how trends have changed over time. Power BI lets users drill down into their MailChimp data without any coding knowledge, and automatic data updates help you make the most informed decisions possible.',
            MashUpContentProvider_MailChimp_More2: ' connecting to MailChimp data',
            MashUpContentProvider_SQLSentry_Bullet1: 'Server Health',
            MashUpContentProvider_SQLSentry_Bullet2: 'Server Availability',
            MashUpContentProvider_SQLSentry_Bullet3: 'Disk Utilization',
            MashUpContentProvider_SQLSentry_Bullet4: 'CPU Utilization',
            MashUpContentProvider_SQLSentry_Bullet5: 'Memory Utilization',
            MashUpContentProvider_SQLSentry_Description1: 'Use Power BI to analyze and share performance and operational data collected by SQL Sentry. Get insights into the health of your SQL Server and Windows environment. This content pack includes powerful visualizations to help you to better evaluate and manage resources for several key areas, including:',
            MashUpContentProvider_SQLSentry_Description2: 'To use this dashboard, you must have SQL Sentry installed and monitoring at least one server, and cloud synchronization must be enabled.',
            MashUpContentProvider_SQLSentry_More2: ' connecting to SQL Sentry data to the cloud',
            QuotaManagement_FreeUser: 'Free User',
            QuotaManagement_ManageAccount: 'Manage Account',
            QuotaManagement_ModelAssociatedWith: 'Associated With',
            QuotaManagement_ModelLastRefreshedTime: 'Last Refreshed',
            QuotaManagement_ModelName: 'Name',
            QuotaManagement_ModelSize: 'Size',
            QuotaManagement_ModelType: 'Type',
            QuotaManagement_ModelType_Report: 'Report',
            QuotaManagement_ModelType_Dataset: 'Dataset',
            QuotaManagement_OwnedByMe: 'Owned By Me',
            QuotaManagement_OwnedByOthers: 'Owned By Others',
            QuotaManagement_OwnedByUs: 'Owned By Us',
            QuotaManagement_PaidUser: 'Paid User',
            QuotaManagement_UpgradeAccount: 'Upgrade Account',
            QuotaManagement_ManageStorage: 'Manage Storage',
            QuotaManagement_ManagePersonalStorage: 'Manage Personal Storage',
            QuotaManagement_ManageGroupStorage: 'Manage Group Storage',
            QuotaManagement_AssociatedDashboards: 'Associated Dashboards',
            QuotaManagement_AssociatedReports: 'Associated Reports',
            QuotaManagement_AssociatedWorkbooks: 'Associated Workbooks',
            QuotaManagement_DeleteButtonText: 'Delete',
            QuotaManagement_DeleteConfirmationTitle: 'Delete Item',
            QuotaManagement_DeleteConfirmationMessage: 'Are you sure you want to delete this item? This action may affect some of your dashboards and reports, and anyone with whom those dashboards and reports are shared.',
            QuotaManagement_RemoveConfirmationTitle: 'Remove Item',
            QuotaManagement_RemoveConfirmationMessage: 'Are you sure you want to remove the link to this item? This action may affect some of your dashboards, reports, and shared datasets.',
            QuotaExceedDialogButtonText_DismissMessage: 'Dismiss Message',
            QuotaExceedDialogButtonText_ManageAccount: 'Manage Account',
            QuotaExceedDialogButtonText_ManageStorage: 'Manage Storage',
            QuotaExceedDialogButtonText_UpgradeAccount: 'Upgrade Account',
            QuotaExceedDialogTitle: 'Over your storage limit',
            QuotaExceedDialogMessage_FreeUser: 'You are over your storage limit. To get data, pin tiles or share your dashboards, upgrade your account to Power BI Pro or manage your storage.',
            QuotaExceedDialogMessage_TrialAndPaidUser: 'You are over your storage limit. To get data, pin tiles or share your dashboards, you need to manage your storage.',
            QuotaExceedBannerMessage_FreeUser: 'You are over your storage limit. To get data or share your dashboards, upgrade your account to Power BI Pro or manage your storage.',
            QuotaExceedBannerMessage_TrialAndPaidUser: 'You are over your storage limit. To get data or share your dashboards, you need to manage your storage.',
            QuotaManagement_UsageDescription: '{0} of {1} used',
            QuotaManagement_CancelButtonText: 'Cancel',
            QuotaManagement_RemoveButtonText: 'Remove',
            QuotaUsage_SizeInMB: '{0} MB',
            QuotaUsage_SizeInGB: '{0} GB',
            InfoNav_SourceLabel: 'Source: {0}',
            UserMetadata_FailedRefresh: 'We failed to refresh user metadata. Please try again later.',
            Visual_DefaultColor: 'Default Color',
            FieldListMenuItem_NewColumn: 'New Column',
            FieldListMenuItem_NewMeasure: 'New Measure',
            Visual_ColumnTotals: 'Column Totals',
            Visual_General: 'General',
            Visual_RowTotals: 'Row Totals',
            Visual_Totals: 'Totals',
            NavigationPane_ExcelWorkbook: 'Excel Workbook',
            WorkbookContextMenu_Edit: 'EDIT',
            WorkbookContextMenu_RefreshNow: 'REFRESH NOW',
            WorkbookContextMenu_Remove: 'REMOVE',
            WorkbookContextMenu_Rename: 'RENAME',
            WorkbookContextMenu_ScheduleRefresh: 'SCHEDULE REFRESH',
            WorkbookContextMenu_View: 'VIEW',
            WorkbookReadyNotificationTitle: 'Your workbook is ready',
            WorkbookReadyNotificationMessage: 'Your Excel workbook is now in your list of reports. Take a look: {0}',
            UpgradeDialogButtonText_Trial: 'Try Power BI Pro',
            UpgradeDialogButtonText_UpgradeAccount: 'Upgrade Account',
            UpgradeDialogMessage: 'Want to use Power BI with {0}? Try Power BI Pro for free or upgrade your account today.',
            UpgradeDialogTitle: 'Need Power BI Pro for {0}',
            UpgradeReasonText_Groups: 'Groups',
            ServiceError_CannotLoadVisual: 'Can\'t display this visual.',
            ServiceError_ExecuteSemanticQueryErrorKey: 'Can\'t display this visual',
            ServiceError_ExecuteSemanticQueryErrorValue: 'Couldn’t retrieve the data for this visual. Please try again later.',
            ServiceError_ExecuteSemanticQueryInvalidStreamFormatKey: 'Can\'t display this visual',
            ServiceError_ExecuteSemanticQueryInvalidStreamFormatValue: 'Power BI couldn’t load the data for this visual because it isn’t in the right format. Please contact the dashboard owner.',
            ServiceError_GeneralError: 'An unexpected error occurred.',
            ServiceError_GeneralErrorKey: 'An unexpected error occurred',
            ServiceError_GeneralErrorValue: 'An unexpected error occurred. Please try again later.',
            ServiceError_ModelCannotLoad: 'Couldn’t load the model schema.',
            ServiceError_ModelConvertFailureKey: 'Internal error prevented loading the schema',
            ServiceError_ModelConvertFailureValue: 'An internal error prevented loading the model schema associated with this report. Please try again later. If the issue persists, contact Power BI support.',
            ServiceError_ModelCreationFailureKey: 'Internal error prevented preparing the schema',
            ServiceError_ModelCreationFailureValue: 'An internal error prevented preparing the model schema associated with this report. Please try again later. If the issue persists, contact Power BI support.',
            ServiceError_ModelFetchingFailureKey: 'Couldn’t load the schema for the database model',
            ServiceError_ModelFetchingFailureValue: 'Couldn’t load the model schema associated with this report. Make sure you have a connection to the server, and try again.',
            VisualContainer_FailedToLoadVisual: 'Can\'t display this visual.',
            VisualContainer_ShowErrorDetails: 'See details',
            ClientError_UnknownClientErrorKey: 'Unknown error',
            ClientError_UnknownClientErrorValue: 'An unexpected script error occurred.',
            VisualContainer_UnableToFindVisualValue: 'Support for this type of visual is coming soon.',
            DsrError_LoadingModelKey: 'The model could not be loaded',
            DsrError_InvalidDataShapeValue: 'Data shapes must contain at least one group or calculation that outputs data. Please contact the dashboard owner.',
            DsrError_InvalidUnconstrainedJoinKey: 'Can’t determine relationships between the fields',
            DsrError_InvalidUnconstrainedJoinValue: 'Can’t display the data because Power BI can’t determine the relationship between two or more fields.',
            DsrError_Key: 'Couldn\'t load the data for this visual',
            DsrError_LoadingModelValue: 'Power BI encountered an unexpected error while loading the model. Please try again later.',
            DsrError_Message: 'Can\'t display the visual.',
            DsrError_ModelGroupingInstructionsIgnoredKey: 'Model grouping instructions ignored',
            DsrError_ModelGroupingInstructionsIgnoredValue: 'The groups on a key should be grouped on another field.',
            DsrError_ModelUnavailableValue: 'Couldn’t retrieve the data model. Please contact the dashboard owner to make sure the data sources and model exist and are accessible.',
            DsrError_MoreInfo: 'More Details',
            DsrError_OverlappingKeysKey: 'Data in the visual is structured incorrectly',
            DsrError_OverlappingKeysValue: 'The groups in the primary axis and the secondary axis overlap. Groups in the primary axis can’t have the same keys as groups in the secondary axis.',
            DsrError_SuppressJoinPredicateValue: 'The column included in the join predicate must refer to a measure. Please contact the dashboard owner.',
            DsrError_UnknownErrorValue: 'Couldn’t retrieve the data for this visual. Please try again later.',
            Publish_DescriptionSizeExceeded: 'Description is too long',
            Publish_GroupAddressExceeded: 'You can only publish to {maxGroups} groups at a time, please remove some',
            Publish_InvalidEntry: 'Invalid entry',
            Publish_NoGroupAddressSpecified: 'Please specify one or more group addresses',
            Publish_TitleSizeExceeded: 'Title is too long',
            Publish_WrongGrouplAddresses: 'Invalid list of group addresses. Please correct them',
            Visual_LegendPosition_Bottom: 'Bottom',
            Visual_LegendPosition_Left: 'Left',
            Visual_LegendPosition_Right: 'Right',
            Visual_LegendPosition_Top: 'Top',
            Visual_yAxis_Left: 'Left',
            Visual_yAxis_Right: 'Right',
            DashboardReadOnly_Tooltip: 'This is a read-only dashboard',
            GetData_BrowserPopUpDisabled: 'Browser pop-up is disabled. Please verify browser settings.',
            GetData_AuthenticationError_Title: 'Failed to show authentication dialog',
            GetData_OK: 'OK',
            GetData_UnableToRetrieveTheAuthenticationEndpoint: 'Unable to retrieve the authentication endpoint',
            GetData_Zendesk_FinePrint: 'Your data in the Zendesk service is transmitted to Power BI so that you can perform business analytics.',
            DataDotClusteredColumnComboChart_ToolTip: 'Data-Dot and Clustered Column Chart',
            DataDotStackedColumnComboChart_ToolTip: 'Data-Dot and Stacked Column Chart',
            Visual_DisplayUnits_Auto: 'Auto',
            Visual_LabelPosition_BottomCenter: 'Bottom Center',
            Visual_LabelPosition_BottomLeft: 'Bottom Left',
            Visual_LabelPosition_BottomRight: 'Bottom Right',
            Visual_LabelPosition_InsideBase: 'Inside Base',
            Visual_LabelPosition_InsideCenter: 'Inside Center',
            Visual_LabelPosition_InsideEnd: 'Inside End',
            Visual_LabelPosition_MiddleCenter: 'Middle Center',
            Visual_LabelPosition_MiddleLeft: 'Middle Left',
            Visual_LabelPosition_MiddleRight: 'Middle Right',
            Visual_LabelPosition_OutsideBase: 'Outside Base',
            Visual_LabelPosition_OutsideEnd: 'Outside End',
            Visual_LabelPosition_TopCenter: 'Top Center',
            Visual_LabelPosition_TopLeft: 'Top Left',
            Visual_LabelPosition_TopRight: 'Top Right',
            Visual_DisplayUnits_Billions: 'B',
            Visual_DisplayUnits_Millions: 'M',
            Visual_DisplayUnits_Thousands: 'K',
            Visual_Card_Placeholder_Auto: 'Automatic',
            AreaChart_ToolTip: 'Area Chart',
            VisualContainer_UnableToFindVisualMessage: 'This visual type is not yet supported.',
            Waterfall_DecreaseLabel: 'Decrease',
            Waterfall_IncreaseLabel: 'Increase',
            Waterfall_SentimentColors: 'Sentiment Colors',
            GetData_StatsNFL2014SeasonRecap: 'Explore statistics from National Football League regular season and playoff games for the 2014 season. Statistics and key measures are provided game by game for each team and player, with additional data for fan attendance, game day weather, and player backgrounds.<br>This copy of the sample is yours to experiment with. You can always connect to the sample again for a fresh copy.',
            ExploreCompatibility_ToggleExplore: 'Explore the new Power BI report canvas',
            ExploreCompatibility_ToggleLegacy: 'Go back to classic report',
            ExploreCompatibility_WarnMessage: 'Would you like to keep a copy of your report in the classic format? Selecting "No" will overwrite the file and you will be unable to go back.',
            ExploreCompatibility_WarnTitle: 'You\'re about to save your report in the new format',
            ExploreCompatibility_PromptMessageLegacy: 'Power BI is changing the way you view, interact with and create reports. Please {0}send us feedback{1} about the new experience.',
            ExploreCompatibility_PromptTitleLegacy: 'New Power BI report canvas',
            ExploreCompatibility_TryNow: 'Try it now',
            MashUpContentProvider_UserVoice_Description1: 'Monitor and explore your UserVoice data in Power BI by simply connecting to UserVoice using your admin credentials. With Power BI, you will have your tickets, suggestions and user satisfaction data right at your fingertips. Use the dashboard and reports that are readily available for you to analyze your data, or customize your own to highlight the information you care about most. Power BI will refresh your User Voice data daily so your dashboards and reports are always up to date.',
            MashUpContentProvider_UserVoice_More2: ' connecting to UserVoice data',
            GetData_Mailchimp: 'With the MailChimp content pack for Power BI, quickly identify trends within your campaigns, reports, and individual subscribers. Find out who your most engaged subscribers are, which countries open the most campaigns, or how trends have changed over time. Drill down into your MailChimp data in Power BI without any coding knowledge. Automatic data updates help you make the most timely decisions.',
            FilledMap_ToolTip: 'Filled Map',
            Visual_Gradient_Diverging: 'Diverging',
            Visual_Gradient_MaxColor: 'Maximum',
            Visual_Gradient_MaxValue: 'Maximum',
            Visual_Gradient_MidColor: 'Center',
            Visual_Gradient_MidValue: 'Center',
            Visual_Gradient_MinColor: 'Minimum',
            Visual_Gradient_MinValue: 'Minimum',
            DonutChart_ToolTip: 'Donut Chart',
            MashUpContentProvider_SweetIQ_Description1: 'Easily track and analyze your local search ecosystem with the SweetIQ Power BI connector. Log in with your SweetIQ account to review search listings for all of your locations as well as analyze and monitor customer reviews. Use the dashboard and reports provided, or customize them to highlight the information you care about most. Data is automatically updated daily with the latest from SweetIQ based on a schedule that you set.',
            MashUpContentProvider_SweetIQ_More2: ' connecting to SweetIQ data',
            DirectQueryContentProvider_Error1: 'Please enter Server.',
            DirectQueryContentProvider_Error2: 'Please enter Database.',
            DirectQueryContentProvider_Error3: 'Please enter User.',
            DirectQueryContentProvider_Error4: 'Please enter Password.',
            DirectQueryContentProvider_Error5: 'Refresh Interval cannot be less than 15 minutes',
            DirectQueryContentProvider_InvalidConnectionString: 'We are unable to establish connection, please check connection information.',
            DirectQueryContentProvider_UnableToReachService: 'We are unable to reach our service to perform test connection, please retry.',
            DirectQueryContentProvider_RefreshInterval: 'Refresh Interval in Minutes:',
            SettingsDataset_DisableEntireRefreshPageErrorMessage_DirectQueryScheduleInfo: 'This dataset connects to a source with direct connect which is always up-to-date. You do not have to schedule a refresh on this dataset.',
            SettingsWorkbook_NoModel_workbookIsUpToDate: 'This workbook is always up-to-date.',
            LineClusteredColumnComboChart_ToolTip: 'Line and Clustered Column Chart',
            LineStackedColumnComboChart_ToolTip: 'Line and Stacked Column Chart',
            ReportAppBar_InsertTextboxButton: 'Insert Textbox',
            GetData_SweetIQ: 'Easily track and analyze your local search ecosystem with the SweetIQ Power BI connector. Log in with your SweetIQ account to review search listings for all of your locations as well as analyze and monitor customer reviews. Use the dashboard and reports provided, or customize them to highlight the information you care about most. Data is automatically updated daily with the latest from SweetIQ based on a schedule that you set.',
            GetData_Acumatica: 'Connecting to Acumatica directly from Power BI allows you to access powerful business insights. Log in to Power BI using Acumatica ERP credentials, and build valuable insights into the opportunity pipeline, opportunities in various stages, and opportunities won and lost. The out-of-the-box dashboard provides a set of views and this can be fully customized. You can ask a question about the data in Q&A, or click a tile to open the underlying report and change the tiles in the dashboard. Acumatica will continue to release additional dashboards for leads, support analysis, financials and more.',
            Clear: 'Clear',
            DsrLimitWarning_RepresentativeSampleKey: 'Showing representative sample.',
            DsrLimitWarning_RepresentativeSampleMessage: 'Showing representative sample.',
            DsrLimitWarning_RepresentativeSampleVal: 'Too many \'{0}\' values. Showing a representative sample. Filter the data or choose another field.',
            DsrLimitWarning_RepresentativeSampleValMultipleColumns: 'Showing representative sample. Filter the data or choose another field.',
            DsrLimitWarning_TooMuchDataKey: 'Too many values',
            DsrLimitWarning_TooMuchDataMessage: 'Too many values. Not showing all data.',
            DsrLimitWarning_TooMuchDataVal: 'Too many \'{0}\' values. Not displaying all data. Filter the data or choose another field.',
            DsrLimitWarning_TooMuchDataValMultipleColumns: 'Too many values. Not showing all data. Filter the data or choose another field.',
            GroupEditor_DiscardButton_Text: 'Discard',
            GroupEditor_SaveButton_Text: 'Save',
            GroupEditor_Title_CreateGroup: 'Create a Group',
            GroupEditor_Title_EditGroup: 'Edit Group',
            GroupEditor_GroupNameLabel_Text_CreateGroup: 'Name your group',
            GroupEditor_GroupNameLabel_Text_EditViewGroup: 'Name',
            GroupEditor_PrivacyLabel_Text: 'Privacy',
            GroupEditor_PrivacyOptions_Private: 'Private - Only approved members can see what\'s inside',
            GroupEditor_PrivacyOptions_Public: 'Public - Anyone can see what\'s inside',
            GroupEditor_AddGroupMembersLabel_Text: 'Add group members',
            GroupEditor_AddButton_Text: 'Add',
            GroupEditor_GroupIdLabel_Text: 'Group ID',
            GroupEditor_CreateGroup_GroupId_Available_Text: 'Available',
            GroupEditor_CreateGroup_GroupId_NotAvailable_Text: 'Not available; please edit',
            EmailsListPlaceholder: 'Enter email addresses separated by ; or ,',
            EmailsList_EmailAddressExceeded: 'You can only email {{maxEmails}} contacts at a time, please remove some.',
            EmailsList_EmailDomainNotInTenant: 'One or more email addresses are outside your organization: {{invalidDomains}}',
            EmailsList_FailureToValidateEmailsDomains_Message: 'Couldn\'t validate the domains for these email addresses',
            EmailsList_FailureToValidateEmailsDomains_Title: 'Couldn\'t validate',
            EmailsList_NoEmailAddressSpecified: 'Specify at least one email address',
            EmailsList_WrongEmailAddresses: 'These email addresses aren’t valid: {0}',
            GroupEditor_CreateGroup_GroupId_GroupIdEditing_NotAvailable_Text: 'Not available',
            GroupEditor_CreateGroup_GroupId_HasInvalidCharacters: 'The Group ID can\'t contain symbols',
            GroupEditor_AreYouSureYouWantToDiscard_Message: 'Your changes will be lost.',
            GroupEditor_AreYouSureYouWantToDiscard_Title: 'Are you sure you want to leave Group Editor?',
            GroupEditor_DeleteGroup_Text: 'Delete Group',
            ServerError_PersonalGateway_DataSourceErrorLabel: 'Data Source Error',
            ServerError_PersonalGateway_LongMessage_DataSource_Inaccessible: 'Last refresh attempt failed. Cannot connect to the data source. Ensure the data source is accessible.',
            ServerError_PersonalGateway_LongMessage_DataSource_InvalidCredential: 'Last refresh attempt failed. The data source has invalid credentials. Update the credentials & also ensure the rest of the data sources in the dataset have valid credentials.',
            ServerError_PersonalGateway_LongMessage_DataSource_MissingProvider: 'Last refresh attempt failed. The right data provider must be installed on the computer on which the gateway is installed.',
            ServerError_PersonalGateway_LongMessage_Gateway_Offline: 'Last refresh attempt failed. Your gateway is offline or could not be reached. Ensure the computer on which the gateway is installed is not switched off during the scheduled refresh period.',
            ServerError_PersonalGateway_LongMessage_Gateway_OfflineNonAdminUser: 'Last refresh attempt failed. Your gateway is offline or could not be reached. Ensure the computer on which the gateway is installed is not switched off or logged off during the scheduled refresh period.',
            ServerError_PersonalGateway_LongMessage_Gateway_WindowsCredentialError: 'Last refresh attempt failed. Power BI Personal Gateway cannot connect due to invalid windows credentials. Go to the machine where gateway was installed and update the windows credentials in the gateway. You can find the gateway in the tray or can search for \'Power BI Gateway\' on your computer.',
            ServerError_PersonalGateway_LongMessage_ProcessingError: 'Error during processing the data in the dataset',
            ServerError_PersonalGateway_LongMessage_ServiceError: 'Last refresh attempt failed. An unexpected error happened in the service that prevented the refresh.',
            ServerError_PersonalGateway_ProcessingErrorLabel: 'Processing Error',
            ServerError_PersonalGateway_ShortMessage_DataSource_Inaccessible: 'Last refresh attempt failed. Cannot connect to the data source.',
            ServerError_PersonalGateway_ShortMessage_DataSource_InvalidCredential: 'Last refresh attempt failed. Cannot connect to the data source.',
            ServerError_PersonalGateway_ShortMessage_DataSource_MissingProvider: 'Last refresh attempt failed.',
            ServerError_PersonalGateway_ShortMessage_Gateway_Offline: 'Last refresh attempt failed. Your gateway is offline or could not be reached.',
            ServerError_PersonalGateway_ShortMessage_Gateway_OfflineNonAdminUser: 'Last refresh attempt failed. Your gateway is offline or could not be reached.',
            ServerError_PersonalGateway_ShortMessage_Gateway_WindowsCredentialError: 'Last refresh attempt failed. Power BI Personal Gateway cannot start due to invalid windows credentials.',
            ServerError_PersonalGateway_ShortMessage_ProcessingError: 'Error during processing the data in the dataset',
            ServerError_PersonalGateway_ShortMessage_ServiceError: 'Last refresh attempt failed. Internal service error.',
            NavigationPane_ArchivedContent: 'Archived Content',
            TutorialPopup_ViewArchivedContentText: 'To view and interact with your archived content click on the button below.',
            TutorialPopup_ViewArchivedContentTitle: 'View archived content',
            TutorialPopup_WelcomeArchivedContentGoingForward: 'Going forward, create and share content in this new space managed by your administrator.',
            TutorialPopup_WelcomeArchivedContentLearnMoreLinkText: 'Learn more about archived Power BI content',
            TutorialPopup_WelcomeArchivedContentParagraphOne: 'An administrator has started managing Power BI for users at your organization. A new space has been created for all of your business data so it can be securely stored and shared with others in your organization.',
            TutorialPopup_WelcomeArchivedContentParagraphTwo: 'As a part of this transition, we have archived all of the Power BI content you created before your administrator started managing Power BI. You can click the Archived Content button to view this  archive at any time. Data in your archive will continue to refresh. You and any existing users that your content is shared with will be able to continue viewing dashboards and reports. However, you can’t share your archived content with new users in your organization.',
            TutorialPopup_WelcomeArchivedContentTitle: 'Say hello to the new Power BI for your organization',
            TutorialPopup_ArchivedContentText: 'Your previously acquired content.',
            TutorialPopup_ArchivedContentTitle: 'Archived<br/>Content',
            TutorialPopup_ForYourOrganizationText: 'New content you create and share with others.',
            TutorialPopup_ForYourOrganizationTitle: 'Power BI for your organization',
            ArchivedContent_BackToPowerBI: 'Back to Power BI',
            ArchivedContent_HeaderLinkText: 'Learn More',
            ArchivedContent_HeaderMessage: 'This is your archived content. Some features, like sharing and access on mobile devices, are disabled.',
            ArchivedContent_ErrorMessageGroup: 'Creating a group is not supported while you are in your archived content. Go back to Power BI to create a group with others in your organization.',
            ArchivedContent_ErrorMessageOneDrivePro: 'OneDrive for Business is not supported while you are in your archived content. Go back to PowerBI to connect to your OneDrive for Business account.',
            ArchivedContent_ErrorMessageSharing: 'Sharing with other members of your organization is not supported while you are in your archived content. Go to back to Power BI to share work.',
            ArchivedContent_ErrorOptionOneText: 'Go back to Power BI',
            ArchivedContent_ErrorOptionTwoText: 'Stay in Archived Content',
            ArchivedContent_ErrorTitle: 'You\'re in Archived Content',
            CloseAccount_Description: 'Didn\'t mean to close your account?',
            CloseAccount_ReopenYourAccount: 'Reopen your account',
            CloseAccount_YourAccountIsClosed: 'Your account is closed.',
            GetData_FindAPartner: 'Find a Partner',
            Groups_Splash_Description1: 'You\'re on your way to exploring your data and monitoring what matters with all your group members.',
            Groups_Splash_Description2: 'Let\'s start by getting some data.',
            Groups_Splash_Title: 'Welcome to the {0} group',
            GroupEditor_Email_Address_DoNotExist: 'These email addresses don’t exist in your organization: {0}',
            GroupEditor_Email_Address_DoNotExistOrNotPowerBiUsers: 'These email addresses don’t exist in your organization or aren’t Power BI users: {0}',
            Settings_CloseAccount: 'Close Account',
            Settings_CloseAccount_Button: 'Close Account',
            Settings_CloseAccount_Description: 'You can close your Power BI account. You will no longer be able to access Power BI and any content you created will be deleted.',
            Settings_CloseAccount_Reason_DecidedToUseOtherSoftware: 'Decided to use other software',
            Settings_CloseAccount_Reason_DidntNeedToUseIt: 'Didn\'t need to use it',
            Settings_CloseAccount_Reason_ForgotAboutIt: 'Forgot about it',
            Settings_CloseAccount_Reason_HardToUse: 'Hard to use',
            Settings_CloseAccount_Reason_HaventHadTimeToUseIt: 'Haven\'t had time to use it',
            Settings_CloseAccount_Reason_MissingFeatures: 'Missing features',
            Settings_CloseAccount_Reason_NotValuableEnoughToMe: 'Not valuable enough to me',
            Settings_CloseAccount_Reason_PlaceHolder: 'Select Reason (optional)',
            Settings_CloseAccount_Reason_TooManyErrors: 'Too many errors',
            Settings_CloseAccount_WhyAreYouClosingYourAccount: 'Why are you closing your account?',
            AfterUpgradeDialogTitle: 'After you upgrade',
            AfterUpgradeDialogMessage: 'After you upgrade successfully to Power BI Pro, click Refresh to take advantage of new features.',
            AfterUpgradeDialogRefreshButton: 'Refresh',
            UpgradeAccount_BrowseContentMessage: 'You may browse through the gallery of your organizational content. To connect to them, upgrade your account to Power BI Pro.',
            UpgradeAccount_ConnectContentMessage: 'To connect to your organizational content in Power BI, upgrade your account to Power BI Pro.',
            UpgradeAccount_ConnectContentTitle: 'Organizational content in Power BI',
            UpgradeAccount_GroupsCollaborationMessage: 'To collaborate with your team in Power BI, upgrade your account to Power BI Pro.',
            UpgradeAccount_GroupsCollaborationTitle: 'Team Collaboration in Power BI',
            UpgradeAccount_ScheduleOnPremDataRefreshMessage: 'This dataset contains on-premise data source. To schedule data refresh, upgrade your account to Power BI Pro.',
            UpgradeAccount_ScheduleDataRefreshMessage: 'To schedule hourly data refresh, upgrade your account to Power BI Pro.',
            UpgradeAccount_ShareDashboardWarnMessage: 'This dashboard contains {0}. Only users who have Power BI Pro can access this dashboard. {1}Learn more{2}',
            UpgradeAccount_ShareDashboardTitle: '{0} contains Power BI Pro content',
            UpgradeAccount_ShareDashboardMessage: 'To see this dashboard, upgrade your account to Power BI Pro.',
            UpgradeAccount_TryfreeButton: 'Try free for {0} days',
            UpgradeAccount_SuccessMessage: 'After you have successfully upgraded to Power BI Pro, click reload to refresh this page and take advantage of new features.',
            UpgradeAccount_SuccessTitle: 'Once you\'ve upgraded..',
            GetData_UserVoice: 'Monitor and explore your UserVoice data in Power BI by simply connecting to UserVoice using your admin credentials. With Power BI, you will have your tickets, suggestions and user satisfaction data right at your fingertips. Use the dashboard and reports that are readily available for you to analyze your data, or customize your own to highlight the information you care about most. Power BI will refresh your UserVoice data daily so your dashboards and reports are always up to date.',
            PublishContentPack_EmptyTitle: 'Be sure to enter a title for your content pack.',
            PublishContentPack_EmptyDescription: 'Be sure to enter a description for your content pack.',
            PublishContentPack_Changes: 'You\'ve made changes to this published content pack. Do you want others to see these changes?',
            PublishContentPack_NoItemsSelected: 'Be sure to select a dashboard, report or dataset for your content pack.',
            PublishContentPack_PersonalizeDashboard_Desc: 'You\'re making changes to a dashboard created from an organizational content pack. Click Save to create your own personal copy.',
            PublishContentPack_PersonalizeReport_Desc: 'You\'re making changes to a report created from an organizational content pack. Click Save to create your own personal copy.',
            PublishContentPack_Personalize_Dashboard: 'Personalize this dashboard',
            PublishContentPack_Personalize_DontSave: 'Don\'t Save',
            PublishContentPack_Personalize_Save: 'Save',
            PublishContentPack_UnsavedChanges: 'You have unsaved changes',
            PublishContentPack_UnsavedChanges_Desc: 'You\'ve made changes to a content pack. Do you want to publish them or cancel?',
            PublishContentPack_Failed_Desc: 'Failed to publish Organizational Apps',
            UploadReplace_DatasetExists: 'You already have a dataset named {0} in Power BI. Do you want to replace the existing dataset with this one?',
            UploadReplace_MultipleDatasetExists: 'You already have more than one dataset named {0} in Power BI. To replace an existing dataset make sure you have only one dataset with this name. Otherwise rename the file and try again.',
            UploadReplace_ReplaceButton: 'Replace it',
            UploadReplace_DontImportButton: 'Don\'t import',
            NewVisualThemeWelcomeNotificationText: 'You might notice our new look and feel. We’ve optimized our visualization colors across dashboards and reports to make your Power BI experience even better.',
            NavigationPane_DevTools: 'Dev Tools',
            Extensibility_DevTools: 'Dev Tools',
            Error_PleaseWait: 'Preparing Power BI',
            Error_PleaseWaitDescription: 'Finishing set up...',
            ErrorDescription_TenantNotAllowed_RetryLimitReached: 'We were not able to retrieve your tenant license within the allotted time limit.',
            ErrorDescription_UserNotLicensed_RetryLimitReached: 'We were not able to retrieve your user license within the allotted time limit.',
            ServerError_ActivityIdText: 'Activity Id',
            ServerError_ClusterUriText: 'Cluster URI',
            ServerError_RequestIdText: 'Request Id',
            ServerError_TimestampText: 'Time',
            ServerError_VersionText: 'Version',
            VisualContainer_Hide: 'Hide',
            GetData_FindOneHere: 'Find one here!',
            ExploreCompatibility_PromptMessageNew: 'We encourage you to try out the new report canvas and {0}send us your feedback{1}.  Prefer the classic report canvas?  You can go back by clicking above.',
            ExploreCompatibility_PromptTitleNew: 'Welcome to the new Power BI report canvas',
            ExploreCompatibility_TakeTour: 'Take the tour',
            Error_PleaseWaitSubtext: 'less than a minute remaining',
            GroupEditor_FailedCreateGroup_Message: 'Couldn\'t create the group',
            GroupEditor_FailedValidateMembers_Message: 'Couldn\'t validate group members',
            GroupEditor_FailedGetGroupMembers_Message: 'Couldn\'t get group members',
            GroupEditor_AreYouSureYouWantToDeleteGroup_Message: 'Power BI will delete all dashboards, reports, and models in this group.',
            GroupEditor_AreYouSureYouWantToDeleteGroup_Title: 'Are you sure you want to delete this group?',
            GroupEditor_FailedDeleteGroup_Message: 'Couldn\'t delete the group',
            GroupEditor_FailedUpdateGroup_Message: 'Couldn\'t update the group',
            GroupEditor_FailedValidateGroupId_Message: 'Unable to validate group ID, please try again later.',
            GroupEditor_WaitForSave: 'Saving...',
            GroupEditor_WaitForAddingMembers: 'Adding members...',
            GroupEditor_WaitLoadMembers: 'Loading members...',
            GroupEditor_WaitDeleteGroup: 'Deleting group...',
            GetData_Zuora: 'Visualize important revenue, billing, and subscription data in Power BI by connecting your Zuora account. Use the default dashboard and reports to analyze usage trends, track billings and payments, and monitor recurring revenue, or customize them to meet your own unique dashboard and reporting needs. Different users in your organization can customize their own reports and dashboards, and these can be shared with other users if desired. Data is automatically updated daily, ensuring you have the latest information available.',
            GetData_BIProfessional_Title: 'BI Professional',
            GetData_BusinessAnalyst_Title: 'Business Analyst',
            GetData_BusinessUser_Title: 'Business User',
            GetData_CustomerProfitabilitySample_Title: 'Customer Profitability Sample',
            GetData_Developer_Title: 'Developer',
            GetData_FilesTutorial_Title: 'Learn about importing files',
            GetData_HumanResourcesSample_Title: 'Human Resources Sample',
            GetData_ITSpendAnalysisSample_Title: 'IT Spend Analysis Sample',
            GetData_LocalFile_Title: 'Local File',
            GetData_OpportunityAnalysisSample_Title: 'Opportunity Analysis Sample',
            GetData_ProcurementAnalysisSample_Title: 'Procurement Analysis Sample',
            GetData_Retail_Analysis_Sample_Title: 'Retail Analysis Sample',
            GetData_SalesAndMarketingSample_Title: 'Sales and Marketing Sample',
            GetData_StatsNFL2014SeasonRecap_Title: 'STATS NFL 2014 Season Recap',
            GetData_SupplierQualityAnalysisSample_Title: 'Supplier Quality Analysis Sample',
            GetData_OneDriveBusiness_Title: 'OneDrive - Business',
            GetData_OneDrivePersonal_Title: 'OneDrive - Personal',
            NoMapLocationKey: 'Need a location to place values on the map',
            NoMapLocationMessage: 'Location is required to create a map.',
            NoMapLocationValue: 'Add a field to the Location box that specifies the position of data points on the map. The field can contain either specific geographic names or longitude and latitude values.',
            GetData_AzureHDInsightSparkLiveConnect: 'Apache Spark™ is a fast and general engine for large-scale data processing. Azure HDInsight offers a fully managed Spark service which allows for massive scale-out and interactive performance. HDInsight Spark can connect to any Blob storage in Azure Storage or Azure Data Lake. With the Spark on Azure HDInsight connector for Power BI, users can query and visualize the large volumes of unstructured data that have been modeled in Spark. The result is interactive data exploration and reporting in Power BI on a massive scale of data.',
            SparkContentProvider_Description: 'With Power BI you can create dynamic reports mashups with data and metrics you already have in Spark on Azure HDInsight. To get started, we need some information to connect.',
            SparkContentProvider_Landing_ConnectButton: 'Connect',
            SparkContentProvider_Password: 'Password:',
            SparkContentProvider_ServerName: 'Server:',
            SparkContentProvider_Title: 'Spark on Azure HDInsight',
            SparkContentProvider_UserName: 'User:',
            SparkContentProvider_Description2: 'More about',
            SparkContentProvider_Description3: 'direct connect with Spark on Azure HDInsight',
            PropertyPane_Unavailable: 'Formatting options are unavailable for this visual',
            DesignerContainer_FailedToLoadReport: 'Failed to load the report.',
            GetData_VisualStudioOnlineVNext: 'Visualize your engineering activity in Power BI by connecting to Microsoft Visual Studio Online. The default dashboard and report provide at-a-glance views of work and code across the projects you configure for your account.  You can customize the dashboard and report to highlight the deeper insights you care about most. The data that appears in Power BI will be updated from Microsoft Visual Studio Online according to a schedule that you control.',
            GroupEditor_Title_ViewGroup: 'View Group',
            GroupNavigationPaneContextMenuItem_ViewGroup: 'View Group',
            GroupEditor_AddGroupMembers_ViewMode_Label_Text: 'Group members',
            HistoryDialog_RefreshStatus_TimedOut: 'Timed Out',
            GroupEditor_ViewMode_OkButton_Text: 'Ok',
            GroupEditor_WaitForGroupIdValidation: 'Validating...',
            PublishContentPack_Update: 'Update',
            Publish_UpdateContentPack: 'Update Content Pack',
            UpdateContentPack_NoChangesMade: 'No content pack changes has been made.',
            PublishContentPack_GroupsValidationFailed: 'Be sure to enter valid groups',
            PublishContentPack_InvalidGroupAddresses: 'The following groups have failed validation : {0}',
            DashboardContentPackNewVersion: 'A new version of the "{0}" content pack is available.',
            Extensibility_Download: 'Download',
            Extensibility_Import: 'Import',
            Extensibility_Properties: 'Properties',
            Extensibility_Run: 'Run',
            Extensibility_Undo: 'Undo',
            Extensibility_DeveloperTools: 'Developer Tools',
            Extensibility_Extensibility: 'Extensibility',
            FixReferences_ToolTip: 'Fix References',
            Missing_References_Details_Title: 'List of Missing References',
            Missing_References_Message: 'This visual in broken due to missing references',
            Fix_This: 'Fix This',
            NaNValue: 'NaN',
            InfinityValue: '+Infinity',
            NegativeInfinityValue: '-Infinity',
        };
    })(localization = powerbi.localization || (powerbi.localization = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var common;
    (function (common) {
        var localization;
        (function (localization) {
            var LocalizationLoader = (function () {
                function LocalizationLoader(currentLanguageLocale) {
                    this.isDataLoaded = false;
                    this.isDataLoading = false;
                    this.isDefaultLanguage = false;
                    this.currentLanguageLocale = currentLanguageLocale;
                }
                LocalizationLoader.prototype.load = function (isOptional) {
                    var _this = this;
                    // for now, all English ones will map to en-US
                    var localeRegex = /en-\w+/;
                    //isOptional=true will not localize dashboard
                    if (localeRegex.test(this.currentLanguageLocale)) {
                        this.currentLanguageLocale = isOptional ? 'en-US' : this.currentLanguageLocale;
                    }
                    var task = LocalizationLoader.promiseFactory.defer();
                    if (this.currentLanguageLocale !== LocalizationLoader.defaultLanguageLocale) {
                        this.isDefaultLanguage = this.isDataLoaded = false;
                        this.isDataLoading = true;
                        // If we're not able to load localized strings,
                        // fallback to the default language 
                        LocalizationLoader.requestLocalizedStrings(this.currentLanguageLocale).promise.then(function (strings) {
                            _this.isDataLoaded = true;
                            _this.isDataLoading = false;
                            _this.strings = strings;
                            task.resolve({});
                        }, function () {
                            _this.isDefaultLanguage = _this.isDataLoaded = true;
                            _this.isDataLoading = false;
                            task.resolve({});
                        });
                    }
                    else {
                        this.isDefaultLanguage = this.isDataLoaded = true;
                        this.isDataLoading = false;
                        task.resolve({});
                    }
                    return task;
                };
                LocalizationLoader.requestLocalizedStrings = function (language) {
                    var task = LocalizationLoader.promiseFactory.defer();
                    var parentWindow = window.parent;
                    var currentWindow = window;
                    //If we have loaded localized strings for parent window, use it
                    if (parentWindow.localizedStrings) {
                        currentWindow.localizedStrings = parentWindow.localizedStrings;
                        task.resolve(currentWindow.localizedStrings);
                    }
                    else {
                        currentWindow.localizedStrings = powerbi.common.localizedStrings;
                        if (!currentWindow.localizedStrings) {
                            task.reject();
                        }
                        else {
                            task.resolve(currentWindow.localizedStrings);
                        }
                    }
                    return task;
                };
                // TODO: Remove this local promise factory instance and use DI once localization loader is changed from singleton implementation.
                LocalizationLoader.promiseFactory = powerbi.createJQueryPromiseFactory();
                LocalizationLoader.defaultLanguageLocale = 'en-US';
                return LocalizationLoader;
            })();
            localization.LocalizationLoader = LocalizationLoader;
            localization.loader = new LocalizationLoader(powerbi.common.cultureInfo || window.navigator.language || window.navigator.userLanguage);
            localization.promiseLoad = localization.loader.load();
        })(localization = common.localization || (common.localization = {}));
    })(common = powerbi.common || (powerbi.common = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var common;
    (function (common) {
        var Helpers = powerbitests.helpers;
        /** factory method to create the localization service. */
        function createLocalizationService(promiseFactory, loader) {
            if (loader === void 0) { loader = common.localization.loader; }
            return new LocalizationService(loader, promiseFactory);
        }
        common.createLocalizationService = createLocalizationService;
        /**
         * the translation service class which implements the common.ILocalizationService
         * For localized strings in view, use Localize directive to do the translation, apply watch on it and once loaded, deregister the watch.
         * For localized strings in controller, use rootScopt.emit to make a event call to only load the values once the strings are ready.
         * If the localized string ID doesn't exist, look for it in the default localized resources
         */
        var LocalizationService = (function () {
            function LocalizationService(loader, promiseFactory) {
                this.promiseFactory = promiseFactory || powerbi.createJQueryPromiseFactory();
                this.loader = loader;
            }
            Object.defineProperty(LocalizationService.prototype, "currentLanguageLocale", {
                get: function () {
                    return this.loader.currentLanguageLocale;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * localize the string according to the id
             * @param {string} id - the lookup id in dictionary.
             */
            LocalizationService.prototype.get = function (id) {
                return this.getImpl(id);
            };
            LocalizationService.prototype.getOptional = function (id) {
                return this.getImpl(id, true);
            };
            LocalizationService.prototype.ensureLocalization = function (action) {
                var isLoadedDeferred = this.promiseFactory.defer();
                if (this.loader.isDataLoaded) {
                    action();
                    isLoadedDeferred.resolve({});
                }
                else if (this.loader.isDataLoading) {
                    common.localization.promiseLoad.promise.then(function () {
                        action();
                        isLoadedDeferred.resolve({});
                    }, function () {
                        debug.assertFail("LocalizationLoader failed loading data");
                        isLoadedDeferred.resolve({});
                    });
                }
                else {
                    common.localization.promiseLoad = this.loader.load();
                    common.localization.promiseLoad.promise.then(function () {
                        action();
                        isLoadedDeferred.resolve({});
                    }, function () {
                        debug.assertFail("LocalizationLoader should not fail loading in any case");
                        isLoadedDeferred.resolve({});
                    });
                }
                return isLoadedDeferred;
            };
            LocalizationService.prototype.format = function (id, args) {
                var result = this.get(id);
                var index = args.length;
                while (index--) {
                    result = result.replace(new RegExp('\\{' + index + '\\}', 'gm'), this.formatValue(args[index]));
                }
                return result;
            };
            LocalizationService.prototype.formatValue = function (arg) {
                if (arg == null) {
                    return '';
                }
                else if (jsCommon.Utility.isString(arg)) {
                    return arg;
                }
                else if (jsCommon.Utility.isNumber(arg)) {
                    return arg.toLocaleString();
                }
                else if (jsCommon.Utility.isDate(arg)) {
                    return arg.toLocaleString();
                }
                else if (jsCommon.Utility.isObject(arg)) {
                    if (arg['toLocaleString'] != null) {
                        return arg['toLocaleString']();
                    }
                    else {
                        return arg.toString();
                    }
                }
                else {
                    return '';
                }
            };
            LocalizationService.prototype.getImpl = function (id, isOptional) {
                if (this.loader.isDataLoaded && !this.loader.isDefaultLanguage) {
                    var localizationValue = this.loader.strings[id];
                    if (!Helpers.isUndefined(localizationValue) && localizationValue !== null) {
                        return localizationValue;
                    }
                }
                var defaultValue = powerbi.localization.defaultLocalizedStrings[id];
                if (Helpers.isUndefined(defaultValue) || defaultValue === null) {
                    if (!isOptional) {
                        debug.assertFail('Localization Resource for ' + id + ' not found');
                    }
                }
                return defaultValue;
            };
            return LocalizationService;
        })();
        /** the localization service */
        common.localize;
    })(common = powerbi.common || (powerbi.common = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbitests;
(function (powerbitests) {
    var utils;
    (function (utils) {
        var ColorUtility;
        (function (ColorUtility) {
            var HexPattern = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
            var RGBRegex = /^rgb\(\s*(-?\d+)(%?)\s*,\s*(-?\d+)(%?)\s*,\s*(-?\d+)(%?)\s*\)$/;
            function convertFromRGBorHexToHex(value) {
                if (value.match(HexPattern)) {
                    return value;
                }
                return rgbStringToHex(value);
            }
            ColorUtility.convertFromRGBorHexToHex = convertFromRGBorHexToHex;
            ;
            function rgbStringToHex(rgb) {
                var result, r, g, b, hex = "";
                if ((result = RGBRegex.exec(rgb))) {
                    r = componentFromStr(result[1], result[2]);
                    g = componentFromStr(result[3], result[4]);
                    b = componentFromStr(result[5], result[6]);
                    hex = "#" + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
                }
                return hex;
            }
            ;
            function componentFromStr(numStr, percent) {
                var num = Math.max(0, parseInt(numStr, 10));
                return percent ? Math.floor(255 * Math.min(100, num) / 100) : Math.min(255, num);
            }
            ;
        })(ColorUtility = utils.ColorUtility || (utils.ColorUtility = {}));
    })(utils = powerbitests.utils || (powerbitests.utils = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../typedefs/globalize/globalize.d.ts"/>
///<reference path="../../typedefs/d3/d3.d.ts"/>
///<reference path="../../typedefs/jasmine/jasmine-jquery.d.ts"/>
///<reference path="../../typedefs/jasmine/jasmine.d.ts"/>
///<reference path="../../typedefs/jQuery/jQuery.d.ts"/>
///<reference path="../../JSCommon/obj/Utility.d.ts"/>
///<reference path="../../Data/obj/Data.d.ts"/>
///<reference path="../../Visuals/obj/Visuals.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    describe("GradientUtils", function () {
        it('getFillRuleRole with fillRule', function () {
            var desc = {
                test: {
                    displayName: 'displayName',
                    properties: {
                        fillRule: {
                            displayName: 'fillRule',
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'inputRoleValue',
                            },
                        }
                    }
                }
            };
            expect(powerbi.visuals.GradientUtils.getFillRuleRole(desc)).toBe('inputRoleValue');
        });
        it('getFillRuleRole without fillRule', function () {
            var desc = {
                test: {
                    displayName: 'displayName',
                    properties: {
                        fill: {
                            displayName: 'fill',
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            };
            expect(powerbi.visuals.GradientUtils.getFillRuleRole(desc)).toBeUndefined();
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var AxisHelper = powerbi.visuals.AxisHelper;
    var ValueType = powerbi.ValueType;
    describe("AxisHelper invertOrdinalScale tests", function () {
        var range;
        var ordinalScale;
        var domain;
        beforeEach(function () {
            range = [0, 99];
            domain = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            ordinalScale = d3.scale.ordinal();
            ordinalScale.rangeRoundBands(range, 0.1);
            ordinalScale.domain(domain);
        });
        it('invertOrdinalScale in middle', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 50);
            expect(invertedValue).toBe(5);
        });
        it('invertOrdinalScale at start', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 0);
            expect(invertedValue).toBe(0);
        });
        it('invertOrdinalScale at end', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 99);
            expect(invertedValue).toBe(9);
        });
        it('invertOrdinalScale at before start', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, -4);
            expect(invertedValue).toBe(0);
        });
        it('invertOrdinalScale at after end', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 1222);
            expect(invertedValue).toBe(9);
        });
    });
    describe("AxisHelper create scales tests", function () {
        var dataStrings = ['Sun', 'Mon', 'Holiday'];
        var dataNumbers = [47.5, 98.22, 127.3];
        var dataTime = [new Date('10/15/2014'), new Date('10/15/2015'), new Date('10/15/2016')];
        var domainOrdinal3 = [0, 1, 2];
        var domainBoolIndex = [0, 1];
        var domainNaN = [NaN, NaN];
        var metaDataColumnText = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ text: true })
        };
        var metaDataColumnNumeric = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ numeric: true })
        };
        var metaDataColumnBool = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ bool: true })
        };
        var metaDataColumnTime = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ dateTime: true })
        };
        var formatStringProp = {
            objectName: 'general',
            propertyName: 'formatString',
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        // TODO: add a getValueFn mock to provide to createAxis so we can test tickValue generation
        it('create ordinal scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnText,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) {
                    return dataStrings[index];
                }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('Sun');
            // Provides category thickness is not set when not defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeUndefined();
            // Proves label max width is pixelSpan/tickValues when categoryThickness not defined
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toEqual(25);
        });
        it('create ordinal scale with linear values', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) {
                    return dataNumbers[index];
                }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('47.50');
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
        });
        it('create ordinal scale with no categories', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: undefined,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) {
                    return dataStrings[index];
                }
            });
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(0);
        });
        it('create ordinal scale with boolean values', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainBoolIndex,
                metaDataColumn: metaDataColumnBool,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (d, dataType) {
                    if (d === 0)
                        return true;
                    else
                        return false;
                }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            // check tick labels values
            expect(os.values[0]).toBe('True');
            expect(os.values[1]).toBe('False');
        });
        it('create ordinal scale with category thickness', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnText,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                categoryThickness: 5,
                getValueFn: function (index, type) {
                    return dataStrings[index];
                }
            });
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('Sun');
            // Provides category thickness set when defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toEqual(5);
            // Provides category thickness used as xLabelMaxWidth when not is scalar
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toEqual(5);
        });
        it('create linear scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataNumbers[0], dataNumbers[2]],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // Provides category thickness is not set when not defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[1]).toBe('100.00');
            // Proves label max width is pixelSpan/tickValues when is scalar and category thickness not defined
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toBeGreaterThan(33);
            expect(xLabelMaxWidth).toBeLessThan(34);
        });
        it('create linear scale with NaN domain', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainNaN,
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: true
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // check for default value fallbackDomain
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[2]).toBe('10.00');
        });
        it('create value scale - near zero min check', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [-0.000001725, 15],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: true
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[0]).toBe('0.00');
        });
        it('create linear scale with category thickness', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [40, 60],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 20,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // Proves category thickness set when defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toEqual(20);
            // Proves category thickness not considered for label max width when is scalar
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toBe(25);
        });
        it('create linear scale with category thickness that needs to change', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 200,
                dataDomain: [2007, 2011],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 50,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // category thickness was altered
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toBeCloseTo(33.3, 1);
        });
        it('create linear scale with category thickness and zero range (single value)', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 200,
                dataDomain: [9, 9],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 50,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // category thickness was altered
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toBe(50);
        });
        it('create scalar time scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataTime[0].getTime(), dataTime[2].getTime()],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) {
                    return new Date(index);
                } //index is actually milliseconds in this case
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[0]).toBe('2015');
        });
        it('create scalar time scale - single day', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataTime[0].getTime(), dataTime[0].getTime()],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) {
                    return new Date(index);
                } //index is actually milliseconds in this case
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(1);
            expect(values[0]).toBe('Oct 15');
        });
        it('create ordinal time scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) {
                    return dataTime[index];
                }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('2014');
        });
    });
    describe("AxisHelper column type tests", function () {
        it('createOrdinalType', function () {
            var ordinalType = AxisHelper.createOrdinalType();
            expect(AxisHelper.isOrdinal(ordinalType)).toBe(true);
            expect(AxisHelper.isDateTime(ordinalType)).toBe(false);
        });
        it('isOrdinal not valid for DateTime', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ dateTime: true }))).toBe(false);
        });
        it('isOrdinal valid for bool', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ bool: true }))).toBe(true);
        });
        it('isOrdinal not valid for numeric', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ numeric: true }))).toBe(false);
        });
        it('isOrdinal valid for text', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ text: true }))).toBe(true);
        });
        it('isDateTime valid for DateTime', function () {
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ dateTime: true }))).toBe(true);
        });
        it('isDateTime not valid for non-DateTIme', function () {
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ numeric: true }))).toBe(false);
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ text: true }))).toBe(false);
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ bool: true }))).toBe(false);
        });
        it('isDateTime null', function () {
            expect(AxisHelper.isDateTime(null)).toBe(false);
        });
        it('isDateTime undefined', function () {
            expect(AxisHelper.isDateTime(undefined)).toBe(false);
        });
    });
    describe("AxisHelper get Recommended tick values tests", function () {
        var labels = ['VRooom', 'FROM', '1984', 'OR', 'YEAR', '3000', '?', '?'];
        it('max is half the ticks', function () {
            var expected = ['VRooom', '1984', 'YEAR', '?'];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(4, labels);
            expect(actual).toEqual(expected);
        });
        it('max is zero ticks', function () {
            var expected = [];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(0, labels);
            expect(actual).toEqual(expected);
        });
        it('max is negative ticks', function () {
            var expected = [];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(-1, labels);
            expect(actual).toEqual(expected);
        });
        it('max is equal to ticks', function () {
            var expected = labels;
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(8, labels);
            expect(actual).toEqual(expected);
        });
        it('max is more than ticks', function () {
            var expected = labels;
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(10, labels);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: ordinal index', function () {
            var expected = [0, 2, 4, 6, 8];
            var scale = AxisHelper.createOrdinalScale(400, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0.4);
            var actual = AxisHelper.getRecommendedTickValues(5, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: ordinal index - zero maxTicks', function () {
            var vals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            var scale = AxisHelper.createOrdinalScale(400, vals, 0.4);
            var actual = AxisHelper.getRecommendedTickValues(0, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual([]);
        });
        it('getRecommendedTickValues: ordinal index - maxTicks greater than len', function () {
            var vals = [0, 1, 2, 3, 4];
            var scale = AxisHelper.createOrdinalScale(400, vals, 0.4);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual(vals);
        });
        // linear domains are always [min,max], only two values, and are already D3.nice()
        it('getRecommendedTickValues: scalar numeric - easy', function () {
            var expected = [0, 20, 40, 60, 80, 100];
            var scale = AxisHelper.createLinearScale(400, [0, 100]);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: 0 tick count', function () {
            var expected = [];
            var scale = AxisHelper.createLinearScale(400, [0, 100]);
            var actual = AxisHelper.getRecommendedTickValues(0, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: positive range', function () {
            var expected = [60, 80, 100];
            var scale = AxisHelper.createLinearScale(400, [60, 100]);
            var actual = AxisHelper.getRecommendedTickValues(3, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: negative range', function () {
            var expected = [-200, -180, -160, -140, -120, -100];
            var scale = AxisHelper.createLinearScale(400, [-200, -100]);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: 0 between min and max', function () {
            var expected = [0, 50, 100];
            var scale = AxisHelper.createLinearScale(400, [-20, 100]);
            var actual = AxisHelper.getRecommendedTickValues(4, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('ensureValuesInRange: unsorted tick values', function () {
            var values = [1, 2, 3, 4, 5];
            var actual = AxisHelper.ensureValuesInRange(values, 2.2, 5.5);
            expect(actual).toEqual([3, 4, 5]);
        });
        it('ensureValuesInRange: only one value in range', function () {
            var values = [1, 2, 3, 4, 5];
            var actual = AxisHelper.ensureValuesInRange(values, 1.5, 2.5);
            expect(actual).toEqual([1.5, 2.5]);
        });
        it('ensureValuesInRange: no value in range', function () {
            var values = [1, 2];
            var actual = AxisHelper.ensureValuesInRange(values, 1.25, 1.75);
            expect(actual).toEqual([1.25, 1.75]);
        });
    });
    describe("AxisHelper get best number of ticks tests", function () {
        var dataViewMetadataColumnWithIntegersOnly = [
            {
                displayName: 'col1',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            }
        ];
        var dataViewMetadataColumnWithNonInteger = [
            {
                displayName: 'col1',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: ValueType.fromDescriptor({ numeric: true })
            }
        ];
        it('dataViewMetadataColumn with only integers small range', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 3, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(4); // [0,1,2,3]
        });
        it('dataViewMetadataColumn with only integers large range', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 10, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(6);
        });
        it('hundred percent dataViewMetadataColumn with only integers', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 1, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(6);
        });
        it('dataViewMetadataColumn with non integers', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 3, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(6);
        });
        it('dataViewMetadataColumn with NaN min/max', function () {
            var actual = AxisHelper.getBestNumberOfTicks(NaN, 3, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
            actual = AxisHelper.getBestNumberOfTicks(1, NaN, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
            actual = AxisHelper.getBestNumberOfTicks(NaN, NaN, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
        });
    });
    describe("AxisHelper diffScaled", function () {
        var scale;
        beforeEach(function () {
            var range = [0, 999];
            var domain = [0, 1, 2, 3, 4, 5, 6, 7, 8, 999];
            scale = d3.scale.linear().range(range).domain(domain);
        });
        it('diffScaled: zero', function () {
            expect(AxisHelper.diffScaled(scale, 0, 0)).toBe(0);
        });
        it('diffScaled: small nonzero +ve', function () {
            expect(AxisHelper.diffScaled(scale, 0.00000001, 0)).toBe(1);
        });
        it('diffScaled: small nonzero -ve', function () {
            expect(AxisHelper.diffScaled(scale, -0.00000001, 0)).toBe(-1);
        });
    });
    describe("AxisHelper getRecommendedNumberOfTicks tests", function () {
        it('getRecommendedNumberOfTicksForXAxis small tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(220);
            expect(tickCount).toBe(3);
        });
        it('getRecommendedNumberOfTicksForXAxis median tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(480);
            expect(tickCount).toBe(6);
        });
        it('getRecommendedNumberOfTicksForXAxis large tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(730);
            expect(tickCount).toBe(6);
        });
        it('getRecommendedNumberOfTicksForYAxis small tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(80);
            expect(tickCount).toBe(3);
        });
        it('getRecommendedNumberOfTicksForYAxis median tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(230);
            expect(tickCount).toBe(6);
        });
        it('getRecommendedNumberOfTicksForYAxis large tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(350);
            expect(tickCount).toBe(6);
        });
    });
    describe("AxisHelper margins", function () {
        var viewPort = { width: 10, height: 20 };
        var xAxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [87, 78],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var y1AxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [20, 30, 50],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var y2AxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [2000, 3000, 5000],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var textProperties = {
            fontFamily: '',
            fontSize: '16',
        };
        it('Check that margins are calculatde correctly when you render 2 axes', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, true, true, true);
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(12);
            expect(tickCount.yRight).toBe(24);
        });
        it('Check that margins are calculated correctly when you hide all axes', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, false, false, false);
            expect(tickCount.xMax).toBe(0);
            expect(tickCount.yLeft).toBe(0);
            expect(tickCount.yRight).toBe(0);
        });
        it('Disable the secondary axis', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, true, true, false); //don't display secondary which is on the left now
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(12);
            expect(tickCount.yRight).toBe(0);
        });
        it('Switch the y-axes, and disable the secondary axis', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, true, true, true, false); //don't display secondary which is on the left now
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(0);
            expect(tickCount.yRight).toBe(12);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ColorHelper = powerbi.visuals.ColorHelper;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    describe('Color Helper', function () {
        var colorHelper;
        var style;
        var colors;
        var columnIdentity = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
        beforeEach(function () {
            style = powerbi.visuals.visualStyles.create();
            colors = style.colorPalette.dataColors;
            colorHelper = new ColorHelper(colors, null);
        });
        it('getColorForSeriesValue should handle undefined identity array', function () {
            var color = colorHelper.getColorForSeriesValue(undefined, undefined, 'value');
            var expectedColor = colors.getColorByScale(SQExprShortSerializer.serializeArray([]), 'value').value;
            expect(color).toEqual(expectedColor);
        });
        it('getColorForSeriesValue should return the same color for the same series and value', function () {
            var color1 = colorHelper.getColorForSeriesValue(null, [columnIdentity], 'value');
            var color2 = colorHelper.getColorForSeriesValue(null, [columnIdentity], 'value');
            expect(color1).toEqual(color2);
        });
        // TODO: add more unit tests (Defect 5037722)
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    describe("converterHelper tests", function () {
        it('categoryIsAlsoSeriesRole default', function () {
            var dataView = createCategoricalDataView({});
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
            // Only a 'Series' role prevents us from using the Default strategy
            var dataView = createCategoricalDataView({ 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
            var dataView = createCategoricalDataView({ 'E === mc^2': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
        });
        it('categoryIsAlsoSeriesRole series and category', function () {
            var dataView = createCategoricalDataView({ 'Series': true, 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBe(true);
            var dataView = createCategoricalDataView({ 'Series': true, 'F === ma': true, 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBe(true);
        });
        it('getPivotedCategories default', function () {
            var dataView = createCategoricalDataView({});
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            // Note: Since the result includes a function property we can't perform a toEqual directly on the result, so check each part individually.
            expect(categoryInfo.categories).toEqual(['a', 'b']);
            expect(categoryInfo.categoryIdentities).toEqual([dataView.categories[0].identity[0], dataView.categories[0].identity[1]]);
        });
        it('getPivotedCategories empty categories', function () {
            var dataView = createCategoricalDataView({});
            // Empty the categories array
            dataView.categories = [];
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            validateEmptyCategoryInfo(categoryInfo);
        });
        it('getPivotedCategories empty category values', function () {
            var dataView = createCategoricalDataView({});
            // Empty the category values array
            dataView.categories[0].values = [];
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            expect(categoryInfo.categories).toEqual([]);
            expect(categoryInfo.categoryIdentities).toBeUndefined();
        });
        function validateEmptyCategoryInfo(categoryInfo) {
            // Note: Since the result includes a function property we can't perform a toEqual directly on the result, so check each part individually.
            expect(categoryInfo.categories).toEqual([null]);
            expect(categoryInfo.categoryIdentities).toBeUndefined();
        }
        function createCategoricalDataView(roles) {
            var metadata = {
                columns: [
                    { displayName: 'col1', roles: roles },
                    { displayName: 'col2', isMeasure: true, roles: { 'Y': true } },
                ]
            };
            return {
                categories: [{
                    source: metadata.columns[0],
                    values: ['a', 'b'],
                    identity: [
                        powerbitests.mocks.dataViewScopeIdentity('a'),
                        powerbitests.mocks.dataViewScopeIdentity('b'),
                    ]
                }],
                values: powerbi.data.DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [100, 200]
                    }
                ])
            };
        }
        function formatStringProp() {
            return { objectName: 'general', propertyName: 'formatString' };
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var DataLabelUtils = powerbi.visuals.dataLabelUtils;
    var DefaultWaitForRender = 100;
    describe("dataLabelUtils Line Chart Collision Detection", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    isMeasure: false,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */),
                    format: 'd'
                }
            ],
            objects: { labels: { show: true } },
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '150');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 2465000
                        }])
                    }
                }]
            });
            setTimeout(function () {
                // Only the top two label should be hidden
                expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(3);
                expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toContain("495");
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            var metadataWithoutPrecision = jQuery.extend(true, {}, dataViewMetadata);
            //force ignoring label precision to take the format from the metadata, so collision detection will affect 2 labels.
            metadataWithoutPrecision.objects.labels['labelPrecision'] = null;
            v.onDataChanged({
                dataViews: [{
                    metadata: metadataWithoutPrecision,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 550000, 550000, 550000, 600000],
                            subtotal: 2750000
                        }])
                    }
                }]
            });
            setTimeout(function () {
                // Two label should be hidden because it collides
                expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('undefined labelSettings validation', function () {
            var labelSettings;
            var instance = DataLabelUtils.enumerateDataLabels(labelSettings, false);
            expect(instance).toEqual([]);
        });
    });
    describe("dataLabelUtils Scatter Chart Collision Detection", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    isMeasure: false,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */),
                    format: 'd'
                }
            ],
            objects: { categoryLabels: { show: true } },
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('250', '200');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['First', 'Second', 'Third', 'Fourth']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [110, 120, 130, 140],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                // No label should be hidden
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('First');
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['First', 'Second', 'Third', 'Fourth', 'Fifth']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [110, 120, 130, 140, 150],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                // Two labels should be hidden because they collides
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("dataLabelUtils Map Collision Detection", function () {
        var mockGeotaggingAnalyzerService;
        var mockDatalabelSettings = {
            show: true,
            displayUnits: 2,
            position: 0 /* Above */,
            precision: 2,
            labelColor: "#000000",
            overrideDefaultColor: false,
            formatterOptions: {},
        };
        var mockViewPort = {
            height: 150,
            width: 300
        };
        beforeEach(function () {
            var localizationService = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(localizationService);
            powerbi.common.localize = localizationService;
            mockGeotaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(function (stringId) { return localizationService.get(stringId); });
        });
        afterEach(function () {
            // Clear labels
            $('.data-labels').remove();
        });
        it('Show bubble labels validation', function () {
            var mockBubbleData = [
                {
                    x: 0,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                },
                {
                    x: 50,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                }
            ];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapBubbles1", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapBubbles1 text').length).toBe(2);
        });
        it('Hide bubble labels validation', function () {
            var mockBubbleData = [
                {
                    x: 45,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                },
                {
                    x: 50,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                }
            ];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapBubbles2", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapBubbles2 text').length).toBe(1);
        });
        it('Show slice labels validation', function () {
            var mockSliceData = [
                {
                    x: 0,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                    value: 20,
                },
                {
                    x: 50,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                    value: 20,
                }
            ];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockSliceGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapSlice1", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockSliceGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapSlice1 text').length).toBe(2);
        });
        it('Hide slice labels validation', function () {
            var mockSliceData = [
                {
                    x: 45,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                    value: 20,
                },
                {
                    x: 50,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                    value: 20,
                }
            ];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockSliceGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapSlice2", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockSliceGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapSlice2 text').length).toBe(1);
        });
    });
    function columnChartDataLabelsShowValidation(chartType, collide) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, labelPrecision: 0, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            if (collide)
                element = powerbitests.helpers.testDom('100', '100');
            else
                element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Visibility Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [20, 20, 100],
                        subtotal: 140
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                if (collide)
                    switch (chartType) {
                        case 'columnChart':
                        case 'clusteredColumnChart':
                        case 'barChart':
                        case 'clusteredBarChart':
                            expect(labels.length).toBe(3);
                            break;
                        case 'hundredPercentStackedColumnChart':
                            expect(labels.length).toBe(0);
                            break;
                        case 'hundredPercentStackedBarChart':
                            expect(labels.length).toBe(3);
                            break;
                    }
                else
                    switch (chartType) {
                        case 'columnChart':
                        case 'barChart':
                        case 'clusteredColumnChart':
                        case 'clusteredBarChart':
                            expect(labels.length).toBe(3);
                            break;
                        case 'hundredPercentStackedColumnChart':
                        case 'hundredPercentStackedBarChart':
                            expect(labels.length).toBe(3);
                            break;
                    }
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('barChart', false); });
    describe("Clustered Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('clusteredBarChart', false); });
    describe("Hundred Percent Stacked Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedBarChart', false); });
    describe("Stacked Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('columnChart', false); });
    describe("Clustered Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('clusteredColumnChart', false); });
    describe("Hundred Percent Stacked Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedColumnChart', false); });
    describe("Stacked Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('barChart', true); });
    describe("Clustered Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('clusteredBarChart', true); });
    describe("Hundred Percent Stacked Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedBarChart', true); });
    describe("Stacked Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('columnChart', true); });
    describe("Clustered Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('clusteredColumnChart', true); });
    describe("Hundred Percent Stacked Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedColumnChart', true); });
    describe("dataLabelUtils Waterfall Chart Collision Detection", function () {
        var v, element;
        ;
        var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
        var SemanticType = powerbi.data.SemanticType;
        var DataViewTransform = powerbi.data.DataViewTransform;
        var localizationService = powerbi.common.createLocalizationService();
        powerbi.common.localize = localizationService;
        var values = [100, -200, 250];
        var categories = [2010, 2011, 2012];
        var categoryColumn = { displayName: 'year', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } } };
        var dataView = {
            categories: [{
                source: categoryColumn,
                values: categories,
            }],
            values: DataViewTransform.createValueColumns([{
                source: measureColumn,
                values: values,
            }]),
        };
        var metadata = {
            columns: [categoryColumn, measureColumn],
        };
        var data = {
            categorical: dataView,
            metadata: metadata,
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
        });
        it('Show labels validation', function (done) {
            element = powerbitests.helpers.testDom('500', '500');
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            data.metadata.objects = {
                labels: {
                    show: true,
                }
            };
            var dataChangedOptions = {
                dataViews: [data]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                // Two last labels are hidden due to collision detection
                expect($('.dataLabelsSVG text').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            element = powerbitests.helpers.testDom('120', '100');
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            data.metadata.objects = {
                labels: {
                    show: true,
                }
            };
            var dataChangedOptions = {
                dataViews: [data]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.dataLabelsSVG text').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("dataLabelUtils tests", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('display units formatting values : Auto', function () {
            var value = 20000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 0;
            labelSettings.precision = 0;
            var formatter = powerbi.visuals.valueFormatter.create(DataLabelUtils.getLabelFormatterOptions(labelSettings));
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("20000");
        });
        it('display units formatting values : K', function () {
            var value = 20000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 10000;
            labelSettings.precision = 0;
            var formatter = powerbi.visuals.valueFormatter.create(DataLabelUtils.getLabelFormatterOptions(labelSettings));
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("20K");
        });
        it('display units formatting values : M', function () {
            var value = 200000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000;
            labelSettings.precision = 1;
            var formatter = powerbi.visuals.valueFormatter.create(DataLabelUtils.getLabelFormatterOptions(labelSettings));
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("0.2M");
        });
        it('display units formatting values : B', function () {
            var value = 200000000000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000000;
            labelSettings.precision = 0;
            var formatter = powerbi.visuals.valueFormatter.create(DataLabelUtils.getLabelFormatterOptions(labelSettings));
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("200bn");
        });
        it('display units formatting values : T', function () {
            var value = 200000000000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000000000;
            labelSettings.precision = 1;
            var formatter = powerbi.visuals.valueFormatter.create(DataLabelUtils.getLabelFormatterOptions(labelSettings));
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("0.2T");
        });
    });
    describe("dataLabelUtils Test enumerate ctegory labels", function () {
        it('test default values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, true);
            var objectsNoColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, false);
            expect(objectsWithColor[0].properties['show']).toBe(false);
            expect(objectsNoColor[0].properties['show']).toBe(false);
            expect(objectsWithColor[0].properties['color']).toBe(labelSettings.labelColor);
            expect(objectsNoColor[0].properties['color']).toBeUndefined();
        });
        it('test custom values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            labelSettings.show = true;
            labelSettings.labelColor = '#FF0000';
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, true);
            expect(objectsWithColor[0].properties['show']).toBe(true);
            expect(objectsWithColor[0].properties['color']).toBe('#FF0000');
        });
        it('test category labels objetcs for donut chart', function () {
            var labelSettings = DataLabelUtils.getDefaultDonutLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, false, true);
            expect(objectsWithColor[0].properties['show']).toBe(labelSettings.showCategory);
        });
        it('test null values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            var donutLabelSettings = DataLabelUtils.getDefaultDonutLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(null, true);
            var donutObjectsWithColor = DataLabelUtils.enumerateCategoryLabels(null, false, true);
            expect(objectsWithColor[0].properties['show']).toBe(labelSettings.show);
            expect(objectsWithColor[0].properties['color']).toBe(labelSettings.labelColor);
            expect(donutObjectsWithColor[0].properties['show']).toBe(donutLabelSettings.showCategory);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataRoleHelper = powerbi.visuals.DataRoleHelper;
    var DataViewTransform = powerbi.data.DataViewTransform;
    describe("dataRoleHelper tests", function () {
        it('getMeasureIndexOfRole with roles validation', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [1, 2, 3],
                        subtotal: 6
                    }, {
                        source: dataViewMetadata.columns[3],
                        values: [4, 5, 6],
                        subtotal: 15
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(0);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
            expect(result).toBe(2);
        });
        it('getMeasureIndexOfRole without roles validation', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [1, 2, 3],
                        subtotal: 6
                    }, {
                        source: dataViewMetadata.columns[3],
                        values: [4, 5, 6],
                        subtotal: 15
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
            expect(result).toBe(-1);
        });
        it('getMeasureIndexOfRole without roles validation with default', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [1, 2, 3],
                        subtotal: 6
                    }, {
                        source: dataViewMetadata.columns[3],
                        values: [4, 5, 6],
                        subtotal: 15
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size", 0);
            expect(result).toBe(0);
        });
        it('getMeasureIndexOfRole without roles validation with default too few measures', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "2nd measure", 1);
            expect(result).toBe(-1);
        });
        it('hasRoleInDataView', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(DataRoleHelper.hasRoleInDataView(dataView, 'Series')).toBe(true);
            expect(DataRoleHelper.hasRoleInDataView(dataView, 'Category')).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var DataViewTransform = powerbi.data.DataViewTransform;
    describe('InvalidDataValuesCheckerTests', function () {
        var categoryValues = ['a', 'b', 'c', 'd', 'e'];
        var categoryIdentities = categoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'stringColumn',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'numberColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'dateTimeColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */)
                }
            ]
        };
        function getDataViewForValueWarning(values) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: categoryValues,
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: values,
                    }])
                }
            };
            return dataView;
        }
        it('empty values does not display a warning all supported.', function () {
            var dataView = getDataViewForValueWarning([]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it('empty values does not display a warning none supported.', function () {
            var dataView = getDataViewForValueWarning([]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it('single value does not display a warning all supported.', function () {
            var dataView = getDataViewForValueWarning([300]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it('single value does not display a warning none supported.', function () {
            var dataView = getDataViewForValueWarning([300]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it('NaN value does not display a warning when supported.', function () {
            var dataView = getDataViewForValueWarning([NaN]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it('NaN value does not display a warning when others not supported.', function () {
            var dataView = getDataViewForValueWarning([NaN]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, false, false);
            expect(warnings.length).toBe(0);
        });
        it('NaN value displays a warning when not supported.', function () {
            var dataView = getDataViewForValueWarning([NaN]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('NaNNotSupported');
        });
        it('NaN value displays a warning when not supported but others are supported.', function () {
            var dataView = getDataViewForValueWarning([NaN]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('NaNNotSupported');
        });
        it('Negative infinity value does not display a warning when supported.', function () {
            var dataView = getDataViewForValueWarning([Number.NEGATIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it('Negative infinity value does not display a warning when others not supported.', function () {
            var dataView = getDataViewForValueWarning([Number.NEGATIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, false);
            expect(warnings.length).toBe(0);
        });
        it('Negative infinity value displays a warning when not supported.', function () {
            var dataView = getDataViewForValueWarning([Number.NEGATIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            var i = 0;
            expect(warnings[i++].code).toBe('InfinityValuesNotSupported');
        });
        it('Negative infinity value displays a warning when not supported but others are supported.', function () {
            var dataView = getDataViewForValueWarning([Number.NEGATIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, false, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('InfinityValuesNotSupported');
        });
        it('Positive infinity value does not display a warning when supported.', function () {
            var dataView = getDataViewForValueWarning([Number.POSITIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it('Positive infinity value does not display a warning when others not supported.', function () {
            var dataView = getDataViewForValueWarning([Number.POSITIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, true);
            expect(warnings.length).toBe(0);
        });
        it('Postive infinity value displays a warning when not supported.', function () {
            var dataView = getDataViewForValueWarning([Number.POSITIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('InfinityValuesNotSupported');
        });
        it('Positive infinity value displays a warning when not supported but others are supported.', function () {
            var dataView = getDataViewForValueWarning([Number.POSITIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('InfinityValuesNotSupported');
        });
        it('Out of range value displays a warning when others are supported.', function () {
            var dataView = getDataViewForValueWarning([1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('ValuesOutOfRange');
        });
        it('Negative out of range value displays a warning when others are supported.', function () {
            var dataView = getDataViewForValueWarning([-27e300]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('ValuesOutOfRange');
        });
        it('Out of range value displays a warning when others are not supported.', function () {
            var dataView = getDataViewForValueWarning([1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('ValuesOutOfRange');
        });
        it('Negative out of range value displays a warning when others are not supported.', function () {
            var dataView = getDataViewForValueWarning([1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe('ValuesOutOfRange');
        });
        it('NaN and infinity sends warning for both when all not supported', function () {
            var dataView = getDataViewForValueWarning([NaN, Number.POSITIVE_INFINITY]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(2);
            var i = 0;
            expect(warnings[i++].code).toBe('NaNNotSupported');
            expect(warnings[i++].code).toBe('InfinityValuesNotSupported');
        });
        it('NaN and infinity and out of range sends warning for all when all not supported', function () {
            var dataView = getDataViewForValueWarning([NaN, Number.POSITIVE_INFINITY, 1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var i = 0;
            expect(warnings[i++].code).toBe('NaNNotSupported');
            expect(warnings[i++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[i++].code).toBe('ValuesOutOfRange');
        });
        it('NaN and infinity and out of range sends warning for all when all not supported has no duplications', function () {
            var dataView = getDataViewForValueWarning([NaN, Number.POSITIVE_INFINITY, NaN, 1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('NaN and infinity and out of range sends warning for all when Infinity supported has no infinity warning', function () {
            var dataView = getDataViewForValueWarning([NaN, Number.POSITIVE_INFINITY, NaN, 1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, true);
            expect(warnings.length).toBe(2);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('NaN and infinity and out of range sends warning for all with good values at the beginning', function () {
            var dataView = getDataViewForValueWarning([100, 200, 300, 400, NaN, Number.POSITIVE_INFINITY, NaN, 1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('NaN and infinity and out of range sends warning for all with good values throughout', function () {
            var dataView = getDataViewForValueWarning([100, 200, NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('Multiple dataViews both good does not show a warning', function () {
            var dataView = getDataViewForValueWarning([100, 200, 500]);
            var dataView2 = getDataViewForValueWarning([200, 300, 400]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it('Multiple dataviews first has invalid shows warnings', function () {
            var dataView = getDataViewForValueWarning([100, 200, NaN,]);
            var dataView2 = getDataViewForValueWarning([100, 200, 300]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(1);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
        });
        it('Multiple datasets last has invalid values shows warnings', function () {
            var dataView = getDataViewForValueWarning([100, 200, 300, 400]);
            var dataView2 = getDataViewForValueWarning([100, 200, NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('Multiple dataViews both have invalid values shows correct warning', function () {
            var dataView = getDataViewForValueWarning([100, 200, Number.NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500]);
            var dataView2 = getDataViewForValueWarning([Number.NEGATIVE_INFINITY, Number.NaN, 300, 1e301]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
        it('Multiple dataViews both have invalid values not overlapping shows correct warning', function () {
            var dataView = getDataViewForValueWarning([100, 200, 300, Number.POSITIVE_INFINITY, 400, 1e301, 500]);
            var dataView2 = getDataViewForValueWarning([Number.NEGATIVE_INFINITY, Number.NaN, 300]);
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe('NaNNotSupported');
            expect(warnings[index++].code).toBe('InfinityValuesNotSupported');
            expect(warnings[index++].code).toBe('ValuesOutOfRange');
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ListViewFactory = powerbi.visuals.ListViewFactory;
    var DefaultRenderTime = 10;
    describe("List view tests", function () {
        var element;
        var rowExit = function (rowSelection) {
            rowSelection.remove();
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('200', '200');
        });
        function generateNestedData(tuples) {
            var testData = [];
            for (var i = 0; i < tuples.length; i++) {
                testData.push({
                    id: i,
                    children: [{ name: tuples[i].first }, { name: tuples[i].second }]
                });
            }
            return testData;
        }
        function createHTMLListViewOptions() {
            var rowEnter = function (rowSelection) {
                rowSelection.append('div').style('height', '30px').classed('item', true).selectAll('span').data(function (d) {
                    return d.children;
                }).enter().append("span");
            };
            var rowUpdate = function (rowSelection) {
                rowSelection.selectAll('.item').selectAll('span').text(function (d) {
                    return '-->' + d.name;
                });
            };
            return {
                enter: rowEnter,
                exit: rowExit,
                update: rowUpdate,
                loadMoreData: function () {
                },
                baseContainer: d3.select(element.get(0)),
                rowHeight: 30,
                viewport: { height: 200, width: 200 }
            };
        }
        function createSVGListViewOptions() {
            var rowEnterSVG = function (rowSelection) {
                rowSelection.append('g').style('height', '30px').classed('item', true).selectAll('g').data(function (d) {
                    return d.children;
                }).enter().append("span").classed('column', true);
            };
            var rowUpdateSVG = function (rowSelection) {
                rowSelection.selectAll('.item').selectAll('.column').text(function (d) {
                    return '-->' + d.name;
                });
            };
            return {
                enter: rowEnterSVG,
                exit: rowExit,
                update: rowUpdateSVG,
                loadMoreData: function () {
                },
                baseContainer: d3.select(element.get(0)),
                rowHeight: 30,
                viewport: { height: 200, width: 200 }
            };
        }
        function createHTMLListView(options) {
            var data = generateNestedData([
                { first: 'Mickey', second: 'Mouse' },
                { first: 'Mini', second: 'Mouse' },
                { first: 'Daffy', second: 'Duck' },
                { first: 'Captain', second: 'Planet' },
                { first: 'Russell', second: 'Wilson' },
                { first: 'Jack', second: 'Sparrow' },
                { first: 'James', second: 'Bond' },
                { first: 'Sea', second: 'Hawks' },
                { first: 'Sachin', second: 'Patney' },
            ]);
            var listView = ListViewFactory.createHTMLListView(options);
            listView.data(data, function (d) { return d.id; }).render(true);
        }
        function createSVGLListView(options) {
            var data = generateNestedData([
                { first: 'Mickey', second: 'Mouse' },
                { first: 'Mini', second: 'Mouse' },
                { first: 'Daffy', second: 'Duck' },
                { first: 'Captain', second: 'Planet' },
                { first: 'Russell', second: 'Wilson' },
                { first: 'Jack', second: 'Sparrow' },
                { first: 'James', second: 'Bond' },
                { first: 'Sea', second: 'Hawks' },
                { first: 'Sachin', second: 'Patney' },
            ]);
            var listView = ListViewFactory.createSVGListView(options);
            listView.data(data, function (d) {
                return d.id;
            }).render(true);
        }
        it('Create HTML List View Correctly', function (done) {
            createHTMLListView(createHTMLListViewOptions());
            setTimeout(function () {
                var itemCount = element.find('.item').length;
                expect(itemCount).toBeGreaterThan(0);
                expect(itemCount).toBeLessThan(9); // Some should be virtualized, so shouldn't show all 9 items
                done();
            }, DefaultRenderTime);
        });
        it('Create SVG List View Correctly', function (done) {
            createSVGLListView(createSVGListViewOptions());
            setTimeout(function () {
                var itemCount = element.find('.item').length;
                expect(itemCount).toBeGreaterThan(0);
                expect(itemCount).toBeLessThan(9); // Some should be virtualized, so shouldn't show all 9 items
                done();
            }, DefaultRenderTime);
        });
        it('Scroll to last to check if items come in view HTML', function (done) {
            var options = createHTMLListViewOptions();
            var spy = spyOn(options, "loadMoreData");
            createHTMLListView(options);
            var lastElem = element.find('.item').last().text();
            expect(lastElem).not.toEqual('-->Sachin-->Patney');
            element.scrollTop(1000);
            setTimeout(function () {
                var lastElem2 = element.find('.item').last().text();
                expect(lastElem2).toEqual('-->Sachin-->Patney');
                expect(spy).toHaveBeenCalled();
                done();
            }, DefaultRenderTime);
        });
        it('Scroll to last to check if items come in view SVG', function (done) {
            var options = createSVGListViewOptions();
            var spy = spyOn(options, "loadMoreData");
            createSVGLListView(options);
            var lastElem = element.find('.item').last().text();
            expect(lastElem).not.toEqual('-->Sachin-->Patney');
            element.scrollTop(1000);
            setTimeout(function () {
                var lastElem2 = element.find('.item').last().text();
                expect(lastElem2).toEqual('-->Sachin-->Patney');
                expect(spy).toHaveBeenCalled();
                done();
            }, DefaultRenderTime);
        });
        it('Reset scrollbar position when ResetScrollbar flag is set', function (done) {
            var options = createHTMLListViewOptions();
            var data = generateNestedData([
                { first: 'Mickey', second: 'Mouse' },
                { first: 'Mini', second: 'Mouse' },
                { first: 'Daffy', second: 'Duck' },
                { first: 'Captain', second: 'Planet' },
                { first: 'Russell', second: 'Wilson' },
                { first: 'Jack', second: 'Sparrow' },
                { first: 'James', second: 'Bond' },
                { first: 'Sea', second: 'Hawks' },
            ]);
            var listView = ListViewFactory.createHTMLListView(options);
            listView.data(data, function (d) { return d.id; }).render(true);
            element.scrollTop(1000);
            setTimeout(function () {
                expect(element.find('.scrollRegion').first().parent().scrollTop()).toBe(40);
                listView.data(data, function (d) { return d.id; }).render(true, false);
                expect(element.find('.scrollRegion').first().parent().scrollTop()).toBe(40);
                listView.data(data, function (d) { return d.id; }).render(true, true);
                expect(element.find('.scrollRegion').first().parent().scrollTop()).toBe(0);
                done();
            }, DefaultRenderTime);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    describe("VisualFactory", function () {
        beforeEach(function () {
            powerbitests.helpers.suppressDebugAssertFailure();
            powerbi.common.localize = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(powerbi.common.localize);
        });
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        function initVisual(v) {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var element = powerbitests.helpers.testDom('500', '500');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: undefined,
                interactivity: undefined,
                animation: undefined,
            });
        }
        function setData(v, objectDescs) {
            // full
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: ['abc', 'def'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('abc'), powerbitests.mocks.dataViewScopeIdentity('def')],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 123,
                            max: 234,
                            subtotal: 357,
                            values: [123, 234]
                        }
                    ])
                }
            }]);
            // empty
            changeData(v, objectDescs, []);
            // no categorical
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: undefined,
            }]);
            // no metadata
            changeData(v, objectDescs, [{
                metadata: undefined,
                categorical: {
                    categories: [],
                    values: undefined,
                }
            }]);
            // no categorical.values
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: ['abc', 'def'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('abc'), powerbitests.mocks.dataViewScopeIdentity('def')],
                        identityFields: [categoryColumnRef],
                    }],
                    values: undefined,
                }
            }]);
            // no categories
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: undefined,
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 123,
                            max: 123,
                            subtotal: 123,
                            values: [123]
                        }
                    ])
                }
            }]);
            // no values.values
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: ['abc', 'def'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('abc'), powerbitests.mocks.dataViewScopeIdentity('def')],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }
                    ])
                }
            }]);
            // no categories.values
            changeData(v, objectDescs, [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: [],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }
                    ])
                }
            }]);
        }
        function changeData(v, objectDescs, dataViews) {
            v.onDataChanged({ dataViews: dataViews });
            if (v.enumerateObjectInstances && objectDescs) {
                for (var objectName in objectDescs)
                    v.enumerateObjectInstances({ objectName: objectName });
            }
        }
        it('VisualFactory.getVisuals - categorical - various dataViews', function () {
            var allVisuals = powerbi.visuals.visualPluginFactory.create().getVisuals();
            for (var i = 0; i < allVisuals.length; i++) {
                var vizPlugin = allVisuals[i];
                if (vizPlugin.capabilities && vizPlugin.capabilities.dataViewMappings && vizPlugin.capabilities.dataViewMappings.length > 0 && vizPlugin.capabilities.dataViewMappings[0].categorical) {
                    var v = vizPlugin.create();
                    try {
                        initVisual(v);
                        setData(v, vizPlugin.capabilities.objects);
                    }
                    catch (e) {
                        expect(vizPlugin.name + ' : ' + e.message).toBe('passed');
                    }
                }
            }
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var SelectionId = powerbi.visuals.SelectionId;
    var Selector = powerbi.data.Selector;
    describe("SelectionId tests", function () {
        var categoryA = powerbitests.mocks.dataViewScopeIdentity("A");
        var categoryB = powerbitests.mocks.dataViewScopeIdentity("B");
        var seriesa = powerbitests.mocks.dataViewScopeIdentity("a");
        var seriesb = powerbitests.mocks.dataViewScopeIdentity("b");
        var measure1 = "measure1";
        var measure2 = "measure2";
        var idA = SelectionId.createWithId(categoryA);
        var idB = SelectionId.createWithId(categoryB);
        var ida = SelectionId.createWithId(seriesa);
        var idb = SelectionId.createWithId(seriesb);
        var id1 = SelectionId.createWithMeasure(measure1);
        var id2 = SelectionId.createWithMeasure(measure2);
        var idAa = SelectionId.createWithIds(categoryA, seriesa);
        var idAb = SelectionId.createWithIds(categoryA, seriesb);
        var idBa = SelectionId.createWithIds(categoryB, seriesa);
        var idA1 = SelectionId.createWithIdAndMeasure(categoryA, measure1);
        var idA2 = SelectionId.createWithIdAndMeasure(categoryA, measure2);
        var idB1 = SelectionId.createWithIdAndMeasure(categoryB, measure1);
        it('SelectionId equals single identifier', function () {
            expect(idA.equals(SelectionId.createWithId(categoryA))).toBe(true);
            expect(idA.equals(idB)).toBe(false);
            expect(ida.equals(SelectionId.createWithId(seriesa))).toBe(true);
            expect(ida.equals(idb)).toBe(false);
            expect(id1.equals(SelectionId.createWithMeasure(measure1))).toBe(true);
            expect(id1.equals(id2)).toBe(false);
        });
        it('SelectionId equals two identifiers', function () {
            expect(idAa.equals(SelectionId.createWithIds(categoryA, seriesa))).toBe(true);
            expect(idAa.equals(idAb)).toBe(false);
            expect(idAa.equals(idBa)).toBe(false);
            expect(idAa.equals(idA1)).toBe(false);
            expect(idA1.equals(SelectionId.createWithIdAndMeasure(categoryA, measure1))).toBe(true);
            expect(idA1.equals(idA2)).toBe(false);
            expect(idA1.equals(idB1)).toBe(false);
            expect(idA1.equals(idAa)).toBe(false);
        });
        it('SelectionId equals different identifiers', function () {
            expect(idA.equals(ida)).toBe(false);
            expect(idA.equals(idAa)).toBe(false);
            expect(idA.equals(idA1)).toBe(false);
            expect(idb.equals(id1)).toBe(false);
            expect(idb.equals(idAb)).toBe(false);
            expect(id1.equals(idA)).toBe(false);
            expect(id1.equals(idA1)).toBe(false);
        });
        it('SelectionId includes with category', function () {
            expect(idA.includes(idA)).toBe(true);
            expect(idA.includes(idAb)).toBe(true);
            expect(idA.includes(idA1)).toBe(true);
            expect(idA.includes(idB)).toBe(false);
            expect(idA.includes(ida)).toBe(false);
            expect(idA.includes(id1)).toBe(false);
        });
        it('SelectionId includes with series', function () {
            expect(ida.includes(ida)).toBe(true);
            expect(ida.includes(idAa)).toBe(true);
            expect(ida.includes(idA)).toBe(false);
            expect(ida.includes(idb)).toBe(false);
            expect(ida.includes(id1)).toBe(false);
        });
        it('SelectionId includes with measure', function () {
            expect(id1.includes(id1)).toBe(true);
            expect(id1.includes(idA1)).toBe(true);
            expect(id1.includes(idA)).toBe(false);
            expect(id1.includes(ida)).toBe(false);
            expect(id1.includes(id2)).toBe(false);
        });
        it('SelectionId includes with two identifiers', function () {
            expect(idAa.includes(idAa)).toBe(true);
            expect(idAa.includes(idA1)).toBe(false);
            expect(idAa.includes(idA)).toBe(false);
            expect(idA1.includes(idA1)).toBe(true);
            expect(idA1.includes(idA)).toBe(true);
            expect(idAa.includes(idBa)).toBe(false);
            expect(idA1.includes(idB1)).toBe(false);
        });
        it('SelectionId createNull', function () {
            var selectionId = SelectionId.createNull();
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: null, highlight: false }));
        });
        it('SelectionId createWithId', function () {
            var selectionId = SelectionId.createWithId(categoryA);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA] }), highlight: false }));
        });
        it('SelectionId createWithMeasure', function () {
            var selectionId = SelectionId.createWithMeasure(measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ metadata: measure1 }), highlight: false }));
        });
        it('SelectionId createWithIdAndMeasure', function () {
            var selectionId = SelectionId.createWithIdAndMeasure(categoryA, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
        });
        it('SelectionId createWithIds', function () {
            var selectionId = SelectionId.createWithIds(categoryA, seriesa);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa] }), highlight: false }));
        });
        it('SelectionId createWithIds: with duplicates', function () {
            var selectionId = SelectionId.createWithIds(categoryA, categoryA);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA] }), highlight: false }));
        });
        it('SelectionId createWithIdsAndMeasure', function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(undefined, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [seriesa], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(categoryA, undefined, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, undefined);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa] }), highlight: false }));
        });
        it('SelectionId createWithIdsAndMeasure: with duplicates', function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, categoryA, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
        });
        it('SelectionId createWithHighlight', function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa], metadata: measure1 }), highlight: false }));
            var selectionIdWithHighlight = SelectionId.createWithHighlight(selectionId);
            expect(selectionIdWithHighlight.getSelector()).toBe(selectionId.getSelector());
            expect(selectionIdWithHighlight.getKey()).not.toBe(selectionId.getKey());
        });
        it('SelectionId creates using undefined', function () {
            var nullKey = SelectionId.createNull().getKey();
            var ids = SelectionId.createWithIdAndMeasure(undefined, undefined);
            expect(ids.getKey()).toEqual(nullKey);
            var idAndMeasure = SelectionId.createWithIdAndMeasure(undefined, undefined);
            expect(idAndMeasure.getKey()).toEqual(nullKey);
            var idsAndMeasure = SelectionId.createWithIdsAndMeasure(undefined, undefined, undefined);
            expect(idsAndMeasure.getKey()).toEqual(nullKey);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var Shapes = powerbi.visuals.shapes;
    var Point = powerbi.visuals.shapes.Point;
    var Size = powerbi.visuals.shapes.Size;
    var Rect = powerbi.visuals.shapes.Rect;
    var Thickness = powerbi.visuals.shapes.Thickness;
    var Vector = powerbi.visuals.shapes.Vector;
    describe("Point tests", function () {
        var pointA;
        it("offset with positive value", function () {
            var pointA = { x: 10, y: 10 };
            var offset = Point.offset(pointA, 20, 25);
            expect(offset.x).toBe(30);
            expect(offset.y).toBe(35);
        });
        it("offset with negative value", function () {
            var pointA = { x: 100, y: 100 };
            var offset = Point.offset(pointA, -20, -25);
            expect(offset.x).toBe(80);
            expect(offset.y).toBe(75);
        });
        it("Check equals - return true", function () {
            var pointA = { x: 100, y: 100 };
            var pointB = { x: 100, y: 100 };
            var offset = Point.equals(pointA, pointB);
            expect(offset).toBe(true);
        });
        it("Check equals - return false", function () {
            var pointA = { x: 100, y: 100 };
            var pointB = { x: 50, y: 100 };
            var offset = Point.equals(pointA, pointB);
            expect(offset).toBe(false);
        });
        it("Check clone", function () {
            var point = { x: 100, y: 100 };
            var clonePoint = Point.clone(point);
            expect(clonePoint.x).toBe(point.x);
            expect(clonePoint.y).toBe(point.y);
        });
        it("Point - To String", function () {
            var point = { x: 100, y: 100 };
            var pointToString = Point.toString(point);
            expect(pointToString).toBe("{x:100, y:100}");
        });
        it("Check Serialize", function () {
            var point = { x: 200, y: 200 };
            var pointSerialize = Point.serialize(point);
            expect(pointSerialize).toBe("200,200");
        });
        it("Check Distance ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 250, y: 300 };
            var distance = Point.getDistance(pointA, pointB);
            var calculatedDistance = Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + (Math.pow(pointB.y - pointA.y, 2)));
            expect(distance).toBe(calculatedDistance);
        });
        it("Check Distance (null values)", function () {
            pointA = null;
            var pointB = { x: 150, y: 200 };
            var distance = Point.getDistance(pointA, pointB);
            expect(distance).toBe(null);
        });
        it("Check zero Distance ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 200, y: 200 };
            var distance = Point.getDistance(pointA, pointB);
            expect(distance).toBe(0);
        });
        it("Equals (static) - return true ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(pointA, pointB);
            expect(arePointsEqual).toBe(true);
        });
        it("Equals (static) - point A is null ", function () {
            var pointB = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(null, pointB);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals (static) - point B is null ", function () {
            var pointA = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(pointA, null);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals (static) - points are null ", function () {
            var arePointsEqual = Point.equals(null, null);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals with Precision - return true ", function () {
            var pointA = { x: 200.23, y: 200.32 };
            var pointB = { x: 200.23, y: 200.32 };
            var arePointsEqual = Shapes.Point.equalWithPrecision(pointA, pointB);
            expect(arePointsEqual).toBe(true);
        });
        it("Parse Point (from string no default value)", function () {
            var pointStr = "200,215";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA.x).toBe(200);
            expect(pointA.y).toBe(215);
        });
        it("Parse Point (from string,2 points)", function () {
            var pointStr = "190,220";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (from string,2 points (default value ignored)", function () {
            var pointStr = "190,220";
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(pointStr, defaultValue);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (from empty string)", function () {
            var pointStr = "";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA).toBe(null);
        });
        it("Parse Point - from empty string (default value taken)", function () {
            var pointStr = "";
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(pointStr, defaultValue);
            expect(pointA.x).toBe(defaultValue.x);
            expect(pointA.y).toBe(defaultValue.y);
        });
        it("Parse Point (from int array)", function () {
            var intArray = [190, 220];
            var pointA = Point.parsePoint(intArray);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point - from int array (default value ignored)", function () {
            var intArray = [190, 220];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (int with more than 2 elements)", function () {
            var intArray = [190, 220, 200, 210];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point (int with more than 2 elements (default value taken)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { x: 110, y: 100 };
            pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point (int with one element)", function () {
            var intArray = [190];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point - int with one element (default value taken)", function () {
            var intArray = [190];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(defaultValue.x);
            expect(pointA.y).toBe(defaultValue.y);
        });
        it("Parse Point (int with empty array)", function () {
            var intArray = [];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point  - not string and not array)", function () {
            var num = true;
            var pointA = Point.parsePoint(num);
            expect(pointA).toBe(null);
        });
        it("Parse Point - not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(num, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point - getting null", function () {
            var pointA = Point.parsePoint(null);
            expect(pointA).toBe(null);
        });
        it("Parse Point - getting null (default value taken)", function () {
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(null, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
    });
    describe("Size Tests", function () {
        it("Is Empty - true", function () {
            var size = { width: 0, height: 0 };
            var isEmpty = Size.isEmpty(size);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty - false", function () {
            var size = { width: 50, height: 50 };
            var isEmpty = Size.isEmpty(size);
            expect(isEmpty).toBe(false);
        });
        it("Check equals - return true", function () {
            var sizeA = { width: 120, height: 100 };
            var sizeB = { width: 120, height: 100 };
            var sizeEquals = Size.equals(sizeA, sizeB);
            expect(sizeEquals).toBe(true);
        });
        it("Check equals - return false", function () {
            var sizeA = { width: 120, height: 100 };
            var sizeB = { width: 120, height: 150 };
            var sizeEquals = Size.equals(sizeA, sizeB);
            expect(sizeEquals).toBe(false);
        });
        it("Check equals - null", function () {
            var size = { width: 120, height: 100 };
            var sizeEquals = Size.equals(size, null);
            expect(sizeEquals).toBe(false);
        });
        it("clone", function () {
            var size = { width: 120, height: 100 };
            var sizeCloned = Size.clone(size);
            expect(sizeCloned.width).toBe(size.width);
            expect(sizeCloned.height).toBe(size.height);
        });
        it("clone - null", function () {
            var size = null;
            var sizeCloned = Size.clone(size);
            expect(sizeCloned).toBe(null);
        });
        it("inflate - Positive values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 5, top: 10, right: 5, bottom: 10 };
            var sizeInflated = Size.inflate(size, padding);
            expect(sizeInflated.width).toBe(130);
            expect(sizeInflated.height).toBe(120);
        });
        it("inflate - Zero values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 0, top: 0, right: 0, bottom: 0 };
            var sizeInflated = Size.inflate(size, padding);
            expect(sizeInflated.width).toBe(size.width);
            expect(sizeInflated.height).toBe(size.height);
        });
        it("deflate - Positive values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 5, top: 10, right: 5, bottom: 10 };
            var sizeDeflated = Size.deflate(size, padding);
            expect(sizeDeflated.width).toBe(110);
            expect(sizeDeflated.height).toBe(80);
        });
        it("deflate - Zero values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 0, top: 0, right: 0, bottom: 0 };
            var sizeDeflated = Size.deflate(size, padding);
            expect(sizeDeflated.width).toBe(size.width);
            expect(sizeDeflated.height).toBe(size.height);
        });
        it("Combine 2 sizes", function () {
            var sizeA = { width: 70, height: 110 };
            var sizeB = { width: 30, height: 120 };
            Size.combine(sizeA, sizeB);
            var newSize = { width: 70, height: 120 };
            expect(newSize.width).toBe(70);
            expect(newSize.height).toBe(120);
        });
        it("Combine 2 sizes (A contains B)", function () {
            var sizeA = { width: 150, height: 120 };
            var sizeB = { width: 80, height: 110 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeA.width);
            expect(newSize.height).toBe(sizeA.height);
        });
        it("Combine 2 sizes (B contains A)", function () {
            var sizeA = { width: 150, height: 120 };
            var sizeB = { width: 180, height: 170 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeB.width);
            expect(newSize.height).toBe(sizeB.height);
        });
        it("Combine 2 sizes (one empty)", function () {
            var sizeA = { width: 110, height: 120 };
            var sizeB = { width: 0, height: 0 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeA.width);
            expect(newSize.height).toBe(sizeA.height);
        });
        it("To Rect", function () {
            var size = { width: 120, height: 100 };
            var sizeToRect = Size.toRect(size);
            expect(sizeToRect.left).toBe(0);
            expect(sizeToRect.top).toBe(0);
            expect(sizeToRect.width).toBe(120);
            expect(sizeToRect.height).toBe(100);
        });
        it("To string", function () {
            var size = { width: 150, height: 30 };
            var sizeToString = Size.toString(size);
            expect(sizeToString).toBe("{width:150, height:30}");
        });
        it("Equals (static) - return true ", function () {
            var SizeA = { width: 200, height: 200 };
            var SizeB = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(SizeA, SizeB);
            expect(areSizesEqual).toBe(true);
        });
        it("Equals (static) - size A is null ", function () {
            var SizeB = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(null, SizeB);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals (static) - size B is null ", function () {
            var SizeA = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(SizeA, null);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals (static) - sizes are null ", function () {
            var areSizesEqual = Size.equals(null, null);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals with Precision - return true ", function () {
            var SizeA = { width: 200.23, height: 200.32 };
            var SizeB = { width: 200.23, height: 200.32 };
            var areSizesEqual = Shapes.Size.equalWithPrecision(SizeA, SizeB);
            expect(areSizesEqual).toBe(true);
        });
        it("Parse Size (from string no default value)", function () {
            var sizeStr = "200,215";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA.width).toBe(200);
            expect(sizeA.height).toBe(215);
        });
        it("Parse Size (from string,2 points)", function () {
            var sizeStr = "190,220";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size - from string,2 points (default value ignored)", function () {
            var sizeStr = "190,220";
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(sizeStr, defaultValue);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size (from empty string)", function () {
            var sizeStr = "";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA).toBe(null);
        });
        it("Parse Size - from empty string (default value taken)", function () {
            var sizeStr = "";
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(sizeStr, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size (from int array)", function () {
            var intArray = [190, 220];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size - from int array (default value ignored)", function () {
            var intArray = [190, 220];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size (int with more than 2 elements)", function () {
            var intArray = [190, 220, 200, 210];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with more than 2 elements (default value taken)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(defaultValue.width);
            expect(sizeA.height).toBe(defaultValue.height);
        });
        it("Parse Size (int with one element)", function () {
            var intArray = [190];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with one element (default value taken)", function () {
            var intArray = [190];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(defaultValue.width);
            expect(sizeA.height).toBe(defaultValue.height);
        });
        it("Parse Size (int with empty array)", function () {
            var intArray = [];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size (not string and not array)", function () {
            var num = true;
            var sizeA = Size.parseSize(num);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(num, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size - getting null", function () {
            var sizeA = Size.parseSize(null);
            expect(sizeA).toBe(null);
        });
        it("Parse Size - getting null (default value taken)", function () {
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(null, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
    });
    describe("Rect tests", function () {
        var rectA;
        var rectB;
        var isEmpty;
        var isIntersecting;
        var defaultRect = { left: 110, top: 100, width: 150, height: 117 };
        function AreRectsEqual(rectA, rectB) {
            return (rectB.left === rectA.left && rectB.top === rectA.top && rectB.width === rectA.width && rectB.height === rectA.height);
        }
        it("Is Empty - true", function () {
            rectA = { left: 0, top: 0, width: 0, height: 0 };
            var isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty - false", function () {
            rectA = { left: 0, top: 0, width: 50, height: 20 };
            var isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(false);
        });
        it("Is Empty - null", function () {
            rectA = null;
            isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(true);
        });
        it("Is Intersecting - true", function () {
            rectA = { left: 0, top: 0, width: 200, height: 300 };
            rectB = { left: 170, top: 30, width: 300, height: 400 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(true);
        });
        it("Is Intersecting - false", function () {
            rectA = { left: 0, top: 0, width: 10, height: 10 };
            rectB = { left: 100, top: 200, width: 500, height: 400 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - first rect is null", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = null;
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - second rect is null", function () {
            rectA = null;
            rectB = { left: 0, top: 0, width: 200, height: 200 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Get offset", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = Rect.getOffset(rectA);
            expect(rectB.x).toBe(0);
            expect(rectB.y).toBe(0);
        });
        it("Get size", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = Rect.getSize(rectA);
            expect(rectB.width).toBe(200);
            expect(rectB.height).toBe(200);
        });
        it("Set size", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            var newSize = { width: 150, height: 170 };
            Rect.setSize(rectA, newSize);
            expect(rectA.width).toBe(150);
            expect(rectA.height).toBe(170);
        });
        it("Get Right (Property)", function () {
            rectA = { left: 120, top: 50, width: 200, height: 200 };
            var right = Rect.right(rectA);
            expect(right).toBe(320);
        });
        it("Get Bottom (Property)", function () {
            rectA = { left: 70, top: 130, width: 200, height: 200 };
            var bottom = Rect.bottom(rectA);
            expect(bottom).toBe(330);
        });
        it("Get TopLeft (Property)", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            var topLeft = Rect.topLeft(rectA);
            expect(topLeft.x).toBe(0);
            expect(topLeft.y).toBe(0);
        });
        it("Get TopRight (Property)", function () {
            rectA = { left: 80, top: 170, width: 150, height: 220 };
            var topRight = Rect.topRight(rectA);
            expect(topRight.x).toBe(230);
            expect(topRight.y).toBe(170);
        });
        it("Get BottomLeft (Property)", function () {
            rectA = { left: 0, top: 10, width: 30, height: 220 };
            var bottomLeft = Rect.bottomLeft(rectA);
            expect(bottomLeft.x).toBe(rectA.left);
            expect(bottomLeft.y).toEqual(rectA.top + rectA.height);
        });
        it("Get BottomRight (Property)", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            var bottomRight = Rect.bottomRight(rectA);
            expect(bottomRight.x).toBe(250);
            expect(bottomRight.y).toBe(360);
        });
        it("Check equals - return true", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            rectB = { left: 50, top: 90, width: 200, height: 270 };
            var rectEquals = Rect.equals(rectA, rectB);
            expect(rectEquals).toBe(true);
        });
        it("Check equals - return false", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            rectB = { left: 50, top: 90, width: 250, height: 270 };
            var rectEquals = Rect.equals(rectA, rectB);
            expect(rectEquals).toBe(false);
        });
        it("Check equals - null", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectEquals = Rect.equals(rectA, null);
            expect(rectEquals).toBe(false);
        });
        it("Clone", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.clone(rectA);
            expect(AreRectsEqual(rectA, rectB)).toBe(true);
        });
        it("Rect ToString", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectToString = "{left:70, top:90, width:130, height:270}";
            expect(Rect.toString(rectA)).toBe(rectToString);
        });
        it("Rect offset - Positive Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectB = Rect.offset(rectA, 30, 30);
            expect(rectB.left).toBe(rectA.left + 30);
            expect(rectB.top).toBe(rectA.top + 30);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect offset - Zero Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectB = Rect.offset(rectA, 0, 0);
            expect(rectB.left).toBe(rectA.left);
        });
        it("Rect offset - Negative Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.offset(rectA, -30, -60);
            expect(rectB.left).toBe(rectA.left - 30);
            expect(rectB.top).toBe(rectA.top - 60);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect offset - Negative Offset Bigger than Top Left", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.offset(rectA, -100, -130);
            expect(rectB.left).toBe(0);
            expect(rectB.top).toBe(0);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect inflate", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 30, top: 20, right: 50, bottom: 40 };
            rectB = Rect.inflate(rectA, thickness);
            expect(rectB.left).toBe(40);
            expect(rectB.top).toBe(90);
            expect(rectB.width).toBe(210);
            expect(rectB.height).toBe(330);
        });
        it("Rect inflate - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 0, top: 0, right: 0, bottom: 0 };
            rectB = Rect.inflate(rectA, thickness);
            expect(rectB.left).toBe(70);
            expect(rectB.top).toBe(110);
            expect(rectB.width).toBe(130);
            expect(rectB.height).toBe(270);
        });
        it("Rect deflate", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 30, top: 20, right: 50, bottom: 40 };
            rectB = Rect.deflate(rectA, thickness);
            expect(rectB.left).toBe(100);
            expect(rectB.top).toBe(130);
            expect(rectB.width).toBe(50);
            expect(rectB.height).toBe(210);
        });
        it("Rect deflate - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 0, top: 0, right: 0, bottom: 0 };
            rectB = Rect.deflate(rectA, thickness);
            expect(rectB.left).toBe(70);
            expect(rectB.top).toBe(110);
            expect(rectB.width).toBe(130);
            expect(rectB.height).toBe(270);
        });
        it("Rect inflateBy", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.inflateBy(rectA, 20);
            expect(rectA.left).toBe(50);
            expect(rectA.top).toBe(90);
            expect(rectA.width).toBe(170);
            expect(rectA.height).toBe(310);
        });
        it("Rect inflateBy - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.inflateBy(rectA, 0);
            expect(rectA.left).toBe(70);
            expect(rectA.top).toBe(110);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(270);
        });
        it("Rect deflateBy", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.deflateBy(rectA, 30);
            expect(rectA.left).toBe(100);
            expect(rectA.top).toBe(140);
            expect(rectA.width).toBe(70);
            expect(rectA.height).toBe(210);
        });
        it("Rect deflateBy - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.deflateBy(rectA, 0);
            expect(rectA.left).toBe(70);
            expect(rectA.top).toBe(110);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(270);
        });
        it("Contains Point - Return true", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var newPoint = { x: 100, y: 140 };
            var isContains = Shapes.Rect.containsPoint(rectA, newPoint);
            expect(isContains).toBe(true);
        });
        it("Contains Point - Return false", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var newPoint = { x: 220, y: 170 };
            var isContains = Shapes.Rect.containsPoint(rectA, newPoint);
            expect(isContains).toBe(false);
        });
        it("Contains Point - null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var isContains = Shapes.Rect.containsPoint(rectA, null);
            expect(isContains).toBe(false);
        });
        it("Is Intersecting - Return true", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 70, top: 150, width: 130, height: 320 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(true);
        });
        it("Is Intersecting - Return false", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 30, top: 20, width: 20, height: 20 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - first null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = null;
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - second null", function () {
            rectA = null;
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A Contains B", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 90, top: 140, width: 20, height: 20 };
            //var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect B Contains A", function () {
            rectA = { left: 110, top: 150, width: 30, height: 25 };
            rectB = { left: 90, top: 140, width: 100, height: 120 };
            //    var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A Intersect B", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 90, top: 130, width: 80, height: 70 };
            //    var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A don't Intersect B", function () {
            rectA = { left: 0, top: 0, width: 20, height: 30 };
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            //    var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A is null", function () {
            rectA = null;
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            //    var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect B is null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = null;
            //    var intersectingRect = Shapes.Rect.intersect(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Combine 2 rects", function () {
            rectA = { left: 50, top: 50, width: 50, height: 50 };
            rectB = { left: 60, top: 60, width: 60, height: 60 };
            var newRect = Rect.combine(rectA, rectB);
            var newRectCalculated = { left: 50, top: 50, width: 70, height: 70 };
            expect(AreRectsEqual(newRectCalculated, newRect)).toBe(true);
        });
        it("Combine 2 rects (A contains B)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 160, top: 160, width: 10, height: 10 };
            var newRect = Rect.combine(rectA, rectB);
            expect(AreRectsEqual(rectA, newRect)).toBe(true);
        });
        it("Combine 2 rects (B contains A)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 130, top: 130, width: 50, height: 50 };
            var newRect = Rect.combine(rectA, rectB);
            expect(AreRectsEqual(newRect, rectB)).toBe(true);
        });
        it("Combine 2 rects (one empty)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 0, top: 0, width: 0, height: 0 };
            var newRect = rectA;
            Rect.combine(rectA, rectB);
            expect(AreRectsEqual(rectA, newRect)).toBe(true);
        });
        it("Parse Rect (from string no default value)", function () {
            var rectStr = "200,215,200,180";
            rectA = Rect.parseRect(rectStr);
            expect(rectA.left).toBe(200);
            expect(rectA.top).toBe(215);
            expect(rectA.width).toBe(200);
            expect(rectA.height).toBe(180);
        });
        it("Parse Rect - from string,(default value ignored)", function () {
            var rectStr = "190,220,150,170";
            rectA = Rect.parseRect(rectStr, defaultRect);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(150);
            expect(rectA.height).toBe(170);
        });
        it("Parse Rect (from empty string)", function () {
            var rectStr = "";
            rectA = Rect.parseRect(rectStr);
            expect(rectA).toBe(null);
        });
        it("Parse Rect - from empty string (default value taken)", function () {
            var rectStr = "";
            rectA = Rect.parseRect(rectStr, defaultRect);
            expect(rectA.left).toBe(defaultRect.left);
            expect(rectA.top).toBe(defaultRect.top);
            expect(rectA.width).toBe(defaultRect.width);
            expect(rectA.height).toBe(defaultRect.height);
        });
        it("Parse Rect (from int array)", function () {
            var intArray = [190, 220, 100, 150];
            rectA = Rect.parseRect(intArray);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(100);
            expect(rectA.height).toBe(150);
        });
        it("Parse Rect - from int array (default value ignored)", function () {
            var intArray = [190, 220, 130, 115];
            rectA = Rect.parseRect(intArray, defaultRect);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(115);
        });
        it("Parse Rect (int with more than 4 elements)", function () {
            var intArray = [190, 220, 200, 210, 118];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with more than 4 elements (default value ignored)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(intArray, defaultValue);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(200);
            expect(rectA.height).toBe(210);
        });
        it("Parse Rect (int with one element)", function () {
            var intArray = [190];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with one element (default value taken)", function () {
            var intArray = [190];
            rectA = Rect.parseRect(intArray, defaultRect);
            expect(rectA.left).toBe(defaultRect.left);
            expect(rectA.top).toBe(defaultRect.top);
            expect(rectA.width).toBe(defaultRect.width);
            expect(rectA.height).toBe(defaultRect.height);
        });
        it("Parse Rect (int with empty array)", function () {
            var intArray = [];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(intArray, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
        it("Parse Rect (not string and not array)", function () {
            var num = true;
            rectA = Rect.parseRect(num);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(num, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
        it("Parse Rect - getting null", function () {
            rectA = Rect.parseRect(null);
            expect(rectA).toBe(null);
        });
        it("Parse Rect - getting null (default value taken)", function () {
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(null, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
    });
    describe("Thickness tests", function () {
        var thicknessA;
        var thicknessB;
        var defaultThickness = { left: 105, top: 100, right: 122, bottom: 122 };
        it("Inflate", function () {
            thicknessA = { left: 120, top: 100, right: 150, bottom: 170 };
            thicknessB = { left: 20, top: 20, right: 20, bottom: 20 };
            var newThickness = Thickness.inflate(thicknessA, thicknessB);
            expect(newThickness.left).toBe(140);
            expect(newThickness.top).toBe(120);
            expect(newThickness.right).toBe(170);
            expect(newThickness.bottom).toBe(190);
        });
        it("Get Width", function () {
            thicknessA = { left: 115, top: 134, right: 212, bottom: 270 };
            var thicknessWidth = Thickness.getWidth(thicknessA);
            expect(thicknessWidth).toBe(327);
        });
        it("Get Width - Zero Thickness", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var thicknessWidth = Thickness.getWidth(thicknessA);
            expect(thicknessWidth).toBe(0);
        });
        it("Get Height", function () {
            thicknessA = { left: 80, top: 215, right: 212, bottom: 15 };
            var thicknessHeight = Thickness.getHeight(thicknessA);
            expect(thicknessHeight).toBe(230);
        });
        it("Get Height", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var thicknessHeight = Thickness.getHeight(thicknessA);
            expect(thicknessHeight).toBe(0);
        });
        it("Clone", function () {
            thicknessA = { left: 158, top: 150, right: 215, bottom: 412 };
            thicknessB = Thickness.clone(thicknessA);
            expect(thicknessB.left).toBe(thicknessA.left);
            expect(thicknessB.top).toBe(thicknessA.top);
            expect(thicknessB.right).toBe(thicknessA.right);
            expect(thicknessB.bottom).toBe(thicknessA.bottom);
        });
        it("Clone - null value", function () {
            thicknessA = null;
            thicknessB = Thickness.clone(thicknessA);
            expect(thicknessB).toBe(null);
        });
        it("Equals - return true", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(true);
        });
        it("Equals - return false", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 100, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Equals - first value is null", function () {
            thicknessA = null;
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Equals - second value is null", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = null;
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Flip Horizontal", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            Thickness.flipHorizontal(thicknessA);
            expect(thicknessA.left).toBe(180);
            expect(thicknessA.right).toBe(87);
            expect(thicknessA.top).toBe(156);
            expect(thicknessA.bottom).toBe(95);
        });
        it("Flip Vertical", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            Thickness.flipVertical(thicknessA);
            expect(thicknessA.left).toBe(87);
            expect(thicknessA.right).toBe(180);
            expect(thicknessA.top).toBe(95);
            expect(thicknessA.bottom).toBe(156);
        });
        it("To string", function () {
            thicknessA = { left: 158, top: 150, right: 215, bottom: 412 };
            var thicknessString = Thickness.toString(thicknessA);
            expect(thicknessString).toBe("{top:150, left:158, right:215, bottom:412}");
        });
        it("To Css String", function () {
            thicknessA = { left: 95, top: 140, right: 217, bottom: 107 };
            var thicknessString = Thickness.toCssString(thicknessA);
            expect(thicknessString).toBe("140px 217px 107px 95px");
        });
        it("Is Empty true", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var isEmpty = Thickness.isEmpty(thicknessA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty false", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            var isEmpty = Thickness.isEmpty(thicknessA);
            expect(isEmpty).toBe(false);
        });
        it("Equals (static) - return true ", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var areThicknessesEqual = Thickness.equals(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(true);
        });
        it("Equals (static) - return false ", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            thicknessB = { left: 125, top: 130, right: 110, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thickness A is null ", function () {
            var thicknessB = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(null, thicknessB);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thickness B is null ", function () {
            var thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(thicknessA, null);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thicknesses are null ", function () {
            var areThicknessesEqual = Thickness.equals(null, null);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals with Precision (static) - return true ", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            thicknessB = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Shapes.Thickness.equalWithPrecision(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(true);
        });
        it("Parse Thickness (from string no default value)", function () {
            var thicknessStr = "200,215,200,180";
            thicknessA = Thickness.parseThickness(thicknessStr);
            expect(thicknessA.left).toBe(200);
            expect(thicknessA.top).toBe(215);
            expect(thicknessA.right).toBe(200);
            expect(thicknessA.bottom).toBe(180);
        });
        it("Parse Thickness - from string,(default value ignored)", function () {
            var thicknessStr = "190,220,150,170";
            thicknessA = Thickness.parseThickness(thicknessStr, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(150);
            expect(thicknessA.bottom).toBe(170);
        });
        it("Parse Thickness (from empty string)", function () {
            var thicknessStr = "";
            thicknessA = Thickness.parseThickness(thicknessStr);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness - from empty string (default value taken)", function () {
            var thicknessStr = "";
            thicknessA = Thickness.parseThickness(thicknessStr, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (from int array)", function () {
            var intArray = [190, 220, 100, 150];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(100);
            expect(thicknessA.bottom).toBe(150);
        });
        it("Parse Thickness - from int array (default value ignored)", function () {
            var intArray = [190, 220, 130, 115];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(130);
            expect(thicknessA.bottom).toBe(115);
        });
        it("Parse Thickness (int with more than 4 elements)", function () {
            var intArray = [190, 220, 200, 210, 118];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with more than 4 elements (default value ignored)", function () {
            var intArray = [190, 220, 200, 210];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(200);
            expect(thicknessA.bottom).toBe(210);
        });
        it("Parse Thickness (int with one element)", function () {
            var intArray = [190];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with one element (default value taken)", function () {
            var intArray = [190];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (int with empty array)", function () {
            var intArray = [];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with empty array (default value taken)", function () {
            var intArray = [];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (not string and not array)", function () {
            var num = true;
            thicknessA = Thickness.parseThickness(num);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (not string and not array (default value taken)", function () {
            var num = true;
            thicknessA = Thickness.parseThickness(num, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness - getting null", function () {
            thicknessA = Thickness.parseThickness(null);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness - getting null (default value taken)", function () {
            thicknessA = Thickness.parseThickness(null, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
    });
    describe("Vector tests", function () {
        var vectorA;
        var vectorB;
        it("Is Empty true", function () {
            vectorA = { x: 0, y: 0 };
            var isEmpty = Vector.isEmpty(vectorA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty false", function () {
            vectorA = { x: 125, y: 130 };
            var isEmpty = Vector.isEmpty(vectorA);
            expect(isEmpty).toBe(false);
        });
        it("Equals - return true", function () {
            vectorA = { x: 180, y: 95 };
            vectorB = { x: 180, y: 95 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(true);
        });
        it("Equals - return false", function () {
            vectorA = { x: 180, y: 95 };
            vectorB = { x: 100, y: 180 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Equals - first value is null", function () {
            vectorA = null;
            vectorB = { x: 150, y: 117 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Equals - second value is null", function () {
            vectorA = { x: 156, y: 95 };
            vectorB = null;
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Clone", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.clone(vectorA);
            expect(vectorB.left).toBe(vectorA.left);
            expect(vectorB.top).toBe(vectorA.top);
        });
        it("Clone - null value", function () {
            vectorA = null;
            vectorB = Vector.clone(vectorA);
            expect(vectorB).toBe(null);
        });
        it("To string", function () {
            vectorA = { x: 215, y: 412 };
            var vectorString = Vector.toString(vectorA);
            expect(vectorString).toBe("{x:215, y:412}");
        });
        it("Get Length", function () {
            vectorA = { x: 215, y: 412 };
            var vectorLength = Vector.getLength(vectorA);
            var vectorLengthCalculated = Math.sqrt(215 * 215 + 412 * 412);
            expect(vectorLength).toBe(vectorLengthCalculated);
        });
        it("Get Length - Zero", function () {
            vectorA = { x: 0, y: 0 };
            var vectorLength = Vector.getLength(vectorA);
            expect(vectorLength).toBe(0);
        });
        it("Get Length Sqr", function () {
            vectorA = { x: 215, y: 412 };
            var vectorLength = Vector.getLengthSqr(vectorA);
            var vectorLengthCalculated = 215 * 215 + 412 * 412;
            expect(vectorLength).toBe(vectorLengthCalculated);
        });
        it("Get Length Sqr - Zero", function () {
            vectorA = { x: 0, y: 0 };
            var vectorLength = Vector.getLengthSqr(vectorA);
            expect(vectorLength).toBe(0);
        });
        it("Scale - Greater than 1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 15);
            expect(vectorB.x).toBe(vectorA.x * 15);
            expect(vectorB.y).toBe(vectorA.y * 15);
        });
        it("Scale -  1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 1);
            expect(vectorB.x).toBe(vectorA.x);
            expect(vectorB.y).toBe(vectorA.y);
        });
        it("Scale -  between 0 and 1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 0.4);
            expect(vectorB.x).toBe(vectorA.x * 0.4);
            expect(vectorB.y).toBe(vectorA.y * 0.4);
        });
        it("Scale -  0", function () {
            vectorA = { x: 215, y: 412 };
            ;
            vectorB = Vector.scale(vectorA, 0);
            expect(vectorB.x).toBe(0);
            expect(vectorB.y).toBe(0);
        });
        it("Scale -  Negative", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, -4);
            expect(vectorB.x).toBe(vectorA.x * -4);
            expect(vectorB.y).toBe(vectorA.y * -4);
        });
        it("Normalize", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.normalize(vectorA);
            var vectorALength = Vector.getLength(vectorA);
            var newVector = { x: vectorA.x / vectorALength, y: vectorA.y / vectorALength };
            expect(newVector.x).toBe(vectorB.x);
            expect(newVector.y).toBe(vectorB.y);
        });
        it("Normalize - empty vector", function () {
            vectorA = { x: 0, y: 0 };
            vectorB = Vector.normalize(vectorA);
            expect(vectorB.x).toBe(0);
            expect(vectorB.y).toBe(0);
        });
        it("Rotate Vector 90 degrees CW", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate90DegCW(vectorA);
            expect(vectorB.x).toBe(vectorA.y);
            expect(vectorB.y).toBe(-vectorA.x);
        });
        it("Rotate Vector 90 degrees CCW", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate90DegCCW(vectorA);
            expect(vectorB.x).toBe(-vectorA.y);
            expect(vectorB.y).toBe(vectorA.x);
        });
        /*Using the Vector rotate formula newX=(X*cosA)-(y*sinA) */
        it("Rotate - between 0 to 360 degrees", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate(vectorA, 47);
            var newVector = { x: vectorA.x * Math.cos(47) - vectorA.y * Math.sin(47), y: vectorA.x * Math.sin(47) + vectorA.y * Math.cos(47) };
            expect(vectorB.x).toBe(newVector.x);
            expect(vectorB.y).toBe(newVector.y);
        });
        it("Rotate - 0 degrees", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate(vectorA, 0);
            expect(vectorB.x).toBe(vectorA.x);
            expect(vectorB.y).toBe(vectorA.y);
        });
        it("Equals (static) - return true ", function () {
            vectorA = { x: 130, y: 47 };
            vectorB = { x: 130, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Equals (static) - return false ", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 110, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, vectorB);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vector A is null ", function () {
            vectorB = { x: 121, y: 88 };
            var areVectorsEqual = Vector.equals(null, vectorB);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vector B is null ", function () {
            vectorA = { x: 114, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, null);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vectors are null ", function () {
            var areVectorsEqual = Vector.equals(null, null);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals with Precision (static) - return true ", function () {
            vectorA = { x: 130, y: 114.4 };
            vectorB = { x: 130, y: 114.4 };
            var areVectorsEqual = Shapes.Thickness.equalWithPrecision(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Equals with Precision (static) - return false ", function () {
            vectorA = { x: 130.2, y: 114 };
            vectorB = { x: 130, y: 114 };
            var areVectorsEqual = Shapes.Thickness.equalWithPrecision(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Add 2 Vectors", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 117, y: 134 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x + vectorB.x);
            expect(newVector.y).toBe(vectorA.y + vectorB.y);
        });
        it("Add Vector to Empty Vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 0, y: 0 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x);
            expect(newVector.y).toBe(vectorA.y);
        });
        it("Add Vector to its Inverse vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: -114, y: -47 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(0);
            expect(newVector.y).toBe(0);
        });
        it("Subtract 2 Vectors", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 117, y: 134 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x - vectorB.x);
            expect(newVector.y).toBe(vectorA.y - vectorB.y);
        });
        it("Subtract Vector to Empty Vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 0, y: 0 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x);
            expect(newVector.y).toBe(vectorA.y);
        });
        it("Subtract Vector from the same vector", function () {
            vectorA = { x: 116, y: 49 };
            vectorB = { x: 116, y: 49 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(0);
            expect(newVector.y).toBe(0);
        });
        it("dotProduct", function () {
            vectorA = { x: 116, y: 49 };
            vectorA = { x: 140, y: 154 };
            var dotProduct = Shapes.Vector.dotProduct(vectorA, vectorB);
            var dotProductCalculated = vectorA.x * vectorB.x + vectorA.y * vectorB.y;
            expect(dotProduct).toBe(dotProductCalculated);
        });
        it("Delta Vector", function () {
            var pointA = { x: 145, y: 217 };
            var pointB = { x: 140, y: 154 };
            var vectorA = Shapes.Vector.getDeltaVector(pointA, pointB);
            expect(vectorA.x).toBe(pointB.x - pointA.x);
            expect(vectorA.y).toBe(pointB.y - pointA.y);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var SVGUtil = powerbi.visuals.SVGUtil;
describe("SvgUtil tests", function () {
    it('validate the pie chart transform parsing logic for Chrome', function () {
        var transform = 'translate(110.21,46.5)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.21');
        expect(parsedTransform.y).toBe('46.5');
    });
    it('validate the pie chart transform parsing logic for IE', function () {
        var transform = 'translate(110.6 34.56)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.6');
        expect(parsedTransform.y).toBe('34.56');
    });
    it('validate transform parsing logic with no y value', function () {
        var transform = 'translate(110.6)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.6');
        expect(parsedTransform.y).toBe('0');
    });
    it('validate convertToPixelString', function () {
        var pixelString = SVGUtil.convertToPixelString(34);
        expect(pixelString).toBe('34px');
    });
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var UrlHelper = powerbi.visuals.UrlHelper;
    describe("UrlHelper isValidUrl", function () {
        var webUrlColumnMetadata = {
            displayName: 'webUrl',
            type: new powerbi.ValueType(powerbi.ExtendedType.WebUrl, 'WebUrl')
        };
        var textColumnMetadata = {
            displayName: 'text',
            type: new powerbi.ValueType(1 /* Text */, 'Text')
        };
        it('isValidUrl null', function () {
            expect(UrlHelper.isValidUrl(null, null)).toBe(false);
        });
        it('isValidUrl http', function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, 'http://www.microsoft.com')).toBe(true);
        });
        it('isValidUrl https', function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, 'https://www.microsoft.com')).toBe(true);
        });
        it('isValidUrl HTTPS', function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, 'HTTPS://WWW.MICROSOFT.COM')).toBe(true);
        });
        it('isValidUrl dataUri', function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, 'data://www.microsoft.com')).toBe(false);
        });
        it('isValidUrl not weburl', function () {
            expect(UrlHelper.isValidUrl(textColumnMetadata, 'http://www.microsoft.com')).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ContentPositions = powerbi.ContentPositions;
    var DataLabelManager = powerbi.DataLabelManager;
    var RectOrientation = powerbi.RectOrientation;
    var OutsidePlacement = powerbi.OutsidePlacement;
    function CreateSampleDataLabelInfo() {
        var element1 = {
            maximumMovingDistance: 12,
            minimumMovingDistance: 2,
            anchorMargin: 3,
            anchorRectOrientation: 0 /* None */,
            contentPosition: 2 /* TopCenter */,
            outsidePlacement: 1 /* Disallowed */,
            validContentPositions: ContentPositions.All,
            opacity: 1,
            size: { width: 45, height: 20 }
        };
        var element2 = {
            maximumMovingDistance: 12,
            minimumMovingDistance: 2,
            anchorMargin: 3,
            anchorRectOrientation: 0 /* None */,
            contentPosition: 2 /* TopCenter */,
            outsidePlacement: 1 /* Disallowed */,
            validContentPositions: ContentPositions.All,
            opacity: 1,
            size: { width: 45, height: 20 }
        };
        var result = [];
        result.push(element1, element2);
        return result;
    }
    describe("Default Settings", function () {
        it("Check default values are true", function () {
            var labelManager = new DataLabelManager();
            var defaultSettings = labelManager.defaultSettings;
            expect(defaultSettings.anchorMargin).toBe(0);
            expect(defaultSettings.anchorRectOrientation).toBe(0 /* None */);
            expect(defaultSettings.contentPosition).toBe(128 /* BottomCenter */);
            expect(defaultSettings.maximumMovingDistance).toBe(12);
            expect(defaultSettings.minimumMovingDistance).toBe(3);
            expect(defaultSettings.opacity).toBe(1);
            expect(defaultSettings.outsidePlacement).toBe(1 /* Disallowed */);
            expect(defaultSettings.validContentPositions).toBe(128 /* BottomCenter */);
        });
    });
    describe("Get Label info - One value provided", function () {
        it("Get Label info", function () {
            var labelManager = new DataLabelManager();
            var defaultSettings = labelManager.defaultSettings;
            var result = { minimumMovingDistance: 10 };
            result = labelManager.getLabelInfo(result);
            expect(defaultSettings.minimumMovingDistance).toEqual(3);
            expect(result.minimumMovingDistance).toEqual(10);
        });
        it("Get Label info - all values Provided", function () {
            var labelManager = new DataLabelManager();
            var defaultSettings = labelManager.defaultSettings;
            var result = CreateSampleDataLabelInfo();
            labelManager.getLabelInfo(result);
            expect(defaultSettings.anchorMargin).toEqual(0);
            expect(result[0].maximumMovingDistance).toEqual(12);
        });
        it("Get Label info - Default value should be taken", function () {
            var labelManager = new DataLabelManager();
            var result = {
                maximumMovingDistance: 12,
                minimumMovingDistance: 2,
                anchorRectOrientation: 0 /* None */,
                contentPosition: 2 /* TopCenter */,
                outsidePlacement: 1 /* Disallowed */,
                validContentPositions: ContentPositions.All,
                opacity: 1
            };
            var defaultSettings = labelManager.defaultSettings;
            labelManager.getLabelInfo(result);
            expect(defaultSettings.anchorMargin).toEqual(0);
            expect(result.anchorMargin).toEqual(0);
        });
    });
    describe("Is Valid Rect", function () {
        var rect;
        it("Is Valid Rect - Return true", function () {
            rect = { left: 150, top: 130, width: 120, height: 110 };
            var isValidRect = DataLabelManager.isValid(rect);
            expect(isValidRect).toBe(true);
        });
        it("Is Valid Rect - Negative values", function () {
            rect = { left: -150, top: -130, width: -120, height: -110 };
            var isValidRect = DataLabelManager.isValid(rect);
            expect(isValidRect).toBe(false);
        });
        it("Is Valid Rect - Empty Rect", function () {
            rect = { left: 0, top: 0, width: 0, height: 0 };
            var isValidRect = DataLabelManager.isValid(rect);
            expect(isValidRect).toBe(false);
        });
        it("Is Valid Rect - null Rect", function () {
            rect = null;
            var isValidRect = DataLabelManager.isValid(rect);
            expect(isValidRect).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    describe("ValueFormatter", function () {
        var valueFormatter = powerbi.visuals.valueFormatter;
        var columnIntObjFormat = { displayName: 'col', objects: { fmtObj: { fmtProp: 'R' } } };
        var columnIntObjFormatIdentitifer = { objectName: 'fmtObj', propertyName: 'fmtProp' };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it("format null", function () {
            expect(valueFormatter.format(null)).toBe('(Blank)');
            expect(valueFormatter.formatRaw(null)).toBe('');
        });
        it("format non-null value", function () {
            var formatValue1 = valueFormatter.format(2010);
            var formatValue2 = valueFormatter.formatRaw(2010);
            expect(formatValue1).not.toBeNull();
            expect(formatValue2).not.toBeNull();
            expect(formatValue1).toBe(formatValue2);
        });
        it("format 100 pct", function () {
            expect(valueFormatter.format(1, '0.00 %;-0.00 %;0.00 %', true)).toBe('100%');
        });
        it("format 100 pct - no beautify", function () {
            expect(valueFormatter.format(1, '0.00 %;-0.00 %;0.00 %')).toBe('100.00 %');
        });
        it("format 100 pct - variation", function () {
            expect(valueFormatter.format(1, '0.0 %;-0.0 %;0.0 %', true)).toBe('100%');
        });
        it("format 52 pct - 4 decimals beautified", function () {
            // we only beautify the default format strings for percent
            expect(valueFormatter.format(0.52, '0.0000 %;-0.0000 %;0.0000 %', true)).toBe('52.0000 %');
        });
        it("format whole pct", function () {
            expect(valueFormatter.format(0.5, '0 %;-0 %;0 %', true)).toBe('50 %');
        });
        it("getFormatString: column with custom object", function () {
            expect(valueFormatter.getFormatString(columnIntObjFormat, columnIntObjFormatIdentitifer)).toBe('R');
        });
        it("getFormatString: column with custom object (unspecified)", function () {
            expect(valueFormatter.getFormatString({ displayName: 'col' }, columnIntObjFormatIdentitifer)).toBeUndefined();
        });
        it("format Boolean", function () {
            expect(valueFormatter.format(true)).toBe('True');
            expect(valueFormatter.format(false)).toBe('False');
        });
        it("format Invalids", function () {
            expect(valueFormatter.format(Number.NaN)).toBe('NaN');
            expect(valueFormatter.format(Number.NEGATIVE_INFINITY)).toBe('-Infinity');
            expect(valueFormatter.format(Number.POSITIVE_INFINITY)).toBe('+Infinity');
            var nullNumber = null;
            expect(valueFormatter.format(nullNumber)).toBe('(Blank)');
        });
        it("create basic format with invalid values", function () {
            var scale = valueFormatter.create({ format: '0', value: 0 });
            expect(scale.format(Number.NaN)).toBe('NaN');
            expect(scale.format(Number.NEGATIVE_INFINITY)).toBe('-Infinity');
            expect(scale.format(Number.POSITIVE_INFINITY)).toBe('+Infinity');
            var nullNumber = null;
            expect(scale.format(nullNumber)).toBe('(Blank)');
        });
        it("create non-null/null init", function () {
            var scale = valueFormatter.create({ format: '0', value: 1e6, value2: null });
            expect(scale.format(-2.4e6)).toBe('-2.4M');
        });
        it("create null/non-null init", function () {
            var scale = valueFormatter.create({ format: '0', value: null, value2: 1e6 });
            expect(scale.format(-2.4e6)).toBe('-2.4M');
        });
        it("create abs value init", function () {
            var scale = valueFormatter.create({ format: '0', value: -3e6, value2: 2 });
            expect(scale.format(-3e6)).toBe('-3M');
        });
        it("create Year", function () {
            var scale = valueFormatter.create({ format: '0', value: 2014 });
            expect(scale.format(2010)).toBe('2010');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create No Scale", function () {
            var column;
            var scale = valueFormatter.create({ column: column, value: 0 });
            expect(scale.format(0)).toBe('0');
            expect(scale.format(0.5678934)).toBe('0.5679');
            expect(scale.format(-0.5678934)).toBe('-0.5679');
            expect(scale.format(1.234e7)).toBe('12340000');
            expect(scale.format(1.12000000000007)).toBe('1.12');
        });
        it("create Million", function () {
            var column;
            var scale = valueFormatter.create({ column: column, value: 1e6 });
            expect(scale.format(4.56e7)).toBe('45.6M');
            expect(scale.format(4.56789123e7)).toBe('45.68M');
            expect(scale.format(-3130000.567)).toBe('-3.13M');
            expect(scale.format(10000)).toBe('0.01M');
            expect(scale.format(100000)).toBe('0.1M');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create Billion", function () {
            var column;
            var scale = valueFormatter.create({ column: column, value: 1e9 });
            expect(scale.format(4.56e10)).toBe('45.6bn');
            expect(scale.format(4.56789123e10)).toBe('45.68bn');
            expect(scale.format(-3130000000.567)).toBe('-3.13bn');
            expect(scale.format(100000000)).toBe('0.1bn');
            expect(scale.format(1000000000)).toBe('1bn');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create Trillion", function () {
            var column;
            var scale = valueFormatter.create({ column: column, value: 1e12 });
            expect(scale.format(4.56e13)).toBe('45.6T');
            expect(scale.format(4.56789123e13)).toBe('45.68T');
            expect(scale.format(-3130000000000.567)).toBe('-3.13T');
            expect(scale.format(100000000000)).toBe('0.1T');
            expect(scale.format(1000000000000)).toBe('1T');
            expect(scale.format(1000000000000000)).toBe('1000T');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create Exponent format", function () {
            var scale = valueFormatter.create({ format: 'E', value: 1e15 });
            expect(scale.format(719200000000001920000000000)).toBe('7.192000E+026');
        });
        it("create Exponent format", function () {
            var column;
            var scale = valueFormatter.create({ column: column, value: 1e15 });
            expect(scale.format(719200000000001920000000000)).toBe('7.192E+26');
        });
        it("create Percentage", function () {
            var format = '0.00 %;-0.00 %;0.00 %';
            var scale = valueFormatter.create({ format: format, value: 1, allowFormatBeautification: true });
            expect(scale.format(0)).toBe('0%');
            expect(scale.format(1)).toBe('100%');
            expect(scale.format(-1)).toBe('-100%');
            expect(scale.format(.54)).toBe('54%');
            expect(scale.format(.543)).toBe('54.3%');
            expect(scale.format(.5432)).toBe('54.32%');
            expect(scale.format(.54321)).toBe('54.32%');
            expect(scale.format(6.54321)).toBe('654.32%');
            expect(scale.format(76.54321)).toBe('7,654.32%');
        });
        it("create Escaped Character format", function () {
            var scale = valueFormatter.create({ format: "\\$#,0.00;(\\$#,0.00);\\$#,0.00", value: 1e6 });
            expect(scale.format(107384391.61)).toBe('$107.38M');
            expect(scale.format(-107384391.61)).toBe('($107.38M)');
        });
        it("create Format no custom negative", function () {
            var scale = valueFormatter.create({ format: "$#,0.00", value: 1e6 });
            expect(scale.format(-107384391.61)).toBe('-$107.38M');
        });
        it('create HundredThousand', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 300000 });
            expect(scale.format(300000)).toBe('0.3M');
        });
        it('create Million', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000 });
            expect(scale.format(900000000)).toBe('0.9bn');
        });
        it('create Billion', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000 });
            expect(scale.format(900000000000)).toBe('0.9T');
        });
        it('create Trillion', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: 0 /* Default */ });
            expect(scale.format(900000000000000)).toBe('9E+14');
        });
        it('create HundredThousand Whole Units', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 300000, displayUnitSystemType: 2 /* WholeUnits */ });
            expect(scale.format(300000)).toBe('300K');
        });
        it('create Million Whole Units', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000, displayUnitSystemType: 2 /* WholeUnits */ });
            expect(scale.format(900000000)).toBe('900M');
        });
        it('create Billion Whole Units', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000, displayUnitSystemType: 2 /* WholeUnits */ });
            expect(scale.format(900000000000)).toBe('900bn');
        });
        it('create Trillion Whole Units', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: 2 /* WholeUnits */ });
            expect(scale.format(900000000000000)).toBe('900T');
        });
        it('create HundredThousand Verbose (No Units)', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 300000, displayUnitSystemType: 1 /* Verbose */ });
            expect(scale.format(300000)).toBe('300000');
        });
        it('create Million Verbose (No Units)', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000, displayUnitSystemType: 1 /* Verbose */ });
            expect(scale.format(900000000)).toBe('900000000');
        });
        it('create Billion Verbose (No Units)', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000, displayUnitSystemType: 1 /* Verbose */ });
            expect(scale.format(900000000000)).toBe('900000000000');
        });
        it('create Trillion Verbose (No Units)', function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: 1 /* Verbose */ });
            expect(scale.format(900000000000000)).toBe('900000000000000');
        });
        it('create single value formatting verbose', function () {
            var format = '#,0.00';
            var scale = valueFormatter.create({ format: format, value: 26.254, displayUnitSystemType: 1 /* Verbose */, formatSingleValues: true });
            // Default formatting for numeric types is 2dp
            expect(scale.format(26.254)).toBe('26.25');
        });
        it('create single value formatting verbose large', function () {
            var format = '#,0.00';
            var scale = valueFormatter.create({ format: format, value: 300000.254, displayUnitSystemType: 1 /* Verbose */, formatSingleValues: true });
            // Verbose formatting shouldn't use units
            expect(scale.format(300000.254)).toBe('300,000.25');
        });
        it('precision without display units', function () {
            var scale = valueFormatter.create({ value: 0, precision: 3 });
            expect(scale.format(12.1012)).toBe('12.101');
        });
        it('precision with display units', function () {
            var format = '#,0.00';
            var scale = valueFormatter.create({ format: format, value: 10000, precision: 2 });
            expect(scale.format(12177)).toBe('12.18K');
        });
        it('precision 1 with display units', function () {
            var format = '#,0.00';
            var scale = valueFormatter.create({ format: format, value: 10000, precision: 1 });
            expect(scale.format(12177)).toBe('12.2K');
        });
        it('precision with display units and no format string', function () {
            var scale = valueFormatter.create({ value: 10000, precision: 2 });
            expect(scale.format(12177)).toBe('12.18K');
        });
        it("create Boolean", function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: false, value2: true, tickCount: 6 });
            expect(scale.format(true)).toBe('True');
            expect(scale.format(false)).toBe('False');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create Boolean with numeric index values", function () {
            var format;
            var scale = valueFormatter.create({ format: format, value: 0, value2: 1, tickCount: 6 });
            expect(scale.format(true)).toBe('True');
            expect(scale.format(false)).toBe('False');
            expect(scale.format(null)).toBe('(Blank)');
        });
        it("create Date", function () {
            var format = 'O';
            var minDate = new Date(2014, 10, 4, 12, 34, 56, 789);
            var maxDate = new Date(2014, 10, 9, 12, 34, 56, 789);
            var scale = valueFormatter.create({ format: format, value: minDate, value2: maxDate, tickCount: 6 });
            expect(scale.format(minDate)).toBe('Nov 04');
            expect(scale.format(maxDate)).toBe('Nov 09');
            expect(scale.format(null)).toBe('(Blank)');
        });
        describe('formatListAnd', function () {
            it('formatListAnd no values', function () {
                var result = valueFormatter.formatListAnd([]);
                expect(result).toBeNull();
            });
            it('formatListAnd 1 value', function () {
                var result = valueFormatter.formatListAnd(['1']);
                expect(result).toBe('1');
            });
            it('formatListAnd 2 values', function () {
                var result = valueFormatter.formatListAnd(['1', '2']);
                expect(result).toBe('1 and 2');
            });
            it('formatListAnd 3 values', function () {
                var result = valueFormatter.formatListAnd(['1', '2', '3']);
                expect(result).toBe('1, 2 and 3');
            });
            it('formatListAnd wrong parameters values', function () {
                var result = valueFormatter.formatListAnd(null);
                expect(result).toBeNull();
                var result = valueFormatter.formatListAnd(undefined);
                expect(result).toBeNull();
            });
        });
        describe('formatListOr', function () {
            it('formatListOr no values', function () {
                var result = valueFormatter.formatListOr([]);
                expect(result).toBeNull();
            });
            it('formatListOr 1 value', function () {
                var result = valueFormatter.formatListOr(['1']);
                expect(result).toBe('1');
            });
            it('formatListOr 2 values', function () {
                var result = valueFormatter.formatListOr(['1', '2']);
                expect(result).toBe('1 or 2');
            });
            it('formatListOr 3 values', function () {
                var result = valueFormatter.formatListOr(['1', '2', '3']);
                expect(result).toBe('1, 2 or 3');
            });
            it('formatListOr wrong parameters values', function () {
                var result = valueFormatter.formatListOr(null);
                expect(result).toBeNull();
                var result = valueFormatter.formatListOr(undefined);
                expect(result).toBeNull();
            });
        });
        it('getDisplayUnits', function () {
            var displayUnits = valueFormatter.getDisplayUnits(0 /* Default */);
            expect(displayUnits).toBeDefined();
            expect(displayUnits.length).toBeGreaterThan(0);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var AnimatedNumber = powerbi.visuals.AnimatedNumber;
    describe("AnimatedNumber", function () {
        it('AnimatedNumber registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('animatedNumber').capabilities).toBe(AnimatedNumber.capabilities);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(AnimatedNumber.capabilities.objects)).toEqual(AnimatedNumber.formatStringProp);
        });
    });
    describe("AnimatedNumber DOM tests", function () {
        var v, element;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('200', '300');
            v = new AnimatedNumber();
        });
        it('AnimatedText onDataChanged sets text (no settings)', function () {
            var dataViewMetadata = {
                columns: [{ displayName: 'col1', isMeasure: true }],
            };
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: 123.456 }
            };
            var initOptions = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width(),
                },
                animation: {
                    transitionImmediate: true,
                }
            };
            v.init(initOptions);
            v.onDataChanged({ dataViews: [dataView] });
            expect($('.animatedNumber')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var AnimatedText = powerbi.visuals.AnimatedText;
    describe("AnimatedText", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('AnimatedText_getSeedFontHeight does not exceed style maximum', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.style = powerbi.visuals.visualStyles.create();
            expect(animatedText.getSeedFontHeight(100, 90)).toBeLessThan(100);
        });
        it('AnimatedText_getSeedFontHeight returns a smaller number than the height', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.style = powerbi.visuals.visualStyles.create();
            expect(animatedText.getSeedFontHeight(100, 90)).toBeLessThan(100);
        });
        it('AnimatedText_getTextAnchor when the aligment is "left"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'left'
            };
            expect(animatedText.getTextAnchor()).toBe('start');
        });
        it('AnimatedText_getTextAnchor when the aligment is "right"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'right'
            };
            expect(animatedText.getTextAnchor()).toBe('end');
        });
        it('AnimatedText_getTextAnchor when the aligment is undefined', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = undefined;
            expect(animatedText.getTextAnchor()).toBe('middle');
            animatedText.visualConfiguration = {
                align: 'center'
            };
            expect(animatedText.getTextAnchor()).toBe('middle');
        });
        it('AnimatedText_getTranslateX alignment is "left"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'left'
            };
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(0);
        });
        it('AnimatedText_getTranslateX alignment is "right"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'right'
            };
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(100);
        });
        it('AnimatedText_getTranslateX when alignment is undefined, returns the center', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = undefined;
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(50);
        });
    });
    describe("AnimatedText DOM tests", function () {
        var v, element;
        var defaultTimeout = 500;
        beforeEach(function (done) {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('200', '300');
            v = new AnimatedText('animatedText');
            v.currentViewport = {
                height: element.height(),
                width: element.width()
            };
            v.hostServices = powerbitests.mocks.createVisualHostServices();
            v.svg = d3.select(element.get(0)).append('svg');
            v.graphicsContext = v.svg.append('g');
            v.style = powerbi.visuals.visualStyles.create();
            done();
        });
        it('AnimatedText_getAdjustedFontHeight when seed font width is bigger than the width', function () {
            // parameters are availableWidth, textToMeasure, seedFontHeight
            // When the measured text with the seed height is bigger than availableWidth, decrease the font height
            expect(v.getAdjustedFontHeight(4, "text", 10)).toBeLessThan(10);
        });
        it('AnimatedText_getAdjustedFontHeight when seed font width is smaller or equal to the width', function () {
            // parameters are availableWidth, textToMeasure, seedFontHeight
            // When the measured text with the seed height is equal/smaller than availableWidth, return the font height
            expect(v.getAdjustedFontHeight(30, "text", 3)).toBe(3);
        });
        it('AnimatedText doValueTransition sets text', function (done) {
            v.doValueTransition(3, 4, null, null, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('4');
                done();
            }, defaultTimeout);
        });
        it('AnimatedText doValueTransition formats number > 10000', function (done) {
            v.doValueTransition(3, 4534353, null, null, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('4.53M');
                done();
            }, defaultTimeout);
        });
        it('AnimatedText doValueTransition sets translateY correctly', function (done) {
            v.doValueTransition(3, 4, null, null, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                // IE and Chrome represent the transform differently
                expect(v.graphicsContext.attr('transform')).toMatch(/translate\(\d+(,| )130\)/);
                done();
            }, defaultTimeout);
        });
        it('AnimatedText doValueTransition to 0', function (done) {
            v.doValueTransition(null, 0, null, null, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('0');
                done();
            }, defaultTimeout);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var Card = powerbi.visuals.Card;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ValueType = powerbi.ValueType;
    describe("Card", function () {
        it('Card_registered_capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('card').capabilities).toBe(Card.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(Card.capabilities.dataViewMappings).toBeDefined();
            expect(Card.capabilities.dataViewMappings.length).toBe(1);
        });
        it('Capabilities should have condition', function () {
            expect(Card.capabilities.dataViewMappings[0].conditions[0][Card.capabilities.dataRoles[0].name].max).toBe(1);
        });
        it('Capabilities should include dataRoles', function () {
            expect(Card.capabilities.dataRoles).toBeDefined();
            expect(Card.capabilities.dataRoles.length).toBe(1);
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(Card.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Card.capabilities.objects)).toEqual(Card.formatStringProp);
        });
    });
    it('cardChart preferred capabilities requires at most 1 row', function () {
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1' },
                { displayName: 'col2', isMeasure: true }
            ]
        };
        var dataViewWithTwoRows = {
            metadata: dataViewMetadata,
            categorical: {
                categories: [{
                    source: dataViewMetadata.columns[0],
                    values: ['John Domo', 'Delta Force'],
                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b')]
                }],
                values: DataViewTransform.createValueColumns([{
                    source: dataViewMetadata.columns[1],
                    values: [100, 200],
                    subtotal: 300
                }])
            }
        };
        var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('card');
        expect(powerbi.DataViewAnalysis.supports(dataViewWithTwoRows, plugin.capabilities.dataViewMappings[0], true)).toBe(false);
    });
    it('cardChart preferred capabilities requires 1 row', function () {
        var dataViewMetadata = {
            columns: [
                { displayName: 'numeric', type: ValueType.fromDescriptor({ numeric: true }) }
            ],
        };
        var data = {
            metadata: dataViewMetadata,
            single: { value: 123.456 }
        };
        var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('card');
        expect(powerbi.DataViewAnalysis.supports(data, plugin.capabilities.dataViewMappings[0], true)).toBe(true);
    });
    describe("Card DOM tests", function () {
        var v, element;
        var defaultTimeout = 30;
        var dataViewMetadata = {
            columns: [{ displayName: 'col1', isMeasure: true, objects: { 'general': { formatString: '#0' } } }],
            groups: [],
            measures: [0],
        };
        var cardStyles = Card.DefaultStyle.card;
        beforeEach(function () {
            createCard();
        });
        function createCard(displayUnitSystemType) {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('card').create();
            var settings;
            if (displayUnitSystemType) {
                settings = {
                    DisplayUnitSystemType: displayUnitSystemType
                };
            }
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
            });
        }
        it('Card_getAdjustedFontHeight with seed font size fitting in available width but equal/larger than MaxFontSize', function () {
            v.currentViewport = {
                height: 500,
                width: 500
            };
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize)).toBe(cardStyles.maxFontSize);
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize + 5)).toBe(cardStyles.maxFontSize);
        });
        it('Card_getAdjustedFontHeight with seed font size not fitting in available width and smaller than MaxFontSize', function () {
            v.currentViewport = {
                height: 30,
                width: 30
            };
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize)).toBeLessThan(cardStyles.maxFontSize);
        });
        it('Card_onDataChanged (single value)', function () {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: '7191394482447.7'
                    }
                }]
            });
            v.onResizing({
                height: element.height(),
                width: element.width()
            }, 0);
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            var titleText = $('.card').find('title').text();
            expect(titleText).toBe('7191394482447.7');
        });
        it('Card_onDataChanged (0)', function () {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 0
                    }
                }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            var titleText = $('.card').find('title').text();
            expect(titleText).toBe('0');
        });
        it('Ensure clear on null dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 0
                    }
                }]
            });
            setTimeout(function () {
                expect($('.mainText').first().text()).toBe('0');
                v.onDataChanged({ dataViews: [null] });
                setTimeout(function () {
                    expect($('.mainText').first().text()).toBe('');
                    done();
                }, defaultTimeout);
            }, defaultTimeout);
        });
        it('Card_onDataChanged formats number < 10000', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 85.23498239847123
                    }
                }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('85');
                done();
            }, defaultTimeout);
        });
        it('Card_onDataChanged verbose display units (explore mode)', function (done) {
            createCard(1 /* Verbose */);
            var spy = spyOn(powerbi.visuals.valueFormatter, 'create');
            spy.and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 900000
                    }
                }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect(spy.calls.count()).toBe(1);
                var args = spy.calls.argsFor(0);
                expect(args).toBeDefined();
                expect(args[0].displayUnitSystemType).toBe(1 /* Verbose */);
                done();
            }, defaultTimeout);
        });
        it('Card_onDataChanged whole display units (dashboard tile mode, default)', function (done) {
            var spy = spyOn(powerbi.visuals.valueFormatter, 'create');
            spy.and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 900000
                    }
                }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect(spy.calls.count()).toBe(1);
                var args = spy.calls.argsFor(0);
                expect(args).toBeDefined();
                expect(args[0].displayUnitSystemType).toBe(2 /* WholeUnits */);
                done();
            }, defaultTimeout);
        });
        it('Card with DateTime value on dashboard', function (done) {
            var dateValue = new Date(2015, 5, 20);
            var dataViewMetadata = {
                columns: [
                    { displayName: 'date', type: powerbi.ValueType.fromDescriptor({ dateTime: true }), isMeasure: true }
                ],
            };
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: dateValue
                    }
                }]
            });
            setTimeout(function () {
                expect($('.mainText').first().text()).toBe('6/20/2015');
                done();
            }, defaultTimeout);
        });
    });
    describe("Card tests on Minerva", function () {
        var v, element;
        var defaultTimeout = 30;
        var dataViewMetadata = {
            columns: [{ displayName: 'col1', isMeasure: true, format: '#0' }],
            groups: [],
            measures: [0],
        };
        var labelStyles = Card.DefaultStyle.label;
        var valueStyles = Card.DefaultStyle.value;
        beforeEach(function () {
            createCardOnMinerva();
        });
        function createCardOnMinerva(displayUnitSystemType) {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
            }).getPlugin('card').create();
            var settings;
            if (displayUnitSystemType) {
                settings = {
                    DisplayUnitSystemType: displayUnitSystemType
                };
            }
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
            });
        }
        it('Card on Canvas DOM validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 90
                    }
                }]
            });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.label')).toBeInDOM();
                expect($('.value')).toBeInDOM();
                expect($('.label').length).toBe(1);
                expect($('.value').length).toBe(1);
                expect($('.label').first().text()).toBe('col1');
                expect($('.value').first().text()).toBe('90');
                done();
            }, defaultTimeout);
        });
        it('Card on Canvas Style validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 900000
                    }
                }]
            });
            setTimeout(function () {
                expect($('.label')).toBeInDOM();
                expect($('.value')).toBeInDOM();
                expect(parseInt($('.label')[0].style.fontSize, 10)).toBe(labelStyles.fontSize);
                expect(parseInt($('.value')[0].style.fontSize, 10)).toBe(valueStyles.fontSize);
                expect($('.label')[0].style.fill).toBe(labelStyles.color);
                expect($('.value')[0].style.fill).toBe(valueStyles.color);
                expect($('.value')[0].style.fontFamily).toBe(valueStyles.fontFamily);
                done();
            }, defaultTimeout);
        });
        it('Card with DateTime value on canvas', function (done) {
            var dateValue = new Date(2015, 5, 20);
            var dataViewMetadata = {
                columns: [
                    { displayName: 'date', type: powerbi.ValueType.fromDescriptor({ dateTime: true }), isMeasure: true }
                ],
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: dateValue
                    }
                }]
            });
            setTimeout(function () {
                expect($('.label').first().text()).toBe('date');
                expect($('.value').first().text()).toBe('6/20/2015');
                done();
            }, defaultTimeout);
        });
        it('Card with zero currency value', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'price', type: powerbi.ValueType.fromDescriptor({ numeric: true }), isMeasure: true, objects: { 'general': { formatString: '$0' } } }
                ],
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 0
                    }
                }]
            });
            setTimeout(function () {
                expect($('.label').first().text()).toBe('price');
                expect($('.value').first().text()).toBe('$0');
                done();
            }, defaultTimeout);
        });
        it('Ensure clear value on null dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: {
                        value: 900
                    }
                }]
            });
            setTimeout(function () {
                expect($('.value').first().text()).toBe('900');
                expect($('.label').first().text()).toBe('col1');
                v.onDataChanged({ dataViews: [null] });
                setTimeout(function () {
                    expect($('.value').first().text()).toBe('');
                    expect($('.label').first().text()).toBe('col1');
                    done();
                }, defaultTimeout);
            }, defaultTimeout);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewSelfCrossJoin = powerbi.data.DataViewSelfCrossJoin;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ColumnChart = powerbi.visuals.ColumnChart;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var ClusteredUtil = powerbi.visuals.ClusteredUtil;
    var StackedUtil = powerbi.visuals.StackedUtil;
    var ColumnUtil = powerbi.visuals.ColumnUtil;
    var AxisHelper = powerbi.visuals.AxisHelper;
    var ValueType = powerbi.ValueType;
    var SelectionId = powerbi.visuals.SelectionId;
    var PrimitiveType = powerbi.PrimitiveType;
    var Prototype = powerbi.Prototype;
    var CartesianChart = powerbi.visuals.CartesianChart;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var AxisType = powerbi.axisType;
    var ColorUtility = powerbitests.utils.ColorUtility;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    var DefaultWaitForRender = 10;
    describe("ColumnChart", function () {
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } } };
        var measure2Column = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) };
        var measure3Column = { displayName: 'profit', queryName: 'selectProfit', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) };
        var nullMeasureColumn = { displayName: null, queryName: 'selectNull', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) };
        var measureWithFormatString = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */), format: '$0' };
        var measureColumnDynamic1 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } }, groupName: 'A' };
        var measureColumnDynamic2 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } }, groupName: 'B' };
        var measureColumnDynamic1RefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
        it('ColumnChart registered capabilities', function () {
            expect(JSON.stringify(powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').capabilities)).toBe(JSON.stringify(powerbi.visuals.getColumnChartCapabilities()));
        });
        it('ColumnChart registered customizeQuery', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').customizeQuery).toBe(ColumnChart.customizeQuery);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.getColumnChartCapabilities().objects)).toEqual(powerbi.visuals.columnChartProps.general.formatString);
        });
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('CustomizeQuery scalar type, no scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: null
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery non-scalar type, scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(1 /* Text */), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery scalar type, scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ sample: {} });
        });
        it('CustomizeQuery no category', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('Sortable roles with scalar axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            expect(ColumnChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toBeNull();
        });
        it('Sortable roles with categorical axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Categorical',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            expect(ColumnChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toEqual(['Category', 'Y']);
        });
        function createCompiledDataViewMapping(categoryType, objects) {
            var categoryItems = [];
            if (categoryType)
                categoryItems.push({ type: categoryType });
            return {
                metadata: {
                    objects: objects
                },
                categorical: {
                    categories: {
                        for: {
                            in: { role: 'Category', items: categoryItems }
                        },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: { role: 'Series', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(1 /* Text */) }] },
                            select: [
                                { for: { in: { role: 'Y', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(4 /* Integer */) }] } } }
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    }
                }
            };
        }
        it('has positive measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, 200]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName), SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)];
            expect(powerbi.visuals.valueFormatter.create).toHaveBeenCalledWith({ format: undefined, value: 2011, value2: 2012, displayUnitSystemType: 1 /* Verbose */ });
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 200]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 200
            });
        });
        it('has positive measure (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, 200]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 1,
                        position: 1,
                        valueAbsolute: 1,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 1,
                        originalPosition: 1,
                        originalValueAbsolute: 1,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 1,
                        position: 1,
                        valueAbsolute: 1,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 1,
                        originalPosition: 1,
                        originalValueAbsolute: 1,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('has positive measure - two series (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, 200],
                }, {
                    source: measure2Column,
                    values: [60, 50],
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectTax"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectTax")
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 0.625,
                        position: 0.625,
                        valueAbsolute: 0.625,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 0.625,
                        originalPosition: 0.625,
                        originalValueAbsolute: 0.625,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 0.8,
                        position: 0.8,
                        valueAbsolute: 0.8,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 0.8,
                        originalPosition: 0.8,
                        originalValueAbsolute: 0.8,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'tax',
                identity: SelectionId.createWithMeasure("selectTax"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 0.375,
                        position: 1,
                        valueAbsolute: 0.375,
                        valueOriginal: 60,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 0.375,
                        originalPosition: 1,
                        originalValueAbsolute: 0.375,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "60" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 0.2,
                        position: 1,
                        valueAbsolute: 0.2,
                        valueOriginal: 50,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 0.2,
                        originalPosition: 1,
                        originalValueAbsolute: 0.2,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "50" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('has negative measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, -200]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: -200,
                        position: 0,
                        valueAbsolute: 200,
                        valueOriginal: -200,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -200,
                        originalPosition: 0,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-200, 100]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -200,
                max: 100
            });
        });
        it('has positive and negative measure - two series', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [2, -2],
                }, {
                    source: measure2Column,
                    values: [-3, 4],
                }, {
                    source: measure3Column,
                    values: [4, -3],
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            expect(data.series[2].data[0].position).toEqual(6);
            expect(data.series[2].data[1].position).toEqual(-2);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-3, 4]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -5,
                max: 6
            });
        });
        it('has negative measure (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, -200]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 1,
                        position: 1,
                        valueAbsolute: 1,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 1,
                        originalPosition: 1,
                        originalValueAbsolute: 1,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: -1,
                        position: 0,
                        valueAbsolute: 1,
                        valueOriginal: -200,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -1,
                        originalPosition: 0,
                        originalValueAbsolute: 1,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('is missing a measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, null]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: null,
                        position: 0,
                        valueAbsolute: 0,
                        valueOriginal: null,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: null,
                        originalPosition: 0,
                        originalValueAbsolute: 0,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 100]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
        });
        it('is missing a category', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity(null),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, null],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, 175]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: null,
                        value: 175,
                        position: 175,
                        valueAbsolute: 175,
                        valueOriginal: 175,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 175,
                        originalPosition: 175,
                        originalValueAbsolute: 175,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "(Blank)" }, { displayName: "sales", value: "$175" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 175]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 175
            });
        });
        it('multiple measures', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [100, 200]
                    },
                    {
                        source: measure2Column,
                        values: [62, 55]
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColor(measureColumn.queryName).value;
            var series2Color = colors.getColor(measure2Column.queryName).value;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectTax"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectTax"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'tax',
                identity: SelectionId.createWithMeasure("selectTax"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 62,
                        position: 162,
                        valueAbsolute: 62,
                        valueOriginal: 62,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 62,
                        originalPosition: 162,
                        originalValueAbsolute: 62,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "62" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 55,
                        position: 255,
                        valueAbsolute: 55,
                        valueOriginal: 55,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 1,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 55,
                        originalPosition: 255,
                        originalValueAbsolute: 55,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "55" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 200]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 255
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: series1Color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
                { icon: 0 /* Box */, color: series2Color, label: measure2Column.displayName, identity: SelectionId.createWithMeasure("selectTax"), selected: false }
            ]);
        });
        it('converter: dynamic series', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }
                ], [measureColumnDynamic1RefExpr])
            };
            dataView.values.source = measureColumn;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesColumnId = SQExprShortSerializer.serializeArray([measureColumnDynamic1RefExpr]);
            var series1Color = colors.getColorByScale(seriesColumnId, 'A').value;
            var series2Color = colors.getColorByScale(seriesColumnId, 'B').value;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[0], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[0], measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[1], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[1], measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'A',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'B',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 62,
                        position: 162,
                        valueAbsolute: 62,
                        valueOriginal: 62,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 62,
                        originalPosition: 162,
                        originalValueAbsolute: 62,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 55,
                        position: 255,
                        valueAbsolute: 55,
                        valueOriginal: 55,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 1,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 55,
                        originalPosition: 255,
                        originalValueAbsolute: 55,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: series1Color, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: 0 /* Box */, color: series2Color, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series falsy group instances', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, null),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, false),
            ];
            var measureColumnSources = [
                Prototype.inherit(measureColumnDynamic1, function (c) { return c.groupName = null; }),
                Prototype.inherit(measureColumnDynamic2, function (c) { return c.groupName = false; }),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnSources[0],
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: measureColumnSources[1],
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }
                ], [measureColumnDynamic1RefExpr])
            };
            dataView.values.source = measureColumn;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var legendItems = data.legendData.dataPoints;
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: '(Blank)', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnSources[0].queryName), selected: false },
                { icon: 0 /* Box */, color: legendItems[1].color, label: 'False', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnSources[1].queryName), selected: false }
            ]);
        });
        it('converter: dynamic series + fill color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }
                ], [measureColumnDynamic1RefExpr])
            };
            dataView.values.source = measureColumn;
            var groupedValues = dataView.values.grouped();
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[0], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[0], measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[1], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[1], measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'A',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'B',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 62,
                        position: 162,
                        valueAbsolute: 62,
                        valueOriginal: 62,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 62,
                        originalPosition: 162,
                        originalValueAbsolute: 62,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 55,
                        position: 255,
                        valueAbsolute: 55,
                        valueOriginal: 55,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 1,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 55,
                        originalPosition: 255,
                        originalValueAbsolute: 55,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: '#01B8AA', label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: 0 /* Box */, color: 'red', label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series, default color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var hexDefaultColorRed = "#FF0000";
            var metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }
                ], [measureColumnDynamic1RefExpr])
            };
            dataView.values.source = measureColumn;
            var groupedValues = dataView.values.grouped();
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, null, null, null, metadata);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[0], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[0], measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[1], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[1], measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'A',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 0,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 1,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'B',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 62,
                        position: 162,
                        valueAbsolute: 62,
                        valueOriginal: 62,
                        seriesIndex: 1,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 0,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 62,
                        originalPosition: 162,
                        originalValueAbsolute: 62,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 55,
                        position: 255,
                        valueAbsolute: 55,
                        valueOriginal: 55,
                        seriesIndex: 1,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 1,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 55,
                        originalPosition: 255,
                        originalValueAbsolute: 55,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: hexDefaultColorRed, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: 0 /* Box */, color: hexDefaultColorRed, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series, formatted color + default color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }
                ], [measureColumnDynamic1RefExpr])
            };
            dataView.values.source = measureColumn;
            var groupedValues = dataView.values.grouped();
            var hexGreen = "#00FF00";
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: hexGreen } } } };
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            var metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var data = ColumnChart.converter(dataView, colors, undefined, undefined, undefined, metadata);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[0], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[0], measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[0], seriesIdentities[1], measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasure(categoryIdentities[1], seriesIdentities[1], measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'A',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 0,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 0,
                        labelFill: hexDefaultColorRed,
                        categoryIndex: 1,
                        color: hexDefaultColorRed,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'B',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName),
                data: [
                    {
                        categoryValue: 2011,
                        value: 62,
                        position: 162,
                        valueAbsolute: 62,
                        valueOriginal: 62,
                        seriesIndex: 1,
                        labelFill: hexGreen,
                        categoryIndex: 0,
                        color: hexGreen,
                        selected: false,
                        originalValue: 62,
                        originalPosition: 162,
                        originalValueAbsolute: 62,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 55,
                        position: 255,
                        valueAbsolute: 55,
                        valueOriginal: 55,
                        seriesIndex: 1,
                        labelFill: hexGreen,
                        categoryIndex: 1,
                        color: hexGreen,
                        selected: false,
                        originalValue: 55,
                        originalPosition: 255,
                        originalValueAbsolute: 55,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: hexDefaultColorRed, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: 0 /* Box */, color: hexGreen, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('validate highlighted tooltip', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
                powerbitests.mocks.dataViewScopeIdentity("2013"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012, 2013],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, 200, 300],
                    highlights: [null, 50, 0],
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            //first tooltip is regular because highlighted value is null
            expect(data.series[0].data[0].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }]);
            expect(data.series[0].data[1].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }]);
            //tooltips with highlighted value
            expect(data.series[0].data[2].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$50" }]);
            expect(data.series[0].data[3].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$50" }]);
            //tooltips with highlighted value 0
            expect(data.series[0].data[4].tooltipInfo).toEqual([{ displayName: "year", value: "2013" }, { displayName: "sales", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$0" }]);
            expect(data.series[0].data[5].tooltipInfo).toEqual([{ displayName: "year", value: "2013" }, { displayName: "sales", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$0" }]);
        });
        it('null measures legend', function () {
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012]
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: nullMeasureColumn,
                        values: [100, 200]
                    },
                    {
                        source: measure2Column,
                        values: [62, 55]
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var legendItems = data.legendData.dataPoints;
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: powerbi.visuals.valueFormatter.format(null), identity: SelectionId.createWithMeasure(nullMeasureColumn.queryName), selected: false },
                { icon: 0 /* Box */, color: legendItems[1].color, label: dataView.values[1].source.displayName, identity: SelectionId.createWithMeasure(measure2Column.queryName), selected: false },
            ]);
        });
        it('multiple measures (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2010"),
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
                powerbitests.mocks.dataViewScopeIdentity("2013"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2010, 2011, 2012, 2013],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [30, -20, 100, -300]
                    },
                    {
                        source: measure2Column,
                        values: [90, 50, -100, -100]
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[2], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[3], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectTax"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectTax"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[2], "selectTax"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[3], "selectTax"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2010,
                        value: 0.25,
                        position: 0.25,
                        valueAbsolute: 0.25,
                        valueOriginal: 30,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 0.25,
                        originalPosition: 0.25,
                        originalValueAbsolute: 0.25,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2010" }, { displayName: "sales", value: "$30" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2011,
                        value: -0.2857142857142857,
                        position: 0,
                        valueAbsolute: 0.2857142857142857,
                        valueOriginal: -20,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -0.2857142857142857,
                        originalPosition: 0,
                        originalValueAbsolute: 0.2857142857142857,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "-$20" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: 0.5,
                        position: 0.5,
                        valueAbsolute: 0.5,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 2,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 0.5,
                        originalPosition: 0.5,
                        originalValueAbsolute: 0.5,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2013,
                        value: -0.75,
                        position: 0,
                        valueAbsolute: 0.75,
                        valueOriginal: -300,
                        seriesIndex: 0,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 3,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -0.75,
                        originalPosition: 0,
                        originalValueAbsolute: 0.75,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2013" }, { displayName: "sales", value: "-$300" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'tax',
                identity: SelectionId.createWithMeasure("selectTax"),
                data: [
                    {
                        categoryValue: 2010,
                        value: 0.75,
                        position: 1,
                        valueAbsolute: 0.75,
                        valueOriginal: 90,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 0.75,
                        originalPosition: 1,
                        originalValueAbsolute: 0.75,
                        identity: selectionIds[4],
                        key: selectionIds[4].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2010" }, { displayName: "tax", value: "90" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2011,
                        value: 0.7142857142857143,
                        position: 0.7142857142857143,
                        valueAbsolute: 0.7142857142857143,
                        valueOriginal: 50,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 1,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 0.7142857142857143,
                        originalPosition: 0.7142857142857143,
                        originalValueAbsolute: 0.7142857142857143,
                        identity: selectionIds[5],
                        key: selectionIds[5].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "50" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: -0.5,
                        position: 0,
                        valueAbsolute: 0.5,
                        valueOriginal: -100,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 2,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: -0.5,
                        originalPosition: 0,
                        originalValueAbsolute: 0.5,
                        identity: selectionIds[6],
                        key: selectionIds[6].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "-100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2013,
                        value: -0.25,
                        position: -0.75,
                        valueAbsolute: 0.25,
                        valueOriginal: -100,
                        seriesIndex: 1,
                        labelFill: data.labelSettings.labelColor,
                        categoryIndex: 3,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: -0.25,
                        originalPosition: -0.75,
                        originalValueAbsolute: 0.25,
                        identity: selectionIds[7],
                        key: selectionIds[7].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2013" }, { displayName: "tax", value: "-100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('no category single measure', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionId = SelectionId.createWithMeasure(measureColumn.queryName);
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: measureColumn.displayName,
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: null,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionId,
                        key: selectionId.getKey(),
                        tooltipInfo: [{ displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('no category multiple measure', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [100]
                    },
                    {
                        source: measure2Column,
                        values: [200]
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("selectSales"),
                SelectionId.createWithMeasure("selectTax"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: null,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'tax',
                identity: SelectionId.createWithMeasure("selectTax"),
                data: [
                    {
                        categoryValue: null,
                        value: 200,
                        position: 300,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 300,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "tax", value: "200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 300
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
                { icon: 0 /* Box */, color: legendItems[1].color, label: measure2Column.displayName, identity: SelectionId.createWithMeasure("selectTax"), selected: false }
            ]);
        });
        it('no category multiple measure + fill color', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([
                    {
                        source: {
                            displayName: 'sales',
                            queryName: 'selectSales',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(SemanticType.Integer),
                            objects: {
                                general: { formatString: '$0' },
                                dataPoint: { fill: { solid: { color: 'red' } } }
                            },
                        },
                        values: [100],
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("selectSales"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: null,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: 'red',
                        categoryIndex: 0,
                        color: 'red',
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: 'red', label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
            ]);
        });
        it('category and measure + fill color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var dataView = {
                categories: [{
                    source: {
                        displayName: 'prod',
                        queryName: 'selectProd',
                        type: DataShapeUtility.describeDataType(SemanticType.Integer),
                    },
                    values: ['a', 'b'],
                    objects: [undefined, { dataPoint: { fill: { solid: { color: 'red' } } } }],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: {
                        displayName: 'sales',
                        queryName: 'selectSales',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(SemanticType.Integer),
                    },
                    values: [100, 150],
                }])
            };
            var data = ColumnChart.converter(dataView, powerbi.visuals.visualStyles.create().colorPalette.dataColors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "selectSales"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "selectSales"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'sales',
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 'a',
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: '#01B8AA',
                        categoryIndex: 0,
                        color: '#01B8AA',
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "prod", value: "a" }, { displayName: "sales", value: "100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 'b',
                        value: 150,
                        position: 150,
                        valueAbsolute: 150,
                        valueOriginal: 150,
                        seriesIndex: 0,
                        labelFill: 'red',
                        categoryIndex: 1,
                        color: 'red',
                        selected: false,
                        originalValue: 150,
                        originalPosition: 150,
                        originalValueAbsolute: 150,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "prod", value: "b" }, { displayName: "sales", value: "150" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(legendItems).toEqual([
                { icon: 0, color: '#01B8AA', label: 'sales', identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('Gradient measure: should not become a series', function () {
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: [
                        powerbitests.mocks.dataViewScopeIdentity("2011"),
                        powerbitests.mocks.dataViewScopeIdentity("2012"),
                    ],
                }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: Prototype.inherit(measureColumn, function (c) { return c.roles = { 'Y': true }; }),
                        values: [100, 200],
                    },
                    {
                        source: Prototype.inherit(measure2Column, function (c) { return c.roles = { 'Gradient': true }; }),
                        values: [75, 50],
                    }
                ])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            expect(data.legendData.dataPoints.length).toBe(1);
            expect(data.series.length).toBe(1);
            expect(data.series[0].data.length).toBe(2);
            expect(data.series[0].data.map(pruneColunnChartDataPoint)).toEqual([
                {
                    categoryValue: 2011,
                    value: 100,
                },
                {
                    categoryValue: 2012,
                    value: 200,
                }
            ]);
        });
        it('single measure with infinite value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, Number.POSITIVE_INFINITY]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: measureColumn.displayName,
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: Number.MAX_VALUE,
                        position: Number.MAX_VALUE,
                        valueAbsolute: Number.MAX_VALUE,
                        valueOriginal: Number.MAX_VALUE,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: Number.MAX_VALUE,
                        originalPosition: Number.MAX_VALUE,
                        originalValueAbsolute: Number.MAX_VALUE,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$179769313486231600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: Number.MAX_VALUE
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('single measure with negative infinite value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, Number.NEGATIVE_INFINITY]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: measureColumn.displayName,
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: -Number.MAX_VALUE,
                        position: 0,
                        valueAbsolute: Number.MAX_VALUE,
                        valueOriginal: -Number.MAX_VALUE,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -Number.MAX_VALUE,
                        originalPosition: 0,
                        originalValueAbsolute: Number.MAX_VALUE,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$179769313486231600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -Number.MAX_VALUE,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('single measure with NaN value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, Number.NaN]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: measureColumn.displayName,
                identity: SelectionId.createWithMeasure("selectSales"),
                data: [
                    {
                        categoryValue: 2011,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 2012,
                        value: null,
                        position: 0,
                        valueAbsolute: 0,
                        valueOriginal: null,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: null,
                        originalPosition: 0,
                        originalValueAbsolute: 0,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "2012" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('Tooltip info formatString with measure that has no object', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: [2011, 2012],
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureWithFormatString,
                    values: [100, 200]
                }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            expect(data.series[0].data[0].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "tax", value: "$100" }]);
            expect(data.series[0].data[1].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "tax", value: "$200" }]);
        });
        it('dataView that should pivot categories', function () {
            var metadata = {
                columns: [
                    { displayName: '', index: 0 },
                    { displayName: '', isMeasure: true, index: 1 },
                ]
            };
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var categoryColRefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'category' });
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b'],
                        identity: seriesIdentities,
                        identityFields: [categoryColRefExpr],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200]
                        }
                    ])
                }
            };
            dataView = DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: powerbi.visuals.plugins.columnChart.capabilities.objects,
                dataViewMappings: powerbi.visuals.plugins.columnChart.capabilities.dataViewMappings,
                transforms: {
                    selects: [
                        { displayName: 'col1', queryName: 'select1', roles: { 'Series': true } },
                        { displayName: 'col2', queryName: 'select2', roles: { 'Y': true } },
                    ]
                },
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
            })[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView.categorical, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(seriesIdentities[0], 'select2'),
                SelectionId.createWithIdAndMeasure(seriesIdentities[1], 'select2'),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'a',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], 'select2'),
                data: [
                    {
                        categoryValue: null,
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: legendItems[0].color,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'b',
                identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], 'select2'),
                data: [
                    {
                        categoryValue: null,
                        value: 200,
                        position: 300,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 1,
                        labelFill: legendItems[1].color,
                        categoryIndex: 0,
                        color: legendItems[1].color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 300,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "200" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
            expect(legendItems).toEqual([
                { icon: 0 /* Box */, color: legendItems[0].color, label: 'a', identity: selectionIds[0], selected: false },
                { icon: 0 /* Box */, color: legendItems[1].color, label: 'b', identity: selectionIds[1], selected: false }
            ]);
        });
        it('dataView with Series & Category role that should pivot categories', function () {
            var metadata = {
                columns: [
                    { displayName: 'col1', queryName: 'selectCol1', roles: { "Series": true, "Category": true } },
                    { displayName: 'col2', queryName: 'selectCol2', properties: { "Y": true } },
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var categoryColRefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var dataView = DataViewSelfCrossJoin.apply({
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b'],
                        identity: categoryIdentities,
                        identityFields: [categoryColRefExpr],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200],
                        }
                    ])
                }
            });
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorByScale(SQExprShortSerializer.serialize(categoryColRefExpr), 'a').value;
            var series2Color = colors.getColorByScale(SQExprShortSerializer.serialize(categoryColRefExpr), 'b').value;
            var data = ColumnChart.converter(dataView.categorical, colors, undefined, undefined, undefined, metadata);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'selectCol2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'selectCol2'),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(legendItems.map(function (l) { return l.label; })).toEqual(['a', 'b']);
            // Should get a result shaped like a diagonal matrix
            expect(data.series).toEqual([{
                key: 'series0',
                index: 0,
                displayName: 'a',
                identity: selectionIds[0],
                data: [
                    {
                        categoryValue: 'a',
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        labelFill: '#01B8AA',
                        categoryIndex: 0,
                        color: series1Color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                        lastSeries: undefined,
                        chartType: undefined
                    },
                    {
                        categoryValue: 'b',
                        value: null,
                        position: 0,
                        valueAbsolute: 0,
                        valueOriginal: null,
                        seriesIndex: 0,
                        labelFill: '#01B8AA',
                        categoryIndex: 1,
                        color: '#01B8AA',
                        selected: false,
                        originalValue: null,
                        originalPosition: 0,
                        originalValueAbsolute: 0,
                        identity: jasmine.any(Object),
                        key: jasmine.any(String),
                        tooltipInfo: [{ displayName: "col1", value: "b" }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }, {
                key: 'series1',
                index: 1,
                displayName: 'b',
                identity: selectionIds[1],
                data: [
                    {
                        categoryValue: 'b',
                        value: 200,
                        position: 200,
                        valueAbsolute: 200,
                        valueOriginal: 200,
                        seriesIndex: 1,
                        labelFill: '#374649',
                        categoryIndex: 1,
                        color: series2Color,
                        selected: false,
                        originalValue: 200,
                        originalPosition: 200,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: 'col2', value: '200' }],
                        lastSeries: undefined,
                        chartType: undefined
                    }
                ]
            }]);
        });
        it('100% stacked -- rounding (-1)', function () {
            var selectionIds = [
                SelectionId.createWithMeasure("measure0"),
                SelectionId.createWithMeasure("measure1"),
            ];
            var data = [{
                key: '1',
                index: 0,
                displayName: 'measure0',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: -0.75,
                        position: 0,
                        valueAbsolute: 0.75,
                        valueOriginal: -0.75,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        labelFill: 'red',
                        color: 'red',
                        selected: false,
                        originalValue: -0.75,
                        originalPosition: 0,
                        originalValueAbsolute: 0.75,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedColumn
                    }
                ]
            }, {
                key: '2',
                index: 1,
                displayName: 'measure1',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: -0.25000001,
                        position: -0.75,
                        valueAbsolute: 0.25000001,
                        valueOriginal: -0.25000001,
                        categoryIndex: 0,
                        seriesIndex: 1,
                        labelFill: 'blue',
                        color: 'blue',
                        selected: false,
                        originalValue: -0.25000001,
                        originalPosition: -0.75,
                        originalValueAbsolute: 0.25000001,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedColumn
                    }
                ]
            }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: -1,
                max: 0
            });
        });
        it('100% stacked -- rounding (+1)', function () {
            var selectionIds = [
                SelectionId.createWithMeasure("measure0"),
                SelectionId.createWithMeasure("measure1"),
            ];
            var data = [{
                key: '1',
                index: 0,
                displayName: 'measure0',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: 0.25,
                        position: 0.25,
                        valueAbsolute: 0.25,
                        valueOriginal: 0.25,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        labelFill: 'red',
                        color: 'red',
                        selected: false,
                        originalValue: 0.25,
                        originalPosition: 0.25,
                        originalValueAbsolute: 0.25,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    }
                ]
            }, {
                key: '2',
                index: 1,
                displayName: 'measure1',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: 0.7500001,
                        position: 1.000001,
                        valueAbsolute: 0.75000001,
                        valueOriginal: 0.7500001,
                        categoryIndex: 0,
                        seriesIndex: 1,
                        labelFill: 'blue',
                        color: 'blue',
                        selected: false,
                        originalValue: 0.7500001,
                        originalPosition: 1.000001,
                        originalValueAbsolute: 0.75000001,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    }
                ]
            }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('100% stacked -- rounding (+1 and -1)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "measure0"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "measure1"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "measure0"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "measure1"),
            ];
            var data = [{
                key: '1',
                index: 0,
                displayName: 'measure0',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: -0.75,
                        position: 0,
                        valueAbsolute: 0.75,
                        valueOriginal: -0.75,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        color: 'red',
                        selected: false,
                        originalValue: -0.75,
                        originalPosition: 0,
                        originalValueAbsolute: 0.75,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    },
                    {
                        categoryValue: 1,
                        value: 0.25,
                        position: 0.25,
                        valueAbsolute: 0.25,
                        valueOriginal: 0.25,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        color: 'red',
                        selected: false,
                        originalValue: 0.25,
                        originalPosition: 0.25,
                        originalValueAbsolute: 0.25,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    }
                ]
            }, {
                key: '2',
                index: 1,
                displayName: 'measure1',
                identity: SelectionId.createNull(),
                data: [
                    {
                        categoryValue: 0,
                        value: -0.25000001,
                        position: -0.75,
                        valueAbsolute: 0.25000001,
                        valueOriginal: -0.25000001,
                        categoryIndex: 0,
                        seriesIndex: 1,
                        labelFill: 'blue',
                        color: 'blue',
                        selected: false,
                        originalValue: -0.25000001,
                        originalPosition: -0.75,
                        originalValueAbsolute: 0.25000001,
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    },
                    {
                        categoryValue: 1,
                        value: 0.7500001,
                        position: 1.000001,
                        valueAbsolute: 0.75000001,
                        valueOriginal: 0.7500001,
                        categoryIndex: 1,
                        seriesIndex: 1,
                        labelFill: 'blue',
                        color: 'blue',
                        selected: false,
                        originalValue: 0.7500001,
                        originalPosition: 1.000001,
                        originalValueAbsolute: 0.75000001,
                        identity: selectionIds[3],
                        key: selectionIds[3].getKey(),
                        chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                    }
                ]
            }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('createValueFormatter: value (hundreds)', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 200, value = 100;
            expect(ClusteredUtil.createValueFormatter(columns, max - min).format(value)).toBe('$100');
            expect(StackedUtil.createValueFormatter(columns, false, max - min).format(value)).toBe('$100');
        });
        it('createValueFormatter: value (millions)', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 2e6, value = 1e6;
            expect(ClusteredUtil.createValueFormatter(columns, max - min).format(value)).toBe('$1M');
            expect(StackedUtil.createValueFormatter(columns, false, max - min).format(value)).toBe('$1M');
        });
        it('createValueFormatter: 100% stacked', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 1, value = .5;
            expect(StackedUtil.createValueFormatter(columns, true, max - min).format(value)).toBe('50%');
        });
        var categoricalData = {
            categories: [],
            categoryFormatter: null,
            series: [],
            valuesMetadata: [],
            legendData: { dataPoints: [] },
            hasSelection: false,
            hasHighlights: false,
            selectedIds: [],
            categoryMetadata: null,
            scalarCategoryAxis: false,
            labelSettings: null,
            axesLabels: { x: null, y: null },
            hasDynamicSeries: false,
        };
        var metadataColumnText = {
            displayName: 'NumberCol',
            type: ValueType.fromDescriptor({ text: true })
        };
        var scalarData = {
            categories: [1, 2, 3],
            categoryFormatter: null,
            series: [{ key: '1', index: 0, displayName: '1', identity: SelectionId.createNull(), data: [] }],
            valuesMetadata: [],
            legendData: { dataPoints: [] },
            hasSelection: false,
            hasHighlights: false,
            selectedIds: [],
            categoryMetadata: null,
            scalarCategoryAxis: true,
            labelSettings: null,
            axesLabels: { x: null, y: null },
            hasDynamicSeries: false,
        };
        var metadataColumnNumber = {
            displayName: 'NumberCol',
            type: ValueType.fromDescriptor({ numeric: true })
        };
        var metadataColumnTime = {
            displayName: 'DateCol',
            type: ValueType.fromDescriptor({ dateTime: true })
        };
        it('getLayout: no category metadata', function () {
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 114,
                categoryCount: 1,
                domain: []
            })).toEqual({
                categoryCount: 1,
                categoryThickness: 30,
                outerPaddingRatio: 1.4,
                isScalar: false
            });
        });
        it('getLayout: text (one)', function () {
            categoricalData.categories = ['A'];
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 114,
                categoryCount: 1,
                domain: []
            })).toEqual({
                categoryCount: 1,
                categoryThickness: 30,
                outerPaddingRatio: 1.4,
                isScalar: false
            });
        });
        it('getLayout: text (few)', function () {
            categoricalData.categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 204,
                categoryCount: 6,
                domain: []
            })).toEqual({
                categoryCount: 6,
                categoryThickness: 30,
                outerPaddingRatio: 0.4,
                isScalar: false
            });
        });
        it('getLayout: text (too many)', function () {
            var cats = [];
            for (var i = 0, len = 200; i < len; i++) {
                cats.push(Math.round(Math.random()).toString());
            }
            categoricalData.categories = cats;
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 220,
                categoryCount: 200,
                domain: []
            })).toEqual({
                categoryCount: 10,
                categoryThickness: 20,
                outerPaddingRatio: 0.5,
                isScalar: false
            });
        });
        it('getLayout: number (few)', function () {
            var series = [];
            for (var i = 0, len = 10; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    // use pow to create x values that get farther apart (testing minInterval)
                    categoryValue: i * 10 + Math.pow(i * 10, 1.8),
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: '#41BEE9',
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnNumber;
            expect(CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 10,
                domain: [0, 6400],
                isScalar: true
            })).toEqual({
                categoryCount: 10,
                categoryThickness: 2,
                outerPaddingRatio: 0.4,
                isScalar: true
            });
        });
        it('getLayout: number (many)', function () {
            var series = [];
            for (var i = 0, len = 100; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    categoryValue: i + Math.pow(i, 1.8),
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: '#41BEE9',
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnNumber;
            expect(CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 100,
                domain: [0, 4000],
                isScalar: true
            })).toEqual({
                categoryCount: 49,
                categoryThickness: 2,
                outerPaddingRatio: 0.4,
                isScalar: true
            });
        });
        it('getLayout: datetime', function () {
            var series = [];
            for (var i = 0, len = 25; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    // use fractional pow to create x values that get closer together (testing minInterval)
                    categoryValue: new Date(2000, 1, 1).getTime() + Math.pow(i, 0.66) * 86000000,
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: '#41BEE9',
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnTime;
            var layout = CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 25,
                domain: [series[0].categoryValue, series[series.length - 1].categoryValue],
                isScalar: true
            });
            expect(layout.categoryCount).toEqual(25);
            expect(layout.categoryThickness).toBeCloseTo(2.7, 1);
            expect(layout.isScalar).toBeTruthy();
        });
        it('getLayout: datetime with highlights', function () {
            var series = [];
            var idx = 0;
            for (var i = 0, len = 10; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                idx = Math.floor(i / 2);
                var dataPoint = {
                    // use fractional pow to create x values that get closer together (testing minInterval)
                    categoryValue: new Date(2000, 1, 1).getTime() + Math.pow(idx, 0.66) * 86000000,
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: '#41BEE9',
                    categoryIndex: idx,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                if (i % 2 !== 0) {
                    dataPoint.highlight = true;
                }
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnTime;
            var layout = CartesianChart.getLayout(scalarData, {
                availableWidth: 400,
                categoryCount: idx + 1,
                domain: [series[0].categoryValue, series[series.length - 1].categoryValue],
                isScalar: true
            });
            expect(layout.categoryCount).toEqual(idx + 1);
            expect(layout.categoryThickness).toBeCloseTo(61, 0);
            expect(layout.isScalar).toBeTruthy();
        });
        it('getForcedTickValues: 0 forced tick count', function () {
            var expected = [];
            var actual = ColumnChart.getForcedTickValues(0, 100, 0);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 min', function () {
            var expected = [0, 50, 100];
            var actual = ColumnChart.getForcedTickValues(0, 100, 3);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 max', function () {
            var expected = [-200, -150, -100, -50, 0];
            var actual = ColumnChart.getForcedTickValues(-200, 0, 5);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 between min and max', function () {
            var expected = [-20, 40, 100, 0];
            var actual = ColumnChart.getForcedTickValues(-20, 100, 3);
            expect(actual).toEqual(expected);
        });
        it('getTickCount: 6 max tick count without forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measure2Column);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 6, false);
            expect(actual).toEqual(6);
        });
        it('getTickCount: 6 max tick count with 2 forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measureColumn);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 6, false, 2);
            expect(actual).toEqual(2);
        });
        it('getTickCount: 0 max tick count with 2 forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measureColumn);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 0, false, 2);
            expect(actual).toEqual(0);
        });
        it('getTickInterval: empty tick value', function () {
            var tickValues = [];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(0);
        });
        it('getTickInterval: single tick value', function () {
            var tickValues = [2.35];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(2.35);
        });
        it('getTickInterval: sorted tick values', function () {
            var tickValues = [48000, 48500, 49000, 49500, 50000];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(500);
        });
        it('getTickInterval: unsorted tick values', function () {
            var tickValues = [48500, 49000, 48000, 49500, 50000];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(500);
        });
    });
    function clusterColumnChartDomValidation(interactiveChart, scalarSetting) {
        var v, element;
        var dataViewMetadataTwoColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        var dataViewMetadataScalarDateTime = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(4 /* DateTime */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns) {
            var categoryAxisObject = scalarSetting ? { axisType: 'Scalar' } : { axisType: 'Categorical' };
            var metadata = {
                columns: columns,
                objects: { categoryAxis: categoryAxisObject }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('clusteredColumnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('clustered column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.data-labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart dom validation - datetime', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("1999/3/1"),
                powerbitests.mocks.dataViewScopeIdentity("1999/6/20"),
                powerbitests.mocks.dataViewScopeIdentity("2003/6/1"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataScalarDateTime),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataScalarDateTime[0],
                            values: [new Date(1999, 3, 1), new Date(1999, 6, 20), new Date(2003, 6, 1)],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataScalarDateTime[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234, 32]
                            },
                            {
                                source: dataViewMetadataScalarDateTime[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88, 44]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(6);
                if (scalarSetting) {
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(31, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(12, 0);
                }
                else {
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(179, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart dom validation - null datetime', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("1999/3/1"),
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity("2003/6/1"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataScalarDateTime),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataScalarDateTime[0],
                            values: [new Date(1999, 3, 1), null, new Date(2003, 6, 1)],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataScalarDateTime[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234, 32]
                            },
                            {
                                source: dataViewMetadataScalarDateTime[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88, 44]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                if (scalarSetting) {
                    expect($('.column').length).toBe(4);
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(363, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                else {
                    expect($('.column').length).toBe(6);
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(179, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [-123, -234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [-12, -88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toEqual(+$('.column')[0].attributes.getNamedItem('y').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart partial highlights with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [157, 260]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [18, 102]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('width').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart partial highlights with positive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('width').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart missing measure in first series to not be dropped in dom', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [null, 123]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 23]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, null]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                values: [0.0001, 234]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                values: [12, -0.0001]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var smallPositiveRectYValue = $('.column')[0].attributes.getNamedItem('y').value;
                var smallNegativeRectYValue = $('.column')[3].attributes.getNamedItem('y').value;
                expect(smallPositiveRectYValue).not.toEqual(smallNegativeRectYValue);
                done();
            }, DefaultWaitForRender);
        });
        it('empty clustered column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataTwoColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataTwoColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata(dataViewMetadataTwoColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        if (!interactiveChart) {
            it('legend formatting', function (done) {
                var categoryIdentities = [
                    powerbitests.mocks.dataViewScopeIdentity("abc"),
                    powerbitests.mocks.dataViewScopeIdentity("def"),
                ];
                var dataView = {
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            }
                        ])
                    }
                };
                dataView.metadata.objects = { legend: { show: true, position: 'Top' } };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.legend').attr('orientation')).toBe(0 /* Top */.toString());
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.legend').attr('orientation')).toBe(2 /* Right */.toString());
                        //set title
                        var testTitle = 'Test Title';
                        dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.legend').attr('orientation')).toBe(2 /* Right */.toString());
                            expect($('.legendTitle').text()).toBe(testTitle);
                            //hide legend
                            dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.legend').attr('orientation')).toBe(4 /* None */.toString());
                                done();
                            }, DefaultWaitForRender);
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
        }
    }
    describe("Clustered ColumnChart DOM validation", function () { return clusterColumnChartDomValidation(false, false); });
    describe("Clustered ColumnChart DOM validation - Scalar", function () { return clusterColumnChartDomValidation(false, true); });
    describe("Interactive Clustered ColumnChart DOM validation", function () { return clusterColumnChartDomValidation(true, false); });
    describe("Interactive Clustered ColumnChart DOM validation - Scalar", function () { return clusterColumnChartDomValidation(true, true); });
    function stackedColumnChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.data-labels').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('200K');
                if (interactiveChart)
                    expect($('.interactive-legend').length).toBe(1);
                else
                    expect($('.legend').attr('orientation')).toBe(4 /* None */.toString());
                done();
            }, DefaultWaitForRender);
        });
        it('single measure column chart with too many values for view dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
                powerbitests.mocks.dataViewScopeIdentity("f"),
                powerbitests.mocks.dataViewScopeIdentity("g"),
                powerbitests.mocks.dataViewScopeIdentity("h"),
                powerbitests.mocks.dataViewScopeIdentity("i"),
                powerbitests.mocks.dataViewScopeIdentity("j"),
                powerbitests.mocks.dataViewScopeIdentity("k"),
                powerbitests.mocks.dataViewScopeIdentity("l"),
                powerbitests.mocks.dataViewScopeIdentity("m"),
                powerbitests.mocks.dataViewScopeIdentity("n"),
                powerbitests.mocks.dataViewScopeIdentity("o"),
                powerbitests.mocks.dataViewScopeIdentity("p"),
                powerbitests.mocks.dataViewScopeIdentity("q"),
                powerbitests.mocks.dataViewScopeIdentity("r"),
                powerbitests.mocks.dataViewScopeIdentity("s"),
                powerbitests.mocks.dataViewScopeIdentity("y"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 10,
                            max: 30,
                            subtotal: 420,
                            values: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                // Data should be spliced down to a smaller set that will fit inside the view
                expect($('.column').length).toBe(13);
                // The max value in the view is ...
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('25');
                if (interactiveChart)
                    expect($('.interactive-legend').length).toBe(1);
                else
                    expect($('.legend').attr('orientation')).toBe(4 /* None */.toString());
                // now update with empty series values to test corner case where we slice the category data but have no series data
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                                identity: categoryIdentities,
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('stacked column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('with partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true } };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataWithLabelsObject.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataWithLabelsObject.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                if (interactiveChart)
                    // Collision detection hides a label
                    expect($('.data-labels').length).toBe(5);
                else
                    expect($('.data-labels').length).toBe(6);
                //opacity of highlighted labels 
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                //opacity of not highlighted labels 
                expect($(labels[0]).css('fill-opacity')).toEqual('0');
                expect($(labels[3]).css('fill-opacity')).toEqual('0');
                expect($(labels[2]).css('fill-opacity')).toEqual('0');
                expect($(labels[4]).css('fill-opacity')).toEqual('0');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: -234,
                                max: -123,
                                subtotal: -357,
                                values: [-123, -234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: -88,
                                max: -12,
                                subtotal: -100,
                                values: [-12, -88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBe(+$('.column')[0].attributes.getNamedItem('y').value);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [154, 274]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [26, 166]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight with postitive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, null]
                            }
                        ])
                    }
                }]
            });
            v.onResizing({ height: 500, width: 500 }, 0);
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.0001, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [12, -0.0001]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var smallPositiveRectYValue = $('.column')[0].attributes.getNamedItem('y').value;
                var smallNegativeRectYValue = $('.column')[3].attributes.getNamedItem('y').value;
                expect(smallPositiveRectYValue).not.toEqual(smallNegativeRectYValue);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart optimal ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [1, 3]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('3');
                done();
            }, DefaultWaitForRender);
        });
        it('empty stacked column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked ColumnChart DOM validation", function () { return stackedColumnChartDomValidation(false); });
    describe("Interactive Stacked ColumnChart DOM validation", function () { return stackedColumnChartDomValidation(true); });
    function hundredPercentStackedColumnChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('hundredPercentStackedColumnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataFourColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataFourColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000],
                            highlights: [50000, 10000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(2);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                expect($('.data-labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent column chart - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true } };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000],
                            highlights: [50000, 10000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                expect(labels.length).toBe(3);
                //opacity of highlighted columns
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                //opacity of not highlighted columns
                expect($(labels[0]).css('fill-opacity')).toEqual('0');
                expect($(labels[2]).css('fill-opacity')).toEqual('0');
                done();
            }, DefaultWaitForRender);
        });
        it('multi measure hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 100000,
                                max: 200000,
                                subtotal: 300000,
                                values: [100000, 200000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 100000,
                                max: 200000,
                                subtotal: 300000,
                                values: [100000, 200000]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, DefaultWaitForRender);
        });
        it('empty hundred percent column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                done();
            }, DefaultWaitForRender);
        });
        it('hundred percent column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    }
    describe("Hundred Percent Stacked ColumnChart DOM validation", function () { return hundredPercentStackedColumnChartDomValidation(false); });
    describe("Interactive Hundred Percent Stacked ColumnChart DOM validation", function () { return hundredPercentStackedColumnChartDomValidation(true); });
    function stackedBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ]
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ]
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure bar chart long labels dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends..."),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.data-labels').length).toBe(0);
                // Y-axis margin should be limited to a % of the chart area, and excess text should be replaced with an ellipsis.
                expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(100,8)');
                // Note: the exact text will be different depending on the environment in which the test is run, so we can't do an exact match.
                // Just check that the text is truncated with ellipses.
                var labelText = $('.columnChart .axisGraphicsContext .y.axis .tick').find('text').first().text();
                expect(labelText.length).toBeLessThan(30);
                expect(labelText.substr(labelText.length - 3)).toBe('...');
                done();
            }, DefaultWaitForRender);
        });
        it('single measure bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('200K');
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: -234,
                                max: -123,
                                subtotal: -357,
                                values: [-123, -234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: -88,
                                max: -12,
                                subtotal: -100,
                                values: [-12, -88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [154, 264]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [16, 166]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight with positive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('incremental render bar chart one to multiple series bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('200K');
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                // Legend should be empty, axis should be further up to take the extra space.
                if (!interactiveChart)
                    expect($('.legendItem')).not.toBeInDOM();
                // Note: depending on where the tests is run there can be a 1 pixel difference in the location of the axis
                //expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(25,8)');
                //expect(helpers.isTranslateCloseTo($('.columnChart .axisGraphicsContext').attr('transform'), 25, 8)).toBe(true);
                // Update the data set so that the chart is redrawn with multiple series and a legend
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataFourColumn.columns[0],
                                values: ['abc', 'def'],
                                identity: categoryIdentities,
                            }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88]
                                }
                            ])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.columnChart')).toBeInDOM();
                    expect($('.bar').length).toBe(4);
                    // Legend should be visible, axis shouldn't need to move, since we use relative layout
                    var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                    expect($(legendSelector)).toBeInDOM();
                    expect($(legendSelector).children.length).toBe(2);
                    //expect(helpers.isTranslateCloseTo($('.columnChart .axisGraphicsContext').attr('transform'), 28, 8)).toBe(true);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('stacked bar chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, null]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.0001, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [12, -0.0001]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                var smallPositiveRectXValue = $('.bar')[0].attributes.getNamedItem('x').value;
                var smallNegativeRectXValue = $('.bar')[3].attributes.getNamedItem('x').value;
                expect(smallPositiveRectXValue).not.toEqual(smallNegativeRectXValue);
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart optimal ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [1, 3]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('3');
                done();
            }, DefaultWaitForRender);
        });
        it('empty stacked bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, DefaultWaitForRender);
        });
        it('stacked bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked BarChart DOM validation", function () { return stackedBarChartDomValidation(false); });
    describe("Interactive Stacked BarChart DOM validation", function () { return stackedBarChartDomValidation(true); });
    function hundredPercentStackedBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ]
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('hundredPercentStackedBarChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataFourColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataFourColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000],
                            highlights: [50000, 10000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(2);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, DefaultWaitForRender);
        });
        it('multi measure hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 100000,
                                max: 200000,
                                subtotal: 300000,
                                values: [100000, 200000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 100000,
                                max: 200000,
                                subtotal: 300000,
                                values: [100000, 200000]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, DefaultWaitForRender);
        });
        it('empty hundred percent bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                done();
            }, DefaultWaitForRender);
        });
        it('hundred percent bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    }
    describe("Hundred Percent Stacked BarChart DOM validation", function () { return hundredPercentStackedBarChartDomValidation(false); });
    describe("Interactive Hundred Percent Stacked BarChart DOM validation", function () { return hundredPercentStackedBarChartDomValidation(true); });
    function clusterdBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('clusteredBarChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('clustered bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                min: 27,
                                max: 113,
                                subtotal: 140,
                                values: [27, 113]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(6);
                var rects = $('.bar');
                expect(rects.length).toBe(6);
                expect($('.data-labels').length).toBe(0);
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(1).attr('y'));
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(2).attr('y'));
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(4).attr('y'));
                expect(+rects.eq(2).attr('y')).toBeLessThan(+rects.eq(4).attr('y'));
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect($('.data-labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true, labelPrecision: 0 } };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataWithLabelsObject.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204]
                            },
                            {
                                source: dataViewMetadataWithLabelsObject.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                expect(labels.length).toBe(8);
                //opacity of highlighted labels 
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                expect($(labels[5]).css('fill-opacity')).toEqual('1');
                expect($(labels[3]).css('fill-opacity')).toEqual('1');
                //opacity of not highlighted labels 
                expect($(labels[0]).css('fill-opacity')).toEqual('0');
                expect($(labels[2]).css('fill-opacity')).toEqual('0');
                expect($(labels[4]).css('fill-opacity')).toEqual('0');
                expect($(labels[6]).css('fill-opacity')).toEqual('0');
                expect($(labels[6]).css('fill-opacity')).toEqual('0');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: -234,
                                max: -54,
                                subtotal: -357,
                                values: [-123, -234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: -88,
                                max: -12,
                                subtotal: -100,
                                values: [-12, -88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [150, 264]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [18, 104]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('height').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight with postiive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [-54, -204]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [-6, -66]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.bar')[0].attributes.getNamedItem('height').value);
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, null]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.0001, 234]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [12, -0.0001]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                var smallPositiveRectXValue = $('.bar')[0].attributes.getNamedItem('x').value;
                var smallNegativeRectXValue = $('.bar')[3].attributes.getNamedItem('x').value;
                expect(smallPositiveRectXValue).not.toEqual(smallNegativeRectXValue);
                done();
            }, DefaultWaitForRender);
        });
        it('empty clustered bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, DefaultWaitForRender);
        });
        it('clustered bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    }
    describe("Clustered BarChart DOM validation", function () { return clusterdBarChartDomValidation(false); });
    describe("Interactive Clustered BarChart DOM validation", function () { return clusterdBarChartDomValidation(true); });
    describe("Enumerate Objects", function () {
        var v, element;
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } } };
        var measure2Column = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('800', '800');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('enumerateObjectInstances: category+measure', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [categoryColumn, measureColumn] },
                    categorical: {
                        categories: [{
                            source: categoryColumn,
                            values: ['red', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            min: 100000,
                            max: 200000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[0]['properties']['defaultColor']).toBeDefined();
                expect(points[1]['properties']['showAllDataPoints']).toBeDefined();
                expect(points[2].displayName).toBe('red');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('def');
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                var points = v.enumerateObjectInstances({ objectName: 'legend' });
                expect(points).toBeUndefined();
                done();
            }, DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify instances on ordinal category axis', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [categoryColumn, measureColumn] },
                    categorical: {
                        categories: [{
                            source: categoryColumn,
                            values: ['red', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            min: 100000,
                            max: 200000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[2].displayName).toBe('red');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('def');
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                expect(points[0].properties['start']).toBeUndefined();
                expect(points[0].properties['end']).toBeUndefined();
                expect(points[0].properties['axisType']).toBeUndefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
                done();
            }, DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify instances on numerical category axis', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [measureColumn, measureColumn] },
                    categorical: {
                        categories: [{
                            source: measureColumn,
                            values: [5000, 10000],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            min: 100000,
                            max: 200000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[2].displayName).toBe('$5000');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('$10000');
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                expect('start' in points[0].properties).toBeTruthy(); //better to check if the index key is found
                expect('end' in points[0].properties).toBeTruthy();
                expect('axisType' in points[0].properties).toBeTruthy();
                expect('show' in points[0].properties).toBeTruthy();
                expect('showAxisTitle' in points[0].properties).toBeTruthy();
                expect('axisStyle' in points[1].properties).toBeTruthy();
                done();
            }, DefaultWaitForRender);
        });
        it('enumerateObjectInstances: category+multi-measure', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [categoryColumn, measureColumn] },
                    categorical: {
                        categories: [{
                            source: categoryColumn,
                            values: ['red', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: measureColumn,
                                min: 100000,
                                max: 200000,
                                values: [100000, 200000]
                            },
                            {
                                source: measure2Column,
                                min: 150,
                                max: 250,
                                values: [150, 250]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBe(measureColumn.displayName);
                expect(points[0].selector).toEqual({ metadata: measureColumn.queryName });
                expect(points[1].displayName).toBe(measure2Column.displayName);
                expect(points[1].selector).toEqual({ metadata: measure2Column.queryName });
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Column chart labels", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('800', '800');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check margins for long labels, when you have a few columns that do not take up the whole width, and get centered', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends..."),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 100000,
                            max: 200000,
                            subtotal: 300000,
                            values: [100000, 200000]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                //expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(36,8)');
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("BarChart Interactivity", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var DefaultOpacity = "" + ColumnUtil.DefaultOpacity;
        var DimmedOpacity = "" + ColumnUtil.DimmedOpacity;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
        });
        it('Bar chart with dragDataPoint enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var dataViewScopeIdentity2 = powerbitests.mocks.dataViewScopeIdentity('b');
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                dataViewScopeIdentity2,
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            spyOn(hostServices, 'onDragStart').and.callThrough();
            var trigger = powerbitests.helpers.getDragStartTriggerFunctionForD3(bars[1]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            trigger(mockEvent);
            expect(hostServices.onDragStart).toHaveBeenCalledWith({
                event: mockEvent,
                data: {
                    data: {
                        data: [dataViewScopeIdentity2]
                    }
                }
            });
        });
        it('Bar chart without dragDataPoint enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            var trigger = powerbitests.helpers.getDragStartTriggerFunctionForD3(bars[1]);
            expect(trigger).not.toBeDefined();
        });
        it('Bar chart with selection enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var dataViewScopeIdentity2 = powerbitests.mocks.dataViewScopeIdentity('b');
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                dataViewScopeIdentity2,
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            spyOn(hostServices, 'onSelect').and.callThrough();
            var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            trigger(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [dataViewScopeIdentity2]
                    }
                ]
            });
        });
        it('Bar chart without selection enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            expect(trigger).not.toBeDefined();
        });
        it('Bar chart multi-selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var mockEvent = {
                abc: 'def',
                ctrlKey: true,
                stopPropagation: function () {
                },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[0]]
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[0]]
                    },
                    {
                        data: [identities[3]]
                    }
                ]
            });
            trigger0(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[3]]
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: []
            });
        });
        it('Bar chart repeated single selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[0]]
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[3]]
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: []
            });
        });
        it('Bar chart single and multi selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[4]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            var mockMultiEvent = {
                abc: 'def',
                ctrlKey: true,
                stopPropagation: function () {
                },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[0]]
                    }
                ]
            });
            trigger3(mockMultiEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[0]]
                    },
                    {
                        data: [identities[3]]
                    }
                ]
            });
            trigger3(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[3]]
                    }
                ]
            });
            trigger1(mockMultiEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[3]]
                    },
                    {
                        data: [identities[1]]
                    }
                ]
            });
            trigger4(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        data: [identities[4]]
                    }
                ]
            });
        });
        it('Bar chart external clear selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                                powerbitests.mocks.dataViewScopeIdentity('d'),
                                powerbitests.mocks.dataViewScopeIdentity('e'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            v.onClearSelection();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
        });
        it('Bar clear selection on clearCatcher click', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                                powerbitests.mocks.dataViewScopeIdentity('d'),
                                powerbitests.mocks.dataViewScopeIdentity('e'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.5, 1.0, 2.5]
                        }])
                    }
                }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () {
                },
            };
            var triggerClear = powerbitests.helpers.getClickTriggerFunctionForD3($('.clearCatcher')[0]);
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            triggerClear(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: []
            });
        });
    });
    function columnChartInteractivity(chartType, columnSelector, thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: true },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
        });
        it('Drag and click interaction validation', function () {
            // drag and click on chart (not on bar) are implemented the same
            var barChart = v.layers[0];
            spyOn(barChart, 'selectColumn').and.callThrough();
            // click on the graph, expect selectColumn to have been called
            $('.columnChartMainGraphicsContext').d3Click(thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick);
            expect(barChart.selectColumn).toHaveBeenCalled();
            // now, instead of clicking on the graph, which can be unstable due to different user's configurations
            // we will validate that the code knows how to deal with such a click
            var selectedIndex = barChart.columnChart.getClosestColumnIndex(thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick);
            var expectedSelectedIndex = 2;
            expect(selectedIndex).toBe(expectedSelectedIndex);
        });
        it('Columns Opacity validation', function (done) {
            var barChart = v.layers[0];
            var selectedIndex = 2;
            barChart.selectColumn(selectedIndex);
            SVGUtil.flushAllD3TransitionsIfNeeded({ transitionImmediate: true });
            setTimeout(function () {
                var allRects = d3.selectAll('.bar' + columnSelector);
                expect(allRects).not.toBeEmpty();
                allRects.each(function (data, index) {
                    if (data.categoryIndex === selectedIndex) {
                        expect(parseFloat(($(allRects[0]).eq(index)).css('fill-opacity'))).toBeCloseTo(ColumnUtil.DefaultOpacity, 0);
                    }
                    else {
                        expect(parseFloat(($(allRects[0]).eq(index)).css('fill-opacity'))).toBeCloseTo(ColumnUtil.DimmedOpacity, 1);
                    }
                });
                done();
            }, DefaultWaitForRender);
        });
        it('Update legend is not called twice on same column', function () {
            var barChart = v.layers[0];
            var cartesianVisualHost = barChart.cartesianVisualHost;
            spyOn(cartesianVisualHost, 'updateLegend').and.callThrough();
            // first column is selected. try to select it again
            barChart.selectColumn(0);
            // update legend should not be called again
            expect(cartesianVisualHost.updateLegend).not.toHaveBeenCalled();
        });
        it('Legend validation validation', function () {
            var barChart = v.layers[0];
            // trigger select column
            barChart.selectColumn(2);
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            var item = legend.find('.item');
            var hoverLine = $('.interactive-hover-line');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('c');
            expect(item.find('.itemName').text()).toBe('col2');
            expect(item.find('.itemMeasure').text().trim()).toBe('490000');
            expect(hoverLine.length).toBe(1);
        });
    }
    var x = 250, y = 200;
    describe("Stacked Bar Chart Interactivity", function () { return columnChartInteractivity('barChart', '.bar', x, y); });
    describe("Clustered Bar Chart Interactivity", function () { return columnChartInteractivity('clusteredBarChart', '.bar', x, y); });
    describe("Hundred Percent Stacked Bar Chart Interactivity", function () { return columnChartInteractivity('hundredPercentStackedBarChart', '.bar', x, y); });
    describe("Stacked Column Chart Interactivity", function () { return columnChartInteractivity('columnChart', '.column', x, y); });
    describe("Clustered Column Chart Interactivity", function () { return columnChartInteractivity('clusteredColumnChart', '.column', x, y); });
    describe("Hundred Percent Stacked Column Chart Interactivity", function () { return columnChartInteractivity('hundredPercentStackedColumnChart', '.column', x, y); });
    function columnChartWebAnimations(chartType) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns
            };
            return metadata;
        }
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
                scrollableVisuals: false,
            }).getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('highlight Animation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewNoHighlights = {
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                            }
                        ])
                    }
                }]
            };
            var dataViewHighlightsA = {
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [54, 204],
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [6, 66],
                            }
                        ])
                    }
                }]
            };
            var dataViewHighlightsB = {
                dataViews: [{
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['abc', 'def'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234],
                                highlights: [120, 10],
                            },
                            {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88],
                                highlights: [8, 20],
                            }
                        ])
                    }
                }]
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged(dataViewNoHighlights);
            v.onDataChanged(dataViewHighlightsA);
            v.onDataChanged(dataViewHighlightsB);
            v.onDataChanged(dataViewNoHighlights);
            expect(animator).toBeTruthy();
            expect(animator.animate).toHaveBeenCalled();
            done();
        });
    }
    describe("Stacked Bar Chart Web Animations", function () { return columnChartWebAnimations('barChart'); });
    describe("Clustered Bar Chart Web Animations", function () { return columnChartWebAnimations('clusteredBarChart'); });
    describe("Hundred Percent Stacked Bar Chart Web Animations", function () { return columnChartWebAnimations('hundredPercentStackedBarChart'); });
    describe("Stacked Column Chart Web Animations", function () { return columnChartWebAnimations('columnChart'); });
    describe("Clustered Column Chart Web Animations", function () { return columnChartWebAnimations('clusteredColumnChart'); });
    describe("Hundred Percent Stacked Column Chart Web Animations", function () { return columnChartWebAnimations('hundredPercentStackedColumnChart'); });
    it('tooltip has category formatted date values', function () {
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: DataShapeUtility.describeDataType(SemanticType.Date), objects: { general: { formatString: "d" } } };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
        var categoryIdentities = [
            powerbitests.mocks.dataViewScopeIdentity("2011"),
            powerbitests.mocks.dataViewScopeIdentity("2012"),
        ];
        var dataView = {
            categories: [{
                source: categoryColumn,
                values: [new Date(2011, 4, 31), new Date(2012, 6, 30)],
                identity: categoryIdentities,
            }],
            values: DataViewTransform.createValueColumns([{
                source: measureColumn,
                values: [100, -200]
            }])
        };
        var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        var data = ColumnChart.converter(dataView, colors);
        var selectionIds = [
            SelectionId.createWithIdAndMeasure(categoryIdentities[0], measureColumn.queryName),
            SelectionId.createWithIdAndMeasure(categoryIdentities[1], measureColumn.queryName)
        ];
        var legendItems = data.legendData.dataPoints;
        expect(data.series).toEqual([{
            key: 'series0',
            index: 0,
            displayName: 'sales',
            identity: SelectionId.createWithMeasure("selectSales"),
            data: [
                {
                    categoryValue: new Date(2011, 4, 31).getTime(),
                    value: 100,
                    position: 100,
                    valueAbsolute: 100,
                    valueOriginal: 100,
                    seriesIndex: 0,
                    labelFill: legendItems[0].color,
                    categoryIndex: 0,
                    color: legendItems[0].color,
                    selected: false,
                    originalValue: 100,
                    originalPosition: 100,
                    originalValueAbsolute: 100,
                    identity: selectionIds[0],
                    key: selectionIds[0].getKey(),
                    tooltipInfo: [{ displayName: "year", value: "5/31/2011" }, { displayName: "sales", value: "100" }],
                    lastSeries: undefined,
                    chartType: undefined
                },
                {
                    categoryValue: new Date(2012, 6, 30).getTime(),
                    value: -200,
                    position: 0,
                    valueAbsolute: 200,
                    valueOriginal: -200,
                    seriesIndex: 0,
                    labelFill: legendItems[0].color,
                    categoryIndex: 1,
                    color: legendItems[0].color,
                    selected: false,
                    originalValue: -200,
                    originalPosition: 0,
                    originalValueAbsolute: 200,
                    identity: selectionIds[1],
                    key: selectionIds[1].getKey(),
                    tooltipInfo: [{ displayName: "year", value: "7/30/2012" }, { displayName: "sales", value: "-200" }],
                    lastSeries: undefined,
                    chartType: undefined
                }
            ]
        }]);
        expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-200, 100]);
        expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
            min: -200,
            max: 100
        });
    });
    function getChartWithTooManyValues(chartType, element) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        v = powerbi.visuals.visualPluginFactory.createMinerva({
            heatMap: false,
            scrollableVisuals: true,
        }).getPlugin(chartType).create();
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true },
        });
        var categoryIdentities = [
            powerbitests.mocks.dataViewScopeIdentity("a"),
            powerbitests.mocks.dataViewScopeIdentity("b"),
            powerbitests.mocks.dataViewScopeIdentity("c"),
            powerbitests.mocks.dataViewScopeIdentity("d"),
            powerbitests.mocks.dataViewScopeIdentity("e"),
            powerbitests.mocks.dataViewScopeIdentity("f"),
            powerbitests.mocks.dataViewScopeIdentity("g"),
            powerbitests.mocks.dataViewScopeIdentity("h"),
            powerbitests.mocks.dataViewScopeIdentity("i"),
            powerbitests.mocks.dataViewScopeIdentity("j"),
            powerbitests.mocks.dataViewScopeIdentity("k"),
            powerbitests.mocks.dataViewScopeIdentity("l"),
            powerbitests.mocks.dataViewScopeIdentity("m"),
            powerbitests.mocks.dataViewScopeIdentity("n"),
            powerbitests.mocks.dataViewScopeIdentity("o"),
            powerbitests.mocks.dataViewScopeIdentity("p"),
            powerbitests.mocks.dataViewScopeIdentity("q"),
            powerbitests.mocks.dataViewScopeIdentity("r"),
            powerbitests.mocks.dataViewScopeIdentity("s"),
            powerbitests.mocks.dataViewScopeIdentity("t"),
        ];
        v.onDataChanged({
            dataViews: [{
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataTwoColumn.columns[1],
                        min: 10,
                        max: 29,
                        subtotal: 390,
                        values: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
                    }])
                }
            }]
        });
        return v;
    }
    function barChartScrollbarValidation(chartType, columnSelector) {
        var element;
        var v;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('100', '100');
            v = getChartWithTooManyValues(chartType, element);
        });
        it('DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('rect' + columnSelector).length).toBe(4);
                expect($('rect.extent').length).toBe(1);
                expect($('rect' + columnSelector)[3].attributes.getNamedItem('y').value).toBeLessThan(element.height());
                var transform = SVGUtil.parseTranslateTransform($('.columnChart .axisGraphicsContext .y.axis .tick').last().attr('transform'));
                expect(transform.y).toBeLessThan(element.height());
                expect(transform.x).toBe('0');
                expect($('.brush').attr('transform')).toBe('translate(90,8)');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('height').value, 0)).toBeGreaterThan(8);
                expect($('.brush .extent')[0].attributes.getNamedItem('y').value).toBe('0');
                done();
            }, DefaultWaitForRender);
        });
        it('Scrollbar OnMousedown Validation', function (done) {
            var transform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
            var cartesianChart = v;
            var brush = v['brush'];
            var brushExtent = [40, 55];
            brush.extent(brushExtent);
            cartesianChart.setMinBrush(100, 10, 4);
            setTimeout(function () {
                var scrolledTransform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
                expect(transform.y).toEqual(scrolledTransform.y);
                expect(scrolledTransform.y).toBe('8');
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Bar chart scrollbar", function () { return barChartScrollbarValidation('barChart', '.bar'); });
    describe("ClusteredBarChart scrollbar", function () { return barChartScrollbarValidation('clusteredBarChart', '.bar'); });
    function columnChartScrollbarValidation(chartType, columnSelector) {
        var element;
        var v;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('100', '100');
            v = getChartWithTooManyValues(chartType, element);
        });
        it('DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('rect' + columnSelector).length).toBe(4);
                expect($('rect.extent').length).toBe(1);
                expect($('rect' + columnSelector)[3].attributes.getNamedItem('x').value).toBeLessThan(element.width());
                var transform = SVGUtil.parseTranslateTransform($('.columnChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.y).toBe('0');
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').attr('transform')).toBe('translate(22,90)');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBe(13);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, DefaultWaitForRender);
        });
        it('Scrollbar On Mousedown Validation', function (done) {
            var transform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
            var cartesianChart = v;
            var brush = v['brush'];
            var brushExtent = [25, 35];
            brush.extent(brushExtent);
            cartesianChart.setMinBrush(100, 10, 4);
            setTimeout(function () {
                var scrolledTransform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
                expect(transform.x).toEqual(scrolledTransform.x);
                expect(scrolledTransform.x).toBe('0');
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("ColumnChart scrollbar", function () { return columnChartScrollbarValidation('columnChart', '.column'); });
    describe("ClusteredcolumnChart Scrollbar", function () { return columnChartScrollbarValidation('clusteredColumnChart', '.column'); });
    describe("Column chart X axis label rotation/cutoff", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('400', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
        });
        it('long label cutoff at the left edge', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var longLabelValue = 'Very very very very long label';
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [longLabelValue, 'b', 'c', 'd'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity(longLabelValue),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                                powerbitests.mocks.dataViewScopeIdentity('d'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.0, 1.5]
                        }])
                    }
                }]
            });
            var actualLongLabelTextContent = element.find('.x.axis text')[0].textContent;
            expect(actualLongLabelTextContent).toContain("...");
        });
    });
    describe("X Axis Customization: Column Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var unitLength;
        var bars;
        var labels;
        var columnWidth;
        var dataChangedOptions;
        var lastIndex;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        function setAxisType(xType) {
            dataViewMetadataTwoColumn.objects['categoryAxis'].axisType = xType;
            dataChangedOptions.dataViews.metadata = dataViewMetadataTwoColumn;
        }
        ;
        it('X Axis Customization: Verify Scalar and Categorical axis type', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("20000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
                powerbitests.mocks.dataViewScopeIdentity("50000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 200000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [50, 20000, 10000, 50000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            bars = $('.column');
            var firstItemGap = (+bars[1].getAttribute('x') - (+bars[0].getAttribute('x') + +bars[0].getAttribute('width')));
            lastIndex = bars.length - 1;
            var lastItemGap = +bars[lastIndex].getAttribute('x') - (+bars[lastIndex - 1].getAttribute('x') + +bars[lastIndex - 1].getAttribute('width'));
            expect(firstItemGap).toBeGreaterThan(0);
            expect(lastItemGap).toBeGreaterThan(firstItemGap);
            setAxisType(AxisType.categorical);
            v.onDataChanged(dataChangedOptions);
            firstItemGap = (+bars[1].getAttribute('x') - (+bars[0].getAttribute('x') + +bars[0].getAttribute('width')));
            lastItemGap = +bars[lastIndex].getAttribute('x') - (+bars[lastIndex - 1].getAttribute('x') + +bars[lastIndex - 1].getAttribute('width'));
            expect(firstItemGap).toBeGreaterThan(0);
            expect(lastItemGap).toBeCloseTo(firstItemGap, 2);
        });
        it('Basic scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 100000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (bars[1].getAttribute('x') - bars[0].getAttribute('x')) / 1500;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 500, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 2000, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 5000, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(unitLength * 10000, 2);
            //Verify no column overlapping
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            expect(+bars[2].getAttribute('x') + +columnWidth).toBeLessThan(+bars[3].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0M');
            expect(labels[labels.length - 1].textContent).toBe('0.1M');
        });
        it('Big Range scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("50"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("100000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 50000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [50, 20000, 10000, 50000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (bars[1].getAttribute('x') - bars[0].getAttribute('x')) / 19950;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 50, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 10000, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 20000, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(unitLength * 50000, 2);
            //Verify no column overlapping
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            expect(+bars[2].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[3].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('50K');
        });
        it('Negative And Positive scale values check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("-50"),
                powerbitests.mocks.dataViewScopeIdentity("-70"),
                powerbitests.mocks.dataViewScopeIdentity("-40"),
                powerbitests.mocks.dataViewScopeIdentity("-100"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: -100,
                    end: 100,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [-50, 0, 40, -100],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (+bars[1].getAttribute('x') - +bars[0].getAttribute('x')) / 50;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 50, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 100, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 140, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(0, 2);
            //Verify no column overlapping
            expect(+bars[3].getAttribute('x') + +columnWidth).toBeLessThan(+bars[0].getAttribute('x'));
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('-100');
            expect(labels[labels.length - 1].textContent).toBe('100');
        });
    });
    describe("Y Axis Customization: Column Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var bars;
        var labels;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
            objects: {
                valueAxis: {
                    show: true,
                    position: 'Right',
                    start: 0,
                    end: 200000,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('verify begin & end', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify begin & end - Big Scale', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 50, 1000000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 1000000, 150000, 50]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify Y position change: the axis text should be further right than the axis line', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            var dataView = {
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: [500, 2000, 50, 1000000],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataTwoColumn.columns[1],
                        min: 50000,
                        max: 200000,
                        subtotal: 500000,
                        values: [100000, 1000000, 150000, 50]
                    }])
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            var yaxis = $('.y.axis');
            var yaxisLine = yaxis.find('line')[0];
            var yaxisText = yaxis.find('text')[0];
            expect(yaxisText['x']['baseVal'].getItem(0).value).toBeGreaterThan(yaxisLine['x2'].baseVal.value);
            setTimeout(function () {
                dataView.metadata.objects['valueAxis']['position'] = 'Left';
                v.onDataChanged({
                    dataViews: [dataView]
                });
                expect(yaxisText['x']['baseVal'].getItem(0).value).toBeLessThan(yaxisLine['x2'].baseVal.value);
            }, DefaultWaitForRender);
        });
    });
    describe("X Axis Customization: Bar Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var bars;
        var labels;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
            objects: {
                valueAxis: {
                    show: true,
                    position: true,
                    start: 0,
                    end: 200000,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('verify begin & end', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify begin & end - Big Range', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [5, 2000, 5000, 1000000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 2000000, 150000, 50]
                        }])
                    }
                }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
    });
    describe("Y Axis Customization: Bar Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var unitLength;
        var bars;
        var labels;
        var barHeight;
        var barHeightArray = [];
        var barArrayLength;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
            objects: {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 100000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('750', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('Basic scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 200000, 150000, 50000]
                        }])
                    }
                }]
            });
            bars = $('.bar');
            labels = $('.y.axis').children('.tick');
            barHeight = bars[0].getAttribute('height');
            barHeightArray = [];
            barArrayLength = bars.length;
            for (var i = 0; i < barArrayLength; i++) {
                barHeightArray.push(bars[i].getAttribute('y'));
            }
            barHeightArray.sort();
            unitLength = (+barHeightArray[1] - +barHeightArray[0]) / 5000;
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0M');
            expect(labels[labels.length - 1].textContent).toBe('0.1M');
        });
    });
    describe("Bar chart legend", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var dataViewMetadataTwoColumnWithGroup = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    groupName: 'group',
                },
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('400', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
        });
        it('hide legend when there is only one legend and no group', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c', 'd'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                                powerbitests.mocks.dataViewScopeIdentity('d'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [0.5, 2.0, 1.0, 1.5]
                        }])
                    }
                }]
            });
            var legend = element.find('.legend');
            var title = legend.find('.title');
            expect(title.length).toBe(0);
        });
        it('show legend when there is one legend and the legend is in a group', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('identity'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumnWithGroup,
                    categorical: {
                        categories: [
                            {
                                source: dataViewMetadataTwoColumnWithGroup.columns[0],
                                values: ['a', 'b', 'c', 'd'],
                                identity: identities,
                            }
                        ],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataTwoColumnWithGroup.columns[1],
                                values: [0.5, 2, 1, 1.5],
                                identity: identities[0],
                            },
                        ])
                    }
                }]
            });
            ;
            var title = $('.legendText');
            expect(title.length).toBe(1);
            expect(title.text()).toBe('group');
        });
    });
    function pruneColunnChartDataPoint(dataPoint) {
        return {
            categoryValue: dataPoint.categoryValue,
            value: dataPoint.value,
        };
    }
    function columnChartDataLabelsValidation(chartType) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        function metadataShowLabels(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Position Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [1000, 2000, 20],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.data-labels');
                switch (chartType) {
                    case 'barChart':
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        var bars = $('.bar');
                        var attrX1 = +$(bars[0]).attr('x');
                        var attrX2 = +$(bars[1]).attr('x');
                        var attrX3 = +$(bars[2]).attr('x');
                        var width1 = +$(bars[0]).attr('width');
                        var width2 = +$(bars[1]).attr('width');
                        var width3 = +$(bars[2]).attr('width');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('x')).toBeGreaterThan(attrX1 + width1);
                        expect($(labels[2]).attr('x')).toBeGreaterThan(attrX3 + width3);
                        //second data label is inside
                        expect($(labels[1]).attr('x')).toBeLessThan(attrX2 + width2);
                        expect($(labels[1]).attr('x')).toBeGreaterThan(attrX2);
                        break;
                    case 'columnChart':
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        var columns = $('.column');
                        var attrY1 = +$(columns[0]).attr('y');
                        var attrY2 = +$(columns[1]).attr('y');
                        var attrY3 = +$(columns[2]).attr('y');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('y')).toBeLessThan(attrY1);
                        expect($(labels[2]).attr('y')).toBeLessThan(attrY3);
                        //second data label is inside
                        expect($(labels[1]).attr('y')).toBeGreaterThan(attrY2);
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        expect($(labels[0]).attr('y')).toEqual($(labels[1]).attr('y'));
                        expect($(labels[1]).attr('y')).toEqual($(labels[2]).attr('y'));
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                        expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                }
                done();
            }, DefaultWaitForRender);
        });
        it('Data Label Position Validation negative value', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [-1000, 2000, -20],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.data-labels');
                var bars = $('.bar');
                switch (chartType) {
                    case 'barChart':
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).toEqual($(labels[2]).attr('x'));
                        var attrX1 = +$(bars[0]).attr('x');
                        var attrX2 = +$(bars[1]).attr('x');
                        var attrX3 = +$(bars[2]).attr('x');
                        var width1 = +$(bars[0]).attr('width');
                        var width2 = +$(bars[1]).attr('width');
                        var width3 = +$(bars[2]).attr('width');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('x')).toBeGreaterThan(attrX1 + width1);
                        expect($(labels[2]).attr('x')).toBeGreaterThan(attrX3 + width3);
                        //second data label is inside
                        expect($(labels[1]).attr('x')).toBeLessThan(attrX2 + width2);
                        expect($(labels[1]).attr('x')).toBeGreaterThan(attrX2);
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).toEqual($(labels[2]).attr('x'));
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[1]).attr('y')).not.toEqual($(labels[2]).attr('y'));
                        expect($(labels[0]).attr('y')).toEqual($(labels[2]).attr('y'));
                        break;
                }
                done();
            }, DefaultWaitForRender);
        });
        it('Data Label Position Validation - multi series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataChangedOptions = {
                dataViews: [{
                    metadata: metadataShowLabels(dataViewMetadataTwoColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata1Category2Measure.columns[1],
                            values: [-200, 100, 150],
                            subtotal: 450
                        }, {
                            source: dataViewMetadata1Category2Measure.columns[2],
                            values: [-300, 300, 30],
                            subtotal: 630
                        }])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var labels = $('.data-labels');
                var bars;
                var startBar1, startBar2, startBar3, startBar4, startBar5, startBar6;
                var lengthBar1, lengthBar2, lengthBar3, lengthBar4, lengthBar5, lengthBar6;
                if (chartType === 'barChart' || chartType === 'hundredPercentStackedBarChart' || chartType === 'clusteredBarChart') {
                    bars = $('.bar');
                    startBar1 = +$(bars[0]).attr('x');
                    startBar2 = +$(bars[1]).attr('x');
                    startBar3 = +$(bars[2]).attr('x');
                    startBar4 = +$(bars[3]).attr('x');
                    startBar5 = +$(bars[5]).attr('x');
                    lengthBar1 = +$(bars[0]).attr('width');
                    lengthBar2 = +$(bars[1]).attr('width');
                    lengthBar3 = +$(bars[2]).attr('width');
                    lengthBar4 = +$(bars[3]).attr('width');
                    lengthBar5 = +$(bars[5]).attr('width');
                }
                else {
                    bars = $('.column');
                    startBar1 = +$(bars[0]).attr('y');
                    startBar2 = +$(bars[1]).attr('y');
                    startBar3 = +$(bars[2]).attr('y');
                    startBar4 = +$(bars[3]).attr('y');
                    startBar5 = +$(bars[4]).attr('y');
                    startBar6 = +$(bars[5]).attr('y');
                    lengthBar1 = +$(bars[0]).attr('height');
                    lengthBar2 = +$(bars[1]).attr('height');
                    lengthBar3 = +$(bars[2]).attr('height');
                    lengthBar4 = +$(bars[3]).attr('height');
                    lengthBar5 = +$(bars[4]).attr('height');
                    lengthBar6 = +$(bars[5]).attr('height');
                }
                switch (chartType) {
                    case 'barChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('x'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('x'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('x'));
                        //outside end position
                        expect(startBar1 + lengthBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeLessThan($(labels[4]).attr('x'));
                        break;
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(6);
                        //outside end position
                        expect(startBar1 + lengthBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeLessThan($(labels[4]).attr('x'));
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(5);
                        startBar5 = +$(bars[4]).attr('x');
                        lengthBar5 = +$(bars[4]).attr('width');
                        //inside center position
                        expect(startBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar1 + lengthBar1).toBeGreaterThan($(labels[0]).attr('x'));
                        expect(startBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('x'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('x'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('x'));
                        expect(startBar5).toBeLessThan($(labels[4]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeGreaterThan($(labels[4]).attr('x'));
                        break;
                    case 'columnChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar2).toBeLessThan($(labels[1]).attr('y'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('y'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('y'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        //outside end position
                        expect(startBar1).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(6);
                        //outside end position
                        expect(startBar1).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        expect(startBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar1).toBeLessThan($(labels[0]).attr('y'));
                        expect(startBar1 + lengthBar2).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar2).toBeLessThan($(labels[1]).attr('y'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('y'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('y'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        expect(startBar5).toBeLessThan($(labels[4]).attr('y'));
                        expect(startBar5 + lengthBar5).toBeGreaterThan($(labels[4]).attr('y'));
                        expect(startBar6).toBeLessThan($(labels[5]).attr('y'));
                        expect(startBar6 + lengthBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                }
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('barChart'); });
    describe("Clustered Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('clusteredBarChart'); });
    describe("Hundred Percent Stacked Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('hundredPercentStackedBarChart'); });
    describe("Stacked Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('columnChart'); });
    describe("Clustered Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('clusteredColumnChart'); });
    describe("Hundred Percent Stacked Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('hundredPercentStackedColumnChart'); });
    function columnChartDataLabelsVisibilityValidation(chartType, show) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: show, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Visibility Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force',],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [20, 100],
                        subtotal: 120
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                if (show)
                    expect($(labels[0]).css('fill-opacity')).toEqual('1');
                else
                    expect($(labels[0]).length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels Visibility", function () { return columnChartDataLabelsVisibilityValidation('barChart', true); });
    describe("Clustered Bar Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('clusteredBarChart', true); });
    describe("Hundred Percent Stacked Bar Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedBarChart', true); });
    describe("Stacked Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('columnChart', true); });
    describe("Clustered Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('clusteredColumnChart', true); });
    describe("Hundred Percent Stacked Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedColumnChart', true); });
    describe("Stacked Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('barChart', false); });
    describe("Clustered Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('clusteredBarChart', false); });
    describe("Hundred Percent Stacked Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedBarChart', false); });
    describe("Stacked Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('columnChart', false); });
    describe("Clustered Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('clusteredColumnChart', false); });
    describe("Hundred Percent Stacked Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedColumnChart', false); });
    function columnChartDataLabelsColorValidation(chartType, color) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        var dataViewMetadataTwoColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, color: { solid: { color: color } } }
            };
            return metadata;
        }
        function metadataWithoutColor(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Color Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force',],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [20, 1000],
                        subtotal: 1020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                //labels should be visible now for all charts
                expect(ColorUtility.convertFromRGBorHexToHex($(labels[0]).css('fill'))).toEqual(ColorUtility.convertFromRGBorHexToHex('#ff0000'));
                done();
            }, DefaultWaitForRender);
        });
        it('Label color should be different from rect color when position inside', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadataWithoutColor(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo', 'Delta Force',],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [20, 1000],
                        subtotal: 1020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            var rects = $('.columnChartMainGraphicsContext rect');
            setTimeout(function () {
                switch (chartType) {
                    case "barChart":
                    case "clusteredBarChart":
                    case "columnChart":
                    case "clusteredColumnChart":
                        //first labels is outside - get bar color
                        expect($(rects[0]).css('fill')).toEqual($(labels[0]).css('fill'));
                        //second label is inside - get white color
                        expect($(labels[1]).css('fill')).toEqual('#ffffff');
                        break;
                    case "hundredPercentStackedBarChart":
                    case "hundredPercentStackedColumnChart":
                        for (var i = 0; i < labels.length; i++) {
                            expect($(rects[i]).css('fill')).not.toEqual($(labels[i]).css('fill'));
                        }
                        break;
                }
                done();
            }, DefaultWaitForRender);
        });
        it('Data Label Color Validation - multi series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
            var dataChangedOptions = {
                dataViews: [{
                    metadata: metadataWithoutColor(dataViewMetadataTwoColumn),
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata1Category2Measure.columns[1],
                            values: [-200, 150, 150],
                            subtotal: 500
                        }, {
                            source: dataViewMetadata1Category2Measure.columns[2],
                            values: [-300, 300, 30],
                            subtotal: 630
                        }])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var labels = $('.data-labels');
                var white = '#ffffff';
                var bars;
                if (chartType === 'barChart' || chartType === 'hundredPercentStackedBarChart' || chartType === 'clusteredBarChart') {
                    bars = $('.bar');
                }
                else {
                    bars = $('.column');
                }
                switch (chartType) {
                    case 'barChart':
                        expect(labels.length).toBe(6);
                        //inside center position - white color 
                        expect($(labels[1]).css('fill')).toBe(white);
                        expect($(labels[2]).css('fill')).toBe(white);
                        expect($(labels[3]).css('fill')).toBe(white);
                        //outside end position - shape color
                        expect($(bars[0]).css('fill')).toBe($(labels[0]).css('fill'));
                        expect($(bars[4]).css('fill')).toBe($(labels[4]).css('fill'));
                        expect($(bars[5]).css('fill')).toBe($(labels[5]).css('fill'));
                        break;
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(6);
                        //outside end position- shape color
                        expect($(bars[0]).css('fill')).toBe($(labels[0]).css('fill'));
                        expect($(bars[1]).css('fill')).toBe($(labels[1]).css('fill'));
                        expect($(bars[2]).css('fill')).toBe($(labels[2]).css('fill'));
                        expect($(bars[3]).css('fill')).toBe($(labels[3]).css('fill'));
                        expect($(bars[5]).css('fill')).toBe($(labels[5]).css('fill'));
                        //inside center position- white color
                        expect($(labels[4]).css('fill')).toBe(white);
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(5);
                        //inside center position - white color
                        expect($(labels[0]).css('fill')).toBe(white);
                        expect($(labels[1]).css('fill')).toBe(white);
                        expect($(labels[2]).css('fill')).toBe(white);
                        expect($(labels[3]).css('fill')).toBe(white);
                        expect($(labels[4]).css('fill')).toBe(white);
                        break;
                    case 'columnChart':
                        expect(labels.length).toBe(6);
                        //inside center position - white color
                        expect($(labels[1]).css('fill')).toBe(white);
                        expect($(labels[2]).css('fill')).toBe(white);
                        expect($(labels[3]).css('fill')).toBe(white);
                        //outside end position - shape color
                        expect($(bars[0]).css('fill')).toBe($(labels[0]).css('fill'));
                        expect($(bars[5]).css('fill')).toBe($(labels[5]).css('fill'));
                        break;
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(6);
                        //outside end position - shape color
                        expect($(bars[0]).css('fill')).toBe($(labels[0]).css('fill'));
                        expect($(bars[1]).css('fill')).toBe($(labels[1]).css('fill'));
                        expect($(bars[2]).css('fill')).toBe($(labels[2]).css('fill'));
                        expect($(bars[3]).css('fill')).toBe($(labels[3]).css('fill'));
                        expect($(bars[5]).css('fill')).toBe($(labels[5]).css('fill'));
                        //inside center position- white color
                        expect($(labels[4]).css('fill')).toBe(white);
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(6);
                        //inside center position- white color
                        expect($(labels[0]).css('fill')).toBe(white);
                        expect($(labels[1]).css('fill')).toBe(white);
                        expect($(labels[2]).css('fill')).toBe(white);
                        expect($(labels[3]).css('fill')).toBe(white);
                        expect($(labels[4]).css('fill')).toBe(white);
                        expect($(labels[5]).css('fill')).toBe(white);
                        break;
                }
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('barChart', 'rgb(255, 0, 0)'); });
    describe("Clustered Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('clusteredBarChart', 'rgb(255, 0, 0)'); });
    describe("Hundred Percent Stacked Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('hundredPercentStackedBarChart', 'rgb(255, 0, 0)'); });
    describe("Stacked Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('columnChart', 'rgb(255, 0, 0)'); });
    describe("Clustered Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('clusteredColumnChart', 'rgb(255, 0, 0)'); });
    describe("Hundred Percent Stacked Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('hundredPercentStackedColumnChart', 'rgb(255, 0, 0)'); });
    it('Column Chart X and Y-axis show/hide Title ', function () {
        var element = powerbitests.helpers.testDom('500', '500');
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
        var v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            interactivity: { isInteractiveLegend: false },
            animation: { transitionImmediate: true },
        });
        var dataViewMetadataOneColumn = {
            columns: [
                {
                    displayName: 'AxesTitleTest',
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
            objects: {
                categoryAxis: {
                    showAxisTitle: true
                },
                valueAxis: {
                    showAxisTitle: true
                }
            }
        };
        v.onDataChanged({
            dataViews: [{
                metadata: dataViewMetadataOneColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataOneColumn.columns[0],
                        values: [500, 2000, 5000, 10000],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataOneColumn.columns[0],
                        values: [20, 1000],
                        subtotal: 1020
                    }])
                }
            }]
        });
        expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
        expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
        dataViewMetadataOneColumn.objects = {
            categoryAxis: {
                showAxisTitle: false
            },
            valueAxis: {
                showAxisTitle: false
            }
        };
        v.onDataChanged({
            dataViews: [{
                metadata: dataViewMetadataOneColumn,
            }]
        });
        expect($('.xAxisLabel').length).toBe(0);
        expect($('.yAxisLabel').length).toBe(0);
    });
    function columnChartDataLabelsFormatValidation(chartType) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: DataShapeUtility.describeDataType(2048 /* String */)
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: DataShapeUtility.describeDataType(1 /* Number */)
            }
        ];
        function metadata(columns, displayUnits, precision) {
            if (displayUnits === void 0) { displayUnits = 0; }
            if (precision === void 0) { precision = 0; }
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, labelDisplayUnits: displayUnits, labelPrecision: precision }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('1000', '1000');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('labels should support display units with no precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 1000, 0),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [500123],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('500K');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should support display units with precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 1000, 1),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [500123],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('500.1K');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should use default display unit automatically', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [1500123],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('1.50M');
                done();
            }, DefaultWaitForRender);
        });
        it('with NaN value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [NaN],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('with Negative Infinity value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [Number.NEGATIVE_INFINITY],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('with Infinity value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [Number.POSITIVE_INFINITY],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('with out of range value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumn[0],
                        values: ['John Domo'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataThreeColumn[1],
                        values: [1e301],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Column chart format validation", function () { return columnChartDataLabelsFormatValidation('columnChart'); });
    describe("Stacked Bar format validation", function () { return columnChartDataLabelsFormatValidation('barChart'); });
    describe("Clustered Bar Chart Labels Color", function () { return columnChartDataLabelsFormatValidation('clusteredBarChart'); });
    describe("Clustered Column Chart Labels Color", function () { return columnChartDataLabelsFormatValidation('clusteredColumnChart'); });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var ComboChart = powerbi.visuals.ComboChart;
    var SemanticType = powerbi.data.SemanticType;
    var ColorConvertor = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var AxisType = powerbi.axisType;
    var DefaultWaitForRender = 100;
    describe("ComboChart", function () {
        it('registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('comboChart').capabilities).toBe(ComboChart.capabilities);
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineClusteredColumnComboChart').capabilities).toBe(ComboChart.capabilities);
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineStackedColumnComboChart').capabilities).toBe(ComboChart.capabilities);
        });
        it('capabilities should include dataViewMappings', function () {
            expect(ComboChart.capabilities.dataViewMappings).toBeDefined();
        });
        it('capabilities should include dataRoles', function () {
            expect(ComboChart.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(ComboChart.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.ComboChart.capabilities.objects)).toEqual(powerbi.visuals.comboChartProps.general.formatString);
        });
    });
    describe("ComboChart DOM validation", function () {
        var v, element;
        function metadata(properties) {
            return {
                columns: [
                    { displayName: 'col1', queryName: 'col1', type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col4', queryName: 'col4', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                properties: properties,
            };
        }
        ;
        function numericMetadata(objects) {
            return {
                columns: [
                    { displayName: 'col1', queryName: 'col1', type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col4', queryName: 'col4', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                objects: objects,
            };
        }
        ;
        function dataViewWithSuperLongLabels(objects) {
            var dataViewMetadata = metadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['This is a pretty long label I think', 'This is a pretty long label I thought', 'This is a pretty long label I should think']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [1000, 2000, 7000],
                            subtotal: 10000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [1000000, 2000000, 7000000],
                            subtotal: 10000000
                        }
                    ])
                }
            };
        }
        ;
        function dataView(objects) {
            var dataViewMetadata = metadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [1000, 2000, 7000],
                            subtotal: 10000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 20000, 70000],
                            subtotal: 100000
                        }
                    ])
                }
            };
        }
        ;
        function dataViewWithInvalid(invalidType) {
            var val = NaN;
            switch (invalidType) {
                case 'PositiveInfinity':
                    val = Number.POSITIVE_INFINITY;
                    break;
                case 'NegativeInfinity':
                    val = Number.NEGATIVE_INFINITY;
                    break;
                case 'OutOfRange':
                    val = 1e301;
                    break;
                case 'NaN':
                    val = NaN;
                    break;
                default:
                    val = 3;
            }
            var dataViewMetadata = metadata();
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [val],
                            subtotal: 1000
                        }
                    ])
                }
            };
        }
        function dataViewNumeric(objects) {
            var dataViewMetadata = numericMetadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: [0, 500, 1000]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [1000, 2000, 7000],
                            subtotal: 10000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 20000, 70000],
                            subtotal: 100000
                        }
                    ])
                }
            };
        }
        ;
        var emptyDataView = {
            metadata: metadata(),
            categorical: {
                categories: [{
                    source: metadata().columns[0],
                    values: []
                }],
                values: DataViewTransform.createValueColumns([])
            }
        };
        function dataViewInAnotherDomain(objects) {
            var dataViewMetadata = metadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [1],
                            subtotal: 1
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [10],
                            subtotal: 10
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [20],
                            subtotal: 20
                        }
                    ])
                }
            };
        }
        ;
        function dataViewInAnotherDomainOneValue(objects) {
            var dataViewMetadata = metadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [1],
                            subtotal: 1
                        }
                    ])
                }
            };
        }
        ;
        function dataViewForLabels(type) {
            var dataViewMetadata = metadata();
            if (type === 1) {
                return {
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [50, 40, 150, 200, 500],
                            subtotal: 200
                        }])
                    }
                };
            }
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [200, 100, 300, 250, 400],
                        subtotal: 300
                    }])
                }
            };
        }
        function dataViewWithManyCategories(objects) {
            var dataViewMetadata = metadata(objects);
            return {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau', 'Cat1', 'Cat2', 'Cat3',]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [1000, 2000, 7000],
                            subtotal: 10000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 200, 700],
                            subtotal: 100000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 20000, 70000],
                            subtotal: 100000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 200, 700],
                            subtotal: 100000
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [10000, 20000, 70000],
                            subtotal: 100000
                        }
                    ])
                }
            };
        }
        ;
        beforeEach(function (done) {
            var localizationService = powerbi.common.createLocalizationService();
            powerbi.common.localize = localizationService;
            powerbitests.mocks.setLocale(localizationService);
            element = powerbitests.helpers.testDom('400', '400');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('comboChart').create();
            done();
        });
        it('Ensure both charts and axis created with two data views - default', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [dataView(), dataViewInAnotherDomain()] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect($('.legend').children.length).toBe(2);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y1).toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure empty 1st dataview and populated 2nd has correct axes and lines', function (done) {
            // if two dataviews come back but the first is filtered to empty,
            // we should use the x-axis from the 2nd and move the y2 axis to be a y1 value axis.
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [emptyDataView, dataView()] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxisCount = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxisCount).toBe(2); //one is empty
                expect(legend).toBe(1);
                var yAxisPos = $('.y.axis').position();
                var rectCount = $('.columnChart .column').length;
                var lineCount = $('.lineChart .cat path').length;
                expect(yAxisPos.left).toBeLessThan(50);
                expect(rectCount).toBe(0);
                expect(lineCount).toBe(3);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y1).toEqual(4);
                expect(y2).toEqual(0);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure comboCharts clear - default', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [dataViewInAnotherDomain(), dataView()] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                var rectCount = $('.columnChart .column').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect(rectCount).toBe(3);
                expect($('.legend').children.length).toBe(2);
                // clear line
                v.onDataChanged({ dataViews: [dataViewInAnotherDomain(), emptyDataView] });
                setTimeout(function () {
                    var rectCountNew = $('.columnChart .column').length;
                    expect(rectCountNew).toBe(3);
                    var catCountNew = $('.lineChart').find('.cat').length;
                    expect(catCountNew).toBe(0);
                    // clear columns, add back line
                    v.onDataChanged({ dataViews: [emptyDataView, dataView()] });
                    setTimeout(function () {
                        var rectCountFinal = $('.columnChart .column').length;
                        expect(rectCountFinal).toBe(0);
                        var catCountFinal = $('.lineChart').find('.cat').length;
                        expect(catCountFinal).toBe(3);
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('Ensure both charts and only one axis created with two data views - default', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [dataView(), dataView()] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect($('.legend').children.length).toBe(2);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure both charts and axis created with two data views - stacked', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'ColumnStacked',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataView(objects), dataViewInAnotherDomain(objects)] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y1).toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure both charts and One axis created with two data views - stacked', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'ColumnStacked',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataView(objects), dataView(objects)] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure both charts and axis created with two data views - clustered', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'ColumnClustered',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataView(objects), dataViewInAnotherDomain(objects)] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y1).toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure both charts and only one axis created with two data views - clustered', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'Column',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataView(objects), dataView(objects)] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($('.y.axis')[0]).find('.tick').length;
                var y2 = $($('.y.axis')[1]).find('.tick').length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, DefaultWaitForRender);
        });
        it('combo chart validate auto margin', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'Column',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataView(objects), dataView(objects)] });
            setTimeout(function () {
                var yTranslate = parseFloat($('.axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                var xTranslate = parseFloat($('.axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                v.onDataChanged({ dataViews: [dataViewWithSuperLongLabels(objects), dataViewWithSuperLongLabels(objects)] });
                setTimeout(function () {
                    var newYTranslate = parseFloat($('.axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                    var newXTranslate = parseFloat($('.axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                    expect(yTranslate).toBeGreaterThan(newYTranslate);
                    expect(newXTranslate).toBeGreaterThan(xTranslate);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('Ensure scrollbar is shown at smaller viewport dimensions', function (done) {
            element = powerbitests.helpers.testDom('100', '100');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
            }).getPlugin('lineClusteredColumnComboChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'ColumnClustered',
                    visualType2: 'Line',
                }
            };
            v.onDataChanged({ dataViews: [dataViewWithManyCategories(objects), dataViewWithManyCategories(objects)] });
            setTimeout(function () {
                var yAxis = $('.y.axis').length;
                expect(yAxis).toBe(2);
                var y1 = $('.svgScrollable').attr('width');
                expect(y1).toBeLessThan(element.width());
                expect($('rect.extent').length).toBe(1);
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(8);
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure all data points has the default color', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var objects = {
                general: {
                    visualType1: 'ColumnClustered',
                    visualType2: 'Line',
                }
            };
            var dataView1 = dataView(objects);
            var dataView2 = dataViewInAnotherDomain(objects);
            dataView1.metadata.objects = {
                dataPoint: {
                    defaultColor: { solid: { color: "#FF0000" } }
                }
            };
            dataView2.metadata.objects = {
                dataPoint: {
                    defaultColor: { solid: { color: "#FF0000" } }
                }
            };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var lineCharts = $('.lineChart').length;
                var columnCharts = $('.columnChart').length;
                var yAxis = $('.y.axis').length;
                var legend = $('.legend').length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect($($('.legendIcon')[0]).css('fill')).toBe("#ff0000");
                expect($($('.legendIcon')[2]).css('fill')).toBe("#ff0000");
                done();
            }, DefaultWaitForRender);
        });
        //Data Labels
        it('Ensure data labels are on both charts with default color', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = dataViewForLabels(2);
            dataView1.metadata.objects = { labels: { show: true } };
            dataView2.metadata.objects = { labels: { show: true } };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .data-labels');
                var lineLabels = $('.dataLabelsSVG .data-labels');
                var columns = $('.columnChartMainGraphicsContext .column');
                var lines = $('.mainGraphicsContext .dot');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                var fillColumnLabel = columnLabels.first().css('fill');
                var fillLineLabel = lineLabels.first().css('fill');
                var fillColumn = columns.first().css('fill');
                var fillLine = lines.first().css('fill');
                expect(fillColumnLabel).toBe(fillColumn);
                expect(fillLineLabel).toBe(fillLine);
                done();
            }, DefaultWaitForRender);
        });
        it('labels should support display units with no precision', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = dataViewForLabels(2);
            dataView1.metadata.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 } };
            dataView2.metadata.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 } };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .data-labels');
                var lineLabels = $('.dataLabelsSVG .data-labels');
                expect(columnLabels.first().text()).toBe('0K');
                expect(lineLabels.first().text()).toBe('0K');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should support display units with precision', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = dataViewForLabels(2);
            dataView1.metadata.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 1 } };
            dataView2.metadata.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 1 } };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .data-labels');
                var lineLabels = $('.dataLabelsSVG .data-labels');
                expect(columnLabels.first().text()).toBe('0.1K');
                expect(lineLabels.first().text()).toBe('0.2K');
                done();
            }, DefaultWaitForRender);
        });
        it('Values that have NaN show a warning.', function (done) {
            var hostService = powerbitests.mocks.createVisualHostServices();
            var warningSpy = jasmine.createSpy('warning');
            hostService.setWarnings = warningSpy;
            v.init({
                element: element,
                host: hostService,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [dataViewWithInvalid('NaN')] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Values that have Negative Infinity show a warning.', function (done) {
            var hostService = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostService,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var warningSpy = jasmine.createSpy('warning');
            hostService.setWarnings = warningSpy;
            v.onDataChanged({ dataViews: [dataViewWithInvalid('NegativeInfinity')] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Values that have Positive Infinity show a warning.', function (done) {
            var hostService = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostService,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var warningSpy = jasmine.createSpy('warning');
            hostService.setWarnings = warningSpy;
            v.onDataChanged({ dataViews: [dataViewWithInvalid('PositiveInfinity')] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Values that are out of range show a warning.', function (done) {
            var hostService = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostService,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var warningSpy = jasmine.createSpy('warning');
            hostService.setWarnings = warningSpy;
            v.onDataChanged({ dataViews: [dataViewWithInvalid('OutOfRange')] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, DefaultWaitForRender);
        });
        it('All values good do not show a warning.', function (done) {
            var hostService = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostService,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var warningSpy = jasmine.createSpy('warning');
            hostService.setWarnings = warningSpy;
            v.onDataChanged({ dataViews: [dataViewWithInvalid('Good')] });
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure data lables are on both charts with custom color', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = dataViewForLabels(2);
            var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
            dataView1.metadata.objects = { labels: { show: true, color: color } };
            dataView2.metadata.objects = { labels: { show: true, color: color } };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .data-labels');
                var lineLabels = $('.dataLabelsSVG .data-labels');
                // Commented because TSLINT throws exception on these vars: unused variable: 'columns', unused variable: 'lines'
                //var columns = $('.columnChartMainGraphicsContext .column');
                //var lines = $('.mainGraphicsContext .dot');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                var fillColumnLabel = columnLabels.first().css('fill');
                var fillLineLabel = lineLabels.first().css('fill');
                expect(ColorConvertor(fillColumnLabel)).toBe(ColorConvertor(color.solid.color));
                expect(ColorConvertor(fillLineLabel)).toBe(ColorConvertor(color.solid.color));
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure data lables are on both charts and removed', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = dataViewForLabels(2);
            dataView1.metadata.objects = { labels: { show: true } };
            dataView2.metadata.objects = { labels: { show: true } };
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .data-labels');
                var lineLabels = $('.dataLabelsSVG .data-labels');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                dataView1.metadata.objects = { labels: { show: false } };
                dataView2.metadata.objects = { labels: { show: false } };
                v.onDataChanged({ dataViews: [dataView1, dataView2] });
                setTimeout(function () {
                    var columnLabels2 = $('.columnChartMainGraphicsContext .data-labels');
                    var lineLabels2 = $('.dataLabelsSVG .data-labels');
                    expect(columnLabels2.length).toBe(0);
                    expect(lineLabels2.length).toBe(0);
                    done();
                }, DefaultWaitForRender);
                done();
            }, DefaultWaitForRender);
        });
        it('validate enumerate labels', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataView1 = dataViewForLabels(1);
            var dataView2 = null;
            v.onDataChanged({ dataViews: [dataView1, dataView2] });
            var points = v.enumerateObjectInstances({ objectName: 'labels' });
            setTimeout(function () {
                expect(points.length).toBeGreaterThan(0);
                done();
            }, DefaultWaitForRender);
        });
        it('xAxis customization- begin and end check', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var objects = {
                general: {
                    visualType1: 'Column',
                    visualType2: 'Line',
                },
                categoryAxis: {
                    displayName: 'scalar',
                    show: true,
                    start: 0,
                    end: 1000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({ dataViews: [dataViewNumeric(objects), dataViewNumeric(objects)] });
            setTimeout(function () {
                var labels = $('.x.axis').children('.tick');
                //Verify begin&end labels
                expect(labels[0].textContent).toBe('0.00');
                expect(labels[labels.length - 1].textContent).toBe('1,000.00');
                done();
            }, DefaultWaitForRender);
        });
        it('Verify force to zero works for a positive domain range', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataViewMetadata = metadata();
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [4000, 6000, 7000],
                            subtotal: 17000
                        }
                    ])
                }
            };
            v.onDataChanged({ dataViews: [dataViewInAnotherDomain(), dataView] });
            setTimeout(function () {
                var axisLabels = $('.axisGraphicsContext .y.axis').last().find('.tick');
                //Verify begin&end labels
                expect(axisLabels[0].textContent).toBe('0K');
                expect(axisLabels[axisLabels.length - 1].textContent).toBe('7K');
                done();
            }, DefaultWaitForRender);
        });
        it('Verify force to zero is not set for a negative domain range', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var dataViewMetadata = metadata();
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [-4000, -6000, -7000],
                            subtotal: -17000
                        }
                    ])
                }
            };
            v.onDataChanged({ dataViews: [dataViewInAnotherDomain(), dataView] });
            setTimeout(function () {
                var axisLabels = $('.axisGraphicsContext .y.axis').last().find('.tick');
                //Verify begin&end axis labels
                expect(axisLabels[0].textContent).toBe('-7,000.00');
                expect(axisLabels[axisLabels.length - 1].textContent).toBe('-4,000.00');
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure both titles created in Line and Stacked column chart', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var objects = {
                general: {
                    visualType1: 'Column',
                    visualType2: 'Line',
                },
                valueAxis: {
                    show: true,
                    showAxisTitle: true,
                    secShowAxisTitle: true
                }
            };
            v.onDataChanged({
                dataViews: [dataViewNumeric(objects), dataViewInAnotherDomainOneValue(objects)]
            });
            setTimeout(function () {
                var lineAxisLabel = $('.yAxisLabel').length;
                expect(lineAxisLabel).toBe(2);
                expect($('.yAxisLabel').first().text()).toBe('col2, col3 and col4');
                expect($('.yAxisLabel').last().text()).toBe('col2');
                done();
            }, DefaultWaitForRender);
        });
        it('Ensure only secondary title created in Line and Stacked column chart', function (done) {
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            var objects = {
                general: {
                    visualType1: 'Column',
                    visualType2: 'Line',
                },
                valueAxis: {
                    show: true,
                    showAxisTitle: false,
                    secShowAxisTitle: true
                }
            };
            v.onDataChanged({
                dataViews: [dataViewNumeric(objects), dataViewInAnotherDomainOneValue(objects)]
            });
            setTimeout(function () {
                var lineAxisLabel = $('.yAxisLabel').length;
                expect(lineAxisLabel).toBe(1);
                expect($('.yAxisLabel').first().text()).toBe('col2');
                done();
            }, DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
describe("DataColorPalette", function () {
    var dataColors = new powerbi.visuals.DataColorPalette();
    it('Check get color no duplicates until wrap-around', function () {
        // Note (param 0): Since conditional formatting is currently not supported, the datavalue param is ignored. For now the
        //                 test will pass in various objects just to make sure we don't crash. Once conditional formatting is
        //                 supported we should pass in objects that will excercise that the conditional formatting code.
        // Note (param 1): We need to support any object as the index key, since some charts will use number or string index keys
        var color0 = dataColors.getColor('test datavalue');
        expect(color0).toExist();
        var color1 = dataColors.getColor('series index N');
        expect(color1).toExist();
        expect(color0.value).not.toBe(color1.value);
        var color2 = dataColors.getColor({ seriesProperty: 'X' });
        expect(color2).toExist();
        expect(color1.value).not.toBe(color2.value);
        var color3 = dataColors.getColor(-1);
        expect(color3).toExist();
        expect(color2.value).not.toBe(color3.value);
        // Wrap around occurs after 40 (base color count) * 12 (cycles) colors currently. We should have no duplicates
        // until that point.
        var previousColor = color3;
        for (var i = 4; i < 480; ++i) {
            var nextColor = dataColors.getColor(i);
            expect(nextColor).toExist();
            expect(nextColor.value).not.toBe(previousColor.value);
            previousColor = nextColor;
        }
        // Wrap around should occur now, verify we are back to the start
        expect(dataColors.getColor('abc series')).toBe(color0);
    });
    it('Check get color same index key returns same color', function () {
        var indexKey0 = 4;
        var indexKey1 = 'pie slice 7';
        var color0_firstGet = dataColors.getColor(indexKey0);
        expect(color0_firstGet).toExist();
        var color1_firstGet = dataColors.getColor(indexKey1);
        expect(color1_firstGet).toExist();
        var color0_secondGet = dataColors.getColor(indexKey0);
        expect(color0_secondGet).toExist();
        expect(color0_secondGet.value).toBe(color0_firstGet.value);
        var color1_secondGet = dataColors.getColor(indexKey1);
        expect(color1_secondGet).toExist();
        expect(color1_firstGet.value).toBe(color1_secondGet.value);
    });
    // The Sentiment/KPI color API is just temporary until conditional formatting is avaiable, but while the API is active it needs to be tested.
    // We can remove this test once the Sentiment API is superseded by conditional formatting.
    it('Check get Sentiment color', function () {
        var sentimentColors = dataColors.getSentimentColors();
        // For now our visuals assume that there are 3 colors
        expect(sentimentColors.length).toBe(3);
        // Check for duplicates
        expect(sentimentColors[0].value).not.toBe(sentimentColors[1].value);
        expect(sentimentColors[1].value).not.toBe(sentimentColors[2].value);
        expect(sentimentColors[0].value).not.toBe(sentimentColors[2].value);
    });
    it('Check parameter colors', function () {
        var localDataColors = new powerbi.visuals.DataColorPalette([{ value: '#112233' }]);
        var firstColor = localDataColors.getColor(0);
        expect(firstColor.value).toBe('#112233');
    });
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataDotChart = powerbi.visuals.DataDotChart;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var SemanticType = powerbi.data.SemanticType;
    var EventType = powerbitests.helpers.ClickEventType;
    var ColumnUtil = powerbi.visuals.ColumnUtil;
    describe("Check DataDotChart capabilities", function () {
        it('DataDotChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('dataDotChart').capabilities).toBe(DataDotChart.capabilities);
        });
        it('DataDotChart capabilities should include dataRoles', function () {
            expect(DataDotChart.capabilities.dataRoles).toBeDefined();
        });
        it('DataDotChart capabilities should include dataViewMappings', function () {
            expect(DataDotChart.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(DataDotChart.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(DataDotChart.capabilities.objects)).toEqual(DataDotChart.formatStringProp);
        });
    });
    describe("DataDotChart converter", function () {
        var blankCategoryValue = '(Blank)';
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'stringColumn',
                    queryName: 'stringColumn',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'numberColumn',
                    queryName: 'numberColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'dateTimeColumn',
                    queryName: 'dateTimeColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */)
                }
            ]
        };
        it('Check converter with string categories undefined series', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: []
                    }],
                    values: undefined
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData).toBeDefined();
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(0);
        });
        it('Check converter with string categories and an empty numeric series', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Cat 1', 'Cat 2', 'Cat 3']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData).toEqual({
                series: {
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: []
                },
                hasHighlights: false,
                hasDynamicSeries: true
            });
        });
        it('Check converter with string categories and a numeric series', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Cat 1', 'Cat 2', 'Cat 3']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[0]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dataView.categorical.categories[0].values[i]);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter with empty categories and single numeric value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toBeUndefined();
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(blankCategoryValue);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter with undefined categories and single numeric value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toBeUndefined();
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(blankCategoryValue);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter with string categories and multiple numeric series', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Cat 1', 'Cat 2', 'Cat 3']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                    }, {
                        source: dataViewMetadata.columns[1],
                        values: [101, 201, 301],
                    }, {
                        source: dataViewMetadata.columns[1],
                        values: [102, 202, 302],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[0]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dataView.categorical.categories[0].values[i]);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter with date-time categories and a numeric series', function () {
            var dates = [new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[2],
                        values: dates
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[2]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dates[i].getTime());
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter with date-time categories and a numeric series where category value is null', function () {
            var dates = [new Date('2014/9/25'), null, new Date('2015/9/25')];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[2],
                        values: dates
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[2]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dates[i] ? dates[i].getTime() : null);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it('Check converter pass string categories and a numeric series produces identities', function () {
            var identityNames = ['John Domo', 'Delta Force', 'Jean Tablau'];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(identityNames[0]),
                powerbitests.mocks.dataViewScopeIdentity(identityNames[1]),
                powerbitests.mocks.dataViewScopeIdentity(identityNames[2]),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Cat 1', 'Cat 2', 'Cat 3'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.identity).toBeDefined();
                expect(seriesData.identity.getKey()).toContain(identityNames[i]);
            }
        });
        it('Check converter passed undefined categories produces measure name identities ', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100],
                    }])
                }
            };
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.identity).toBeDefined();
                expect(seriesData.identity.getKey()).toContain(dataViewMetadata.columns[1].displayName);
            }
        });
    });
    describe("DataDotChart render to DOM", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var DefaultWaitForRender = 100;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'stringColumn',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'numberColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'dateTimeColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */)
                }
            ]
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('dataDotChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: false }
            });
        });
        var categoryValues = ['a', 'b', 'c', 'd', 'e'];
        var categoryIdentities = categoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        function getOptionsForValueWarning(values) {
            var options = {
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: values,
                        }])
                    }
                }]
            };
            return options;
        }
        it('NaN in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([NaN]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Negative Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([Number.NEGATIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Positive Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([Number.POSITIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Out of range value in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([-1e301]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, DefaultWaitForRender);
        });
        it('Values all okay does not show a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([300]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, DefaultWaitForRender);
        });
        it('Check axis in DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.dataDotChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.dataDotChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.dataDotChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0M');
                expect($('.dataDotChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('0.5M');
                done();
            }, DefaultWaitForRender);
        });
        it('Check dots in DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var $dots = $('.dataDotChart .dot');
                expect($dots.length).toBe(5);
                var dotRadius = 0;
                $dots.each(function (index, elem) {
                    var $elem = $(elem);
                    // I verify all dots have the same non-zero radius
                    var radius = +$elem.attr('r');
                    if (index === 0) {
                        expect(radius).toBeGreaterThan(0);
                        dotRadius = radius;
                    }
                    else {
                        expect(radius).toEqual(dotRadius);
                    }
                    expect(+$elem.attr('cx')).toBeGreaterThan(0);
                    // The first and last dots are at the top
                    if (index === 0 || index === 4) {
                        expect(+$elem.attr('cy')).toBe(0);
                    }
                    else {
                        expect(+$elem.attr('cy')).toBeGreaterThan(0);
                    }
                });
                done();
            }, DefaultWaitForRender);
        });
        it('Check dot labels in DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var $labels = $('.dataDotChart .label');
                expect($labels.length).toBe(5);
                $labels.each(function (index, elem) {
                    var $elem = $(elem);
                    expect(+$elem.attr('x')).toBeGreaterThan(0);
                    // The first and last dots are at the top
                    if (index === 0 || index === 4) {
                        expect(+$elem.attr('y')).toBe(0);
                    }
                    else {
                        expect(+$elem.attr('y')).toBeGreaterThan(0);
                    }
                });
                var $label1 = $($labels.get(0));
                expect($label1.text()).toBe('0.5M');
                var $label3 = $($labels.get(2));
                expect($label3.text()).toBe('0.49M');
                done();
            }, DefaultWaitForRender);
        });
        var overflowCategoryValues = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        var overflowCategoryIdentities = overflowCategoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        it('Check dots text overflow handled in DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: overflowCategoryValues,
                            identity: overflowCategoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [999, 888, 777, 666, 555, 444, 333, 222, 111, 999, 888, 777, 666, 555, 444, 333, 222, 111, 999, 888, 777, 666, 555, 444, 333, 222],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var $labels = $('.dataDotChart .label');
                expect($labels.length).toBeGreaterThan(0);
                $labels.each(function (index, elem) {
                    var $elem = $(elem);
                    expect($elem.attr('class')).toContain('overflowed');
                });
                done();
            }, DefaultWaitForRender);
        });
        it('Check partial highlighting dots in DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            highlights: [100000, 195000, null, 180000, 9000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var $dots = $('.dataDotChart .dot');
                expect($dots.length).toBe(10);
                // I check partial highlighting
                var DefaultOpacity = "" + ColumnUtil.DefaultOpacity;
                var DimmedOpacity = "" + ColumnUtil.DimmedOpacity;
                expect($dots[0].style.fillOpacity).toBe(DimmedOpacity);
                expect($dots[1].style.fillOpacity).toBe(DefaultOpacity);
                expect($dots[2].style.fillOpacity).toBe(DimmedOpacity);
                expect($dots[3].style.fillOpacity).toBe(DefaultOpacity);
                expect($dots[4].style.fillOpacity).toBe(DimmedOpacity);
                expect($dots[5].style.fillOpacity).toBe(DefaultOpacity);
                expect($dots[6].style.fillOpacity).toBe(DimmedOpacity);
                expect($dots[7].style.fillOpacity).toBe(DefaultOpacity);
                expect($dots[8].style.fillOpacity).toBe(DimmedOpacity);
                expect($dots[9].style.fillOpacity).toBe(DefaultOpacity);
                // I check that null value causes .null-value css
                expect($($dots[5]).attr('class')).toContain('null-value');
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("DataDotChart interactivity in DOM", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var DefaultWaitForRender = 100;
        var DefaultOpacity = "" + ColumnUtil.DefaultOpacity;
        var DimmedOpacity = "" + ColumnUtil.DimmedOpacity;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'stringColumn',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'numberColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'dateTimeColumn',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */)
                }
            ]
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('dataDotChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true, isInteractiveLegend: false }
            });
        });
        var categoryValues = ['a', 'b', 'c', 'd', 'e'];
        var categoryIdentities = categoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        it('Check select dot', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var dots = $('.dataDotChart .dot');
                spyOn(hostServices, 'onSelect').and.callThrough();
                dots.first().d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('Check multi-select dot', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var dots = $('.dataDotChart .dot');
                spyOn(hostServices, 'onSelect').and.callThrough();
                dots.first().d3Click(0, 0);
                dots.last().d3Click(0, 0, 1 /* CtrlKey */);
                expect(dots[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(DimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        },
                        {
                            data: [categoryIdentities[4]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('Check external clear selection', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var dots = $('.dataDotChart .dot');
                spyOn(hostServices, 'onSelect').and.callThrough();
                dots.first().d3Click(0, 0);
                dots.last().d3Click(0, 0, 1 /* CtrlKey */);
                v.onClearSelection();
                expect(dots[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(DefaultOpacity);
                done();
            }, DefaultWaitForRender);
        });
        it('Check clearCatcher clear selection', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var dots = $('.dataDotChart .dot');
                dots.first().d3Click(0, 0);
                dots.last().d3Click(0, 0, 1 /* CtrlKey */);
                spyOn(hostServices, 'onSelect').and.callThrough();
                ($('.clearCatcher').last()).d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(DefaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ColorConvertor = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var DonutChart = powerbi.visuals.DonutChart;
    var SelectionId = powerbi.visuals.SelectionId;
    var SemanticType = powerbi.data.SemanticType;
    var donutColors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
    var DefaultWaitForRender = 10;
    describe("DonutChart", function () {
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true }
            ]
        };
        var dataViewMetadata3Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1', isMeasure: true },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
                { displayName: 'col3', queryName: 'col3', isMeasure: true }
            ]
        };
        var dataViewMetadata1Category2Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
                { displayName: 'col3', queryName: 'col3', isMeasure: true }
            ]
        };
        var dataViewMetadata1Category2MeasureWithFormat = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true, objects: { general: { formatString: "\$#,0;(\$#,0);\$#,0" } } },
                { displayName: 'col3', queryName: 'col3', isMeasure: true }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('DonutChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart').capabilities).toBe(powerbi.visuals.donutChartCapabilities);
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.donutChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('Donutchart preferred capabilities requires at least 2 row', function () {
            var dataViewWithSingleRow = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['a'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('a')]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100],
                        subtotal: 100
                    }])
                }
            };
            var dataViewWithTwoRows = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['a', 'b'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b')]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200],
                        subtotal: 300
                    }])
                }
            };
            var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart');
            expect(powerbi.DataViewAnalysis.supports(dataViewWithSingleRow, plugin.capabilities.dataViewMappings[0], true)).toBe(false);
            expect(powerbi.DataViewAnalysis.supports(dataViewWithTwoRows, plugin.capabilities.dataViewMappings[0])).toBe(true);
        });
        describe("Data Labels", function () {
            var v;
            var element;
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(SemanticType.Integer)
                    }
                ],
            };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            });
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.createMinerva({
                    heatMap: false,
                    dataDotChartOverride: false
                }).getPlugin('donutChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                });
            });
            function getOptionsForValueWarning(values) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true },
                    categoryLabels: { show: true }
                };
                var options = {
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: values,
                            }])
                        }
                    }]
                };
                return options;
            }
            it('NaN in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, NaN, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Negative Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, Number.NEGATIVE_INFINITY, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Positive Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, Number.POSITIVE_INFINITY, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Out of range value in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, 1e301, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                    done();
                }, DefaultWaitForRender);
            });
            it('All are good in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, 200, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).not.toHaveBeenCalled();
                    done();
                }, DefaultWaitForRender);
            });
            it('Show the correct text - measure and category', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 100");
                    expect($(labels[1]).text()).toBe("b 200");
                    expect($(labels[2]).text()).toBe("c 700");
                    done();
                }, DefaultWaitForRender);
            });
            it('Show the correct text - measure with display units and no precision', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [12345, 15533, 776],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 12K");
                    expect($(labels[1]).text()).toBe("b 16K");
                    expect($(labels[2]).text()).toBe("c 1K");
                    done();
                }, DefaultWaitForRender);
            });
            it('Show the correct text - measure with display units and precision', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelDisplayUnits: 1000000, labelPrecision: 3 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [12345, 15533, 776],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 0.012M");
                    expect($(labels[1]).text()).toBe("b 0.016M");
                    expect($(labels[2]).text()).toBe("c 0.001M");
                    done();
                }, DefaultWaitForRender);
            });
            it('Show the correct text - measure', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0, },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("100");
                    expect($(labels[1]).text()).toBe("200");
                    expect($(labels[2]).text()).toBe("700");
                    done();
                }, DefaultWaitForRender);
            });
            it('Show the correct text - category', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a");
                    expect($(labels[1]).text()).toBe("b");
                    expect($(labels[2]).text()).toBe("c");
                    done();
                }, DefaultWaitForRender);
            });
            it('No data labels', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var label = element.find('.donutChart .labels').find('text');
                    expect($(label[0]).length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            });
            it('Verify data labels - default style', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true },
                    categoryLabels: { show: false }
                };
                var color = "rgb(105, 105, 105)"; // Dim Grey
                var opacity = '1';
                var fontSize = '11px';
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(color));
                    expect($(labels[0]).css('opacity')).toBe(opacity);
                    expect($(labels[0]).css('font-size')).toBe(fontSize);
                    done();
                }, DefaultWaitForRender);
            });
            it('Verify data labels - changing measure color', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, color: color },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(color.solid.color));
                    done();
                }, DefaultWaitForRender);
            });
            it('Verify data labels - changing category color', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false, color: color },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(color.solid.color));
                    done();
                }, DefaultWaitForRender);
            });
            it('Long data labels', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['abcdefghijklmnopqrstuvwxyz', '01234567890123456789', 'abcdefg', 'd', 'e'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('abcdefghijklmnopqrstuvwxyz'), powerbitests.mocks.dataViewScopeIdentity('01234567890123456789'), powerbitests.mocks.dataViewScopeIdentity('abcdefg'), powerbitests.mocks.dataViewScopeIdentity('d'), powerbitests.mocks.dataViewScopeIdentity('e')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [110, 120, 130, 140, 150],
                                subtotal: 650
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toContain("...");
                    expect($(labels[1]).text()).toContain("...");
                    expect($(labels[2]).text()).toBe("abcdefg");
                    expect($(labels[3]).text()).toBe("d");
                    expect($(labels[4]).text()).toBe("e");
                    done();
                }, DefaultWaitForRender);
            });
            it('Data lables with null', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabels.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabels.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect(labels.length).toBe(3);
                    done();
                }, DefaultWaitForRender);
            });
        });
        describe('converter', function () {
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            it('empty', function () {
                var dataView = {
                    categorical: {
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [],
                                subtotal: 0
                            }])
                        }
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var expectSlices = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    legendData: { title: "", dataPoints: [] },
                    hasHighlights: false,
                    dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                    legendObjectProperties: undefined
                };
                expect(actualData).toEqual(expectSlices);
            });
            it('categorical, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-300, null, 700]
                        }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('categorical, no slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-300, null, 700]
                        }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1]
                    },
                    {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('category and series, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata1Category2Measure.columns[1],
                            values: [-200, null, 150],
                            identity: powerbitests.mocks.dataViewScopeIdentity('foo'),
                        }, {
                            source: dataViewMetadata1Category2Measure.columns[2],
                            values: [-300, 300, -50],
                            identity: powerbitests.mocks.dataViewScopeIdentity('bar'),
                        }])
                    },
                    metadata: dataViewMetadata1Category2Measure,
                };
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[0], dataView.categorical.values[0].identity),
                        measure: -200,
                        value: 0.2,
                        index: 0,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-200" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[0], dataView.categorical.values[1].identity),
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[1], dataView.categorical.values[0].identity),
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[1], dataView.categorical.values[1].identity),
                        measure: 300,
                        value: 0.3,
                        index: 1,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[2], dataView.categorical.values[0].identity),
                        measure: 150,
                        value: 0.15,
                        index: 2,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "150" }],
                        color: sliceColors[2],
                    },
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[2], dataView.categorical.values[1].identity),
                        measure: -50,
                        value: 0.05,
                        index: 2,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints.length).toBe(3);
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
                expect(actualData.legendData.dataPoints[1].label).toBe('b');
                expect(actualData.legendData.dataPoints[2].label).toBe('c');
            });
            it('categorical, no slicing, formatted color', function () {
                var hexGreen = "#00FF00";
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                            objects: [
                                undefined,
                                { dataPoint: { fill: { solid: { color: hexGreen } } } },
                                undefined,
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-300, null, 700]
                        }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    hexGreen,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('categorical multi-measure, no slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2MeasureWithFormat.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150]
                            },
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50]
                            }
                        ])
                    },
                    metadata: dataViewMetadata1Category2MeasureWithFormat,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -500,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'a',
                        value: 0.5,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($500)" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        label: 'b',
                        measure: 300,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$300" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        measure: 100,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'c',
                        value: 0.2,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$100" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('categorical multi-measure, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2Measure.columns[1],
                                values: [-200, null, 150]
                            },
                            {
                                source: dataViewMetadata1Category2Measure.columns[2],
                                values: [-300, 300, -50]
                            }
                        ])
                    },
                    metadata: dataViewMetadata1Category2Measure,
                };
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                        measure: -200,
                        label: 'col2',
                        value: 0.2,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-200" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col3'),
                        measure: -300,
                        label: 'col3',
                        value: 0.3,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                        measure: 0,
                        label: 'col2',
                        value: 0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col3'),
                        measure: 300,
                        label: 'col3',
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2'),
                        label: 'col2',
                        measure: 150,
                        value: 0.15,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "150" }],
                        color: sliceColors[2],
                    },
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col3'),
                        label: 'col3',
                        measure: -50,
                        value: 0.05,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints.length).toBe(3);
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
                expect(actualData.legendData.dataPoints[1].label).toBe('b');
                expect(actualData.legendData.dataPoints[2].label).toBe('c');
            });
            it('non-categorical multi-measure, with slicing', function () {
                // Explicitly set the color for the first measure.
                var columnWithColor = powerbi.Prototype.inherit(dataViewMetadata3Measure.columns[0]);
                columnWithColor.objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: columnWithColor,
                                values: [200]
                            },
                            {
                                source: dataViewMetadata3Measure.columns[1],
                                values: [-300]
                            },
                            {
                                source: dataViewMetadata3Measure.columns[2],
                                values: [500]
                            }
                        ])
                    },
                    metadata: dataViewMetadata3Measure,
                };
                // Slicing does not come into effect for non-categorical multi-measure
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var selectionIds = dataViewMetadata3Measure.columns.map(function (c) { return SelectionId.createWithMeasure(c.displayName); });
                var sliceColors = [
                    'red',
                    donutColors.getColor(dataViewMetadata3Measure.columns[1].queryName).value,
                    donutColors.getColor(dataViewMetadata3Measure.columns[2].queryName).value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 0.2,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        label: 'col2',
                        measure: -300,
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col2", value: "-300" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        label: 'col3',
                        measure: 500,
                        value: 0.5,
                        index: 2,
                        tooltipInfo: [{ displayName: "col3", value: "500" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
            });
            it('non-categorical single-measure, with slicing', function () {
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata3Measure.columns[0],
                                values: [200]
                            }
                        ])
                    },
                    metadata: dataViewMetadata3Measure,
                };
                // Slicing does not come into effect for non-categorical single-measure
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var selectionIds = dataViewMetadata3Measure.columns.map(function (c) { return SelectionId.createWithMeasure(c.displayName); });
                var sliceColors = [donutColors.getColor(dataViewMetadata3Measure.columns[0].queryName).value];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 1.0,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
            });
            it('non-categorical series', function () {
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata3Measure.columns[0],
                                values: [200],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col1'),
                            },
                            {
                                source: dataViewMetadata3Measure.columns[1],
                                values: [300],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col2'),
                            }
                        ], [categoryColumnRef])
                    },
                    metadata: dataViewMetadata,
                };
                dataView.categorical.values.source = dataViewMetadata[1];
                var actualData = DonutChart.converter(dataView, true, donutColors);
                var selectionIds = dataView.categorical.values.map(function (c) { return SelectionId.createWithId(c.identity); });
                var columnRefId = powerbi.data.SQExprShortSerializer.serializeArray([categoryColumnRef]);
                var sliceColors = [
                    donutColors.getColorByScale(columnRefId, 'col1').value,
                    donutColors.getColorByScale(columnRefId, 'col2').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 0.4,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        label: 'col2',
                        measure: 300,
                        value: 0.6,
                        index: 1,
                        tooltipInfo: [{ displayName: "col2", value: "300" }],
                        color: sliceColors[1],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
                expect(actualData.legendData.dataPoints[1].label).toBe('col2');
            });
            it('with highlights', function () {
                // categorical, no slicing
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150],
                                highlights: [-100, null, 10],
                            },
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                                highlights: [-150, 75, 50],
                            }
                        ]),
                    },
                    metadata: null,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -500,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'a',
                        value: 0.5,
                        highlightRatio: 0.5,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($500)" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "($250)" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        label: 'b',
                        measure: 300,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        value: 0.3,
                        highlightRatio: 0.25,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$75" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        measure: 100,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'c',
                        value: 0.2,
                        highlightRatio: 0.3,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$100" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$30" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
            });
            //validate tooltip on highlighted values, the first tooptip is regular because highlighted value is 0, another tooltips are highlighted tooltips 
            it('with highlights - tooltip validation', function () {
                // categorical, no slicing
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150],
                                highlights: [0, null, 10],
                            },
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                                highlights: [0, 75, 50],
                            }
                        ]),
                    },
                    metadata: null,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                //regular tooltip
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual([{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($500)" }]);
                //tooltips with highlighted values
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual([{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$75" }]);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual([{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$100" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$30" }]);
            });
            //validate tooltip that tooltip info doesn't change if data and category labels are on and off 
            it('on/off data lables - tooltip validation', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, 100, 150],
                            },
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                            }
                        ]),
                    },
                    metadata: null,
                };
                var tooltipInfo1 = [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($500)" }];
                var tooltipInfo2 = [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$400" }];
                var tooltipInfo3 = [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$100" }];
                var actualData = DonutChart.converter(dataView, false, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                //data labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: true },
                    categoryLabels: { show: false }
                };
                actualData = DonutChart.converter(dataView, false, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                //data labels and category labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: true },
                    categoryLabels: { show: true }
                };
                actualData = DonutChart.converter(dataView, false, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                //data labels off and category labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                actualData = DonutChart.converter(dataView, false, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
            });
            it('with highlights that overflow', function () {
                // categorical, no slicing
                var dataView = {
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150],
                                highlights: [-100, null, 250],
                            },
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                                highlights: [-150, 75, 50],
                            }
                        ]),
                    },
                    metadata: null,
                };
                var actualData = DonutChart.converter(dataView, false, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorByScale(categoryColumnId, 'a').value,
                    donutColors.getColorByScale(categoryColumnId, 'b').value,
                    donutColors.getColorByScale(categoryColumnId, 'c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -250,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'a',
                        value: 0.4,
                        highlightRatio: 1.0,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($250)" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "($250)" }],
                        color: sliceColors[0],
                    },
                    {
                        identity: selectionIds[1],
                        label: 'b',
                        measure: 75,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        value: 0.12,
                        highlightRatio: 1.0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$75" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$75" }],
                        color: sliceColors[1],
                    },
                    {
                        identity: selectionIds[2],
                        measure: 300,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'c',
                        value: 0.48,
                        highlightRatio: 1.0,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$300" }],
                        color: sliceColors[2],
                    }
                ].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
            });
        });
        it('non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', isMeasure: true },
                    { displayName: 'b', isMeasure: true },
                    { displayName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3],
                        }
                    ])
                }
            };
            var actualData = DonutChart.converter(dataView, false, donutColors);
            expect(actualData.dataPoints[0].data.tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(actualData.dataPoints[1].data.tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(actualData.dataPoints[2].data.tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
        function buildDataPoint(data) {
            return {
                identity: data.identity,
                measure: data.measure,
                measureFormat: data.measureFormat,
                percentage: data.value,
                index: data.index,
                label: data.label,
                selected: false,
                highlightRatio: data.highlightRatio || 0,
                tooltipInfo: data.tooltipInfo,
                color: data.color,
                labelColor: powerbi.visuals.dataLabelUtils.defaultLabelColor,
            };
        }
    });
    function pieChartDomValidation(interactiveChart, hasLegendObject) {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        if (hasLegendObject) {
            dataViewMetadataTwoColumn.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadataTwoColumn.objects = undefined;
        }
        var dataViewMetadata1Category2Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
                { displayName: 'col3', queryName: 'col3', isMeasure: true }
            ]
        };
        if (hasLegendObject) {
            dataViewMetadata1Category2Measure.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadata1Category2Measure.objects = undefined;
        }
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            powerbi.common.localize = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(powerbi.common.localize);
            element = powerbitests.helpers.testDom('500', '500');
            if (interactiveChart)
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('pieChart').create();
            else
                v = powerbi.visuals.visualPluginFactory.createMinerva({
                    heatMap: false,
                }).getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart, selection: true },
                animation: { transitionImmediate: true }
            });
        });
        it('pie chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart dom validation with partial highlights', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 0, 300],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                var dimmedOpacity = interactiveChart ? 0.6 : powerbi.visuals.ColumnUtil.DimmedOpacity;
                var slices = $('.donutChart .slice');
                expect(slices.length).toBe(3);
                slices.each(function (i, element) { return expect(parseFloat($(element).css('fill-opacity'))).toBeCloseTo(dimmedOpacity, 0); });
                var highlightSlices = $('.donutChart .slice-highlight');
                expect(highlightSlices.length).toBe(3);
                highlightSlices.each(function (i, element) { return expect(parseFloat($(element).css('fill-opacity'))).toBeCloseTo(powerbi.visuals.ColumnUtil.DefaultOpacity, 2); });
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart should clear dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart)
                    expect($('.legend-item').length).toBe(3);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: [],
                                identity: [],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataTwoColumn.columns[1],
                                values: [],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.donutChart')).toBeInDOM();
                    expect($('.donutChart .slice').length).toBe(0);
                    if (interactiveChart)
                        expect($('.legend-item').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('pie chart dom validation with slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata1Category2Measure,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2Measure.columns[1],
                                values: [200, 100, 150]
                            },
                            {
                                source: dataViewMetadata1Category2Measure.columns[2],
                                values: [300, 200, 50]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                if (interactiveChart)
                    expect($('.donutChart .slice').length).toBe(3);
                else
                    expect($('.donutChart .slice').length).toBe(6);
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart dom validation with normal slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [300, 300, 400],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var svg = $('.donutChart');
                expect(svg).toBeInDOM();
                // Disabling test due to instability in test infrastructure.
                //expect($('.donutChart polyline').filter(function () {
                //       return $(this).css('opacity') === '0.5'
                //    }).length).toBe(3);
                //expect(svg.attr('height')).toBe(initialHeight);
                //expect(svg.attr('width')).toBe(initialWidth);
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart label dom validation with thin slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [5, 5, 990],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // lines are not present on interactive legend mode, and currently if regular legend is on we hide labels
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').length).toBe(3);
                }
                done();
            }, DefaultWaitForRender * 2);
        });
        it('pie chart with duplicate labels dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'abc', 'abc'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').length).toBe(3);
                    expect($('.donutChart .labels text').length).toBe(3);
                }
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart dom validation with very long labels', function (done) {
            //make sure category labels on
            var dataViewMetadataTwoColumnLabels = powerbi.Prototype.inherit(dataViewMetadataTwoColumn);
            dataViewMetadataTwoColumnLabels.objects = { categoryLabels: { show: true }, labels: { show: false } };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumnLabels,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumnLabels.columns[0],
                            values: ['John Domo Who lives far far away', 'Delta Force of the 56th Battalion', 'Jean Tablau from the silicon valley'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumnLabels.columns[1],
                            values: [300, 300, 400],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                var labels = $('.labels').find('text');
                for (var i = 0; i < labels.length; i++) {
                    var text = $(labels[i]).text().substr(-3);
                    expect(text).toEqual('...');
                }
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart opacity validation with overlapping slices', function (done) {
            dataViewMetadataTwoColumn.objects = {
                labels: { show: false },
                categoryLabels: { show: true }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'def', 'ghi', 'jkl'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c'), powerbitests.mocks.dataViewScopeIdentity('d')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [1, 1, 5, 90],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // lines are not present on interactive legend mode, and currently if regular legend is on we hide labels
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').filter(function () {
                        return $(this).css('opacity') === '0.5';
                    }).length).toBe(2);
                    expect($('.donutChart text').filter(function () {
                        return $(this).css('opacity') === '0';
                    }).length).toBe(2);
                }
                done();
            }, DefaultWaitForRender * 2);
        });
        it('pie chart radius calculation validation', function (done) {
            // spy on calculateRadius() method
            var pieChart = v;
            spyOn(pieChart, 'calculateRadius').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['abc', 'def', 'ghi', 'jkl'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c'), powerbitests.mocks.dataViewScopeIdentity('d')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [2, 3, 4, 90],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // verify the calculateRadius() was called during the rendering on the visual 
                expect(pieChart.calculateRadius).toHaveBeenCalled();
                // call calculateRadius() and test for the result, based on whether the chart is interactive or not
                var radiusResult = pieChart.calculateRadius();
                var height = $('.donutChart').height();
                var width = $('.donutChart').width();
                var widthOrHeight = Math.min(width, height);
                var hw = height / width;
                var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                var expectedRadius = interactiveChart ? widthOrHeight / 2 : widthOrHeight / denom;
                expect(radiusResult).toBeCloseTo(expectedRadius, 0);
                done();
            }, DefaultWaitForRender * 2);
        });
        it('pie chart slice select', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            var slices = $('.donutChart .slice');
            var sliceToClickIndex = 1;
            var sliceToClick = $(slices[sliceToClickIndex]);
            var otherSlices = slices.not(sliceToClick);
            var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
            slices.each(function () {
                expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
            });
            var pieChart = v;
            if (interactiveChart) {
                var interactivityState = pieChart.interactivityState;
                var pieLegend = interactivityState.interactiveLegend;
                spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
                spyOn(pieLegend, 'updateLegend').and.callThrough();
            }
            // Click the first slice
            sliceToClick.d3Click();
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart) {
                    expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(sliceToClickIndex);
                    expect(pieLegend.updateLegend).toHaveBeenCalledWith(sliceToClickIndex);
                }
                else {
                    expect(parseFloat(sliceToClick.css('fill-opacity'))).toBe(1);
                    otherSlices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                    });
                    // Legend
                    if (renderLegend) {
                        expect($('.legend .item').length).toBe(3);
                        var icons = $('.legend .icon.tall');
                        expect(icons[sliceToClickIndex].style.backgroundColor).toBe('rgb(55, 70, 73)');
                        expect(icons[0].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(166, 166, 166)');
                    }
                }
                // Click the background
                var clearCatcher = $('.clearCatcher');
                clearCatcher.d3Click();
                setTimeout(function () {
                    slices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
                    });
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('pie chart selecting a slice triggers select', function () {
            if (interactiveChart) {
                // not applicable to interactive charts
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: identities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            var onSelectSpy = spyOn(hostServices, 'onSelect');
            var slices = $('.donutChart .slice');
            var sliceToClick = 1;
            $(slices[sliceToClick]).d3Click();
            expect(onSelectSpy).toHaveBeenCalled();
            expect(onSelectSpy.calls.argsFor(0)[0].data[0]).toEqual({ data: [identities[sliceToClick]] });
        });
        it('pie chart highlighted slice select', function (done) {
            if (interactiveChart) {
                // not applicable to interactive charts
                done();
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: identities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 100, 350],
                        }])
                    }
                }]
            });
            var slices = $('.donutChart .slice');
            var sliceToClickIndex = 1;
            var sliceToClick = $(slices[sliceToClickIndex]);
            var otherSlices = slices.not(sliceToClick);
            // Click the first slice
            sliceToClick.d3Click();
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                expect(parseFloat(sliceToClick.css('fill-opacity'))).toBe(1);
                otherSlices.each(function () {
                    expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                });
                done();
            }, DefaultWaitForRender);
        });
        it('pie chart selecting a highlighted slice triggers select', function () {
            if (interactiveChart) {
                // not applicable to interactive charts
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: identities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 100, 350],
                        }])
                    }
                }]
            });
            var onSelectSpy = spyOn(hostServices, 'onSelect');
            var slices = $('.donutChart .slice-highlight');
            var sliceToClick = 1;
            $(slices[sliceToClick]).d3Click();
            expect(onSelectSpy).toHaveBeenCalled();
            expect(onSelectSpy.calls.argsFor(0)[0].data[0]).toEqual({ data: [identities[sliceToClick]] });
        });
        it('pie chart slice multi-select', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
            var slices = $('.donutChart .slice');
            var slicesToClickIndex = [1, 2];
            var slicesToClick = $(slices).slice(1, 3);
            var otherSlices = slices.not(slicesToClick);
            var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
            slices.each(function () {
                expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
            });
            var pieChart = v;
            if (interactiveChart) {
                var interactivityState = pieChart.interactivityState;
                var pieLegend = interactivityState.interactiveLegend;
                spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
                spyOn(pieLegend, 'updateLegend').and.callThrough();
            }
            // Click the first slice, then the second with ctrl key
            slicesToClick.eq(0).d3Click();
            slicesToClick.eq(1).d3Click(0, 0, 1 /* CtrlKey */);
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart) {
                    slicesToClickIndex.forEach(function (i) {
                        expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(i);
                        expect(pieLegend.updateLegend).toHaveBeenCalledWith(i);
                    });
                }
                else {
                    slicesToClick.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
                    });
                    otherSlices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                    });
                    // Legend
                    if (renderLegend) {
                        expect($('.legend .item').length).toBe(3);
                        var icons = $('.legend .icon.tall');
                        expect(icons[0].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[1].style.backgroundColor).toBe('rgb(157, 73, 140)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(187, 203, 80)');
                        var labels = $('.labels').find('text');
                        expect($(labels[0]).css('opacity')).toBe('0');
                        expect($(labels[1]).css('opacity')).toBe('0');
                        expect($(labels[2]).css('opacity')).toBe('0');
                    }
                    else {
                        expect($('.labels').find('text').length).toBe(3);
                    }
                }
                // Click the background
                var clearCatcher = $('.clearCatcher');
                clearCatcher.d3Click();
                setTimeout(function () {
                    slices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
                    });
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('pie chart legend interactivity', function () {
            if (!interactiveChart) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataTwoColumn.columns[1],
                                values: [100, 200, 700],
                            }])
                        }
                    }]
                });
                // click on legend item
                var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
                if (renderLegend) {
                    var icons = $('.legend .icon.tall');
                    var slices = $('.donutChart .slice');
                    icons.first().d3Click(0, 0);
                    setTimeout(function () {
                        expect(icons[0].style.backgroundColor).toBe('rgb(1, 184, 170)');
                        expect(icons[1].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(parseFloat(slices[0].style.fillOpacity)).toBe(1);
                        expect(parseFloat(slices[1].style.fillOpacity)).toBeLessThan(1);
                        expect(parseFloat(slices[2].style.fillOpacity)).toBeLessThan(1);
                    }, DefaultWaitForRender * 2);
                }
            }
        });
        if (hasLegendObject) {
            it('legend formatting', function (done) {
                var dataView = {
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                };
                dataView.metadata.objects = { legend: { show: true } };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.donutChart')).toBeInDOM();
                    expect($('.donutChart .slice').length).toBe(3);
                    if (hasLegendObject) {
                        expect($('.legend').attr('orientation')).toBe(0 /* Top */.toString());
                    }
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.donutChart')).toBeInDOM();
                        expect($('.donutChart .slice').length).toBe(3);
                        if (hasLegendObject) {
                            expect($('.legend').attr('orientation')).toBe(2 /* Right */.toString());
                        }
                        //set title
                        var testTitle = 'Test Title';
                        dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.donutChart')).toBeInDOM();
                            if (hasLegendObject) {
                                expect($('.legend').attr('orientation')).toBe(2 /* Right */.toString());
                                expect($('.legendTitle').text()).toBe(testTitle);
                            }
                            //hide legend
                            dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.donutChart')).toBeInDOM();
                                if (hasLegendObject) {
                                    expect($('.legend').attr('orientation')).toBe(4 /* None */.toString());
                                }
                                done();
                            }, DefaultWaitForRender);
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
        }
    }
    describe("PieChart DOM validation", function () { return pieChartDomValidation(false, false); });
    describe("PieChart DOM validation - with legend", function () { return pieChartDomValidation(false, true); });
    describe("Interactive PieChart DOM validation", function () { return pieChartDomValidation(true, false); });
    describe("Pie Chart Interactivity", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbi.common.localize = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(powerbi.common.localize);
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: true },
                animation: { transitionImmediate: true },
            });
            var dataViewMetadataTwoColumnLabels = powerbi.Prototype.inherit(dataViewMetadataTwoColumn);
            dataViewMetadataTwoColumnLabels.objects = { categoryLabels: { show: true }, labels: { show: false } };
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataTwoColumnLabels,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumnLabels.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumnLabels.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            });
        });
        it('legend structure', function (done) {
            setTimeout(function () {
                expect($('[data-legend-index=0]>.category').text()).toBe("a");
                expect($('[data-legend-index=0]>.value').text()).toBe("100");
                expect(ColorConvertor($('[data-legend-index=0]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(0).css('fill')));
                expect($('[data-legend-index=1]>.category').text()).toBe("b");
                expect($('[data-legend-index=1]>.value').text()).toBe("200");
                expect(ColorConvertor($('[data-legend-index=1]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(1).css('fill')));
                expect($('[data-legend-index=2]>.category').text()).toBe("c");
                expect($('[data-legend-index=2]>.value').text()).toBe("700");
                expect(ColorConvertor($('[data-legend-index=2]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(2).css('fill')));
                expect($('.donutLegend').length).toBe(1);
                expect($('.legend-item').length).toBe(3);
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
        it('slice drag', function (done) {
            function setD3Event(x, y) {
                var event = document.createEvent('MouseEvents');
                event.sourceEvent = {
                    type: 'mouseEvent',
                    pageX: x,
                    pageY: y,
                    stopPropagation: function () {
                    },
                };
                d3.event = event;
            }
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            spyOn(powerbi.visuals.SVGUtil, 'translateAndRotate');
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieChart, 'getAngleFromDragEvent').and.callThrough();
            // simulate a drag gesture from below the center of the donut to it's upper part, 180 degrees drag.
            var centerCoordinates = interactivityState.donutCenter;
            var dragFromCoordinates = { x: centerCoordinates.x, y: centerCoordinates.y - 20 };
            var dragToCoordinates = { x: centerCoordinates.x, y: centerCoordinates.y + 20 };
            var currentRotation = pieChart.interactivityState.currentRotate;
            // simulate dragging using setting d3.event
            setD3Event(dragFromCoordinates.x, dragFromCoordinates.y);
            pieChart.interactiveDragStart(); // call dragStart
            setD3Event(dragToCoordinates.x, dragToCoordinates.y);
            pieChart.interactiveDragMove(); // call dragMove
            pieChart.interactiveDragEnd(); // complete the drag - call dragEnd
            expect(pieChart.getAngleFromDragEvent.calls.count()).toBe(2); // angle should have been calculated twice (first for dragstart and second for dragEnd)
            expect(powerbi.visuals.SVGUtil.translateAndRotate.calls.first().args[4]).toBe(currentRotation + 180); // first call to rotate (mathches dragMove) should rotate the chart by 180 degrees
            expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(2);
            done();
        });
        function swipeTest(swipeLeft, expectedSliceIndex, done) {
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            var pieLegend = interactivityState.interactiveLegend;
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieLegend, 'updateLegend').and.callThrough();
            // drag on the legend
            pieLegend.dragLegend(swipeLeft);
            setTimeout(function () {
                expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(expectedSliceIndex);
                expect(pieLegend.updateLegend).toHaveBeenCalledWith(expectedSliceIndex);
                expect($('.donutChart').length).toBe(1);
                expect($('.donutLegend').length).toBe(1);
                expect($('.legend-item').length).toBe(3);
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        }
        it('legend items swipe right', function (done) { return swipeTest(false, 2, done); }); // swiping right - exepecting to get the last slice index
        it('legend items swipe left', function (done) { return swipeTest(true, 1, done); }); // swiping left - exepecting to get the second slice index
        function rotateValidation(swipeLeft, done) {
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            var pieLegend = interactivityState.interactiveLegend;
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieLegend, 'updateLegend').and.callThrough();
            // verify the order of the legend items, and their rotation.
            // the middle should be item 0, to the right, item 1 and to the left of item 0 is item 2.
            // meaning, DOM elements order is item2 -> item0 -> item1
            var legendItems = $('.legend-item');
            expect(legendItems.length).toEqual(3);
            expect(legendItems.eq(0).attr('data-legend-index')).toEqual('2');
            expect(legendItems.eq(1).attr('data-legend-index')).toEqual('0');
            expect(legendItems.eq(2).attr('data-legend-index')).toEqual('1');
            // drag on the legend
            pieLegend.dragLegend(swipeLeft);
            setTimeout(function () {
                // items should be rotated
                var rotatedLegendItems = $('.legend-item');
                if (swipeLeft) {
                    expect(rotatedLegendItems.eq(0).attr('data-legend-index')).toBe('0');
                    expect(rotatedLegendItems.eq(1).attr('data-legend-index')).toBe('1');
                    expect(rotatedLegendItems.eq(2).attr('data-legend-index')).toBe('2');
                }
                else {
                    expect(rotatedLegendItems.eq(0).attr('data-legend-index')).toBe('1');
                    expect(rotatedLegendItems.eq(1).attr('data-legend-index')).toBe('2');
                    expect(rotatedLegendItems.eq(2).attr('data-legend-index')).toBe('0');
                }
                done();
            }, DefaultWaitForRender);
        }
        it('legend items are rotated correctly when swiping right', function (done) { return rotateValidation(false, done); });
        it('legend items are rotated correctly when swiping left', function (done) { return rotateValidation(true, done); });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check enumeration for categorical', function (done) {
            dataViewMetadataTwoColumn.objects = {
                labels: { show: false },
                categoryLabels: { show: true }
            };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[0].displayName).toEqual('a');
            expect(points[0].properties['fill']).toBeDefined();
            expect(points[1].displayName).toEqual('b');
            expect(points[1].properties['fill']).toBeDefined();
            done();
        });
        it('Check enumeration for category and series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true }
                ]
            };
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata1Category2Measure.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata1Category2Measure.columns[1],
                            values: [-200, null, 150],
                            identity: powerbitests.mocks.dataViewScopeIdentity('foo'),
                        }, {
                            source: dataViewMetadata1Category2Measure.columns[2],
                            values: [-300, 300, -50],
                            identity: powerbitests.mocks.dataViewScopeIdentity('bar'),
                        }])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[0].displayName).toEqual('a');
            expect(points[0].properties['fill']).toBeDefined();
            expect(points[1].displayName).toEqual('b');
            expect(points[1].properties['fill']).toBeDefined();
            done();
        });
        it('Check datapoints enumeration after hiding legend', function (done) {
            var dataView = {
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumn.columns[0],
                        values: ['a', 'b', 'c'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataTwoColumn.columns[1],
                        values: [100, 200, 700],
                    }])
                }
            };
            dataView.metadata.objects = { legend: { show: false } };
            v.onDataChanged({
                dataViews: [dataView]
            });
            setTimeout(function () {
                // Check legend is hidden
                expect($('.legend').attr('orientation')).toBe(4 /* None */.toString());
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Pie Chart Web Animation", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            powerbi.common.localize = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(powerbi.common.localize);
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
            }).getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { selection: true },
                animation: { transitionImmediate: true }
            });
        });
        it('pie chart partial highlight animations', function (done) {
            var dataViewsNoHighlights = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                    }
                }]
            };
            var dataViewsHighlightsA = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 26, 560],
                        }])
                    }
                }]
            };
            var dataViewsHighlightsB = {
                dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                            highlights: [20, 126, 60],
                        }])
                    }
                }]
            };
            v.onDataChanged(dataViewsNoHighlights);
            setTimeout(function () {
                var svgInit = $('.donutChart');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(dataViewsHighlightsA);
                v.onDataChanged(dataViewsHighlightsB);
                v.onDataChanged(dataViewsNoHighlights);
                expect(animator).toBeTruthy();
                expect(animator.animate).toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.donutChart');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var FunnelChart = powerbi.visuals.FunnelChart;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var EventType = powerbitests.helpers.ClickEventType;
    var SelectionId = powerbi.visuals.SelectionId;
    var DefaultRenderTime = 10;
    describe("FunnelChart", function () {
        it('FunnelChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').capabilities).toBe(powerbi.visuals.funnelChartCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.funnelChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.funnelChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.funnelChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.funnelChartCapabilities.objects)).toEqual(powerbi.visuals.funnelChartProps.general.formatString);
        });
    });
    describe("FunnelChart Dataview Validation", function () {
        var colors;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        });
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        it('Check explicit color is applied', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                        objects: [
                            { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                            { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                            { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                        ]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                    }])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            expect(actualData.slices[0].color).toBe("#FF0000");
            expect(actualData.slices[0].labelFill).toBe("#FF0000");
            expect(actualData.slices[1].color).toBe("#00FF00");
            expect(actualData.slices[1].labelFill).toBe("#00FF00");
            expect(actualData.slices[2].color).toBe("#0000FF");
            expect(actualData.slices[2].labelFill).toBe("#0000FF");
        });
        it('Check default color is applied', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                    }])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, colors, defaultDataPointColor);
            actualData.slices.forEach(function (slice) {
                expect(slice.color).toEqual(defaultDataPointColor);
                expect(slice.labelFill).toEqual(defaultDataPointColor);
            });
        });
        it('Check multi-measures and custom colors', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, objects: { dataPoint: { fill: { solid: { color: "#FF0000" } } } } },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, objects: { dataPoint: { fill: { solid: { color: "#00FF00" } } } } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[0],
                        values: [100],
                    }, {
                        source: dataViewMetadata.columns[1],
                        values: [300],
                    },])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("col2"),
                SelectionId.createWithMeasure("col3")
            ];
            var expectedData = {
                slices: [
                    {
                        value: 100,
                        label: 'col2',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col2", value: "100" }],
                        color: "#FF0000",
                        labelFill: "#FF0000",
                    },
                    {
                        value: 300,
                        label: 'col3',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col2", value: "300" }],
                        color: "#00FF00",
                        labelFill: "#00FF00",
                    }
                ],
                valuesMetadata: [dataViewMetadata.columns[0], dataViewMetadata.columns[1]],
                hasHighlights: false,
                highlightsOverflow: false,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Check converter with category and single measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['a', 'b', 'c'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                    }])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2')
            ];
            var sliceColor = colors.getColor('').value;
            var expectedData = {
                slices: [
                    {
                        value: 100,
                        label: 'a',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    },
                    {
                        value: 200,
                        label: 'b',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "200" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    },
                    {
                        value: 700,
                        label: 'c',
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    }
                ],
                valuesMetadata: [dataViewMetadata.columns[1]],
                hasHighlights: false,
                highlightsOverflow: false,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Validate highlighted tooltip', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        objects: [
                            { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                            { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                            { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                        ]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [0, 140, 420],
                    }])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, colors, defaultDataPointColor);
            //first tooltip is regular because highlighted value is 0
            expect(actualData.slices[0].tooltipInfo).toEqual([{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }]);
            expect(actualData.slices[1].tooltipInfo).toEqual([{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }]);
            //tooltips with highlighted value
            expect(actualData.slices[2].tooltipInfo).toEqual([{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(actualData.slices[3].tooltipInfo).toEqual([{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(actualData.slices[4].tooltipInfo).toEqual([{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "420" }]);
            expect(actualData.slices[5].tooltipInfo).toEqual([{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "420" }]);
        });
        it('Check converter with multi-category and multi-measures', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['a', 'b'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200],
                        subtotal: 300,
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [300, 500],
                        subtotal: 800,
                    },])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
            ];
            var sliceColor = colors.getColor('').value;
            var expectedData = {
                slices: [
                    {
                        value: 400,
                        label: 'a',
                        identity: selectionIds[0],
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "400" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    },
                    {
                        value: 700,
                        label: 'b',
                        identity: selectionIds[1],
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "700" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    }
                ],
                valuesMetadata: [dataViewMetadata.columns[1], dataViewMetadata.columns[2]],
                hasHighlights: false,
                highlightsOverflow: false,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Check converter with no category and multi-measures', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300],
                        subtotal: 600,
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [300, 200, 100],
                        subtotal: 600,
                    },])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("col2"),
                SelectionId.createWithMeasure("col3")
            ];
            var sliceColor = colors.getColor('').value;
            var expectedData = {
                slices: [
                    {
                        value: 600,
                        label: 'col2',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col2", value: "600" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    },
                    {
                        value: 600,
                        label: 'col3',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col2", value: "600" }],
                        color: sliceColor,
                        labelFill: sliceColor,
                    }
                ],
                valuesMetadata: [dataViewMetadata.columns[1], dataViewMetadata.columns[2]],
                hasHighlights: false,
                highlightsOverflow: false,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', isMeasure: true },
                    { displayName: 'b', isMeasure: true },
                    { displayName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1]
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2]
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3]
                        }
                    ])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            expect(actualData.slices[0].tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(actualData.slices[1].tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(actualData.slices[2].tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
    });
    describe("FunnelChart Interactivity", function () {
        var v, element;
        var hostServices;
        var dataViewMetadataCategorySeriesColumns = {
            columns: [
                { displayName: 'Squad', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'Period', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: null, groupName: '201501', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: null, groupName: '201502', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: null, groupName: '201503', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Squad' });
        var DefaultOpacity = "" + FunnelChart.DefaultBarOpacity;
        var DimmedOpacity = "" + FunnelChart.DimmedBarOpacity;
        var interactiveDataViewOptions = {
            dataViews: [{
                metadata: dataViewMetadataCategorySeriesColumns,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategorySeriesColumns.columns[0],
                        values: ['A', 'B'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[2],
                            values: [110, 120],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                        },
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[3],
                            values: [210, 220],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                        },
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[4],
                            values: [310, 320],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                        }
                    ])
                }
            }]
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        function getOptionsForValueWarning(values) {
            var interactiveDataViewOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['A', 'B'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: values,
                                identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                            }
                        ])
                    }
                }]
            };
            return interactiveDataViewOptions;
        }
        it('NaN in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, NaN]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            });
        });
        it('Negative Infinity in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, Number.NEGATIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            });
        });
        it('Positive Infinity in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, Number.POSITIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            });
        });
        it('Out of range value in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, 1e301]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            });
        });
        it('All good in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, 300]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            });
        });
        it('funnel chart category select', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                done();
            });
        });
        it('funnel chart category multi-select', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                bars.last().d3Click(0, 0, 1 /* CtrlKey */);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0],
                            ],
                        },
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[1],
                            ]
                        }
                    ]
                });
                done();
            });
        });
        it('funnel chart external clear', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                v.onClearSelection();
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                done();
            });
        });
        it('funnel chart clear on clearCatcher click', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                var clearCatcher = $('.clearCatcher');
                clearCatcher.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            });
        });
    });
    describe("FunnelChart DOM Validation", function () {
        var v, element;
        var translate = 62;
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1' },
                { displayName: 'col2', isMeasure: true, objects: { general: { formatString: '$0' } } },
            ],
            objects: {
                labels: { show: true, labelPrecision: 0 }
            }
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        // because of different representations of the color (rgb, hex), "going through" the browser and getting its adjusted color value
        function adjustColor(colorToAdjust) {
            var dummy = $('<div/>');
            // Set the color of the div to the color, and read it back.
            $(dummy).css('color', colorToAdjust);
            return $(dummy).css('color');
        }
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Ensure DOM built', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.funnelChart g').length).toBe(6);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                expect($('.funnelChart .innerTextGroup').find('text').length).toBe(3);
                expect($('.funnelChart .innerTextGroup').find('text').first().text()).toBe('$100');
                done();
            }, DefaultRenderTime);
        });
        it('Funnel partial highlight', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [50, 140, 420],
                        subtotal: 1000
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.funnelChart g').length).toBe(6);
                expect($('.funnelBar').length).toBe(6);
                expect($('.highlight').length).toBe(3);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeLessThan(+$('.funnelBar')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeGreaterThan(+$('.funnelBar')[0].attributes.getNamedItem('y').value);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            }, DefaultRenderTime);
        });
        it('Funnel partial highlight with overflow', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [150, 340, 720],
                        subtotal: 1000
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.funnelChart g').length).toBe(6);
                expect($('.funnelBar').length).toBe(6);
                expect($('.highlight').length).toBe(3);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value).toBeGreaterThan(+$('.funnelBar')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value).toBeLessThan(+$('.funnelBar')[0].attributes.getNamedItem('y').value);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            }, DefaultRenderTime);
        });
        it('Ensure Max Width is respected', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200],
                        subtotal: 300
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var rect = $('.funnelChart').find('.funnelBar').first();
                expect(rect.attr('width')).toBeLessThan(40);
                done();
            }, DefaultRenderTime);
        });
        it('Ensure Labels that do not fit in the bar are shown outside and are the bar fill color', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { labelPosition: powerbi.labelPosition.insideCenter } };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1000, 2000, 20],
                        subtotal: 3020
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .innerTextGroup text');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var lastBarHeight = +$('.funnelChart').find('.funnelBar').last().attr('height');
                var lastBarY = +$('.funnelChart').find('.funnelBar').last().attr('y');
                expect(labels.length).toBe(3);
                expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                // Check that the first label is inside and white
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // Check that the last label is outside and equal to fill color
                expect(adjustColor($(labels[2]).css('fill'))).toEqual(adjustColor($('.funnelChart').find('.funnelBar').eq(2).css('fill')));
                expect($(labels[2]).attr('x')).toBeGreaterThan(lastBarY + lastBarHeight + translate);
                done();
            }, DefaultRenderTime);
        });
        it('Ensure Labels hide when viewport forces bars to be smaller than min hight', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                            powerbitests.mocks.dataViewScopeIdentity('Delta Force'),
                            powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                            powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                            powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                            powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 300, 400, 500, 600],
                        subtotal: 2100
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.funnelChart g').length).toBe(9);
                expect($('.funnelChart .axis').find('text').length).toBe(6);
                expect($('.funnelChart .innerTextGroup text').length).toBe(6);
                v.onResizing({ height: 50, width: 100 }, 0);
                setTimeout(function () {
                    expect($('.funnelChart g').length).toBe(3);
                    expect($('.funnelChart .axis').find('text').length).toBe(0);
                    expect($('.funnelChart .innerTextGroup text').length).toBe(0);
                    done();
                }, DefaultRenderTime);
            }, DefaultRenderTime);
        });
        it('Default labels validation', function (done) {
            var metadataWithDisplayUnits = $.extend(true, {}, dataViewMetadata);
            metadataWithDisplayUnits.objects = { labels: { labelDisplayUnits: 1000 } };
            var fontSize = '12px';
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadataWithDisplayUnits,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [555, 2000, 20],
                        subtotal: 2575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .innerTextGroup text');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var lastBarY = +$('.funnelChart').find('.funnelBar').last().attr('y');
                var lastBarHeight = +$('.funnelChart').find('.funnelBar').last().attr('height');
                expect(labels.length).toBe(3);
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect(adjustColor($(labels[2]).css('fill'))).toEqual(adjustColor($('.funnelChart').find('.funnelBar').last().css('fill')));
                expect($(labels[0]).css('fill-opacity')).toEqual('1');
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                expect($(labels[2]).css('fill-opacity')).toEqual('1');
                expect($(labels.first().css('font-size')).selector).toBe(fontSize);
                expect($(labels[0]).text()).toEqual('$0.56K');
                // Check that the first label is inside
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // Check that the last label is outside
                expect($(labels[2]).attr('x')).toBeGreaterThan(lastBarY + lastBarHeight);
                done();
            }, DefaultRenderTime);
        });
        it('Validate label colors and positioning', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [2000, 1555, 20],
                        subtotal: 3575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .innerTextGroup text');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                // The first label should be white and should be inside the bar.
                expect($(labels[0]).text()).toEqual('$2000');
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // The third label should be the same as the fill color and should be outside the bar.
                var thirdBarY = +$('.funnelChart').find('.funnelBar').eq(2).attr('y');
                var thirdBarHeight = +$('.funnelChart').find('.funnelBar').eq(2).attr('height');
                expect($(labels[2]).text()).toEqual('$20');
                expect(adjustColor($(labels[2]).css('fill'))).toEqual(adjustColor($('.funnelChart').find('.funnelBar').eq(2).css('fill')));
                expect($(labels[2]).attr('x')).toBeGreaterThan(thirdBarY + thirdBarHeight + translate);
                done();
            }, DefaultRenderTime);
        });
        it('Change labels position validation', function (done) {
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { labelPosition: powerbi.labelPosition.insideBase } };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1000, 2000, 2000],
                        subtotal: 5000
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .innerTextGroup .data-labels');
                var firstBarX = +$('.funnelChart').find('.funnelBar').first().attr('x');
                var firstBarWidth = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var firstBarTranslated = firstBarX - translate;
                var firstBar = firstBarTranslated + firstBarWidth;
                expect(labels.length).toBe(3);
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect(adjustColor($(labels[1]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect(adjustColor($(labels[2]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                //Check that the labels position is inside
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarTranslated);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBar);
                done();
            }, DefaultRenderTime);
        });
        it('Change labels color validation', function (done) {
            var color = '#CC0099';
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: {
                    color: { solid: { color: '#CC0099' } },
                }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1555, 2000, 20],
                        subtotal: 3575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .innerTextGroup text');
                expect(labels.length).toBe(3);
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor(color));
                expect(adjustColor($(labels[1]).css('fill'))).toEqual(adjustColor(color));
                expect(adjustColor($(labels[2]).css('fill'))).toEqual(adjustColor(color));
                done();
            }, DefaultRenderTime);
        });
        it('Hide labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: false } };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1555, 2000, 20],
                        subtotal: 3575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .innerTextGroup text');
                expect(labels.length).toBe(0);
                done();
            }, DefaultRenderTime);
        });
        it('Funnel highlighted values - validate labels', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [50, 140, 420],
                        subtotal: 1000
                    }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [75, 40, 220],
                        subtotal: 1000
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            v.onDataChanged({ dataViews: [dataViewHighlightsA] });
            v.onDataChanged({ dataViews: [dataViewHighlightsB] });
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            setTimeout(function () {
                var labels = $('.funnelChart .innerTextGroup text');
                expect(labels.length).toBe(3);
                expect(adjustColor($(labels[0]).css('fill'))).toEqual(adjustColor('#FFFFFF'));
                expect($(labels[0]).text()).toEqual('$100');
                expect($(labels[1]).text()).toEqual('$200');
                expect($(labels[2]).text()).toEqual('$700');
                done();
            }, DefaultRenderTime);
        });
        it('labels should support display units with no precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1555, 2000, 20],
                        subtotal: 3575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // Commented because TSLINT throws exception on this var: unused variable: 'labels'
                //var labels = $('.funnelChart .innerTextGroup text');
                expect($('.funnelChart .innerTextGroup text').first().text()).toBe('$2K');
                done();
            }, DefaultRenderTime);
        });
        it('labels should support display units with precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 2 }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                        source: dataViewMetadataWithLabelsObject.columns[0],
                        values: ['John Domo', 'Delta Force', 'Mr Bing'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadataWithLabelsObject.columns[1],
                        values: [1555, 2000, 20],
                        subtotal: 3575
                    }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // Commented because TSLINT throws exception on this var: unused variable: 'labels'
                //var labels = $('.funnelChart .innerTextGroup text');
                expect($('.funnelChart .innerTextGroup text').first().text()).toBe('$1.56K');
                done();
            }, DefaultRenderTime);
        });
    });
    describe("funnel chart web animation", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1' },
                { displayName: 'col2' },
                { displayName: 'col3' }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
            }).getPlugin('funnel').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('funnel highlight animation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [50, 140, 420],
                        subtotal: 1000
                    }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        highlights: [75, 40, 220],
                        subtotal: 1000
                    }])
                }
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            v.onDataChanged({ dataViews: [dataViewHighlightsA] });
            v.onDataChanged({ dataViews: [dataViewHighlightsB] });
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            expect(animator).toBeTruthy();
            expect(animator.animate).toHaveBeenCalled();
            done();
        });
    });
    describe("Enumerate Objects", function () {
        var visual, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    isMeasure: true
                },
                {
                    displayName: 'col3',
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    isMeasure: true
                }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            visual = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            visual.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check enumeration: category measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
            ];
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            }
                        ])
                    }
                }]
            };
            visual.onDataChanged(dataChangedOptions);
            var points = visual.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(4);
            expect(points[1].displayName).toBe('a');
            expect(points[1].properties['fill']).toBeDefined();
            expect(points[2].displayName).toBe('b');
            expect(points[2].properties['fill']).toBeDefined();
        });
        it('Check enumeration: multi-measure', function () {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[1],
                                values: [100]
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [200]
                            }
                        ])
                    }
                }]
            };
            visual.onDataChanged(dataChangedOptions);
            var points = visual.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[1].displayName).toBe('col2');
            expect(points[1].properties['fill']).toBeDefined();
            expect(points[2].displayName).toBe('col3');
            expect(points[2].properties['fill']).toBeDefined();
        });
        it('enumerateObjectInstances - Gradient color', function () {
            var dataColors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var dataViewGradientMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var colors = ["#d9f2fb", "#ff557f", "#b1eab7"];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: colors[0] } } } },
                { dataPoint: { fill: { solid: { color: colors[1] } } } },
                { dataPoint: { fill: { solid: { color: colors[2] } } } }
            ];
            var dataView = {
                metadata: dataViewGradientMetadata,
                categorical: {
                    categories: [{
                        source: dataViewGradientMetadata.columns[0],
                        values: ['a', 'b', 'c'],
                        objects: objectDefinitions
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewGradientMetadata.columns[1],
                            values: [100, 200, 300, 400, 500]
                        },
                        {
                            source: dataViewGradientMetadata.columns[2],
                            values: [200, 400, 600, 800, 1000]
                        }
                    ])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, dataColors, defaultDataPointColor);
            expect(actualData.slices[0].color).toBe(colors[0]);
            expect(actualData.slices[1].color).toBe(colors[1]);
            expect(actualData.slices[2].color).toBe(colors[2]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var GaugeVisual = powerbi.visuals.Gauge;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var DefaultTimeout = 400;
    var sideNumbersVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightGaugeSideNumbersVisible;
    var sideNumbersVisibleGreaterThanMinHeight = sideNumbersVisibleMinHeight + 1;
    var sideNumbersVisibleSmallerThanMinHeight = sideNumbersVisibleMinHeight - 1;
    var sideNumbersVisibleGreaterThanMinHeightString = sideNumbersVisibleGreaterThanMinHeight.toString();
    var sideNumbersVisibleSmallerThanMinHeightString = sideNumbersVisibleSmallerThanMinHeight.toString();
    var marginsOnSmallViewPort = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.GaugeMarginsOnSmallViewPort;
    var dataViewMetadata = {
        columns: [
            {
                displayName: 'col1',
                roles: { 'Y': true },
                isMeasure: true,
                objects: { general: { formatString: '$0' } },
            },
            {
                displayName: 'col2',
                roles: { 'MinValue': true },
                isMeasure: true
            },
            {
                displayName: 'col3',
                roles: { 'MaxValue': true },
                isMeasure: true
            },
            {
                displayName: 'col4',
                roles: { 'TargetValue': true },
                isMeasure: true
            }
        ],
        groups: [],
        measures: [0],
    };
    describe('Gauge', function () {
        it('Capabilities should include dataViewMappings', function () {
            expect(GaugeVisual.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(GaugeVisual.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(GaugeVisual.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(GaugeVisual.capabilities.dataRoles).toBeDefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(GaugeVisual.capabilities.objects)).toEqual(GaugeVisual.formatStringProp);
        });
    });
    describe('Gauge DOM tests', function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            powerbitests.helpers.suppressDebugAssertFailure();
            powerbi.common.localize = powerbi.common.createLocalizationService();
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('gauge').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Ensure min & target dont overlap', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [0],
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var targetText = $('.targetText');
                var maxLabel = $($('.labelText')[0]);
                expect(targetText.length).toBe(1);
                var xyTarget = { x: targetText.attr('x'), y: targetText.attr('y') };
                var xyMaxlabel = { x: maxLabel.attr('x'), y: maxLabel.attr('y') };
                expect(xyTarget.x).not.toEqual(xyMaxlabel.x);
                expect(xyTarget.y).not.toEqual(xyMaxlabel.y);
                done();
            }, DefaultTimeout);
        });
        it('Ensure max & target dont overlap', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [300],
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var targetText = $('.targetText');
                var maxLabel = $($('.labelText')[1]);
                expect(targetText.length).toBe(1);
                var xyTarget = { x: targetText.attr('x'), y: targetText.attr('y') };
                var xyMaxlabel = { x: maxLabel.attr('x'), y: maxLabel.attr('y') };
                expect(xyTarget.x).not.toEqual(xyMaxlabel.x);
                expect(xyTarget.y).not.toEqual(xyMaxlabel.y);
                done();
            }, DefaultTimeout);
        });
        it('Check Gauge DOM', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [200],
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                // Check Arc Drawn
                var backgroundArc = $('.backgroundArc');
                var foregroundArc = $('.foregroundArc');
                expect(backgroundArc.length).toBe(1);
                expect(backgroundArc.attr('d')).toBeDefined();
                expect(foregroundArc.length).toBe(1);
                expect(foregroundArc.attr('d')).toBeDefined();
                expect($('.mainText').length).toBe(1);
                expect($('.mainText').text()).toEqual('$10');
                var translateString = $('.animatedNumber').attr('transform');
                var xy = SVGUtil.parseTranslateTransform(translateString);
                expect(xy.x).toBeGreaterThan(120);
                expect(xy.y).toBeGreaterThan(220);
                done();
            }, DefaultTimeout);
        });
        it('If value less that zero, then scale should be 0-1, but number should show negative value', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [-25],
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var backgroundArc = $('.backgroundArc');
                var foregroundArc = $('.foregroundArc');
                expect(backgroundArc.length).toBe(1);
                expect(backgroundArc.attr('d')).toBeDefined();
                expect(foregroundArc.length).toBe(1);
                expect(foregroundArc.attr('d')).toBeDefined();
                var labels = $('.labelText');
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual('$0');
                expect($(labels[1]).text()).toEqual('$1');
                expect($('.mainText').length).toBe(1);
                expect($('.mainText').text()).toEqual('-$25');
                done();
            }, DefaultTimeout);
        });
        it('Check Gauge DOM on Style Changed', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [500],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [200],
                            }
                        ])
                    }
                }]
            });
            var dataColors = new powerbi.visuals.DataColorPalette();
            v.onStyleChanged({
                titleText: {
                    color: { value: 'rgba(51,51,51,1)' }
                },
                subTitleText: {
                    color: { value: 'rgba(145,145,145,1)' }
                },
                labelText: {
                    color: {
                        value: '#008000',
                    },
                    fontSize: '11px'
                },
                colorPalette: {
                    dataColors: dataColors,
                },
                isHighContrast: false,
            });
            setTimeout(function () {
                var labels = $('.labelText');
                var color = $(labels[0]).css('fill');
                expect(color === '#008000' || color === 'rgb(0, 128, 0)').toBeTruthy();
                done();
            }, DefaultTimeout);
        });
    });
    describe("Gauge Data Tests", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    roles: { 'Y': true },
                    isMeasure: true,
                    objects: { general: { formatString: '$0' } },
                },
                {
                    displayName: 'col2',
                    roles: { 'MinValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col3',
                    roles: { 'MaxValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col4',
                    roles: { 'TargetValue': true },
                    isMeasure: true,
                    objects: { general: { formatString: '$0' } },
                }
            ],
            groups: [],
            measures: [0],
        };
        var dataViewMetadataNumbers = {
            columns: [
                {
                    displayName: 'col1',
                    roles: { 'Y': true },
                    isMeasure: true,
                    objects: { general: { formatString: '0.00' } },
                },
                {
                    displayName: 'col2',
                    roles: { 'MinValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col3',
                    roles: { 'MaxValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col4',
                    roles: { 'TargetValue': true },
                    isMeasure: true
                }
            ],
            groups: [],
            measures: [0],
        };
        it('Gauge registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('gauge').capabilities).toBe(GaugeVisual.capabilities);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(GaugeVisual.capabilities.objects)).toEqual(GaugeVisual.formatStringProp);
        });
        it('Gauge_greaterThanMax', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: 500 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [500],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [0],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [300],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            };
            expect(GaugeVisual.converter(dataView).percent).toBe(1);
        });
        it('Gauge_smallerThanMin', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: -3 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [-3],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [0],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [300],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            };
            expect(GaugeVisual.converter(dataView).percent).toBe(0);
        });
        it('Gauge_betweenMinMax', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: 200 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [200],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [300],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            };
            expect(GaugeVisual.converter(dataView).percent).toBe(0.5);
        });
        it('Gauge_Nulls', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: null },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [null],
                        }
                    ])
                }
            };
            var data = GaugeVisual.converter(dataView);
            expect(data.percent).toBe(0);
            expect(data.targetSettings).toEqual({
                min: 0,
                max: 0,
                target: 0,
            });
        });
        it('Gauge_tooltip_work', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: 500 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [10],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [0],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [500],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            };
            var data = GaugeVisual.converter(dataView);
            var expectedValues = {
                percent: 0.02,
                adjustedTotal: 10,
                total: 10,
                metadataColumn: dataViewMetadata.columns[0],
                targetSettings: {
                    min: 0,
                    max: 500,
                    target: 200
                },
                tooltipInfo: [{ displayName: "col1", value: "$10" }, { displayName: "col4", value: "$200" }],
            };
            expect(data).toEqual(expectedValues);
        });
        it('Gauge_Nulls_Tooltip_Data', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: null },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [null],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [null],
                        }
                    ])
                }
            };
            var data = GaugeVisual.converter(dataView);
            var expectedValues = {
                percent: 0,
                adjustedTotal: 0,
                total: 0,
                metadataColumn: dataViewMetadata.columns[0],
                targetSettings: { min: 0, max: 0, target: 0 },
                tooltipInfo: []
            };
            expect(data).toEqual(expectedValues);
        });
        it('Gauge_betweenMinMax_Tooltip_Data', function () {
            var dataView = {
                metadata: dataViewMetadata,
                single: { value: 200 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [200],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [300],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            };
            var data = GaugeVisual.converter(dataView);
            var expectedValues = {
                percent: 0.5,
                adjustedTotal: 200,
                total: 200,
                metadataColumn: {
                    displayName: 'col1',
                    roles: { Y: true },
                    isMeasure: true,
                    objects: { general: { formatString: '$0' } },
                },
                targetSettings: { min: 100, max: 300, target: 200 },
                tooltipInfo: [{ displayName: 'col1', value: '$200' }, { displayName: 'col4', value: '$200' }]
            };
            expect(data).toEqual(expectedValues);
        });
        describe("Gauge Rendering Tests", function () {
            var v, element;
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var dataViews = [{
                metadata: dataViewMetadata,
                single: { value: 10 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [10],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [0],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [300],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200],
                        }
                    ])
                }
            }];
            var dataViewsWithDecimals = [{
                metadata: dataViewMetadataNumbers,
                single: { value: 10 },
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataNumbers.columns[0],
                            values: [5.5],
                        },
                        {
                            source: dataViewMetadataNumbers.columns[1],
                            values: [0],
                        },
                        {
                            source: dataViewMetadataNumbers.columns[2],
                            values: [10],
                        },
                        {
                            source: dataViewMetadataNumbers.columns[3],
                            values: [6.5],
                        }
                    ])
                }
            }];
            beforeEach(function () {
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('gauge').create();
                element = powerbitests.helpers.testDom('500', '500');
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
            });
            it('Get_Animated_Number_Properties works', function () {
                var gauge = v;
                var expectedNumberProperty = {
                    transformString: "translate(0.2928932188134524,0.29289321881345254)",
                    viewport: {
                        "height": 0.7071067811865475,
                        "width": 1.4142135623730951
                    }
                };
                var animatedNumberProperty = gauge.getAnimatedNumberProperties(1, 1, 1, 1);
                expect(animatedNumberProperty).toEqual(expectedNumberProperty);
            });
            it('Get_Viewport_Properties works', function () {
                var gauge = v;
                var expectedViewPortProperty = {
                    radius: 205,
                    innerRadiusOfArc: 143.5,
                    left: 250,
                    top: 352.5,
                    height: 460,
                    width: 410,
                    margin: {
                        top: 20,
                        bottom: 20,
                        left: 45,
                        right: 45
                    },
                    transformString: "translate(250,352.5)",
                    innerRadiusFactor: 0.7
                };
                var viewPortProperty = gauge.getGaugeVisualProperties();
                expect(viewPortProperty).toEqual(expectedViewPortProperty);
            });
            function createGaugeFromHostServices(hostServices) {
                var gauge = v;
                spyOn(gauge, 'getGaugeVisualProperties').and.callThrough();
                spyOn(gauge, 'getAnimatedNumberProperties').and.callThrough();
                spyOn(gauge, 'drawViewPort').and.callThrough();
                var element = powerbitests.helpers.testDom(sideNumbersVisibleGreaterThanMinHeightString, sideNumbersVisibleGreaterThanMinHeightString);
                gauge.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
                return gauge;
            }
            function getDataViewsForValueWarning(values) {
                var dataViews = [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: values,
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [200],
                            }
                        ])
                    }
                }];
                return dataViews;
            }
            it('NaN in values shows a warning', function (done) {
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var gauge = createGaugeFromHostServices(hostServices);
                var dataViews = getDataViewsForValueWarning([NaN, 1]);
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                    done();
                }, DefaultTimeout);
            });
            it('Negative Infinity in values shows a warning', function (done) {
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var gauge = createGaugeFromHostServices(hostServices);
                var dataViews = getDataViewsForValueWarning([Number.NEGATIVE_INFINITY]);
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultTimeout);
            });
            it('Positive Infinity in values shows a warning', function (done) {
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var gauge = createGaugeFromHostServices(hostServices);
                var dataViews = getDataViewsForValueWarning([Number.POSITIVE_INFINITY]);
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultTimeout);
            });
            it('Value out of range in values shows a warning', function (done) {
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var gauge = createGaugeFromHostServices(hostServices);
                var dataViews = getDataViewsForValueWarning([1e301]);
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                    done();
                }, DefaultTimeout);
            });
            it('All okay in values shows a warning', function (done) {
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var gauge = createGaugeFromHostServices(hostServices);
                var dataViews = getDataViewsForValueWarning([20]);
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(warningSpy).not.toHaveBeenCalled();
                    done();
                }, DefaultTimeout);
            });
            it('OnDataChange calls expected methods', function (done) {
                var gauge = v;
                spyOn(gauge, 'getGaugeVisualProperties').and.callThrough();
                spyOn(gauge, 'getAnimatedNumberProperties').and.callThrough();
                spyOn(gauge, 'drawViewPort').and.callThrough();
                gauge.onDataChanged({ dataViews: dataViews });
                setTimeout(function () {
                    expect(gauge.drawViewPort).toHaveBeenCalled();
                    //Changing data should trigger new calls for viewport and animated number properties
                    expect(gauge.getGaugeVisualProperties).toHaveBeenCalled();
                    expect(gauge.getAnimatedNumberProperties).toHaveBeenCalled();
                    done();
                }, DefaultTimeout);
            });
            it('onResizing calls expected methods', function (done) {
                var gauge = v;
                //Sets private data property of Gauge
                gauge.onDataChanged({ dataViews: dataViews });
                spyOn(gauge, 'getGaugeVisualProperties').and.callThrough();
                spyOn(gauge, 'getAnimatedNumberProperties').and.callThrough();
                spyOn(gauge, 'drawViewPort').and.callThrough();
                gauge.onResizing({ height: 200, width: 300 }, 0);
                setTimeout(function () {
                    expect(gauge.getGaugeVisualProperties).toHaveBeenCalled();
                    expect(gauge.getAnimatedNumberProperties).toHaveBeenCalled();
                    expect(gauge.drawViewPort).toHaveBeenCalled();
                    done();
                }, DefaultTimeout);
            });
            it('onResizing aspect ratio check', function (done) {
                var gauge = v;
                //Sets private data property of Gauge
                gauge.onDataChanged({ dataViews: dataViews });
                gauge.onResizing({ height: 100, width: 400 }, 0);
                setTimeout(function () {
                    var foregroundArc = $('.foregroundArc');
                    var path = foregroundArc.attr('d');
                    // ensure the radius is correct
                    expect(path.indexOf('A 60 60') > -1 || path.indexOf('A60,60') > -1 || path.indexOf('A60 60') > -1).toBeTruthy();
                    done();
                }, DefaultTimeout);
            });
            it('check target has decimal values', function (done) {
                var gauge = v;
                gauge.onDataChanged({ dataViews: dataViewsWithDecimals });
                gauge.onResizing({ height: 100, width: 400 }, 0);
                setTimeout(function () {
                    var targetText = $('.targetText').text();
                    expect(targetText).toEqual('6.50');
                    done();
                }, DefaultTimeout);
            });
            it('Gauge_default_gauge_values', function () {
                var dataView = {
                    metadata: null,
                    single: { value: 500 },
                    categorical: null
                };
                var expectedValues = {
                    percent: 0,
                    adjustedTotal: 0,
                    total: 0,
                    metadataColumn: null,
                    targetSettings: {
                        min: 0,
                        max: 1,
                        target: undefined
                    },
                    tooltipInfo: undefined
                };
                expect(GaugeVisual.converter(dataView)).toEqual(expectedValues);
            });
        });
    });
    describe("Gauge margins tests", function () {
        it('Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString', function () {
            var v = testMargins(sideNumbersVisibleGreaterThanMinHeightString, false);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString', function () {
            var v = testMargins(sideNumbersVisibleSmallerThanMinHeightString, false);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString mobile', function () {
            var v = testMargins(sideNumbersVisibleGreaterThanMinHeightString, true);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString mobile', function () {
            var v = testMargins(sideNumbersVisibleSmallerThanMinHeightString, true);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: marginsOnSmallViewPort,
                    bottom: marginsOnSmallViewPort,
                    left: marginsOnSmallViewPort,
                    right: marginsOnSmallViewPort
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with height greater than width', function () {
            var v = testMargins({ height: "200", width: "199" }, false);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 15
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with height greater than width', function () {
            var v = testMargins({ height: "200", width: "199" }, false);
            var gauge = v;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 15
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with target on left and height greater than width', function () {
            var v = testMargins({ height: "200", width: "199" }, false);
            var gauge = v;
            gauge.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [0],
                            }
                        ])
                    }
                }]
            });
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 15
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with target on right and height greater than width', function () {
            var v = testMargins({ height: "200", width: "199" }, false);
            var gauge = v;
            gauge.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [250],
                            }
                        ])
                    }
                }]
            });
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 45
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it('Gauge margin test with small width and target', function () {
            var v = testMargins({ height: "200", width: "140" }, false);
            var gauge = v;
            gauge.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    single: { value: 10 },
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[0],
                                values: [10],
                            },
                            {
                                source: dataViewMetadata.columns[1],
                                values: [0],
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [300],
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [250],
                            }
                        ])
                    }
                }]
            });
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 15
                },
            };
            var viewPortProperty = gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
    });
    describe('Gauge side number tests', function () {
        it('Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString mobile', function (done) {
            testSideNumbers(sideNumbersVisibleSmallerThanMinHeightString, true);
            setTimeout(function () {
                var labels = $('.labelText');
                expect(labels.length).toBe(0);
                expect($(labels[0]).text()).toEqual('');
                expect($(labels[1]).text()).toEqual('');
                done();
            }, DefaultTimeout);
        });
        it('Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString mobile', function (done) {
            testSideNumbers(sideNumbersVisibleGreaterThanMinHeightString, true);
            setTimeout(function () {
                var labels = $('.labelText');
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual('$0');
                expect($(labels[1]).text()).toEqual('$1');
                done();
            }, DefaultTimeout);
        });
        it('Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString', function (done) {
            testSideNumbers(sideNumbersVisibleSmallerThanMinHeightString, false);
            setTimeout(function () {
                var labels = $('.labelText');
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual('$0');
                expect($(labels[1]).text()).toEqual('$1');
                done();
            }, DefaultTimeout);
        });
        it('Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString', function (done) {
            testSideNumbers(sideNumbersVisibleGreaterThanMinHeightString, false);
            setTimeout(function () {
                var labels = $('.labelText');
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual('$0');
                expect($(labels[1]).text()).toEqual('$1');
                done();
            }, DefaultTimeout);
        });
    });
    function testMargins(domSize, isMobile) {
        var width;
        var height;
        if (typeof domSize === 'string') {
            width = height = domSize;
        }
        else {
            width = domSize.width;
            height = domSize.height;
        }
        var element;
        var v;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        if (isMobile) {
            v = powerbi.visuals.visualPluginFactory.createMobile().getPlugin('gauge').create();
        }
        else {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('gauge').create();
        }
        element = powerbitests.helpers.testDom(height, width);
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true }
        });
        return v;
    }
    function testSideNumbers(domSizeString, isMobile) {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    roles: { 'Y': true },
                    isMeasure: true,
                    objects: { general: { formatString: '$0' } }
                },
                {
                    displayName: 'col2',
                    roles: { 'MinValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col3',
                    roles: { 'MaxValue': true },
                    isMeasure: true
                },
                {
                    displayName: 'col4',
                    roles: { 'TargetValue': true },
                    isMeasure: true
                }
            ],
            groups: [],
            measures: [0],
        };
        powerbi.common.localize = powerbi.common.createLocalizationService();
        element = powerbitests.helpers.testDom(domSizeString, domSizeString);
        if (isMobile) {
            v = powerbi.visuals.visualPluginFactory.createMobile().getPlugin('gauge').create();
        }
        else {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('gauge').create();
        }
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true }
        });
        v.onDataChanged({
            dataViews: [{
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [-25],
                        }
                    ])
                }
            }]
        });
    }
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var GeocodingManager = powerbi.visuals.BI.Services.GeocodingManager;
describe("GeocodingManagerTests", function () {
    it('GeocodingManager.isCategoryType', function () {
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Address)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.City)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Continent)).toBeTruthy();
        expect(GeocodingManager.isCategoryType("Country")).toBeTruthy(); // Country is special
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.County)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Longitude)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Latitude)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Place)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.PostalCode)).toBeTruthy();
        expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.StateOrProvince)).toBeTruthy();
        expect(GeocodingManager.isCategoryType("")).toBeFalsy();
    });
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ImageVisual = powerbi.visuals.ImageVisual;
    describe("ImageVisual", function () {
        it('ImageVisual registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('image').capabilities).toBe(ImageVisual.capabilities);
        });
        it('ImageVisual registered capabilities: objects', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('image').capabilities.objects).toBeDefined();
        });
        it('Image no visual configuration', function () {
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true
                }
            };
            var image = new ImageVisual();
            image.init(options);
            expect(element.children().length).toBe(0);
        });
        it('Image to about:blank', function () {
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true
                },
            };
            var image = new ImageVisual();
            image.init(options);
            image.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [],
                        objects: { general: { imageUrl: 'about:blank' } }
                    }
                }]
            });
            expect(element.find('.imageBackground').css('backgroundImage')).toBe('url(about:blank)');
        });
        it('Image from base64 string', function () {
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true
                },
            };
            var image = new ImageVisual();
            image.init(options);
            var imageBase64value = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAkFBMVEX////+/v78+/vz8e/29PLr5+Tw7etwWEdbPyzTy8Tj3trn4t78+/mTgHOsnZLCt69PMRzX0cvJwLmllYm1qJ53YE8zEQBsUj9QMR68sKZHKRREJA+aiHx+aViGcF7q5t6NeWpkSDafjoAvCwA4FgC4rKSnmJE+HAaKdWhVOCeHeG1TPi5jT0BxX1J5aFtlSznQd83pAAACIklEQVQYGZXBiVraQBiG0ff7s8BMQsJkEaNsalspXbj/u2us1Scg7TM9B64R/0X8H6FMxBPu53ePiCS6bz/qkljCfatK4hnHIxjRjPURiWjCf69AIpYIP44eRCxRdj/bBBFLkHZHh4glQbYOiGgykgoRT2QDIprIhxwRr3AJ8VTuChDvJPFPZQrijQyQuE6vTC94IUiLHMRHMnFGQmSHu+f7vkBckIDcN0PXfR7qJmR5Caj4+mnR1LN5InFGENrDYVHVLviiKIJzIWQp65uG0anCmBKu7ytvTCjNdmVwmJWqDogJEU4NIzPTG0YlCEzdAjFhDPOMP/QbryTAWFcYE4L262lfucx4l7jq0CFAtvGICeGTpN6v5svl/DTrN5t+9rB8/vR0WyMw6kfElHiYMUp8XS22/Wx1WvWbRRXESOT7RGJKrOYmE5cEIm094oxY32cISTaSkMxMYpQOHnHOcDcO443Eu9TliAtSulxjXFHuSsQHxn4ucYVAfCT8vZOIV3KYYUSznfLlgBFHZBk0S09JFOEzjM8PASQuyMQFEQpkNLPOQBITxjVJjWTkj4s6Y0oi/eIQ54QbwAzyuhtclpa8kAT17VODuCCaKgczIE2LXSnJDAj9022D+ECExy5jJEbiRVr3N3ePCeIKoXq/HnzKq9R3m+XzvMpBXCWQa7f9ZrvdbvrV/O521gbAxN+IURKGqm3brvElIxP/ImNCJi78AkZVGOZlPDldAAAAAElFTkSuQmCC';
            image.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [],
                        objects: { general: { imageUrl: imageBase64value } }
                    }
                }]
            });
            expect(element.find('.imageBackground').css('backgroundImage')).toBe('url(' + imageBase64value + ')');
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var LegendIcon = powerbi.visuals.LegendIcon;
var LegendPosition = powerbi.visuals.LegendPosition;
var DefaultWaitForRender = 10;
describe("legendChart DOM validation", function () {
    var element;
    var viewport;
    var legend;
    var interactivityService;
    var hostServices;
    beforeEach(function () {
        powerbi.common.localize = powerbi.common.createLocalizationService();
    });
    beforeEach(function () {
        element = powerbitests.helpers.testDom('500', '500');
        hostServices = powerbitests.mocks.createVisualHostServices();
        interactivityService = powerbi.visuals.createInteractivityService(hostServices);
        legend = powerbi.visuals.createLegend(element, false, interactivityService);
        viewport = {
            height: element.height(),
            width: element.width()
        };
    });
    it('legend dom validation one legend item count validation', function (done) {
        var legendData = [
            {
                label: 'California',
                color: 'red',
                icon: 2 /* Line */,
                identity: powerbi.visuals.SelectionId.createNull(),
                selected: false
            }
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.legendItem').length).toBe(1);
            expect($('.legendText').length).toBe(1);
            expect($('.legendIcon').length).toBe(1);
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items count validation', function (done) {
        var legendData = [
            { label: 'California', color: '#ff0000', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Texas', color: '#0000ff', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Washington', color: '00ff00', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.legendItem').length).toBe(3);
            expect($('.legendText').length).toBe(3);
            expect($('.legendIcon').length).toBe(3);
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation incremental build', function (done) {
        // Draw the legend once with the 3 states
        var initialData = [
            { label: 'California', color: '#fff000', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Texas', color: '#ff00ff', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Washington', color: '#fff000', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.drawLegend({ dataPoints: initialData }, viewport);
        setTimeout(function () {
            validateLegendDOM(initialData);
            // Draw the legend against with a new state at the start
            var legendData = [
                { label: 'Alaska', color: '#fff000', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'California', color: '#fff00d', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: '#fffe00', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: '#0000dd', icon: 0 /* Box */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.reset();
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                validateLegendDOM(legendData);
                done();
            }, DefaultWaitForRender);
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items first item text', function (done) {
        var legendData = [
            { label: 'California', color: 'red', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Texas', color: 'blue', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Washington', color: 'green', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.reset();
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.legendText').first().text()).toBe('California');
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items last item text', function (done) {
        var legendData = [
            { label: 'California', color: 'red', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Texas', color: 'blue', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Washington', color: 'green', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.legendText').last().text()).toBe('Washington');
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items colors count', function (done) {
        var legendData = [
            { label: 'California', color: 'red', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Texas', color: 'blue', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { label: 'Washington', color: 'green', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.legendIcon').length).toBe(3);
            done();
        }, DefaultWaitForRender);
    });
    it('legend defaults', function () {
        var legendArray = getLotsOfLegendData();
        var legendData = { dataPoints: legendArray, title: '' };
        var props = {};
        powerbi.visuals.LegendData.update(legendData, props);
        expect(props[powerbi.visuals.legendProps.show]).toBe(true);
        expect(props[powerbi.visuals.legendProps.position]).toEqual(powerbi.legendPosition.top);
    });
    it('legend with title', function () {
        var legendData = getLotsOfLegendData();
        legend.drawLegend({ dataPoints: legendData, title: 'states' }, viewport);
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendTitle').length).toBe(1);
    });
    it('legend with long title on Right', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(2 /* Right */);
        legend.drawLegend({ dataPoints: legendData, title: 'This is a super long title and should be truncated by now' }, viewport);
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendTitle').text()).toEqual('This is a super long title...');
    });
    it('legend no title', function () {
        var legendData = getLotsOfLegendData();
        legend.drawLegend({ dataPoints: legendData }, viewport);
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendTitle').length).toBe(0);
    });
    it('legend Top & horizontal trim', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(0 /* Top */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBeGreaterThan(5);
        expect($('.legendItem').length).toBeLessThan(52);
    });
    it('legend Bottom & horizontal trim', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(1 /* Bottom */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBeGreaterThan(5);
        expect($('.legendItem').length).toBeLessThan(52);
    });
    it('legend Left & vertical trim', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(3 /* Left */);
        legend.drawLegend({ dataPoints: legendData }, { height: 200, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBeGreaterThan(5);
        expect($('.legendItem').length).toBeLessThan(52);
    });
    it('legend Right & vertical trim', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(2 /* Right */);
        legend.drawLegend({ dataPoints: legendData }, { height: 200, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBeGreaterThan(5);
        expect($('.legendItem').length).toBeLessThan(52);
    });
    it('Intelligent Layout: Low label count should result in longer max-width', function () {
        var legendData = [{
            label: 'Really long label, but i have the space to show',
            color: 'red',
            icon: 2 /* Line */,
            identity: powerbi.visuals.SelectionId.createNull(),
            selected: false
        }];
        legend.changeOrientation(0 /* Top */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBe(1);
        expect($($('.legendText')[0]).text()).not.toContain('...');
    });
    it('Intelligent Layout: Lots of small labels should get compacted in horizontal layout', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(0 /* Top */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect($('.legendItem').length).toBe(25);
    });
    it('Intelligent Layout: If labels in horizontal layout have small widths, width of legend should be small', function () {
        var legendData = getLotsOfLegendData();
        legend.changeOrientation(2 /* Right */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect(legend.getMargins().width).toBeLessThan(200);
    });
    it('Intelligent Layout: If labels in horizontal layout have large widths, width of legend should be 30% of viewport', function () {
        var legendData = [{
            label: 'I am a really long label, but you should not allow me to take more than 300px',
            color: 'red',
            icon: 2 /* Line */,
            identity: powerbi.visuals.SelectionId.createNull(),
            selected: false
        }];
        legend.changeOrientation(2 /* Right */);
        legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
        powerbi.visuals.SVGUtil.flushAllD3Transitions();
        expect(legend.getMargins().width).toBe(300);
    });
    it('legend interactivity test ', function () {
        var scopeId1 = powerbitests.mocks.dataViewScopeIdentity('California');
        var scopeId2 = powerbitests.mocks.dataViewScopeIdentity('Texas');
        var scopeId3 = powerbitests.mocks.dataViewScopeIdentity('Washington');
        var legendData = [
            { label: 'California', color: '#ff0000', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createWithId(scopeId1), selected: false },
            { label: 'Texas', color: '#0000ff', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createWithId(scopeId2), selected: false },
            { label: 'Washington', color: '#00ff00', icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createWithId(scopeId3), selected: false }
        ];
        var viewport = {
            height: 500,
            width: 500
        };
        legend = powerbi.visuals.createLegend(element, false, interactivityService);
        legend.drawLegend({ title: "Top Data", dataPoints: legendData }, viewport);
        var icons = $('.legendIcon');
        spyOn(hostServices, 'onSelect').and.callThrough();
        // Click first legend
        icons.first().d3Click(0, 0);
        expect(icons[0].style.fill).toBe('#ff0000');
        expect(icons[1].style.fill).toBe('#a6a6a6');
        expect(icons[2].style.fill).toBe('#a6a6a6');
        // Click the last legend item, should just select current and clear others
        icons.last().d3Click(0, 0);
        expect(icons[0].style.fill).toBe('#a6a6a6');
        expect(icons[1].style.fill).toBe('#a6a6a6');
        expect(icons[2].style.fill).toBe('#00ff00');
        // Control + Click legend item, should multiselect
        icons.first().d3Click(0, 0, 1 /* CtrlKey */);
        expect(icons[0].style.fill).toBe('#ff0000');
        expect(icons[1].style.fill).toBe('#a6a6a6');
        expect(icons[2].style.fill).toBe('#00ff00');
        // Click the clear catcher should clear the legend selection
        ($('.clearCatcher').first()).d3Click(0, 0);
        expect(icons[0].style.fill).toBe('#ff0000');
        expect(icons[1].style.fill).toBe('#0000ff');
        expect(icons[2].style.fill).toBe('#00ff00');
    });
    function validateLegendDOM(expectedData) {
        var len = expectedData.length;
        var labels = $('.legendText');
        expect(labels.length).toBe(len);
        var icons = $('.legendIcon');
        expect(icons.length).toBe(len);
        for (var i = 0; i < len; ++i) {
            var expectedDatum = expectedData[i];
            expect($(labels.get(i)).text()).toBe(expectedDatum.label);
            expect($(icons.get(i)).css('fill')).toBe(expectedDatum.color);
        }
    }
    function getLotsOfLegendData() {
        var states = ['AL', 'AK', 'AS', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'DC', 'FM', 'FL', 'GA', 'GU', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MH', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'MP', 'OH', 'OK', 'OR', 'PW', 'PA', 'PR', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VI', 'VA', 'WA', 'WV', 'WI', 'WY', 'AE', 'AA', 'AP'];
        var colors = d3.scale.category20c();
        var legendData = [];
        for (var i = 0; i < states.length; i++) {
            legendData.push({ label: states[i], color: colors(i), icon: 2 /* Line */, identity: powerbi.visuals.SelectionId.createNull(), selected: false });
        }
        return legendData;
    }
});
describe("interactive legend DOM validation", function () {
    var element;
    var viewport;
    var legend;
    var colorStyle = 'color: {0};';
    var defaultLegendHeight = 65;
    var interactivityService;
    beforeEach(function () {
        powerbi.common.localize = powerbi.common.createLocalizationService();
    });
    beforeEach(function () {
        element = powerbitests.helpers.testDom('500', '500');
        var hostServices = powerbitests.mocks.createVisualHostServices();
        interactivityService = powerbi.visuals.createInteractivityService(hostServices);
        legend = powerbi.visuals.createLegend(element, true, interactivityService);
    });
    it('legend dom validation one legend item count validation', function (done) {
        var legendData = [
            { category: 'state', label: 'California', color: 'red', icon: 2 /* Line */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.interactive-legend .title').length).toBe(1);
            expect($('.interactive-legend .item').length).toBe(1);
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items count validation', function (done) {
        var legendData = [
            { category: 'state', label: 'California', color: 'red', icon: 2 /* Line */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Texas', color: 'blue', icon: 2 /* Line */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Washington', color: 'green', icon: 2 /* Line */, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.interactive-legend .title').length).toBe(1);
            expect($('.interactive-legend .item').length).toBe(3);
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation incremental build', function (done) {
        // Draw the legend once with the 3 states
        var initialData = [
            { category: 'state', label: 'California', color: 'red', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Texas', color: 'blue', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Washington', color: 'green', icon: 0 /* Box */, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
        ];
        legend.drawLegend({ dataPoints: initialData }, viewport);
        setTimeout(function () {
            validateLegendDOM(initialData);
            // Draw the legend against with a new state at the start
            var legendData = [
                { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'California', color: 'blue', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'green', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Washington', color: 'orange', icon: 0 /* Box */, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.reset();
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                validateLegendDOM(legendData);
                done();
            }, DefaultWaitForRender);
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items first item name and measure', function (done) {
        var legendData = [
            { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'California', color: 'blue', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Texas', color: 'green', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.interactive-legend .title').text()).toBe(legendData[0].category);
            expect($('.interactive-legend .item').first().find('.itemName').text().trim()).toBe('Alaska');
            expect($('.interactive-legend .item').first().find('.itemMeasure').text().trim()).toBe('0');
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items last item name and measure', function (done) {
        var legendData = [
            { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'California', color: 'blue', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Texas', color: 'green', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.interactive-legend .title').text()).toBe(legendData[0].category);
            // last item is actually the second item since values should be placed in a two-row table.
            expect($('.interactive-legend .item').last().find('.itemName').text().trim()).toBe('California');
            expect($('.interactive-legend .item').last().find('.itemMeasure').text().trim()).toBe('5');
            done();
        }, DefaultWaitForRender);
    });
    it('legend dom validation three legend items colors count', function (done) {
        var legendData = [
            { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'California', color: 'blue', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            { category: 'state', label: 'Texas', color: 'green', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
        ];
        legend.drawLegend({ dataPoints: legendData }, viewport);
        setTimeout(function () {
            expect($('.interactive-legend .icon').length).toBe(3);
            done();
        }, DefaultWaitForRender);
    });
    // Legend Height tests - legend height is constant regardless of data.
    it('legend getHeight empty', function () {
        expect(legend.getMargins().height).toBe(defaultLegendHeight);
    });
    it('legend getHeight no data', function () {
        legend.drawLegend({ dataPoints: [] }, viewport);
        expect(legend.getMargins().height).toBe(defaultLegendHeight);
    });
    it('legend getHeight data', function () {
        legend.drawLegend({
            dataPoints: [
                { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'California', color: 'blue', icon: 0 /* Box */, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'green', icon: 0 /* Box */, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ]
        }, viewport);
        expect(legend.getMargins().height).toBe(defaultLegendHeight);
    });
    it('legend getHeight one data point', function () {
        legend.drawLegend({
            dataPoints: [
                { category: 'state', label: 'Alaska', color: 'red', icon: 0 /* Box */, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ]
        }, viewport);
        expect(legend.getMargins().height).toBe(defaultLegendHeight);
    });
    function validateLegendDOM(expectedData) {
        var len = expectedData.length;
        var items = $('.interactive-legend .item');
        expect($('.interactive-legend .title').length).toBe(1);
        expect(items.length).toBe(len);
        var icons = $('.interactive-legend .icon');
        expect(icons.length).toBe(len);
        // items are returned from the table, first row and then second row.
        // rearrage it to match the way the legend outputs it: by columns.
        var rearrangedItems = [];
        var rearrangedIcons = [];
        for (var i = 0; i < len; i = i + 2) {
            rearrangedItems.push($(items.get(i)));
            rearrangedIcons.push($(icons.get(i)));
        }
        for (var i = 1; i < len; i = i + 2) {
            rearrangedItems.push($(items.get(i)));
            rearrangedIcons.push($(icons.get(i)));
        }
        for (var i = 0; i < len; ++i) {
            var expectedDatum = expectedData[i];
            var item = rearrangedItems[i];
            var icon = rearrangedIcons[i];
            expect(item.find('.itemName').text()).toBe(expectedDatum.label);
            expect(item.find('.itemMeasure').text().trim()).toBe(expectedDatum.measure.toString());
            expect(icon.attr('style').trim()).toBe(jsCommon.StringExtensions.format(colorStyle, expectedDatum.color));
        }
    }
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var AxisType = powerbi.axisType;
    var ColorUtility = powerbitests.utils.ColorUtility;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewPivotCategorical = powerbi.data.DataViewPivotCategorical;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var LineChart = powerbi.visuals.LineChart;
    var PrimitiveType = powerbi.PrimitiveType;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var SelectionId = powerbi.visuals.SelectionId;
    var SemanticType = powerbi.data.SemanticType;
    var ValueType = powerbi.ValueType;
    var DefaultWaitForRender = 10;
    describe("LineChart Dataview Validation", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        var blankCategoryValue = '(Blank)';
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */),
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        it('LineChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').capabilities).toBe(powerbi.visuals.lineChartCapabilities);
        });
        it('LineChart registered customizeQuery', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').customizeQuery).toBe(LineChart.customizeQuery);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.lineChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.lineChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.lineChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.lineChartCapabilities.objects)).toEqual(powerbi.visuals.lineChartProps.general.formatString);
        });
        it('CustomizeQuery picks sample based on data type', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ sample: {} });
        });
        it('CustomizeQuery picks top based on data type', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(1 /* Text */), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery no category', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery explicit scalar axis on non-scalar type', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar'
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(1 /* Text */), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery explicit categorical axis on scalar type', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar'
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(1 /* Text */), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('Sortable roles with scalar axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            expect(LineChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toBeNull();
        });
        it('Sortable roles with categorical axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Categorical',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */), objects);
            expect(LineChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toEqual(['Category']);
        });
        function createCompiledDataViewMapping(categoryType, objects) {
            var categoryItems = [];
            if (categoryType)
                categoryItems.push({ type: categoryType });
            return {
                metadata: {
                    objects: objects
                },
                categorical: {
                    categories: {
                        for: {
                            in: { role: 'Category', items: categoryItems }
                        },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: { role: 'Series', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(1 /* Text */) }] },
                            select: [
                                { for: { in: { role: 'Y', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(4 /* Integer */) }] } } }
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    }
                }
            };
        }
        it('Check convert empty + fill color', function () {
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: '#41BEE0' } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: [],
                        objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } }]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: metadata.columns[1],
                        values: [],
                        subtotal: 0
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false);
            expect(actualData.series).toEqual([{
                key: key,
                lineIndex: 0,
                color: '#41BEE0',
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [],
                selected: false,
                identity: SelectionId.createWithMeasure('col2'),
            }]);
        });
        it('Check convert categorical + fill color', function () {
            var seriesColor = '#41BEE0';
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColor } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: metadata.columns[1],
                        values: [100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: 200,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: SelectionId.createWithMeasure('col2'),
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical + default color', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var hexDefaultColorRed = "#FF0000";
            dataView.metadata.objects = {
                dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } }
            };
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false, null).series;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: hexDefaultColorRed,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: hexDefaultColorRed,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: 200,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: hexDefaultColorRed,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: hexDefaultColorRed,
                    },
                ],
                identity: SelectionId.createWithMeasure('col2'),
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical multi-series + fill colors', function () {
            var seriesId1 = SelectionId.createWithMeasure('col2');
            var seriesKey1 = seriesId1.getKey();
            var seriesId2 = SelectionId.createWithMeasure('col3');
            var seriesKey2 = seriesId2.getKey();
            var seriesId3 = SelectionId.createWithMeasure('col4');
            var seriesKey3 = seriesId3.getKey();
            var seriesColors = [
                '#41BEE0',
                '#41BEE1',
                '#41BEE2',
            ];
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[0] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[2], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[1] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[3], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[2] } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200, 700],
                        },
                        {
                            source: metadata.columns[2],
                            values: [700, 100, 200],
                        },
                        {
                            source: metadata.columns[3],
                            values: [200, 700, 100],
                        }
                    ])
                },
            };
            dataView.categorical.values.source = metadata.columns[4];
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [
                {
                    key: seriesKey1,
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 0 }),
                            labelFill: seriesColors[0],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 1 }),
                            labelFill: seriesColors[0],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 2 }),
                            labelFill: seriesColors[0],
                        },
                    ],
                    identity: seriesId1,
                    selected: false
                },
                {
                    key: seriesKey2,
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[2],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 700,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col3", value: "700" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 0 }),
                            labelFill: seriesColors[1],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 100,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col3", value: "100" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 1 }),
                            labelFill: seriesColors[1],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col3", value: "200" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 2 }),
                            labelFill: seriesColors[1],
                        },
                    ],
                    identity: seriesId2,
                    selected: false
                },
                {
                    key: seriesKey3,
                    lineIndex: 2,
                    color: seriesColors[2],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[3],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col4", value: "200" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 0 }),
                            labelFill: seriesColors[2],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 700,
                            categoryIndex: 1,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col4", value: "700" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 1 }),
                            labelFill: seriesColors[2],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 100,
                            categoryIndex: 2,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col4", value: "100" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 2 }),
                            labelFill: seriesColors[2],
                        },
                    ],
                    identity: seriesId3,
                    selected: false,
                },
            ];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical multi-series', function () {
            var seriesId1 = SelectionId.createWithMeasure('col2');
            var seriesKey1 = seriesId1.getKey();
            var seriesId2 = SelectionId.createWithMeasure('col3');
            var seriesKey2 = seriesId2.getKey();
            var seriesId3 = SelectionId.createWithMeasure('col4');
            var seriesKey3 = seriesId3.getKey();
            dataViewMetadata.objects = undefined;
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [700, 100, 200],
                        },
                        {
                            source: dataViewMetadata.columns[3],
                            values: [200, 700, 100],
                        }
                    ]),
                },
            };
            var seriesColors = [
                colors.getColor(dataViewMetadata.columns[1].queryName).value,
                colors.getColor(dataViewMetadata.columns[2].queryName).value,
                colors.getColor(dataViewMetadata.columns[3].queryName).value,
            ];
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [
                {
                    key: seriesKey1,
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 0 }),
                            labelFill: seriesColors[0],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 1 }),
                            labelFill: seriesColors[0],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 2 }),
                            labelFill: seriesColors[0],
                        },
                    ],
                    identity: seriesId1,
                    selected: false
                },
                {
                    key: seriesKey2,
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[2],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 700,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col3", value: "700" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 0 }),
                            labelFill: seriesColors[1],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 100,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col3", value: "100" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 1 }),
                            labelFill: seriesColors[1],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col3", value: "200" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 2 }),
                            labelFill: seriesColors[1],
                        },
                    ],
                    identity: seriesId2,
                    selected: false
                },
                {
                    key: seriesKey3,
                    lineIndex: 2,
                    color: seriesColors[2],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[3],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col4", value: "200" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 0 }),
                            labelFill: seriesColors[2],
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 700,
                            categoryIndex: 1,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col4", value: "700" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 1 }),
                            labelFill: seriesColors[2],
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 100,
                            categoryIndex: 2,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col4", value: "100" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 2 }),
                            labelFill: seriesColors[2],
                        },
                    ],
                    identity: seriesId3,
                    selected: false,
                },
            ];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical multi-series + default color + fill color', function () {
            var seriesId1 = SelectionId.createWithMeasure('col2');
            var seriesKey1 = seriesId1.getKey();
            var seriesId2 = SelectionId.createWithMeasure('col3');
            var seriesKey2 = seriesId2.getKey();
            var seriesId3 = SelectionId.createWithMeasure('col4');
            var seriesKey3 = seriesId3.getKey();
            var series1Color = '#41BEE0';
            var hexDefaultColorRed = "FF0000";
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: series1Color } } } }; }),
                    dataViewMetadata.columns[2],
                    dataViewMetadata.columns[3],
                ],
            };
            metadata.objects = {
                dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultPointLabelSettings();
            dataLabelSettings.formatterOptions = metadata.columns[1];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        objects: [{ dataPoint: { fill: { solid: { color: series1Color } } } }, undefined, undefined]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200, 700],
                        },
                        {
                            source: metadata.columns[2],
                            values: [700, 100, 200],
                        },
                        {
                            source: metadata.columns[3],
                            values: [200, 700, 100],
                        }
                    ])
                },
            };
            dataView.categorical.values.source = metadata.columns[4];
            var hexDefaultColorRed = "FF0000";
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false, null).series;
            var expectedData = [
                {
                    key: seriesKey1,
                    lineIndex: 0,
                    color: series1Color,
                    xCol: metadata.columns[0],
                    yCol: metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 0 }),
                            labelFill: series1Color,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 1 }),
                            labelFill: series1Color,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 2 }),
                            labelFill: series1Color,
                        },
                    ],
                    identity: seriesId1,
                    selected: false
                },
                {
                    key: seriesKey2,
                    lineIndex: 1,
                    color: hexDefaultColorRed,
                    xCol: metadata.columns[0],
                    yCol: metadata.columns[2],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 700,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col3", value: "700" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 0 }),
                            labelFill: hexDefaultColorRed,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 100,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col3", value: "100" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 1 }),
                            labelFill: hexDefaultColorRed,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col3", value: "200" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 2 }),
                            labelFill: hexDefaultColorRed,
                        },
                    ],
                    identity: seriesId2,
                    selected: false
                },
                {
                    key: seriesKey3,
                    lineIndex: 2,
                    color: hexDefaultColorRed,
                    xCol: metadata.columns[0],
                    yCol: metadata.columns[3],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col4", value: "200" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 0 }),
                            labelFill: hexDefaultColorRed,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 700,
                            categoryIndex: 1,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col4", value: "700" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 1 }),
                            labelFill: hexDefaultColorRed,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 100,
                            categoryIndex: 2,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col4", value: "100" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 2 }),
                            labelFill: hexDefaultColorRed,
                        },
                    ],
                    identity: seriesId3,
                    selected: false,
                },
            ];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert non-category multi-measure + fill colors', function () {
            var seriesColors = [
                '#41BEE0',
                '#41BEE1',
            ];
            var metadata = {
                columns: [
                    powerbi.Prototype.inherit(dataViewMetadata.columns[0], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[0] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[1] } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [100],
                        },
                        {
                            source: metadata.columns[1],
                            values: [200],
                        }
                    ])
                }
            };
            var ids = [SelectionId.createWithMeasure('col1'), SelectionId.createWithMeasure('col2')];
            var keys = [ids[0].getKey(), ids[1].getKey()];
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectSlices = [
                {
                    key: keys[0],
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: undefined,
                    yCol: dataView.metadata.columns[0],
                    data: [
                        {
                            categoryValue: blankCategoryValue,
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "100" }],
                            identity: ids[0],
                            selected: false,
                            key: JSON.stringify({ ser: keys[0], catIdx: 0 }),
                            labelFill: seriesColors[0],
                        }
                    ],
                    identity: ids[0],
                    selected: false,
                },
                {
                    key: keys[1],
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: undefined,
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: blankCategoryValue,
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col2", value: "200" }],
                            identity: ids[1],
                            selected: false,
                            key: JSON.stringify({ ser: keys[1], catIdx: 0 }),
                            labelFill: seriesColors[1],
                        }
                    ],
                    identity: ids[1],
                    selected: false
                }
            ];
            expect(actualData).toEqual(expectSlices);
        });
        it('Check convert date time', function () {
            var dateTimeColumnsMetadata = {
                columns: [
                    { displayName: 'Date', queryName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                    { displayName: 'PowerBI Customers', queryName: 'PowerBI Customers', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dateTimeColumnsMetadata,
                categorical: {
                    categories: [{
                        source: dateTimeColumnsMetadata.columns[0],
                        values: [new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dateTimeColumnsMetadata.columns[1],
                        values: [8000, 20000, 1000000],
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('PowerBI Customers');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, true).series;
            var seriesColor = colors.getColor(dateTimeColumnsMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: new Date('2014/9/25').getTime(),
                        value: 8000,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "9/25/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "8000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: new Date('2014/12/12').getTime(),
                        value: 20000,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "12/12/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "20000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: new Date('2015/9/25').getTime(),
                        value: 1000000,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "9/25/2015 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "1000000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert datetime category with null category value', function () {
            var dateTimeColumnsMetadata = {
                columns: [
                    { displayName: 'Date', queryName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                    { displayName: 'PowerBI Customers', queryName: 'PowerBI Customers', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dateTimeColumnsMetadata,
                categorical: {
                    categories: [{
                        source: dateTimeColumnsMetadata.columns[0],
                        values: [null, new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dateTimeColumnsMetadata.columns[1],
                        values: [30000, 8000, 20000, 1000000],
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('PowerBI Customers');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, true).series;
            var seriesColor = colors.getColor(dateTimeColumnsMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: new Date('2014/9/25').getTime(),
                        value: 8000,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "9/25/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "8000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: new Date('2014/12/12').getTime(),
                        value: 20000,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "12/12/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "20000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: new Date('2015/9/25').getTime(),
                        value: 1000000,
                        categoryIndex: 3,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "Date", value: "9/25/2015 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "1000000" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 3 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with null category value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', null, 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, 300, 200, 700],
                        subtotal: 1300
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColor(dataViewMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: null,
                        value: 300,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "(Blank)" }, { displayName: "col2", value: "300" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: 200,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 3,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 3 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with positive infinity value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, Number.POSITIVE_INFINITY, 700],
                        subtotal: 800
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColor(dataViewMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: Number.MAX_VALUE,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "1.7976931348623157E+308" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with negative infinity value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, Number.NEGATIVE_INFINITY, 700],
                        subtotal: 800
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColor(dataViewMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: -Number.MAX_VALUE,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "-1.7976931348623157E+308" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with NaN value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['John Domo', 'Delta Force', 'Jean Tablau']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [100, Number.NaN, 700],
                        subtotal: 800
                    }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColor(dataViewMetadata.columns[1].queryName).value;
            var expectedData = [{
                key: key,
                lineIndex: 0,
                color: seriesColor,
                xCol: dataView.metadata.columns[0],
                yCol: dataView.metadata.columns[1],
                data: [
                    {
                        categoryValue: 'John Domo',
                        value: 100,
                        categoryIndex: 0,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 0 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Delta Force',
                        value: null,
                        categoryIndex: 1,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Delta Force" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 1 }),
                        labelFill: seriesColor,
                    },
                    {
                        categoryValue: 'Jean Tablau',
                        value: 700,
                        categoryIndex: 2,
                        seriesIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                        identity: selectionId,
                        selected: false,
                        key: JSON.stringify({ ser: key, catIdx: 2 }),
                        labelFill: seriesColor,
                    },
                ],
                identity: selectionId,
                selected: false,
            }];
            expect(actualData).toEqual(expectedData);
        });
        function lineChartDomValidation(interactiveChart, minerva) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */),
                        objects: { general: { formatString: '0.000' } },
                    },
                    {
                        displayName: 'col3',
                        isMeasure: false,
                        type: DataShapeUtility.describeDataType(4 /* DateTime */),
                        objects: { general: { formatString: 'd' } },
                    }
                ],
            };
            var dataViewMetadataWithScalarObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithScalarObject.objects = { categoryAxis: { scalar: true } };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
                element = powerbitests.helpers.testDom('500', '500');
                v = minerva ? powerbi.visuals.visualPluginFactory.createMinerva({
                    heatMap: false,
                    scrollableVisuals: true,
                }).getPlugin('lineChart').create() : powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            function getOptionsForValuesWarning(values) {
                var options = {
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: values,
                                subtotal: 246500
                            }])
                        }
                    }]
                };
                return options;
            }
            it('NaN in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([NaN, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Negative Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([Number.NEGATIVE_INFINITY, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Positive Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([Number.POSITIVE_INFINITY, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, DefaultWaitForRender);
            });
            it('Out of range value in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([-1e301, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                    done();
                }, DefaultWaitForRender);
            });
            it('All okay in values does not show a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([480000, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).not.toHaveBeenCalled();
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('480K');
                    done();
                }, DefaultWaitForRender);
            });
            it('verify viewport when filtering data', function (done) {
                // Clone in order to keep the original as it is
                var dataViewMeta = _.clone(dataViewMetadata);
                dataViewMeta.objects = {
                    categoryAxis: {
                        show: true,
                        start: 490001,
                        end: 495001,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                var svgBox = $('.mainGraphicsContext').parent()[0].getBoundingClientRect();
                if (interactiveChart) {
                    setTimeout(function () {
                        expect(svgBox.height).toBeCloseTo(405, 0);
                        expect(svgBox.width).toBeCloseTo(384, 0);
                        done();
                    }, DefaultWaitForRender);
                }
                else {
                    setTimeout(function () {
                        expect(svgBox.height).toBeCloseTo(470, 0);
                        expect(svgBox.width).toBeCloseTo(384, 0);
                        done();
                    }, DefaultWaitForRender);
                }
            });
            it('ensure line chart is cleared when an empty dataview is applied', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var catCount = $('.lineChart').find('.line').length;
                    expect(catCount).toBe(1);
                    v.onDataChanged({
                        dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: []
                                }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                    });
                    setTimeout(function () {
                        var catCountNew = $('.lineChart').find('.line').length;
                        expect(catCountNew).toBe(0);
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
            it('line chart check if date time axis has margin allocated in DOM', function (done) {
                var dateTimeColumnsMetadata = {
                    columns: [
                        { displayName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                        { displayName: 'PowerBI Customers', isMeasure: true }
                    ]
                };
                var dataView = {
                    metadata: dateTimeColumnsMetadata,
                    categorical: {
                        categories: [{
                            source: dateTimeColumnsMetadata.columns[0],
                            values: [new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dateTimeColumnsMetadata.columns[1],
                            values: [8000, 20000, 1000000],
                        }])
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var ticks = $('.lineChart .axisGraphicsContext .x.axis .tick text');
                    expect(ticks.length).toBe(6);
                    var expectedValues = [
                        'Nov 2014',
                        'Jan 2015',
                        'Mar 2015',
                        'May 2015',
                        'Jul 2015',
                        'Sep 2015'
                    ];
                    for (var i = 0; i < 0; i++) {
                        var tick = $(ticks[i]).text();
                        var tickDate = new Date(tick).toUTCString();
                        var expectedDate = new Date(expectedValues[i]).toUTCString();
                        expect(tickDate).toEqual(expectedDate);
                    }
                    done();
                }, DefaultWaitForRender);
            });
            it('Line chart with an undefined domain', function (done) {
                var dateTimeColumnsMetadata = {
                    columns: [
                        { displayName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                        { displayName: 'PowerBI Fans', isMeasure: true }
                    ]
                };
                var dataView = {
                    metadata: dateTimeColumnsMetadata,
                    categorical: {
                        categories: [{
                            source: dateTimeColumnsMetadata.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dateTimeColumnsMetadata.columns[1],
                            values: [],
                        }])
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with small interval dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [1.000, 0.995, 0.990, 0.985, 0.995],
                                subtotal: 4.965
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.985');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart validate auto margin', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['ReallyLongValuesSoYouRotate1', 'ReallyLongValuesSoYouRotate2', 'ReallyLongValuesSoYouRotate3', 'ReallyLongValuesSoYouRotate4', 'ReallyLongValuesSoYouRotate5']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [50000, 49500, 49000, 48000, 50000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var yTranslate = parseFloat($('.lineChart .axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                    var xTranslate = parseFloat($('.lineChart .axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                    v.onDataChanged({
                        dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                                values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [0, 1, 2, 3, 4],
                                    subtotal: 246500
                                }])
                            }
                        }]
                    });
                    setTimeout(function () {
                        var newYTranslate = parseFloat($('.lineChart .axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                        var newXTranslate = parseFloat($('.lineChart .axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                        expect(yTranslate).toBeLessThan(newYTranslate);
                        expect(xTranslate).toBeLessThan(newXTranslate);
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
            it('line chart multi-series dom validation', function (done) {
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: DataShapeUtility.describeDataType(2048 /* String */)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        },
                        {
                            displayName: 'col3',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        }
                    ]
                };
                var seriesIdentities = [
                    powerbitests.mocks.dataViewScopeIdentity('col2'),
                    powerbitests.mocks.dataViewScopeIdentity('col3'),
                ];
                var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
                var col3Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesIdentities[0],
                    },
                    {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesIdentities[1],
                    }
                ], [col3Ref]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                source: metadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e'],
                                identityFields: [categoryColumnRef],
                            }],
                            values: valueColumns
                        }
                    }]
                });
                setTimeout(function () {
                    var lines = $('.lineChart .mainGraphicsContext .line');
                    expect(lines.length).toEqual(2);
                    var lineOne = $(lines.get(0)).attr('style');
                    expect(lineOne).toBeDefined();
                    var lineTwo = $(lines.get(1)).attr('style');
                    expect(lineTwo).toBeDefined();
                    if (!interactiveChart)
                        expect($('.legendTitle').text()).toBe('sales');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with nulls dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [0, 10, null, 15, 5],
                                subtotal: 20
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .mainGraphicsContext .line')[0].getAttribute('d')).toBeDefined();
                    done();
                }, DefaultWaitForRender);
            });
            it('Regression Test: Ensure chart does not miraculously shrink with data updates', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }, {
                                source: dataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var svg = $('.lineChart svg');
                    var height = svg.height();
                    for (var i = 0; i < 5; i++) {
                        v.onDataChanged({
                            dataViews: [{
                                metadata: dataViewMetadata,
                                categorical: {
                                    categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                    values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    }, {
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 6],
                                        subtotal: 16
                                    }])
                                }
                            }]
                        });
                    }
                    setTimeout(function () {
                        var newHeight = $('.lineChart svg').height();
                        expect(newHeight).toBe(height);
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
            it('line chart with null points dom validation (in the middle)', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [null, 10, null, 15, null],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(minerva ? 2 : 5);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(2);
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with null points dom validation (first and last)', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [10, null, 5, null, 15],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(minerva ? 3 : 5);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(3);
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with null points dom validation (first and last) - scalar does not draw dots', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithScalarObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[2],
                                values: [new Date("2014/1/1"), new Date("2014/2/1"), new Date("2014/3/1"), new Date("2014/4/1"), new Date("2014/5/1")]
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [10, null, 5, null, 15],
                                subtotal: 15
                            }])
                        },
                    }]
                });
                setTimeout(function () {
                    var dots = $('.dot').filter('[r^="4"]');
                    expect(dots.length).toBe(0);
                    var lines = $('.lineChart .mainGraphicsContext .line');
                    expect(lines.length).toBe(1);
                    done();
                }, DefaultWaitForRender);
            });
            it('ensure selection circle is removed from dom when series is dropped', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [null, 10, null, 15, null],
                                subtotal: 15
                            }, {
                                source: dataViewMetadata.columns[1],
                                values: [null, 10, null, 15, null],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var dots = $('.selection-circle');
                    expect(dots.length).toBe(minerva ? 0 : 2);
                    v.onDataChanged({
                        dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                                values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [null, 10, null, 15, null],
                                    subtotal: 15
                                }])
                            }
                        }]
                    });
                    setTimeout(function () {
                        var dots = $('.selection-circle');
                        expect(dots.length).toBe(minerva ? 0 : 1);
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
            it('line chart non-category multi-measure dom validation', function (done) {
                var metadata = {
                    columns: [
                        { displayName: 'col1', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                        { displayName: 'col2', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) }
                    ]
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[0],
                                    values: [100]
                                },
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [200]
                                }
                            ])
                        }
                    }]
                });
                setTimeout(function () {
                    if (!minerva) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(2);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(1)').attr('r')).toEqual('4');
                    }
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart series only dom validation', function (done) {
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            properties: { Series: true },
                            type: DataShapeUtility.describeDataType(2048 /* String */)
                        },
                        {
                            displayName: 'col2',
                            properties: { Y: true },
                            type: DataShapeUtility.describeDataType(SemanticType.Integer)
                        }
                    ]
                };
                v.onDataChanged({
                    dataViews: [DataViewPivotCategorical.apply({
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                source: metadata.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('a'),
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                    powerbitests.mocks.dataViewScopeIdentity('c'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [1, 2, 3]
                                }
                            ])
                        }
                    })]
                });
                setTimeout(function () {
                    if (!minerva) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(3);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(1)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(2)').attr('r')).toEqual('4');
                    }
                    done();
                }, DefaultWaitForRender);
            });
            it('empty line chart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: []
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with single point dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [4]
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(1);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(1);
                    if (!minerva) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(1);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                    }
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('5');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart does not show less ticks dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [26.125, 26.125]
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('30');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart shows less ticks dom validation', function (done) {
                var dataViewMetadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: DataShapeUtility.describeDataType(2048 /* String */)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(SemanticType.Integer)
                        }
                    ],
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [5, 5]
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('6');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart on small tile shows at least two tick lines dom validation', function (done) {
                v.onResizing({
                    height: 101,
                    width: 226
                }, 0);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [0.1495, 0.15, 0.1633]
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.150');
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('0.160');
                    done();
                }, DefaultWaitForRender);
            });
        }
        describe("lineChart DOM validation", function () { return lineChartDomValidation(false, false); });
        describe("interactive lineChart DOM validation", function () { return lineChartDomValidation(true, false); });
        describe("minerva lineChart DOM validation", function () { return lineChartDomValidation(false, true); });
        function areaChartDomValidation(interactiveChart) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ]
            };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('areaChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            it('check area rendered', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [50000, 49500, 49000, 48000, 50000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    done();
                }, DefaultWaitForRender);
            });
            it('check linear scale with big interval renders', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('480K');
                    done();
                }, DefaultWaitForRender);
            });
            it('check linear scale with small interval renders', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [1.000, 0.995, 0.990, 0.985, 0.995],
                                subtotal: 4.965
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.98');
                    done();
                }, DefaultWaitForRender);
            });
            it('empty areaChart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: []
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                    done();
                }, DefaultWaitForRender);
            });
        }
        describe("areaChart DOM validation", function () { return areaChartDomValidation(false); });
        describe("interactive areaChart DOM validation", function () { return areaChartDomValidation(true); });
        //Data Labels
        function lineChartDataLabelsValidation(interactiveChart) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */),
                    },
                    {
                        displayName: 'col3',
                        isMeasure: false,
                        type: DataShapeUtility.describeDataType(4 /* DateTime */),
                        format: 'd'
                    }
                ],
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var dataViewMetadataWithLabelsOnObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsOnObject.objects = { labels: { show: true, labelPrecision: 0 } };
            var dataViewMetadataWithLabelsOffObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsOffObject.objects = { labels: { show: false } };
            var dataViewMetadataWithDisplayUnitsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithDisplayUnitsObject.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 } };
            var dataViewMetadataWithDisplayUnitsAndPrecisionObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithDisplayUnitsAndPrecisionObject.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 1 } };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            it('line chart show labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabelsOnObject.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOnObject.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBeGreaterThan(0);
                    // First and last labels are hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toBe('495000');
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart labels style validation', function (done) {
                var selectionId = SelectionId.createWithMeasure('col1');
                var key = selectionId.getKey();
                var color = colors.getColor(key).value;
                var opacity = '1';
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabelsOnObject.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOnObject.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var fill = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill)).toBe(ColorUtility.convertFromRGBorHexToHex(color).toLowerCase());
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().css('fill-opacity')).toBe(opacity);
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart labels custom style validation', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabelsFillObject = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabelsFillObject.objects = { labels: { show: true, color: color } };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsFillObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataWithLabelsFillObject.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsFillObject.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var fill = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill)).toBe(ColorUtility.convertFromRGBorHexToHex(color.solid.color));
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart hide labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOffObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOffObject.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should support display units with no precision', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithDisplayUnitsObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOffObject.columns[1],
                                values: [500123, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toBe('500K');
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should support display units with precision', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithDisplayUnitsAndPrecisionObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOffObject.columns[1],
                                values: [500123, 495000, 490000, 480000, 500000],
                                subtotal: 246500
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toBe('500.1K');
                    done();
                }, DefaultWaitForRender);
            });
            //multi series
            it('line chart data labels multi-series', function (done) {
                var seriesScopeIdentities = [powerbitests.mocks.dataViewScopeIdentity('col2'), powerbitests.mocks.dataViewScopeIdentity('col3')];
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: DataShapeUtility.describeDataType(2048 /* String */)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        },
                        {
                            displayName: 'col3',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        }
                    ]
                };
                metadata.objects = { labels: { show: true } };
                var ids = [SelectionId.createWithMeasure('col1'), SelectionId.createWithMeasure('col2')];
                var keys = [ids[0].getKey(), ids[1].getKey()];
                var color0 = colors.getColor(keys[0]).value;
                var color1 = colors.getColor(keys[1]).value;
                var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
                var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    },
                    {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesScopeIdentities[1],
                    }
                ], [measureColumnRef]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                source: metadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e'],
                                identityFields: [categoryColumnRef],
                            }],
                            values: valueColumns
                        }
                    }]
                });
                setTimeout(function () {
                    var fill0 = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill0)).toBe(ColorUtility.convertFromRGBorHexToHex(color0).toLowerCase());
                    var fill1 = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').last().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill1)).toBe(ColorUtility.convertFromRGBorHexToHex(color1).toLowerCase());
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart data labels multi-series to one series', function (done) {
                var seriesScopeIdentities = [powerbitests.mocks.dataViewScopeIdentity('col2'), powerbitests.mocks.dataViewScopeIdentity('col3')];
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: DataShapeUtility.describeDataType(2048 /* String */)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        },
                        {
                            displayName: 'col3',
                            isMeasure: true,
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        }
                    ]
                };
                metadata.objects = { labels: { show: true } };
                var ids = [SelectionId.createWithMeasure('col1'), SelectionId.createWithMeasure('col2')];
                var keys = [ids[0].getKey(), ids[1].getKey()];
                var color0 = colors.getColor(keys[0]).value;
                var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
                var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    },
                    {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesScopeIdentities[1],
                    }
                ], [measureColumnRef]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                source: metadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e'],
                                identityFields: [categoryColumnRef],
                            }],
                            values: valueColumns
                        }
                    }]
                });
                //to one series
                var valueColumns2 = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    }
                ], [measureColumnRef]);
                valueColumns2.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                source: metadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e'],
                                identityFields: [categoryColumnRef],
                            }],
                            values: valueColumns2
                        }
                    }]
                });
                setTimeout(function () {
                    var fill0 = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill0)).toBe(ColorUtility.convertFromRGBorHexToHex(color0).toLowerCase());
                    var fill1 = $('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').last().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill1)).toBe(ColorUtility.convertFromRGBorHexToHex(color0).toLowerCase());
                    done();
                }, DefaultWaitForRender);
            });
            it('line chart with nulls dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [null, 10, null, 15, null],
                                subtotal: 20
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    // One label is hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(1);
                    done();
                }, DefaultWaitForRender);
            });
            it('change line chart dom data label validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOnObject.columns[1],
                                values: [500000, 495000, 490000, 480000, 500000],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(3);
                    // First and last labels are hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toBe('495000');
                    v.onDataChanged({
                        dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['q', 'w', 'r', 't']
                                }],
                                values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsOnObject.columns[1],
                                    values: [400, 500, 300, 200],
                                }])
                            }
                        }]
                    });
                    setTimeout(function () {
                        // One label is hidden due to collision detection
                        expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(3);
                        expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').first().text()).toBe('400');
                        done();
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
            it('line chart non-category multi-measure dom data label validation', function (done) {
                var metadata = {
                    columns: [
                        { displayName: 'col1', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) },
                        { displayName: 'col2', isMeasure: true, type: DataShapeUtility.describeDataType(1 /* Number */) }
                    ]
                };
                metadata.objects = { labels: { show: true } };
                v.onDataChanged({
                    dataViews: [{
                        metadata: metadata,
                        categorical: {
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[0],
                                    values: [100]
                                },
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [200]
                                }
                            ])
                        }
                    }]
                });
                setTimeout(function () {
                    // One label is hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(1);
                    done();
                }, DefaultWaitForRender);
            });
            //empty dom
            it('empty line chart dom data labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: []
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            });
            //One point
            it('line chart with single point dom data label validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [4]
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .dataLabelsSVG .data-labels').text()).toBe('4');
                    done();
                }, DefaultWaitForRender);
            });
        }
        describe("lineChart Data Labels validation", function () { return lineChartDataLabelsValidation(false); });
        describe("interactive lineChart Data Labels validation", function () { return lineChartDataLabelsValidation(true); });
    });
    describe("Line Chart Legend Formatting", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    format: 'd',
                    type: DataShapeUtility.describeDataType(SemanticType.Date)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: [new Date("Thu Dec 18 2014 00:08:00"), new Date("Thu Dec 19 2014 00:20:00"), new Date("Thu Dec 20 2014 00:11:00")]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
        });
        it('verify legend formatted as date', function () {
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('12/18/2014');
        });
    });
    describe("Line Chart Interactivity", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                }
            ],
            objects: {
                labels: {
                    show: true,
                    labelPrecision: 0,
                }
            }
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
        });
        it('line chart drag and click interaction validation', function () {
            var lineChart = v.layers[0];
            var mainGraphicsContext = $('.mainGraphicsContext');
            expect(mainGraphicsContext.length).toBe(1);
            // instead of clicking on the graph, which can be unstable due to different user's configurations
            // we will validate that the code knows how to deal with such a click
            var calculatedIndex = lineChart.findIndex(250);
            expect(calculatedIndex).toBe(2);
        });
        it('select column validation', function () {
            var lineChart = v.layers[0];
            spyOn(lineChart, 'setHoverLine').and.callThrough();
            ;
            // trigger select column
            lineChart.selectColumn(2);
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            var item = legend.find('.item');
            var hoverLine = $('.hover-line');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('c');
            expect(item.find('.itemName').text()).toBe('col2');
            expect(item.find('.itemMeasure').text().trim()).toBe('490000');
            expect(lineChart.setHoverLine).toHaveBeenCalled();
            var arg = lineChart.setHoverLine.calls ? lineChart.setHoverLine.calls.allArgs()[0][0] : 193;
            expect(Math.floor(arg) === 192 || arg === 193).toBeTruthy();
            expect(hoverLine.length).toBe(1);
        });
    });
    describe("Line Chart Interactivity - Creation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            // Invoke onDataChange to force creation of chart layers.
            v.onDataChanged({ dataViews: [] });
        });
        it('select column validation', function () {
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            var hoverLine = $('.hover-line');
            expect(lineChart.selectColumn).toHaveBeenCalledWith(0, true);
            expect(hoverLine.length).toBe(1);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col3',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                },
                {
                    displayName: 'col4',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadata.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadata.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(3);
                expect(points[0].displayName).toEqual('col2');
                expect(points[0].properties['fill']).toBeDefined();
                expect(points[1].displayName).toEqual('col3');
                expect(points[1].properties['fill']).toBeDefined();
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Line Chart Scrollbar Validation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('150', '50');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
                scrollableVisuals: true,
            }).getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000, 500000, 500000, 500000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
        });
        it('Line Chart Scrollbar DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.lineChart')).toBeInDOM();
                expect($('rect.extent').length).toBe(1);
                var transform = SVGUtil.parseTranslateTransform($('.lineChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').first().attr('transform').split(',')[0].split('(')[1]).toBe('19');
                expect($('.brush').first().attr('transform').split(',')[1].split(')')[0]).toBe('75');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(1);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, DefaultWaitForRender);
        });
        describe("xAxis Validations", function () {
            var path;
            var points;
            var gap;
            var lastIndex;
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col3',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ],
            };
            var nonNumericDataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col3',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ],
            };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            });
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: powerbitests.mocks.createVisualHostServices(),
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
            });
            function setAxis(xType) {
                points = [];
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: xType,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                var dataChangedOptions = {
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: [1, 2, 5, 10, 20],
                            }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                },
                                {
                                    source: dataViewMetadata.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }
                            ])
                        }
                    }]
                };
                v.onDataChanged(dataChangedOptions);
                path = $('.line').first().attr('d');
                var dots = path.split('L');
                dots[0] = dots[0].substr(1);
                for (var i = 0; i < dots.length; i++) {
                    var strPoint = dots[i].split(',');
                    var point = { x: strPoint[0], y: strPoint[1] };
                    points.push(point);
                }
                gap = +points[1].x - +points[0].x;
                lastIndex = points.length - 1;
            }
            it('Category vs Scalar Check', function () {
                setAxis(AxisType.scalar);
                expect(+points[lastIndex].x - +points[lastIndex - 1].x).toBeGreaterThan(gap);
                setAxis(AxisType.categorical);
                expect(+points[lastIndex].x - +points[lastIndex - 1].x).toBeCloseTo(gap, 2);
            });
            it('enumerateObjectInstances: Verify instances on ordinal category axis', function () {
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: nonNumericDataViewMetadata,
                        categorical: {
                            categories: [{
                                source: nonNumericDataViewMetadata.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: nonNumericDataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }, {
                                source: nonNumericDataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points[0].properties['start']).toBeUndefined();
                expect(points[0].properties['end']).toBeUndefined();
                expect(points[0].properties['axisType']).toBeUndefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
            });
            it('enumerateObjectInstances: Verify instances on numerical category axis', function () {
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: [1, 2, 3, 4, 5]
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }, {
                                source: dataViewMetadata.columns[1],
                                values: [1, 2, 3, 4, 5],
                                subtotal: 15
                            }])
                        }
                    }]
                });
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points[0].properties['start']).toBeDefined();
                expect(points[0].properties['end']).toBeDefined();
                expect(points[0].properties['axisType']).toBeDefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
            });
        });
    });
    describe("Area Chart Scrollbar Validation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(SemanticType.Integer)
                }
            ],
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('150', '50');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
                scrollableVisuals: true,
            }).getPlugin('areaChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000, 500000, 500000, 500000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
        });
        it('Area Chart Scrollbar DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.catArea')).toBeInDOM();
                expect($('rect.extent').length).toBe(1);
                var transform = SVGUtil.parseTranslateTransform($('.lineChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').first().attr('transform').split(',')[0].split('(')[1]).toBe('19');
                expect($('.brush').first().attr('transform').split(',')[1].split(')')[0]).toBe('75');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(1);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Line Chart Tooltips", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            // Invoke onDataChange to force creation of chart layers.
            v.onDataChanged({ dataViews: [] });
        });
        it('Scalar xAxis - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ],
            };
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: [2001, 2002, 2003, 2004, 2005],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            var lineChart = v.layers[0];
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2001' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2002' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2004' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2005' }, { displayName: 'col2', value: '500000' }]);
        });
        it('Scalar xAxis, multi series - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    },
                    {
                        displayName: 'col3',
                        type: DataShapeUtility.describeDataType(1 /* Number */),
                        isMeasure: true
                    }
                ],
            };
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('col2'),
                powerbitests.mocks.dataViewScopeIdentity('col3'),
            ];
            var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col2' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: dataViewMetadata.columns[1],
                    values: [500000, 495000, 490000, 480000, 500000],
                    identity: seriesIdentities[0],
                },
                {
                    source: dataViewMetadata.columns[2],
                    values: [null, null, 490000, 480000, 500000],
                    identity: seriesIdentities[1],
                }
            ], [measureColumnRef]);
            valueColumns.source = dataViewMetadata.columns[2];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: [2001, 2002, 2003, 2004, 2005]
                    }],
                    values: valueColumns
                }
            };
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [dataView]
            });
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2001' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2002' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2004' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2005' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '500000' }]);
        });
        it('Line Chart X and Y-axis show/hide Title ', function () {
            var element = powerbitests.helpers.testDom('500', '500');
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
            var v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
            var dataViewMetadataOneColumn = {
                columns: [
                    {
                        displayName: 'AxesTitleTest',
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ],
                objects: {
                    categoryAxis: {
                        showAxisTitle: true
                    },
                    valueAxis: {
                        showAxisTitle: true
                    }
                }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataOneColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataOneColumn.columns[0],
                            values: [20, 1000],
                            subtotal: 1020
                        }])
                    }
                }]
            });
            expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
            expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
            dataViewMetadataOneColumn.objects = {
                categoryAxis: {
                    showAxisTitle: false
                },
                valueAxis: {
                    showAxisTitle: false
                }
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                }]
            });
            expect($('.xAxisLabel').length).toBe(0);
            expect($('.yAxisLabel').length).toBe(0);
        });
        it('Non scalar xAxis - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: DataShapeUtility.describeDataType(2048 /* String */)
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ],
            };
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            var lineChart = v.layers[0];
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'd' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'e' }, { displayName: 'col2', value: '500000' }]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var Map = powerbi.visuals.Map;
    var DataLabelUtils = powerbi.visuals.dataLabelUtils;
    var ValueType = powerbi.ValueType;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    var DefaultWaitForRender = DefaultWaitForRender || 10;
    describe("Map", function () {
        var element;
        var SelectKind = powerbi.data.SelectKind;
        var mockGeotaggingAnalyzerService;
        beforeEach(function () {
            var localizationService = powerbi.common.createLocalizationService();
            powerbitests.mocks.setLocale(localizationService);
            powerbi.common.localize = localizationService;
            mockGeotaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(function (stringId) { return localizationService.get(stringId); });
            element = powerbitests.helpers.testDom('800', '500');
        });
        it('Map registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('map').capabilities).toBe(powerbi.visuals.mapCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.mapCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.mapCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.mapCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('Capabilities DataRole preferredTypes', function () {
            //Map's Category, X and Y fieldWells have preferences for geographic locations, longitude and latitude respectively
            expect(powerbi.visuals.mapCapabilities.dataRoles.map(function (r) { return !!r.preferredTypes; })).toEqual([
                true,
                false,
                true,
                true,
                false,
                false,
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[0].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromExtendedType(powerbi.ExtendedType.Address),
                ValueType.fromExtendedType(powerbi.ExtendedType.City),
                ValueType.fromExtendedType(powerbi.ExtendedType.Continent),
                ValueType.fromExtendedType(powerbi.ExtendedType.Country),
                ValueType.fromExtendedType(powerbi.ExtendedType.County),
                ValueType.fromExtendedType(powerbi.ExtendedType.Place),
                ValueType.fromExtendedType(powerbi.ExtendedType.PostalCode_Text),
                ValueType.fromExtendedType(powerbi.ExtendedType.Region),
                ValueType.fromExtendedType(powerbi.ExtendedType.StateOrProvince)
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[2].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromPrimitiveTypeAndCategory(3 /* Double */, "Longitude")
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[3].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromPrimitiveTypeAndCategory(3 /* Double */, "Latitude")
            ]);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.mapCapabilities.objects)).toEqual(powerbi.visuals.mapProps.general.formatString);
        });
        it('Map.getMeasureIndexOfRole', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [1, 2, 3],
                        subtotal: 6
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(0);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(1);
        });
        it('Map.calculateGroupSizes', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var groupSizeTotals = [];
            var range = null;
            var sizeIndex = 0;
            var result = Map.calculateGroupSizes(dataView.categorical, grouped, groupSizeTotals, sizeIndex, range);
            expect(result.min).toBe(-100);
            expect(result.max).toBe(700);
            expect(groupSizeTotals.length).toBe(3);
            expect(groupSizeTotals[0]).toBe(-100);
            expect(groupSizeTotals[1]).toBe(200);
            expect(groupSizeTotals[2]).toBe(700);
            groupSizeTotals = [];
            sizeIndex = -1;
            result = Map.calculateGroupSizes(dataView.categorical, grouped, groupSizeTotals, sizeIndex, range);
            expect(result).toBe(null);
            expect(groupSizeTotals.length).toBe(3);
            expect(groupSizeTotals[0]).toBe(null);
            expect(groupSizeTotals[1]).toBe(null);
            expect(groupSizeTotals[2]).toBe(null);
        });
        it('Map.createMapDataPoint', function () {
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var group = "Arizona";
            var value = 100;
            var mapSeriesInfo = {
                sizeValuesForGroup: [{
                    value: 100,
                    index: 0,
                    fill: "#112233",
                    stroke: "#223344",
                    seriesId: powerbitests.mocks.dataViewScopeIdentity("Sales"),
                }],
                latitude: null,
                longitude: null,
            };
            var radius = 3;
            // No seriesInfo means the result is null
            var result = Map.createMapDataPoint(group, value, null, radius, colors, null);
            expect(result).toBe(null);
            result = Map.createMapDataPoint(group, value, mapSeriesInfo, radius, colors, powerbitests.mocks.dataViewScopeIdentity("Arizona"));
            expect(result.seriesInfo).toBe(mapSeriesInfo);
            expect(result.radius).toBe(radius);
            expect(result.location).toBe(null);
            expect(result.cachedLocation).toBe(result.location);
            expect(result.geocodingQuery).toBe(group);
            expect(result.categoryValue).toBe(group);
            // No group, latitude, or longitude shouldn't render
            group = null;
            result = Map.createMapDataPoint(group, value, mapSeriesInfo, radius, colors, null);
            expect(result).toBe(null);
        });
        it('Map.calculateSeriesInfo', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, latIndex, longIndex, colors);
            expect(result.sizeValuesForGroup.length).toBe(1);
            expect(result.sizeValuesForGroup[0].value).toBe(-100);
            expect(result.sizeValuesForGroup[0].index).toBe(0);
            expect(result.latitude).toBe(null);
            expect(result.longitude).toBe(null);
        });
        it('Map.calculateSeriesInfo multi-series', function () {
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var categoryColumnRef = dataView.categorical.values.identityFields;
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors, undefined, undefined, categoryColumnRef);
            expect(result.sizeValuesForGroup.length).toBe(2);
            expect(result.sizeValuesForGroup[0].value).toBe(150);
            expect(result.sizeValuesForGroup[0].index).toBe(0);
            expect(result.sizeValuesForGroup[0].fill).not.toBeNull();
            expect(result.sizeValuesForGroup[0].stroke).not.toBeNull();
            expect(result.sizeValuesForGroup[1].value).toBe(100);
            expect(result.sizeValuesForGroup[1].index).toBe(1);
            expect(result.sizeValuesForGroup[1].fill).not.toBeNull();
            expect(result.sizeValuesForGroup[1].stroke).not.toBeNull();
            expect(result.sizeValuesForGroup[1].fill).not.toBe(result.sizeValuesForGroup[0].fill);
            expect(result.latitude).toBe(null);
            expect(result.longitude).toBe(null);
        });
        it('Map.calculateSeriesLegend colors from palette with dynamic series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2' },
                    { displayName: 'col3', isMeasure: true, groupName: 'a' },
                    { displayName: 'col3', isMeasure: true, groupName: 'b' },
                ]
            };
            var col3Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col3' });
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, 'a'),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, 'b'),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona'],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[2],
                        values: [-100, 200, 700],
                        identity: seriesIdentities[0],
                    }, {
                        source: dataViewMetadata.columns[3],
                        values: [200, 400, 500],
                        identity: seriesIdentities[1],
                    }], [col3Ref])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorByScale(SQExprShortSerializer.serialize(col3Ref), 'a');
            var series2Color = colors.getColorByScale(SQExprShortSerializer.serialize(col3Ref), 'b');
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, undefined, [col3Ref]);
            expect(result.length).toBe(2);
            expect(result[0].color).toBe(series1Color.value);
            expect(result[1].color).toBe(series2Color.value);
        });
        it('Map.calculateSeriesLegend colors from palette with static series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                ]
            };
            var col1Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('col2'),
                powerbitests.mocks.dataViewScopeIdentity('col3'),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona'],
                        identityFields: [col1Ref],
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        identity: seriesIdentities[0],
                    }, {
                        source: dataViewMetadata.columns[2],
                        values: [200, 400, 500],
                        identity: seriesIdentities[1],
                    }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorByScale(SQExprShortSerializer.serialize(col1Ref), 'col2').value;
            var series2Color = colors.getColorByScale(SQExprShortSerializer.serialize(col1Ref), 'col3').value;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, undefined, [col1Ref]);
            expect(result.length).toBe(2);
            expect(result[0].color).toBe(series1Color);
            expect(result[1].color).toBe(series2Color);
        });
        // TODO: verify this works when 4906998 is fixed
        //it('Map.calculateSeriesInfo same field category & series',() => {
        //    var dataViewMetadata: powerbi.DataViewMetadata = {
        //        columns: [
        //            { displayName: 'col1', roles: { 'Category': true, 'Series': true } },
        //            { displayName: 'col2', isMeasure: true, queryName: 'selectCol2' },
        //            { displayName: 'lat', isMeasure: true, queryName: 'selectLat' },
        //            { displayName: 'long', isMeasure: true, queryName: 'selectLong' },
        //        ]
        //    };
        //    var dataView: powerbi.DataView = powerbi.data.DataViewSelfCrossJoin.apply({
        //        metadata: dataViewMetadata,
        //        categorical: {
        //            categories: [{
        //                source: dataViewMetadata.columns[0],
        //                values: ['Montana', 'California', 'Arizona'],
        //                identity: [mocks.dataViewScopeIdentity('M'), mocks.dataViewScopeIdentity('C'), mocks.dataViewScopeIdentity('A')]
        //            }],
        //            values: DataViewTransform.createValueColumns([
        //                {
        //                    source: dataViewMetadata.columns[1],
        //                    values: [-100, 200, 700],
        //                }, {
        //                    source: dataViewMetadata.columns[2],
        //                    values: [49, 54, 101],
        //                }, {
        //                    source: dataViewMetadata.columns[3],
        //                    values: [0, 40, 20],
        //                }
        //            ])
        //        }
        //    });
        //    var groupedValues = dataView.categorical.values.grouped();
        //    var sizeIndex = 0;
        //    var latIndex = 1;
        //    var longIndex = 2;
        //    var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        //    var result0 = Map.calculateSeriesInfo(groupedValues, 0, sizeIndex, longIndex, latIndex, colors);
        //    expect(result0.sizeValuesForGroup.length).toBe(1);
        //    expect(result0.sizeValuesForGroup[0].value).toBe(-100);
        //    expect(result0.sizeValuesForGroup[0].index).toBe(0);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBeNull();
        //    expect(result0.sizeValuesForGroup[0].stroke).not.toBeNull();
        //    expect(result0.latitude).toBe(49);
        //    expect(result0.longitude).toBe(0);
        //    var result1 = Map.calculateSeriesInfo(groupedValues, 1, sizeIndex, longIndex, latIndex, colors);
        //    expect(result1.sizeValuesForGroup.length).toBe(1);
        //    expect(result1.latitude).toBe(54);
        //    expect(result1.longitude).toBe(40);
        //    var result2 = Map.calculateSeriesInfo(groupedValues, 2, sizeIndex, longIndex, latIndex, colors);
        //    expect(result2.sizeValuesForGroup.length).toBe(1);
        //    expect(result2.latitude).toBe(101);
        //    expect(result2.longitude).toBe(20);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBe(result1.sizeValuesForGroup[0].fill);
        //    expect(result1.sizeValuesForGroup[0].fill).not.toBe(result2.sizeValuesForGroup[0].fill);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBe(result2.sizeValuesForGroup[0].fill);
        //});
        it('Map.calculateSeriesLegend', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona'],
                        objects: [
                            { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                            { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                            { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                        ]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result.length).toBe(1);
        });
        it('Map.calculateSeriesLegend default color', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, hexDefaultColorRed);
            expect(result.length).toBe(1);
            expect(result[0].color).toBe(hexDefaultColorRed);
        });
        it('Map.calculateSeriesLegend multi-series', function () {
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result.length).toBe(2);
        });
        it('Map.calculateSeriesLegend null legend', function () {
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": null }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var groupIndex = 0, sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result[0].label).toBe(powerbi.visuals.valueFormatter.format(null));
        });
        it('Map.calculateRadius', function () {
            var range = { min: -100, max: 100 };
            // Null should be the minimum size
            var diff = 0;
            var result = Map.calculateRadius(range, 0, null);
            expect(result).toBe(6);
            // Min
            diff = range.max - range.min;
            result = Map.calculateRadius(range, diff, -100);
            expect(result).toBe(6);
            // Middle of zero
            result = Map.calculateRadius(range, diff, 0);
            expect(result).toBe(14 / 2 + 6);
            // Max
            result = Map.calculateRadius(range, diff, 100);
            expect(result).toBe(20);
            // No scale (div by zero or no range scenario
            result = Map.calculateRadius({ min: 100, max: 100 }, 0, 100);
            expect(result).toBe(6);
        });
        it('Map.getGeocodingCategory', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { "StateOrProvince": true } },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var result = Map.getGeocodingCategory(dataView.categorical, mockGeotaggingAnalyzerService);
            expect(result).toBe("StateOrProvince");
        });
        it('Map.getGeocodingCategoryDataCategory', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', type: ValueType.fromDescriptor({ geography: { stateOrProvince: true } }) },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 1000
                    }])
                }
            };
            var result = Map.getGeocodingCategory(dataView.categorical, mockGeotaggingAnalyzerService);
            expect(result).toBe("StateOrProvince");
        });
        it('Map Geocode With Size', function () {
            /* Disable due to way tests run in GCI
            v = powerbi.visuals.VisualFactory.getPlugin('map').create();
            v.init({
                element: element,
                host: mocks.createHostService(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });

            v.onDataChanged([dataView]);
            */
            // Only validation at this point is no exceptions are thrown
        });
        it('Map.hasSizeField', function () {
            var dataViewMetadataOneColumn = {
                columns: [
                    { displayName: 'col1', roles: { 'Category': true } }
                ]
            };
            var dataViewMetadataTwoColumnsWithRoles = {
                columns: [
                    { displayName: 'col1', roles: { 'Category': true } },
                    { displayName: 'col2', roles: { 'Size': true } }
                ]
            };
            var dataViewMetadataTwoColumnsWithoutRoles = {
                columns: [
                    { displayName: 'col1', type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'col2', type: ValueType.fromDescriptor({ numeric: true }) }
                ]
            };
            var dataViewMetadataThreeColumns = {
                columns: [
                    { displayName: 'col1', roles: { 'Category': true } },
                    { displayName: 'col2', roles: { 'Y': true } },
                    { displayName: 'col3', roles: { 'X': true } }
                ]
            };
            var dataViewOneColumn = {
                metadata: dataViewMetadataOneColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataOneColumn.columns[0],
                        values: ['98052', '98004', '98034', '12345', '67890']
                    }]
                }
            };
            var dataViewTwoColumnsWithRoles = {
                metadata: dataViewMetadataTwoColumnsWithRoles,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumnsWithRoles.columns[0],
                        values: ['San Diego', 'San Francisco', 'Seattle']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumnsWithRoles.columns[1],
                            values: [3, 4, 5],
                            subtotal: 12
                        }
                    ])
                }
            };
            var dataViewTwoColumnsWithoutRoles = {
                metadata: dataViewMetadataTwoColumnsWithoutRoles,
                categorical: {
                    categories: [{
                        source: dataViewMetadataTwoColumnsWithoutRoles.columns[0],
                        values: ['San Diego', 'San Francisco', 'Seattle']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumnsWithoutRoles.columns[1],
                            values: [3, 4, 5],
                            subtotal: 12
                        }
                    ])
                }
            };
            var dataViewThreeColumns = {
                metadata: dataViewMetadataThreeColumns,
                categorical: {
                    categories: [{
                        source: dataViewMetadataThreeColumns.columns[0],
                        values: ['San Diego', 'San Francisco', 'Seattle']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataThreeColumns.columns[1],
                            values: [32.715691, 37.777119, 47.603569],
                            subtotal: 39.36545966666666
                        },
                        {
                            source: dataViewMetadataThreeColumns.columns[2],
                            values: [-117.16172, -122.41964, -122.329453],
                            subtotal: -120.63693766666667
                        }
                    ])
                }
            };
            var actual = Map.hasSizeField(dataViewOneColumn.categorical.values, 0);
            expect(actual).toBe(false);
            actual = Map.hasSizeField(dataViewTwoColumnsWithRoles.categorical.values, 0);
            expect(actual).toBe(true);
            actual = Map.hasSizeField(dataViewTwoColumnsWithoutRoles.categorical.values, 0);
            expect(actual).toBe(true);
            actual = Map.hasSizeField(dataViewThreeColumns.categorical.values, 0);
            expect(actual).toBe(false);
        });
        it('Map.createDefaultValueColumns', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Category': true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['98052', '98004', '98034', '12345', '67890']
                    }]
                }
            };
            var expected = [{
                source: {
                    displayName: 'col',
                    isMeasure: true,
                    queryName: '',
                    roles: { Size: true },
                    type: ValueType.fromDescriptor({ numeric: true }),
                    isAutoGeneratedColumn: true
                },
                values: [1, 1, 1, 1, 1]
            }];
            var actual = Map.createDefaultValueColumns(dataView.categorical);
            expect(actual).toEqual(expected);
        });
        it('Map.createDefaultValueColumns with Gradient', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Category': true } },
                    { displayName: 'col2', roles: { 'Gradient': true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['98052', '98004', '98034', '12345', '67890']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [12, 1, 155, 543, 222]
                    }])
                }
            };
            var expected = [{
                source: {
                    displayName: 'col',
                    isMeasure: true,
                    queryName: '',
                    roles: { Size: true },
                    type: ValueType.fromDescriptor({ numeric: true }),
                    isAutoGeneratedColumn: true
                },
                values: [1, 1, 1, 1, 1]
            }, {
                source: {
                    displayName: 'col2',
                    roles: { Gradient: true }
                },
                values: [12, 1, 155, 543, 222]
            }];
            var actual = Map.createDefaultValueColumns(dataView.categorical);
            expect(actual).toEqual(expected);
        });
        it('Map.tooltipInfo single series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [-100, 200, 700],
                        subtotal: 800
                    }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesInfo = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: "col1", value: "Montana" }, { displayName: "col2", value: "-100" }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map.tooltipInfo multi series', function () {
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.DataViewTransform.apply({
                prototype: powerbi.data.dsr.readDsr({
                    Select: [
                        { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                        { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                        { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                        { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                    ],
                    Expressions: {
                        Primary: {
                            Groupings: [{
                                Keys: [{
                                    Source: propertyRef1,
                                    Select: 0,
                                }]
                            }]
                        },
                        Secondary: {
                            Groupings: [{
                                Keys: [{
                                    Source: propertyRef2,
                                    Select: 3,
                                }]
                            }]
                        }
                    }
                }, dsrResult, 's').dataView,
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
                dataViewMappings: powerbi.visuals.mapCapabilities.dataViewMappings,
                objectDescriptors: powerbi.visuals.mapCapabilities.objects,
                transforms: {
                    selects: [
                        { queryName: 'select0' },
                        { queryName: 'select1' },
                        { queryName: 'select2' },
                        { queryName: 'select3' },
                    ]
                }
            })[0];
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesInfo = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: '', value: '2012' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '150.00' }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map.createMapDataLabel bubble', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockBubbleData = [{
                x: 50,
                y: 50,
                radius: 10,
                fill: "#000000",
                stroke: "2",
                strokeWidth: 2,
                selected: true,
                identity: null,
                labeltext: "Test Label",
            }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapBubbles", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            //Should render
            expect(result).toBeDefined();
            expect(result[0][0]).toBeDefined();
            //Data input length
            expect(result.data.length).toBe(2);
            //Color setting properly
            expect(result[0][0].__data__.fill).toBe(mockDatalabelSettings.labelColor);
            //text
            expect(result[0][0].__data__.labeltext).toBe(powerbi.visuals.dataLabelUtils.getLabelFormattedText('Test Label'));
        });
        it('Map.createMapDataLabel slice', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockSliceData = [{
                x: 50,
                y: 50,
                radius: 10,
                fill: "#000000",
                stroke: "2",
                strokeWidth: 2,
                selected: true,
                identity: null,
                labeltext: 'Test Label',
                value: 0,
            }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapBubbles", true);
            var viewPort = {
                height: element.height(),
                width: element.width()
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockBubbleGraphicsContext, mockLayout, viewPort);
            //Should render
            expect(result).toBeDefined();
            expect(result[0][0]).toBeDefined();
            //Data input length
            expect(result.data.length).toBe(2);
            //Color setting properly
            expect(result[0][0].__data__.fill).toBe(mockDatalabelSettings.labelColor);
            //text
            expect(result[0][0].__data__.labeltext).toBe(powerbi.visuals.dataLabelUtils.getLabelFormattedText('Test Label'));
        });
        it('Map.createMapDataLabel hide bubble', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockBubbleData = [{
                x: 50,
                y: 50,
                radius: 10,
                fill: "#000000",
                stroke: "2",
                strokeWidth: 2,
                selected: true,
                identity: null,
                labeltext: "Test Label",
            }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapBubbles1", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            // Simulate the clean function of dataLabelUtils when 'show' is set to false
            DataLabelUtils.cleanDataLabels(mockBubbleGraphicsContext);
            expect(result).toBeDefined();
            expect($('.mapBubbles1 text').length).toBe(0);
        });
        it('Map.createMapDataLabel hide slice', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockSliceData = [{
                x: 50,
                y: 50,
                radius: 10,
                fill: "#000000",
                stroke: "2",
                strokeWidth: 2,
                selected: true,
                identity: null,
                labeltext: "Test Label",
                value: 0,
            }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body').append('svg').style("position", "absolute").append("g").classed("mapSlice1", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            // Simulate the clean function of dataLabelUtils when 'show' is set to false
            DataLabelUtils.cleanDataLabels(mockBubbleGraphicsContext);
            expect(result).toBeDefined();
            expect($('.mapSlice1 text').length).toBe(0);
        });
        it('Map.tooltipInfo no series, no values', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var valueColumns = Map.createDefaultValueColumns(dataView.categorical);
            var seriesInfo = Map.calculateSeriesInfo(valueColumns.grouped(), groupIndex, sizeIndex, latIndex, longIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: "col1", value: "Montana" }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map shows warning with no Location set', function () {
            var dataView = {
                metadata: {
                    columns: [{ displayName: 'NotLocation', roles: { 'NotCategory': true, }, }],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings[0]).not.toBeNull();
        });
        it('Map shows warning with no columns set', function () {
            var dataView = {
                metadata: {
                    columns: [],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings[0]).not.toBeNull();
        });
        it('Map does not show warning with location set', function () {
            var dataView = {
                metadata: {
                    columns: [{ displayName: 'Location', roles: { 'Category': true, }, }],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings).toBeNull();
        });
        it('Map legend is hidden:show false', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: false
                        }
                    }
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(true);
        });
        it('Map legend is hidden:show true', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: true
                        }
                    }
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is hidden:no legend object', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {}
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is hidden:no objects', function () {
            var dataView = {
                metadata: {
                    columns: [],
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is bottom', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            position: 'Bottom'
                        }
                    }
                }
            };
            expect(Map.legendPosition(dataView)).toBe(1 /* Bottom */);
        });
        it('Map enumerateLegend', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: true
                        }
                    }
                }
            };
            var legend = {
                changeOrientation: function () {
                },
                drawLegend: function () {
                },
                getMargins: function () { return {
                    width: 0,
                    height: 0
                }; },
                getOrientation: function () { return 0 /* Top */; },
                isVisible: function () { return true; },
                reset: function () {
                },
            };
            var objects = Map.enumerateLegend(dataView, legend, "");
            expect(objects.length).toBe(1);
            var firstObject = objects[0];
            expect(firstObject.objectName).toBe('legend');
            expect(firstObject.selector).toBeNull();
            expect(firstObject.properties).toBeDefined();
            var properties = firstObject.properties;
            expect(properties['show']).toBe(true);
            expect(properties['position']).toBe('Top');
        });
        it('Map.calculateSeriesInfo - Gradient color', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['Montana', 'California', 'Arizona']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [75, 50, 0],
                        }
                    ])
                }
            };
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: "#d9f2fb" } } } },
                { dataPoint: { fill: { solid: { color: "#b1eab7" } } } }
            ];
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), 0, sizeIndex, longIndex, latIndex, colors, null, objectDefinitions);
            expect(result.sizeValuesForGroup[0].fill).toBe('rgba(217,242,251,0.6)');
            result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), 1, sizeIndex, longIndex, latIndex, colors, null, objectDefinitions);
            expect(result.sizeValuesForGroup[0].fill).toBe('rgba(177,234,183,0.6)');
        });
        it('MapShapeDataPointRenderer.updateInternal calling updateInternal without converter throws a nullref', function () {
            var renderer = new powerbi.visuals.MapShapeDataPointRenderer();
            var mapData = {
                bubbleData: [],
                shapeData: [],
                sliceData: []
            };
            renderer.updateInternal(mapData);
            expect(true).toBe(true); // expect no exception to be thrown
        });
        it('Map.shouldEnumerateDataPoints filledMap', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(false);
        });
        it('Map.shouldEnumerateDataPoints filledMap series overrides size', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(true);
        });
        it('Map.shouldEnumerateDataPoints filledMap', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(true);
        });
        it('Map.shouldEnumerateDataPoints Map', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Gradient": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, false)).toBe(false);
        });
        it('Map.shouldEnumerateDataPoints Map', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, false)).toBe(true);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var CompiledSubtotalType = powerbi.data.CompiledSubtotalType;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewAnalysis = powerbi.DataViewAnalysis;
    var Matrix = powerbi.visuals.Matrix;
    var SemanticType = powerbi.data.SemanticType;
    var valueFormatter = powerbi.visuals.valueFormatter;
    var DefaultWaitForRender = 500;
    var dataTypeNumber = DataShapeUtility.describeDataType(1 /* Number */);
    var dataTypeString = DataShapeUtility.describeDataType(2048 /* String */);
    var dataTypeBoolean = DataShapeUtility.describeDataType(4096 /* Boolean */);
    var dataTypeWebUrl = DataShapeUtility.describeDataType(2048 /* String */, 'WebUrl');
    var rowGroupSource1 = { displayName: 'RowGroup1', queryName: 'RowGroup1', type: dataTypeString, index: 0 };
    var rowGroupSource2 = { displayName: 'RowGroup2', queryName: 'RowGroup2', type: dataTypeString, index: 1 };
    var rowGroupSource3 = { displayName: 'RowGroup3', queryName: 'RowGroup3', type: dataTypeString, index: 2 };
    var rowGroupSource3formatted = { displayName: 'RowGroup3', queryName: 'RowGroup3', type: dataTypeString, index: 2, objects: { general: { formatString: '0.0' } } };
    var rowGroupSource4 = { displayName: 'RowGroup4', queryName: 'RowGroup4', type: dataTypeBoolean, index: 9 };
    var rowGroupSourceWebUrl = { displayName: 'RowGroupWebUrl', queryName: 'RowGroupWebUrl', type: dataTypeWebUrl, index: 0 };
    var columnGroupSource1 = { displayName: 'ColGroup1', queryName: 'ColGroup1', type: dataTypeString, index: 3 };
    var columnGroupSource2 = { displayName: 'ColGroup2', queryName: 'ColGroup2', type: dataTypeString, index: 4 };
    var columnGroupSource3 = { displayName: 'ColGroup3', queryName: 'ColGroup3', type: dataTypeString, index: 5 };
    var columnGroupSource3formatted = { displayName: 'ColGroup3', queryName: 'ColGroup3', type: dataTypeString, index: 5, objects: { general: { formatString: '0.00' } } };
    var columnGroupSource4 = { displayName: 'ColGroup4', queryName: 'ColGroup4', type: dataTypeBoolean, index: 10 };
    var columnGroupSourceWebUrl = { displayName: 'ColGroupWebUrl', queryName: 'ColGroupWebUrl', type: dataTypeWebUrl, index: 0 };
    var measureSource1 = { displayName: 'Measure1', queryName: 'Measure1', type: dataTypeNumber, isMeasure: true, index: 6 };
    var measureSource2 = { displayName: 'Measure2', queryName: 'Measure2', type: dataTypeNumber, isMeasure: true, index: 7 };
    var measureSource3 = { displayName: 'Measure3', queryName: 'Measure3', type: dataTypeNumber, isMeasure: true, index: 8 };
    // ------------
    // | Measure1 |
    // +----------|
    // |      100 |
    // ------------
    var matrixOneMeasure = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    values: {
                        0: { value: 100 }
                    }
                }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{
                sources: [measureSource1]
            }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureDataView = {
        metadata: { columns: [measureSource1] },
        matrix: matrixOneMeasure
    };
    // -----------
    // | Group A |
    // +---------|
    // |     100 |
    // -----------
    var matrixOneMeasureOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    values: {
                        0: { value: 100 }
                    }
                }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Group A'
                    }
                ]
            },
            levels: [{
                sources: [columnGroupSource1]
            }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSource1, measureSource1] },
        matrix: matrixOneMeasureOneColumnGroupOneGroupInstance
    };
    // ---------------------------
    // | http://www.validurl.com |
    // +-------------------------|
    // |     100                 |
    // ---------------------------
    var matrixOneMeasureOneColumnGroupWithUrlOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    values: {
                        0: { value: 100 }
                    }
                }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'http://www.validurl.com'
                    }
                ]
            },
            levels: [{
                sources: [columnGroupSourceWebUrl]
            }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneColumnGroupWithUrlOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSourceWebUrl, measureSource1] },
        matrix: matrixOneMeasureOneColumnGroupWithUrlOneGroupInstance
    };
    // ----------------------------------
    // | Measure1 | Measure2 | Measure3 |
    // +--------------------------------|
    // |      100 |      200 |      300 |
    // ----------------------------------
    var matrixThreeMeasures = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    values: {
                        0: { value: 100 },
                        1: { value: 200, valueSourceIndex: 1 },
                        2: { value: 300, valueSourceIndex: 2 }
                    }
                }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    { level: 0 },
                    { level: 0, levelSourceIndex: 1 },
                    { level: 0, levelSourceIndex: 2 }
                ]
            },
            levels: [{
                sources: [
                    measureSource1,
                    measureSource2,
                    measureSource3
                ]
            }]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresDataView = {
        metadata: { columns: [measureSource1, measureSource2, measureSource3] },
        matrix: matrixThreeMeasures
    };
    // ----------------------------------
    // |                        Group A |
    // |--------------------------------|
    // | Measure1 | Measure2 | Measure3 |
    // +--------------------------------|
    // |      100 |      200 |      300 |
    // ----------------------------------
    var matrixThreeMeasuresOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    values: {
                        0: { value: 100 },
                        1: { value: 200, valueSourceIndex: 1 },
                        2: { value: 300, valueSourceIndex: 2 }
                    }
                }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Group A',
                        children: [
                            { level: 1 },
                            { level: 1, levelSourceIndex: 1 },
                            { level: 1, levelSourceIndex: 2 }
                        ]
                    }
                ]
            },
            levels: [
                {
                    sources: [
                        columnGroupSource1
                    ]
                },
                {
                    sources: [
                        measureSource1,
                        measureSource2,
                        measureSource3
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
        matrix: matrixThreeMeasuresOneColumnGroupOneGroupInstance
    };
    // ----------------------------------------------------------------------------
    // |     RowGroup1 | RowGroup2 |   RowGroup3 | Measure1 | Measure2 | Measure3 |
    // |-----------------------------------------+--------------------------------|
    // | North America |    Canada |     Ontario |     1000 |     1001 |     1002 |
    // |               |           |----------------------------------------------|
    // |               |           |      Quebec |     1010 |     1011 |     1012 |
    // |               |----------------------------------------------------------|
    // |               |       USA |  Washington |     1100 |     1101 |     1102 |
    // |               |           |----------------------------------------------|
    // |               |           |      Oregon |     1110 |     1111 |     1112 |
    // |--------------------------------------------------------------------------|
    // | South America |    Brazil |    Amazonas |     2000 |     2001 |     2002 | 
    // |               |           |----------------------------------------------|
    // |               |           | Mato Grosso |     2010 |     2011 |     2012 |
    // |               |----------------------------------------------------------|
    // |               |     Chile |       Arica |     2100 |     2101 |     2102 |
    // |               |           |----------------------------------------------|
    // |               |           |  Parinacota |     2110 |     2111 |     2112 |
    // ----------------------------------------------------------------------------
    var matrixThreeMeasuresThreeRowGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'North America',
                        children: [
                            {
                                level: 1,
                                value: 'Canada',
                                children: [
                                    {
                                        level: 2,
                                        value: 'Ontario',
                                        values: {
                                            0: { value: 1000 },
                                            1: { value: 1001, valueSourceIndex: 1 },
                                            2: { value: 1002, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: 'Quebec',
                                        values: {
                                            0: { value: 1010 },
                                            1: { value: 1011, valueSourceIndex: 1 },
                                            2: { value: 1012, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'USA',
                                children: [
                                    {
                                        level: 2,
                                        value: 'Washington',
                                        values: {
                                            0: { value: 1100 },
                                            1: { value: 1101, valueSourceIndex: 1 },
                                            2: { value: 1102, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: 'Oregon',
                                        values: {
                                            0: { value: 1110 },
                                            1: { value: 1111, valueSourceIndex: 1 },
                                            2: { value: 1112, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'South America',
                        children: [
                            {
                                level: 1,
                                value: 'Brazil',
                                children: [
                                    {
                                        level: 2,
                                        value: 'Amazonas',
                                        values: {
                                            0: { value: 2000 },
                                            1: { value: 2001, valueSourceIndex: 1 },
                                            2: { value: 2002, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: 'Mato Grosso',
                                        values: {
                                            0: { value: 2010 },
                                            1: { value: 2011, valueSourceIndex: 1 },
                                            2: { value: 2012, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Chile',
                                children: [
                                    {
                                        level: 2,
                                        value: 'Arica',
                                        values: {
                                            0: { value: 2100 },
                                            1: { value: 2101, valueSourceIndex: 1 },
                                            2: { value: 2102, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: 'Parinacota',
                                        values: {
                                            0: { value: 2110 },
                                            1: { value: 2111, valueSourceIndex: 1 },
                                            2: { value: 2112, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: [
                    { level: 0 },
                    { level: 0, levelSourceIndex: 1 },
                    { level: 0, levelSourceIndex: 2 }
                ]
            },
            levels: [{
                sources: [
                    measureSource1,
                    measureSource2,
                    measureSource3
                ]
            }]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresThreeRowGroupsDataView = {
        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
        matrix: matrixThreeMeasuresThreeRowGroups
    };
    // ------------------------
    // | RowGroup1 | Measure1 |
    // |-----------+----------|
    // |   Group 1 |      100 |
    // ------------------------
    var matrixOneMeasureOneRowGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    value: 'Group 1',
                    values: { 0: { value: 100 } }
                }]
            },
            levels: [{ sources: [rowGroupSource1] }]
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{ sources: [measureSource1] }]
        },
        valueSources: [measureSource1]
    };
    // ----------------------------------------
    // | RowGroup1                 | Measure1 |
    // |---------------------------+----------|
    // |   http://www.validurl.com |      100 |
    // ----------------------------------------
    var matrixOneMeasureOneRowGroupUrlOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    value: 'http://www.validurl.com',
                    values: { 0: { value: 100 } }
                }]
            },
            levels: [{ sources: [rowGroupSourceWebUrl] }]
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{ sources: [measureSource1] }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneRowGroupUrlOneGroupInstanceDataView = {
        metadata: { columns: [], segment: {} },
        matrix: matrixOneMeasureOneRowGroupUrlOneGroupInstance
    };
    // ----------------------
    // | RowGroup1 |  Group |
    // |-----------+--------|
    // |     Group |        |
    // ----------------------
    var matrixOneRowGroupOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                    level: 0,
                    value: 10
                }]
            },
            levels: [{ sources: [rowGroupSource1] }]
        },
        columns: {
            root: {
                children: [{
                    level: 0,
                    value: 10
                }]
            },
            levels: [{ sources: [columnGroupSource1] }]
        },
        valueSources: []
    };
    var matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [rowGroupSource1, columnGroupSource1] },
        matrix: matrixOneRowGroupOneColumnGroupOneGroupInstance
    };
    // -------------------------------------
    // | RowGroup1 | RowGroup2 | RowGroup3 |
    // |-----------------------------------+
    // |    Africa |   Algeria |      2008 |
    // -------------------------------------
    var matrixThreeRowGroupsOneGroupInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Africa',
                        children: [
                            {
                                level: 1,
                                value: 'Algeria',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008,
                                        identity: powerbitests.mocks.dataViewScopeIdentity('rowGroup3')
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    var matrixThreeRowGroupsOneGroupInstanceDataView = {
        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3] },
        matrix: matrixThreeRowGroupsOneGroupInstance
    };
    // -------------------------
    // | RowGroup1 | RowGroup2 |
    // |-----------------------+
    // |    Africa |           |
    // |           |-----------|
    // |           |    Angola |
    // |-----------|-----------|
    // |      Asia |     China |
    // |           |-----------|
    // |           |           |
    // |-----------|-----------|
    // |           |           |
    // -------------------------
    var matrixTwoRowGroupsWithNullValues = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Africa',
                        children: [
                            {
                                level: 1
                            },
                            {
                                level: 1,
                                value: 'Angola'
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'China'
                            },
                            {
                                level: 1
                            }
                        ]
                    },
                    {
                        level: 0,
                        children: [
                            {
                                level: 1
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    // -------------------------------------
    // | RowGroup1 | RowGroup2 | RowGroup3 |
    // |-----------------------------------+
    // |    Africa |   Algeria |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |           |-----------------------|
    // |           |    Angola |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |-----------|-----------|-----------|
    // |      Asia |     China |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |           |-----------|-----------|
    // |           |     India |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // -------------------------------------
    var matrixThreeRowGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Africa',
                        children: [
                            {
                                level: 1,
                                value: 'Algeria',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Angola',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'China',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'India',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    // ---------------------------------------------------------
    // |                    Africa |                      Asia | 
    // |---------------------------|---------------------------|
    // |     Algeria |      Angola |       China |       India |
    // |-------------|-------------|-------------|-------------|
    // | 2008 | 2012 | 2008 | 2012 | 2008 | 2012 | 2008 | 2012 |
    // +--------------------------------------------------------
    var matrixThreeColumnGroups = {
        rows: {
            root: {
                children: []
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Africa',
                        children: [
                            {
                                level: 1,
                                value: 'Algeria',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Angola',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'China',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'India',
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        valueSources: []
    };
    var matrixThreeColumnGroupsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                rowGroupSource3
            ]
        },
        matrix: matrixThreeColumnGroups
    };
    // --------------------------------------------
    // |         Africa |           Asia |        |
    // |----------------|----------------|--------|
    // |       | Angola | China |        |        |
    // +-------------------------------------------
    var matrixTwoColumnGroupsWithNullValues = {
        rows: {
            root: {
                children: []
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Africa',
                        children: [
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            },
                            {
                                level: 1,
                                value: 'Angola',
                                identity: jasmine.any(Object)
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'China',
                                identity: jasmine.any(Object)
                            },
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            }
                        ]
                    },
                    {
                        level: 0,
                        children: [
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] }
            ]
        },
        valueSources: []
    };
    // -----------------------------
    // | RowGroup1 | United States |
    // |-----------+---------------|
    // |      2002 |               |
    // -----------------------------
    var matrixOneRowGroupOneColumnGroupOneInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 2002
                    }
                ]
            },
            levels: [
                {
                    sources: [rowGroupSource1]
                }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'United States'
                    }
                ]
            },
            levels: [
                {
                    sources: [columnGroupSource1]
                }
            ]
        },
        valueSources: []
    };
    // -----------------------------------------
    // |           |           | ColGroup1 | B |
    // |-----------|-----------|-----------|---|
    // |           |           | ColGroup2 | b |
    // |-----------|-----------|-----------|---|
    // | RowGroup1 | RowGroup2 | RowGroup3 | 2 |
    // |-----------------------------------+---|
    // |         A |         a |         1 |   |
    // -----------------------------------------
    var matrixThreeRowGroupsThreeColumnGroupsOneInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'A',
                        children: [
                            {
                                level: 1,
                                value: 'a',
                                children: [
                                    {
                                        level: 2,
                                        value: 1
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'B',
                        children: [
                            {
                                level: 1,
                                value: 'b',
                                children: [
                                    {
                                        level: 2,
                                        value: 2
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                { sources: [columnGroupSource3] }
            ]
        },
        valueSources: []
    };
    // -------------------------------------------------
    // |           |           | ColGroup1 |         C |
    // |-----------|-----------|-----------|-----------|
    // |           |           | ColGroup2 |     c | d |
    // |-----------|-----------|-----------|-----------|
    // | RowGroup1 | RowGroup2 | RowGroup3 | 4 | 5 | 6 |
    // |-----------------------------------+-----------|
    // |         A |         a |         1 |   |   |   |
    // |           |           |-----------|---|---|---|
    // |           |           |         2 |   |   |   |
    // |           |-----------|-----------|---|---|---|
    // |           |         b |         3 |   |   |   |
    // -------------------------------------------------
    var matrixThreeRowGroupsThreeColumnGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'A',
                        children: [
                            {
                                level: 1,
                                value: 'a',
                                children: [
                                    {
                                        level: 2,
                                        value: 1
                                    },
                                    {
                                        level: 2,
                                        value: 2
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'b',
                                children: [
                                    {
                                        level: 2,
                                        value: 3
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3formatted] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'C',
                        children: [
                            {
                                level: 1,
                                value: 'c',
                                children: [
                                    {
                                        level: 2,
                                        value: 4
                                    },
                                    {
                                        level: 2,
                                        value: 5
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'd',
                                children: [
                                    {
                                        level: 2,
                                        value: 6
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                { sources: [columnGroupSource3formatted] }
            ]
        },
        valueSources: []
    };
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                                                            1992 |                                                            1996 |
    // |---------------|---------------|-----------------------------------------------------------------|-----------------------------------------------------------------|
    // |               |     ColGroup2 |              Bronze |                Gold |              Silver |              Bronze |                Gold |              Silver |
    // |---------------|---------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|
    // |     RowGroup1 |     RowGroup2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 |
    // |-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------|
    // |          Asia |   South Korea |        0 |        1 |        2 |        3 |        4 |        5 |        6 |        7 |        8 |        9 |       10 |       11 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       12 |       13 |       14 |       15 |       16 |       17 |       18 |       19 |       20 |       21 |       22 |          |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       24 |       25 |       26 |       27 |       28 |       29 |       30 |       31 |       32 |       33 |       34 |       35 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       36 |       37 |       38 |       39 |       40 |       41 |       42 |       43 |       44 |       45 |       46 |       47 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       48 |       49 |       50 |       51 |       52 |       53 |       54 |       55 |       56 |       57 |       58 |       59 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       60 |       61 |       62 |       63 |       64 |       65 |       66 |       67 |       68 |       69 |       70 |       71 |
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasures = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'South Korea',
                                values: {
                                    0: { value: 0 },
                                    1: { value: 1, valueSourceIndex: 1 },
                                    2: { value: 2 },
                                    3: { value: 3, valueSourceIndex: 1 },
                                    4: { value: 4 },
                                    5: { value: 5, valueSourceIndex: 1 },
                                    6: { value: 6 },
                                    7: { value: 7, valueSourceIndex: 1 },
                                    8: { value: 8 },
                                    9: { value: 9, valueSourceIndex: 1 },
                                    10: { value: 10 },
                                    11: { value: 11, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Unified Team',
                                values: {
                                    0: { value: 12 },
                                    1: { value: 13, valueSourceIndex: 1 },
                                    2: { value: 14 },
                                    3: { value: 15, valueSourceIndex: 1 },
                                    4: { value: 16 },
                                    5: { value: 17, valueSourceIndex: 1 },
                                    6: { value: 18 },
                                    7: { value: 19, valueSourceIndex: 1 },
                                    8: { value: 20 },
                                    9: { value: 21, valueSourceIndex: 1 },
                                    10: { value: 22 },
                                    11: { value: null, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Europe',
                        children: [
                            {
                                level: 1,
                                value: 'France',
                                values: {
                                    0: { value: 24 },
                                    1: { value: 25, valueSourceIndex: 1 },
                                    2: { value: 26 },
                                    3: { value: 27, valueSourceIndex: 1 },
                                    4: { value: 28 },
                                    5: { value: 29, valueSourceIndex: 1 },
                                    6: { value: 30 },
                                    7: { value: 31, valueSourceIndex: 1 },
                                    8: { value: 32 },
                                    9: { value: 33, valueSourceIndex: 1 },
                                    10: { value: 34 },
                                    11: { value: 35, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Germany',
                                values: {
                                    0: { value: 36 },
                                    1: { value: 37, valueSourceIndex: 1 },
                                    2: { value: 38 },
                                    3: { value: 39, valueSourceIndex: 1 },
                                    4: { value: 40 },
                                    5: { value: 41, valueSourceIndex: 1 },
                                    6: { value: 42 },
                                    7: { value: 43, valueSourceIndex: 1 },
                                    8: { value: 44 },
                                    9: { value: 45, valueSourceIndex: 1 },
                                    10: { value: 46 },
                                    11: { value: 47, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'North America',
                        children: [
                            {
                                level: 1,
                                value: 'United States',
                                values: {
                                    0: { value: 48 },
                                    1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 },
                                    3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 52 },
                                    5: { value: 53, valueSourceIndex: 1 },
                                    6: { value: 54 },
                                    7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 },
                                    9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 58 },
                                    11: { value: 59, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Oceania',
                        children: [
                            {
                                level: 1,
                                value: 'Australia',
                                values: {
                                    0: { value: 60 },
                                    1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 },
                                    3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 64 },
                                    5: { value: 65, valueSourceIndex: 1 },
                                    6: { value: 66 },
                                    7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 },
                                    9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 70 },
                                    11: { value: 71, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                name: 'Bronze',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Gold',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Silver',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: 'Bronze',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Gold',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Silver',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                {
                    sources: [
                        measureSource1,
                        measureSource2
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2
        ]
    };
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1,
                measureSource2,
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsTwoMeasures
    };
    // --------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                           1992 |                           1996 |    Total |
    // |---------------|---------------|--------------------------------|--------------------------------|          |
    // |     RowGroup1 |     RowGroup2 |   Silver |     Gold |    Total |   Silver |     Gold |    Total |          |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |          Asia |   South Korea |        1 |        2 |        3 |        4 |        5 |        9 |       12 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       11 |       12 |       23 |       14 |       15 |       29 |       52 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       12 |       14 |       26 |       18 |       20 |       38 |       64 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       21 |       22 |       43 |       24 |       25 |       49 |       92 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       31 |       32 |       63 |       34 |       35 |       69 |      132 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       52 |       54 |      106 |       58 |       60 |      118 |      224 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       41 |       42 |       83 |       44 |       45 |       89 |      172 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       41 |       42 |       83 |       44 |       45 |       89 |      172 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       51 |       52 |      103 |       54 |       55 |      109 |      212 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       51 |       52 |      103 |       54 |       55 |      109 |      212 |
    // |-------------------------------|----------|----------|----------|----------|----------|----------|----------|
    // |         Total                 |      156 |      162 |      318 |      174 |      180 |      354 |      672 |
    // --------------------------------------------------------------------------------------------------------------
    var matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'South Korea',
                                values: {
                                    0: { value: 1 },
                                    1: { value: 2 },
                                    2: { value: 3 },
                                    3: { value: 4 },
                                    4: { value: 5 },
                                    5: { value: 9 },
                                    6: { value: 12 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Unified Team',
                                values: {
                                    0: { value: 11 },
                                    1: { value: 12 },
                                    2: { value: 23 },
                                    3: { value: 14 },
                                    4: { value: 15 },
                                    5: { value: 29 },
                                    6: { value: 52 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 12 },
                                    1: { value: 14 },
                                    2: { value: 26 },
                                    3: { value: 18 },
                                    4: { value: 20 },
                                    5: { value: 38 },
                                    6: { value: 64 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Europe',
                        children: [
                            {
                                level: 1,
                                value: 'France',
                                values: {
                                    0: { value: 21 },
                                    1: { value: 22 },
                                    2: { value: 43 },
                                    3: { value: 24 },
                                    4: { value: 25 },
                                    5: { value: 49 },
                                    6: { value: 92 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Germany',
                                values: {
                                    0: { value: 31 },
                                    1: { value: 32 },
                                    2: { value: 63 },
                                    3: { value: 34 },
                                    4: { value: 35 },
                                    5: { value: 69 },
                                    6: { value: 132 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 52 },
                                    1: { value: 54 },
                                    2: { value: 106 },
                                    3: { value: 58 },
                                    4: { value: 60 },
                                    5: { value: 118 },
                                    6: { value: 224 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'North America',
                        children: [
                            {
                                level: 1,
                                value: 'United States',
                                values: {
                                    0: { value: 41 },
                                    1: { value: 42 },
                                    2: { value: 83 },
                                    3: { value: 44 },
                                    4: { value: 45 },
                                    5: { value: 89 },
                                    6: { value: 172 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 41 },
                                    1: { value: 42 },
                                    2: { value: 83 },
                                    3: { value: 44 },
                                    4: { value: 45 },
                                    5: { value: 89 },
                                    6: { value: 172 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Oceania',
                        children: [
                            {
                                level: 1,
                                value: 'Australia',
                                values: {
                                    0: { value: 51 },
                                    1: { value: 52 },
                                    2: { value: 103 },
                                    3: { value: 54 },
                                    4: { value: 55 },
                                    5: { value: 109 },
                                    6: { value: 212 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 51 },
                                    1: { value: 52 },
                                    2: { value: 103 },
                                    3: { value: 54 },
                                    4: { value: 55 },
                                    5: { value: 109 },
                                    6: { value: 212 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 156 },
                            1: { value: 162 },
                            2: { value: 318 },
                            3: { value: 174 },
                            4: { value: 180 },
                            5: { value: 354 },
                            6: { value: 672 }
                        }
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                value: 'Silver'
                            },
                            {
                                level: 1,
                                value: 'Gold'
                            },
                            {
                                level: 1,
                                isSubtotal: true
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: 'Silver'
                            },
                            {
                                level: 1,
                                value: 'Gold'
                            },
                            {
                                level: 1,
                                isSubtotal: true
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] }
            ]
        },
        valueSources: [measureSource1]
    };
    var matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotalsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1,
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals
    };
    // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                                                            1992 |                                                            1996 |               Total |
    // |---------------|---------------|-----------------------------------------------------------------|-----------------------------------------------------------------|                     |
    // |               |     ColGroup2 |              Silver |                Gold |               Total |              Silver |                Gold |               Total |                     |
    // |---------------|---------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|
    // |     RowGroup1 |     RowGroup2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 |
    // |-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------|----------|----------|
    // |          Asia |   South Korea |        0 |        1 |        2 |        3 |        2 |        4 |        6 |        7 |        8 |        9 |       14 |       16 |       16 |       20 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       12 |       13 |       14 |       15 |       26 |       28 |       18 |       19 |       20 |       21 |       38 |       40 |       64 |       68 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       12 |       14 |       16 |       18 |       28 |       32 |       24 |       26 |       28 |       30 |       52 |       56 |       80 |       88 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       24 |       25 |       26 |       27 |       50 |       52 |       30 |       31 |       32 |       33 |       62 |       64 |      112 |      116 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       36 |       37 |       38 |       39 |       74 |       76 |       42 |       43 |       44 |       45 |       86 |       88 |      160 |      164 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       60 |       62 |       64 |       66 |      124 |      128 |       72 |       74 |       76 |       78 |      148 |      152 |      272 |      280 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       48 |       49 |       50 |       51 |       98 |      100 |       54 |       55 |       56 |       57 |      110 |      112 |      208 |      212 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       48 |       49 |       50 |       51 |       98 |      100 |       54 |       55 |       56 |       57 |      110 |      112 |      208 |      212 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       60 |       61 |       62 |       63 |      122 |      124 |       66 |       67 |       68 |       69 |      134 |      136 |      256 |      260 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       60 |       61 |       62 |       63 |      122 |      124 |       66 |       67 |       68 |       69 |      134 |      136 |      256 |      260 |
    // |-------------------------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |         Total                 |      180 |      186 |      192 |      198 |      372 |      384 |      216 |      222 |      228 |      234 |      444 |      456 |      816 |      840 |
    // ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 'Asia',
                        children: [
                            {
                                level: 1,
                                value: 'South Korea',
                                values: {
                                    0: { value: 0 },
                                    1: { value: 1, valueSourceIndex: 1 },
                                    2: { value: 2 },
                                    3: { value: 3, valueSourceIndex: 1 },
                                    4: { value: 2 },
                                    5: { value: 4, valueSourceIndex: 1 },
                                    6: { value: 6 },
                                    7: { value: 7, valueSourceIndex: 1 },
                                    8: { value: 8 },
                                    9: { value: 9, valueSourceIndex: 1 },
                                    10: { value: 14 },
                                    11: { value: 16, valueSourceIndex: 1 },
                                    12: { value: 16 },
                                    13: { value: 20, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Unified Team',
                                values: {
                                    0: { value: 12 },
                                    1: { value: 13, valueSourceIndex: 1 },
                                    2: { value: 14 },
                                    3: { value: 15, valueSourceIndex: 1 },
                                    4: { value: 26 },
                                    5: { value: 28, valueSourceIndex: 1 },
                                    6: { value: 18 },
                                    7: { value: 19, valueSourceIndex: 1 },
                                    8: { value: 20 },
                                    9: { value: 21, valueSourceIndex: 1 },
                                    10: { value: 38 },
                                    11: { value: 40, valueSourceIndex: 1 },
                                    12: { value: 64 },
                                    13: { value: 68, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 12 },
                                    1: { value: 14, valueSourceIndex: 1 },
                                    2: { value: 16 },
                                    3: { value: 18, valueSourceIndex: 1 },
                                    4: { value: 28 },
                                    5: { value: 32, valueSourceIndex: 1 },
                                    6: { value: 24 },
                                    7: { value: 26, valueSourceIndex: 1 },
                                    8: { value: 28 },
                                    9: { value: 30, valueSourceIndex: 1 },
                                    10: { value: 52 },
                                    11: { value: 56, valueSourceIndex: 1 },
                                    12: { value: 80 },
                                    13: { value: 88, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Europe',
                        children: [
                            {
                                level: 1,
                                value: 'France',
                                values: {
                                    0: { value: 24 },
                                    1: { value: 25, valueSourceIndex: 1 },
                                    2: { value: 26 },
                                    3: { value: 27, valueSourceIndex: 1 },
                                    4: { value: 50 },
                                    5: { value: 52, valueSourceIndex: 1 },
                                    6: { value: 30 },
                                    7: { value: 31, valueSourceIndex: 1 },
                                    8: { value: 32 },
                                    9: { value: 33, valueSourceIndex: 1 },
                                    10: { value: 62 },
                                    11: { value: 64, valueSourceIndex: 1 },
                                    12: { value: 112 },
                                    13: { value: 116, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: 'Germany',
                                values: {
                                    0: { value: 36 },
                                    1: { value: 37, valueSourceIndex: 1 },
                                    2: { value: 38 },
                                    3: { value: 39, valueSourceIndex: 1 },
                                    4: { value: 74 },
                                    5: { value: 74, valueSourceIndex: 1 },
                                    6: { value: 42 },
                                    7: { value: 43, valueSourceIndex: 1 },
                                    8: { value: 44 },
                                    9: { value: 45, valueSourceIndex: 1 },
                                    10: { value: 86 },
                                    11: { value: 88, valueSourceIndex: 1 },
                                    12: { value: 160 },
                                    13: { value: 164, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 60 },
                                    1: { value: 62, valueSourceIndex: 1 },
                                    2: { value: 64 },
                                    3: { value: 66, valueSourceIndex: 1 },
                                    4: { value: 124 },
                                    5: { value: 128, valueSourceIndex: 1 },
                                    6: { value: 72 },
                                    7: { value: 74, valueSourceIndex: 1 },
                                    8: { value: 76 },
                                    9: { value: 78, valueSourceIndex: 1 },
                                    10: { value: 148 },
                                    11: { value: 152, valueSourceIndex: 1 },
                                    12: { value: 272 },
                                    13: { value: 280, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'North America',
                        children: [
                            {
                                level: 1,
                                value: 'United States',
                                values: {
                                    0: { value: 48 },
                                    1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 },
                                    3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 98 },
                                    5: { value: 100, valueSourceIndex: 1 },
                                    6: { value: 54 },
                                    7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 },
                                    9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 110 },
                                    11: { value: 112, valueSourceIndex: 1 },
                                    12: { value: 208 },
                                    13: { value: 212, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 48 },
                                    1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 },
                                    3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 98 },
                                    5: { value: 100, valueSourceIndex: 1 },
                                    6: { value: 54 },
                                    7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 },
                                    9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 110 },
                                    11: { value: 112, valueSourceIndex: 1 },
                                    12: { value: 208 },
                                    13: { value: 212, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 'Oceania',
                        children: [
                            {
                                level: 1,
                                value: 'Australia',
                                values: {
                                    0: { value: 60 },
                                    1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 },
                                    3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 122 },
                                    5: { value: 124, valueSourceIndex: 1 },
                                    6: { value: 66 },
                                    7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 },
                                    9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 134 },
                                    11: { value: 136, valueSourceIndex: 1 },
                                    12: { value: 256 },
                                    13: { value: 260, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 60 },
                                    1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 },
                                    3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 122 },
                                    5: { value: 124, valueSourceIndex: 1 },
                                    6: { value: 66 },
                                    7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 },
                                    9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 134 },
                                    11: { value: 136, valueSourceIndex: 1 },
                                    12: { value: 256 },
                                    13: { value: 260, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 180 },
                            1: { value: 186, valueSourceIndex: 1 },
                            2: { value: 192 },
                            3: { value: 198, valueSourceIndex: 1 },
                            4: { value: 372 },
                            5: { value: 384, valueSourceIndex: 1 },
                            6: { value: 216 },
                            7: { value: 222, valueSourceIndex: 1 },
                            8: { value: 228 },
                            9: { value: 234, valueSourceIndex: 1 },
                            10: { value: 444 },
                            11: { value: 456, valueSourceIndex: 1 },
                            12: { value: 816 },
                            13: { value: 840, valueSourceIndex: 1 }
                        }
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                value: 'Silver',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Gold',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                children: [
                                    {
                                        level: 2,
                                        isSubtotal: true
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1,
                                        isSubtotal: true
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: 'Silver',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: 'Gold',
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                children: [
                                    {
                                        level: 2,
                                        isSubtotal: true
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1,
                                        isSubtotal: true
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        children: [
                            {
                                level: 2,
                                isSubtotal: true
                            },
                            {
                                level: 2,
                                levelSourceIndex: 1,
                                isSubtotal: true
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                {
                    sources: [
                        measureSource1,
                        measureSource2
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2
        ]
    };
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotalsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1,
                measureSource2,
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals
    };
    // ----------------------------
    // | RowGroup4 | true | false |
    // |-----------+--------------|
    // |      true |    1 |     2 |
    // |-----------|------|-------|
    // |     false |    3 |     4 |
    // |-----------|------|-------|
    // |           |    5 |     6 |
    // ----------------------------
    var matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true,
                        values: {
                            0: { value: 1 },
                            1: { value: 2 }
                        }
                    },
                    {
                        level: 0,
                        value: false,
                        values: {
                            0: { value: 3 },
                            1: { value: 4 }
                        }
                    },
                    {
                        level: 0,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 }
                        }
                    }
                ]
            },
            levels: [{ sources: [rowGroupSource4] }]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true
                    },
                    {
                        level: 0,
                        value: false
                    }
                ]
            },
            levels: [{ sources: [columnGroupSource4] }]
        },
        valueSources: [measureSource1]
    };
    // ------------------------------------
    // | RowGroup4 | true | false | Total |
    // |-----------+----------------------|
    // |      true |    1 |     2 |   3   |
    // |-----------|------|-------|-------|
    // |     false |    3 |     4 |   7   |
    // |-----------|------|-------|-------|
    // |           |    5 |     6 |   11  |
    // |-----------|------|-------|-------|
    // |    Total  |    9 |    12 |   21  |
    // |----------------------------------|
    var matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true,
                        values: {
                            0: { value: 1 },
                            1: { value: 2 },
                            2: { value: 3 }
                        }
                    },
                    {
                        level: 0,
                        value: false,
                        values: {
                            0: { value: 3 },
                            1: { value: 4 },
                            2: { value: 7 }
                        }
                    },
                    {
                        level: 0,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 },
                            2: { value: 11 }
                        }
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 },
                            2: { value: 21 }
                        }
                    }
                ]
            },
            levels: [{ sources: [rowGroupSource4] }]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true
                    },
                    {
                        level: 0,
                        value: false
                    },
                    {
                        level: 0,
                        isSubtotal: true
                    }
                ]
            },
            levels: [{ sources: [columnGroupSource4] }]
        },
        valueSources: [measureSource1]
    };
    describe('Matrix', function () {
        it('Matrix registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('matrix').capabilities).toBe(Matrix.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(Matrix.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(Matrix.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should include row windowing', function () {
            expect(Matrix.capabilities.dataViewMappings[0].matrix.rows.dataReductionAlgorithm).toBeDefined();
        });
        it('Capabilities should allow measure only matrices', function () {
            var allowedProjections1 = {
                'Values': [{ queryRef: '0' }]
            };
            var allowedProjections2 = {
                'Values': [
                    { queryRef: '0' },
                    { queryRef: '1' },
                    { queryRef: '2' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should allow matrices with row groups only', function () {
            var allowedProjections1 = {
                'Rows': [{ queryRef: '0' }]
            };
            var allowedProjections2 = {
                'Rows': [
                    { queryRef: '2' },
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should allow matrices with row groups and arbitrary number of measures', function () {
            var allowedProjections1 = {
                'Rows': [{ queryRef: '0' }],
                'Values': [
                    { queryRef: '1' },
                    { queryRef: '2' },
                    { queryRef: '3' }
                ]
            };
            var allowedProjections2 = {
                'Rows': [
                    { queryRef: '3' },
                    { queryRef: '2' },
                    { queryRef: '1' }
                ],
                'Values': [
                    { queryRef: '0' }
                ]
            };
            var allowedProjections3 = {
                'Rows': [
                    { queryRef: '1' },
                    { queryRef: '0' }
                ],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '3' }
                ]
            };
            var allowedProjections4 = {
                'Rows': [
                    { queryRef: '0' }
                ],
                'Values': [
                    { queryRef: '1' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should allow matrices with column groups only', function () {
            var allowedProjections1 = {
                'Columns': [{ queryRef: '0' }]
            };
            var allowedProjections2 = {
                'Columns': [
                    { queryRef: '2' },
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should allow matrices with column groups and measures', function () {
            var allowedProjections1 = {
                'Columns': [{ queryRef: '1' }],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '3' },
                    { queryRef: '0' }
                ]
            };
            var allowedProjections2 = {
                'Columns': [
                    { queryRef: '0' },
                    { queryRef: '2' },
                    { queryRef: '1' }
                ],
                'Values': [
                    { queryRef: '3' }
                ]
            };
            var allowedProjections3 = {
                'Columns': [
                    { queryRef: '3' },
                    { queryRef: '2' }
                ],
                'Values': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var allowedProjections4 = {
                'Columns': [
                    { queryRef: '1' }
                ],
                'Values': [
                    { queryRef: '0' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should allow matrices with row groups and arbitrary number of column groups and measures', function () {
            var allowedProjections1 = {
                'Rows': [
                    { queryRef: '0' }
                ],
                'Columns': [
                    { queryRef: '1' }
                ],
                'Values': [
                    { queryRef: '2' }
                ]
            };
            var allowedProjections2 = {
                'Rows': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ],
                'Columns': [
                    { queryRef: '2' },
                    { queryRef: '3' }
                ],
                'Values': [
                    { queryRef: '4' }
                ]
            };
            var allowedProjections3 = {
                'Rows': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ],
                'Columns': [
                    { queryRef: '2' }
                ],
                'Values': [
                    { queryRef: '3' },
                    { queryRef: '4' }
                ]
            };
            var allowedProjections4 = {
                'Rows': [
                    { queryRef: '0' }
                ],
                'Columns': [
                    { queryRef: '1' },
                    { queryRef: '2' }
                ],
                'Values': [
                    { queryRef: '3' },
                    { queryRef: '4' }
                ]
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(Matrix.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Matrix.capabilities.objects)).toEqual(Matrix.formatStringProp);
        });
        it('CustomizeQuery picks up enabled row subtotals', function () {
            var objects = {
                general: {
                    rowSubtotals: true,
                    columnSubtotals: false
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(2 /* After */);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(0 /* None */);
        });
        it('CustomizeQuery picks up enabled column subtotals', function () {
            var objects = {
                general: {
                    rowSubtotals: false,
                    columnSubtotals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(0 /* None */);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(2 /* After */);
        });
        it('CustomizeQuery picks up enabled row and column subtotals', function () {
            var objects = {
                general: {
                    rowSubtotals: true,
                    columnSubtotals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(2 /* After */);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(2 /* After */);
        });
        it('CustomizeQuery handles missing settings', function () {
            var dataViewMapping = createCompiledDataViewMapping();
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Totals default to Enabled (After)
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(2 /* After */);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(2 /* After */);
        });
        it('CustomizeQuery handles missing subtotal settings', function () {
            var objects = {
                general: {
                    rowSubtotals: undefined,
                    columnSubtotals: undefined
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Totals default to Enabled (After)
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(2 /* After */);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(2 /* After */);
        });
        function createCompiledDataViewMapping(objects) {
            return {
                metadata: {
                    objects: objects
                },
                matrix: {
                    rows: {
                        for: {
                            in: { role: 'Rows', items: [] }
                        }
                    },
                    columns: {
                        for: {
                            in: { role: 'Columns', items: [] }
                        }
                    }
                }
            };
        }
    });
    describe('Tablix control tests', function () {
        it('touch disabled', function () {
            var layoutKind = 0 /* Canvas */;
            var matrix = matrixOneMeasure;
            var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
            var binder = new powerbi.visuals.MatrixBinder(navigator, { layoutKind: layoutKind });
            var layoutManager = powerbi.visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(binder);
            var parent = document.createElement('div');
            var tablixControl = new powerbi.visuals.controls.TablixControl(navigator, layoutManager, binder, parent, { interactive: true, enableTouchSupport: false });
            expect(tablixControl['_touchManager']).toBeUndefined();
        });
    });
    describe('Matrix hierarchy navigator tests', function () {
        describe('getDepth', function () {
            it('returns the correct depth for an empty hierarchy', function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(1);
            });
            it('returns the correct depth for a measure only hierarchy', function () {
                var matrix = matrixOneMeasure;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(1);
            });
            it('returns the correct depth for group only hierarchy', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(rowHierarchy)).toBe(3);
            });
            it('returns the correct depth for group and measure hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(3);
            });
        });
        describe('getLeafCount', function () {
            it('returns the right leaf count for a placeholder hierarchy', function () {
                var matrix = matrixOneMeasure;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(rowHierarchy)).toBe(1);
            });
            it('returns the right leaf count for an empty hierarchy', function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(columnHierarchy)).toBe(0);
            });
            it('returns the right leaf count for a one level deep hierarchy', function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(rowHierarchy)).toBe(1);
            });
            it('returns the right leaf count for a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(columnHierarchy)).toBe(12);
            });
        });
        describe('getLeafAt', function () {
            it('returns the correct leaf from a placeholder hierarchy', function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(rowHierarchy, 0)).toBe(rowHierarchyItem);
            });
            it('returns the correct leaf from a one level deep hierarchy', function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(columnHierarchy, 0)).toBe(columnHierarchyItem);
            });
            it('returns the correct leaf from a three level deep hierarchy', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[1].children[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(rowHierarchy, 7)).toBe(rowHierarchyItem);
            });
        });
        describe('getParent', function () {
            it('returns null for outermost node in a one level deep hierarchy', function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var node = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBeNull();
            });
            it('returns null for outermost node in a three level deep hierarchy', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var node = matrix.rows.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBeNull();
            });
            it('returns the correct parent for an innermost node in a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var parentNode = matrix.columns.root.children[1].children[1];
                var node = parentNode.children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBe(parentNode);
            });
            it('returns the correct parent for a non-innermost node in a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var parentNode = matrix.columns.root.children[0];
                var node = parentNode.children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBe(parentNode);
            });
        });
        describe('getIndex', function () {
            it('returns the correct index for outermost nodes', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem0 = rowHierarchy[0];
                var rowHierarchyItem1 = rowHierarchy[1];
                var rowHierarchyItem2 = rowHierarchy[2];
                var rowHierarchyItem3 = rowHierarchy[3];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchyItem0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItem1)).toBe(1);
                expect(navigator.getIndex(rowHierarchyItem2)).toBe(2);
                expect(navigator.getIndex(rowHierarchyItem3)).toBe(3);
            });
            it('returns the correct index for innermost nodes', function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem0 = rowHierarchy[0].children[0].children[0];
                var rowHierarchyItem1 = rowHierarchy[0].children[0].children[1];
                var rowHierarchyItemAgain0 = rowHierarchy[1].children[1].children[0];
                var rowHierarchyItemAgain1 = rowHierarchy[1].children[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchyItem0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItem1)).toBe(1);
                expect(navigator.getIndex(rowHierarchyItemAgain0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItemAgain1)).toBe(1);
            });
            it('returns the correct index for non-innermost nodes', function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem0 = rowHierarchy[0].children[0];
                var rowHierarchyItem1 = rowHierarchy[0].children[1];
                var rowHierarchyItemAgain0 = rowHierarchy[1].children[0];
                var rowHierarchyItemAgain1 = rowHierarchy[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchyItem0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItem1)).toBe(1);
                expect(navigator.getIndex(rowHierarchyItemAgain0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItemAgain1)).toBe(1);
            });
        });
        describe('isLeaf', function () {
            it('returns true for nodes in a one level deep placeholder hierarchy', function () {
                var matrix = matrixThreeMeasures;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(rowHierarchyItem)).toBeTruthy();
            });
            it('returns true for nodes in a one level deep hierarchy', function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(rowHierarchyItem)).toBeTruthy();
            });
            it('returns true for innermost nodes in a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[1].children[2].children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchyItem)).toBeTruthy();
            });
            it('returns false for outermost nodes in a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchyItem)).toBeFalsy();
            });
            it('returns false for non-innermost nodes in a three level deep hierarchy', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[0].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchyItem)).toBeFalsy();
            });
        });
        describe('isRowHierarchyLeaf', function () {
            // TODO
        });
        describe('isColumnHierarchyLeaf', function () {
            // TODO
        });
        describe('isLastItem', function () {
            it('returns true if the last item is the only item in the collection', function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneInstance;
                var items = matrix.rows.root.children;
                var item = items[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(item, items)).toBeTruthy();
            });
            it('returns true if the last item is the last item in its parents collection, but not on the level', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var items = matrix.rows.root.children[0].children;
                var item = items[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(item, items)).toBeTruthy();
            });
            it('returns false if the item is not the last item in its parents collection', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var items = matrix.rows.root.children[1].children[1].children;
                var item = items[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(item, items)).toBeFalsy();
            });
        });
        describe('getChildren', function () {
            it('returns undefined for leaf node', function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var node = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getChildren(node)).toBeUndefined();
            });
            it('returns the correct collection of children', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var node = matrix.rows.root.children[0];
                var children = node.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getChildren(node)).toBe(children);
            });
        });
        describe('getCount', function () {
            it('returns zero if there are no children', function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCount(columnHierarchy)).toBe(0);
            });
            it('returns the length of the children array', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCount(columnHierarchy)).toBe(3);
            });
        });
        describe('getAt', function () {
            it('returns undefined if index is out of bounds', function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(columnHierarchy, 0)).toBeUndefined();
            });
            it('returns the right node from the hierarchy', function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var node = rowHierarchy[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(rowHierarchy, 1)).toBe(node);
            });
            it('returns the right node from the children collection', function () {
                var matrix = matrixThreeRowGroups;
                var children = matrix.rows.root.children[0].children;
                var node = children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(children, 1)).toBe(node);
            });
        });
        describe('getLevel', function () {
            it('returns undefined for root node', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var rootNode = matrix.columns.root;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(rootNode)).toBeUndefined();
            });
            it('returns zero for outermost nodes', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var node = matrix.rows.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(node)).toBe(0);
            });
            it('returns one for nodes on the second level', function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var nodes = matrix.rows.root.children[1].children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(nodes[0])).toBe(1);
                expect(navigator.getLevel(nodes[1])).toBe(1);
            });
        });
        describe('getIntersection', function () {
            it('returns values in the intersection', function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var columnHierarchy = matrix.columns.root.children;
                var level2RowItems = [
                    rowHierarchy[0].children[0],
                    rowHierarchy[0].children[1],
                    rowHierarchy[1].children[0],
                    rowHierarchy[1].children[1]
                ];
                var level3RowItems = [
                    level2RowItems[0].children[0],
                    level2RowItems[0].children[1],
                    level2RowItems[1].children[0],
                    level2RowItems[1].children[1],
                    level2RowItems[2].children[0],
                    level2RowItems[2].children[1],
                    level2RowItems[3].children[0],
                    level2RowItems[3].children[1]
                ];
                var level1ColumnItems = [
                    columnHierarchy[0],
                    columnHierarchy[1],
                    columnHierarchy[2]
                ];
                var expectedValues = [
                    ['1,000.00', '1,001.00', '1,002.00'],
                    ['1,010.00', '1,011.00', '1,012.00'],
                    ['1,100.00', '1,101.00', '1,102.00'],
                    ['1,110.00', '1,111.00', '1,112.00'],
                    ['2,000.00', '2,001.00', '2,002.00'],
                    ['2,010.00', '2,011.00', '2,012.00'],
                    ['2,100.00', '2,101.00', '2,102.00'],
                    ['2,110.00', '2,111.00', '2,112.00']
                ];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                validateIntersections(navigator, level3RowItems, level1ColumnItems, expectedValues);
            });
            it('returns empty string if there are no measures', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowLeaves = rowHierarchy[0].children[0].children.concat(rowHierarchy[0].children[1].children);
                var columnHierarchy = matrix.columns.root.children;
                var columnLeaves = columnHierarchy[0].children[0].children.concat(columnHierarchy[0].children[1]);
                var expectedValues = [
                    ['', '', ''],
                    ['', '', ''],
                    ['', '', '']
                ];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                validateIntersections(navigator, rowLeaves, columnLeaves, expectedValues);
            });
            function validateIntersections(navigator, rowLeaves, columnLeaves, expectedValues) {
                var result = [];
                for (var i = 0, ilen = rowLeaves.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columnLeaves.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rowLeaves[i], columnLeaves[j]).content;
                }
                expect(result).toEqual(expectedValues);
            }
        });
        describe('getCorer', function () {
            it('returns empty value for the upper left cell of a 3x3 corner', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(0, 0).metadata).toBeNull();
                expect(navigator.getCorner(0, 0).isColumnHeaderLeaf).toBeFalsy();
            });
            it('returns row header for the lower left cell of a 3x3 corner', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(0, 2).metadata.displayName).toBe('RowGroup1');
                expect(navigator.getCorner(0, 2).isColumnHeaderLeaf).toBeTruthy();
            });
            it('returns column header for the upper right cell of a 3x3 corner', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(2, 0).metadata.displayName).toBe('ColGroup1');
                expect(navigator.getCorner(2, 0).isColumnHeaderLeaf).toBeFalsy();
            });
            it('returns row header for the lower right cell of a 3x3 corner', function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(2, 2).metadata.displayName).toBe('RowGroup3');
                expect(navigator.getCorner(2, 2).isColumnHeaderLeaf).toBeTruthy();
            });
        });
        describe('headerItemEquals', function () {
            it('returns true if the two items are the same', function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
                var rowNode = matrix.rows.root.children[0];
                var columnNode = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.headerItemEquals(rowNode, rowNode)).toBeTruthy();
                expect(navigator.headerItemEquals(columnNode, columnNode)).toBeTruthy();
            });
            it('returns false if the two items are not same even if they have the same content', function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
                var rowNode = matrix.rows.root.children[0];
                var columnNode = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.headerItemEquals(rowNode, columnNode)).toBeFalsy();
                expect(navigator.headerItemEquals(columnNode, rowNode)).toBeFalsy();
            });
        });
    });
    describe('Matrix logic', function () {
        var v;
        beforeEach(function () {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('matrix').create();
            var element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () {
                return true;
            };
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: 500,
                    width: 500
                },
                animation: { transitionImmediate: true }
            });
        });
        it('loadMoreData calls control refresh', function () {
            var nav = { updateRows: function () {
            } };
            var control = { refresh: function () {
            } };
            var navSpy = spyOn(nav, "updateRows");
            var controlSpy = spyOn(control, "refresh");
            v['hierarchyNavigator'] = nav;
            v['tablixControl'] = control;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView],
                operationKind: 1 /* Append */
            });
            expect(navSpy).toHaveBeenCalled();
            expect(controlSpy).toHaveBeenCalled();
        });
        it('needsMoreData waitingForData', function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
                    matrix: matrix
                }]
            });
            v['waitingForData'] = true;
            var matrixVisual = v;
            var lastLeaf = matrix.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(lastLeaf);
            expect(result).toBe(false);
        });
        it('needsMoreData notLeaf', function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
                    matrix: matrix
                }]
            });
            var matrixVisual = v;
            var item = matrix.rows.root.children[1].children[1];
            var result = matrixVisual.needsMoreData(item);
            expect(result).toBe(false);
        });
        it('needsMoreData segmentComplete', function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3] },
                    matrix: matrix
                }]
            });
            var matrixVisual = v;
            var lastLeaf = matrix.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(lastLeaf);
            expect(result).toBe(false);
        });
        it('needsMoreData belowThreshold', function () {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
            v.onDataChanged({
                dataViews: [matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView]
            });
            var matrixVisual = v;
            var leaf = matrix.rows.root.children[0].children[0];
            var result = matrixVisual.needsMoreData(leaf);
            expect(result).toBe(false);
        });
        it('needsMoreData aboveThreshold', function () {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrixVisual = v;
            var leaf = matrixThreeMeasuresThreeRowGroups.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(leaf);
            expect(result).toBe(true);
        });
        it('bindRowHeader callback', function () {
            var callBackCalled = false;
            var binderOptions = {
                onBindRowHeader: function (item) {
                    callBackCalled = true;
                },
                layoutKind: 0 /* Canvas */,
            };
            var binder = new powerbi.visuals.MatrixBinder(null, binderOptions);
            binder.bindRowHeader({ displayName: null }, {
                type: null,
                item: null,
                colSpan: 0,
                rowSpan: 0,
                textAlign: '',
                extension: { contentHost: { textContent: null }, setContainerStyle: function (className) {
                } }
            });
            expect(callBackCalled).toBe(true);
        });
        it('unbindColumnHeader multimeasure not sortable', function () {
            var binderOptions = {
                onBindRowHeader: function (item) {
                },
                onColumnHeaderClick: function () {
                },
                layoutKind: 0 /* Canvas */,
            };
            var hierarchyNavigator = powerbi.visuals.createMatrixHierarchyNavigator(matrixTwoRowGroupsTwoColumnGroupsTwoMeasures, powerbi.visuals.valueFormatter.formatRaw);
            var binder = new powerbi.visuals.MatrixBinder(hierarchyNavigator, binderOptions);
            var unregisterCalled = false;
            binder.unbindColumnHeader({ displayName: null, isSubtotal: true }, {
                type: null,
                item: null,
                colSpan: 0,
                rowSpan: 0,
                textAlign: '',
                extension: {
                    contentHost: { textContent: null },
                    setContainerStyle: function (className) {
                    },
                    clearContainerStyle: function (className) {
                    },
                    unregisterClickHandler: function () {
                        unregisterCalled = true;
                    }
                }
            });
            expect(unregisterCalled).toBe(false);
        });
        it('enumerateObjectInstances general both totals off', function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: false,
                                columnSubtotals: false
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    rowSubtotals: false,
                    columnSubtotals: false
                }
            }]);
        });
        it('enumerateObjectInstances general both totals on', function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    rowSubtotals: true,
                    columnSubtotals: true
                }
            }]);
        });
        it('enumerateObjectInstances general no objects', function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ]
                    },
                    matrix: matrix
                }]
            });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    rowSubtotals: true,
                    columnSubtotals: true
                }
            }]);
        });
        it('enumerateObjectInstances general no properties', function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ],
                        objects: {
                            general: {}
                        }
                    },
                    matrix: matrix
                }]
            });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    rowSubtotals: true,
                    columnSubtotals: true
                }
            }]);
            it('RefreshControl invisible parent', function () {
                var control = { refresh: function () {
                } };
                var controlSpy = spyOn(control, "refresh");
                v['shouldAllowHeaderResize'] = function () {
                    return true;
                };
                v['hierarchyNavigator'] = { update: function () {
                } };
                v['tablixControl'] = control;
                v['element']['visible'] = function () {
                    return false;
                };
                v.onResizing({ width: 100, height: 100 }, 0);
                expect(controlSpy).not.toHaveBeenCalled();
            });
            it('RefreshControl invisible parent but dashboard layout', function () {
                var control = { refresh: function () {
                } };
                var controlSpy = spyOn(control, "refresh");
                v['shouldAllowHeaderResize'] = function () {
                    return true;
                };
                v['hierarchyNavigator'] = { update: function () {
                } };
                v['tablixControl'] = control;
                v['element']['visible'] = function () {
                    return false;
                };
                v['isInteractive'] = false;
                v.onResizing({ width: 100, height: 100 }, 0);
                expect(controlSpy).toHaveBeenCalled();
            });
        });
    });
    describe('Matrix DOM validation', function () {
        var v, element, EmptyHeaderCell = '\xa0', NoMarginClass = 'bi-tablix-cellNoMarginStyle', HeaderClass = 'bi-tablix-header', ColumnHeaderLeafClass = 'bi-tablix-column-header-leaf', RowHeaderLeafClass = 'bi-tablix-row-header-leaf', RowHeaderStaticLeafClass = 'bi-tablix-row-header-static-leaf', BodyCellClass = 'bi-matrix-body-cell', TotalClass = 'total', TableTotalLabel = 'TableTotalLabel';
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('1500', '1500');
            element['visible'] = function () {
                return true;
            };
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('matrix').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true,
                },
                interactivity: {
                    selection: true
                }
            });
        });
        function validateMatrix(expectedValues) {
            powerbitests.tablixHelper.validateMatrix(expectedValues, '.bi-tablix tr');
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-tablix tr', NoMarginClass);
        }
        it('1x2 matrix (value and static column header)', function (done) {
            var matrix = matrixOneMeasure;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            setTimeout(function () {
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, ''],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass, ''],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 matrix (value and column header value) update', function (done) {
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            // Call onDataChanged again to trigger an update on the hierarchy navigator
            var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneMeasureOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ['', headerValue, ''],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass, ''],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x2 matrix (values and static column headers)', function (done) {
            var matrix = matrixThreeMeasures;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [measureSource1, measureSource2, measureSource3] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ['', measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ''],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ''],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x3 matrix (values, static and value column headers)', function (done) {
            var matrix = matrixThreeMeasuresOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ['', headerValue, ''],
                    ['', measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass, ''],
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('6x9 matrix (values, static column headers and row value headers)', function (done) {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrix = matrixThreeMeasuresThreeRowGroups;
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var cellValue1 = formatter(header_1_1_1.values[0].value, measureSource1);
                var cellValue2 = formatter(header_1_1_1.values[1].value, measureSource2);
                var cellValue3 = formatter(header_1_1_1.values[2].value, measureSource3);
                var cellValue4 = formatter(header_1_1_2.values[0].value, measureSource1);
                var cellValue5 = formatter(header_1_1_2.values[1].value, measureSource2);
                var cellValue6 = formatter(header_1_1_2.values[2].value, measureSource3);
                var cellValue7 = formatter(header_1_2_1.values[0].value, measureSource1);
                var cellValue8 = formatter(header_1_2_1.values[1].value, measureSource2);
                var cellValue9 = formatter(header_1_2_1.values[2].value, measureSource3);
                var cellValue10 = formatter(header_1_2_2.values[0].value, measureSource1);
                var cellValue11 = formatter(header_1_2_2.values[1].value, measureSource2);
                var cellValue12 = formatter(header_1_2_2.values[2].value, measureSource3);
                var cellValue13 = formatter(header_2_1_1.values[0].value, measureSource1);
                var cellValue14 = formatter(header_2_1_1.values[1].value, measureSource2);
                var cellValue15 = formatter(header_2_1_1.values[2].value, measureSource3);
                var cellValue16 = formatter(header_2_1_2.values[0].value, measureSource1);
                var cellValue17 = formatter(header_2_1_2.values[1].value, measureSource2);
                var cellValue18 = formatter(header_2_1_2.values[2].value, measureSource3);
                var cellValue19 = formatter(header_2_2_1.values[0].value, measureSource1);
                var cellValue20 = formatter(header_2_2_1.values[1].value, measureSource2);
                var cellValue21 = formatter(header_2_2_1.values[2].value, measureSource3);
                var cellValue22 = formatter(header_2_2_2.values[0].value, measureSource1);
                var cellValue23 = formatter(header_2_2_2.values[1].value, measureSource2);
                var cellValue24 = formatter(header_2_2_2.values[2].value, measureSource3);
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ''],
                    [header_1.value, header_1_1.value, header_1_1_1.value, cellValue1, cellValue2, cellValue3],
                    [header_1_1_2.value, cellValue4, cellValue5, cellValue6],
                    [header_1_2.value, header_1_2_1.value, cellValue7, cellValue8, cellValue9],
                    [header_1_2_2.value, cellValue10, cellValue11, cellValue12],
                    [header_2.value, header_2_1.value, header_2_1_1.value, cellValue13, cellValue14, cellValue15],
                    [header_2_1_2.value, cellValue16, cellValue17, cellValue18],
                    [header_2_2.value, header_2_2_1.value, cellValue19, cellValue20, cellValue21],
                    [header_2_2_2.value, cellValue22, cellValue23, cellValue24]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ''],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x2 matrix (value, static column header and row value header)', function (done) {
            var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [rowGroupSource1, measureSource1] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header = matrix.rows.root.children[0];
                var cellValue = formatter(header.values[0].value, measureSource1);
                var expectedCells = [
                    [rowGroupSource1.displayName, measureSource1.displayName, ''],
                    [header.value, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ''],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x2 matrix (value, column value header and row value header, empty cell)', function (done) {
            var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var columnHeader = matrix.columns.root.children[0];
                var rowHeader = matrix.rows.root.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, columnHeader.value.toString(), ''],
                    [rowHeader.value.toString(), '']
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x2 matrix (static column headers and row value headers)', function (done) {
            var matrix = matrixThreeRowGroupsOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixThreeRowGroupsOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeader_1_1_1 = rowHeader_1_1.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, ''],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeader_1_1_1.value.toString()]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ''],
                    [HeaderClass, HeaderClass, RowHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x6 matrix (static column headers and row value headers including empty ones)', function (done) {
            var matrix = matrixTwoRowGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, ''],
                    [header_1.value, EmptyHeaderCell],
                    [header_1_2.value],
                    [header_2.value, header_2_1.value],
                    [EmptyHeaderCell],
                    [EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ''],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('5x2 matrix (column value headers including empty ones)', function (done) {
            var matrix = matrixTwoColumnGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            columnGroupSource1,
                            columnGroupSource2
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    ['', header_1.value, header_2.value, EmptyHeaderCell, ''],
                    ['', EmptyHeaderCell, header_1_2.value, header_2_1.value, EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass, HeaderClass, HeaderClass, ''],
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x9 matrix (static column headers and row value headers)', function (done) {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            rowGroupSource3
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, ''],
                    [header_1.value, header_1_1.value, header_1_1_1.value.toString()],
                    [header_1_1_2.value.toString()],
                    [header_1_2.value, header_1_2_1.value.toString()],
                    [header_1_2_2.value.toString()],
                    [header_2.value, header_2_1.value, header_2_1_1.value.toString()],
                    [header_2_1_2.value.toString()],
                    [header_2_2.value, header_2_2_1.value.toString()],
                    [header_2_2_2.value.toString()]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('1x1 matrix loadMoreData', function () {
            var matrix = {
                rows: {
                    root: {
                        children: [{
                            level: 0,
                            value: '1'
                        }]
                    },
                    levels: [{ sources: [rowGroupSource1] }]
                },
                columns: {
                    root: {
                        children: []
                    },
                    levels: []
                },
                valueSources: []
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1
                        ]
                    },
                    matrix: matrix
                }]
            });
            var segment2 = {
                rows: {
                    root: {
                        children: [{
                            level: 0,
                            value: '2'
                        }]
                    },
                    levels: [{ sources: [rowGroupSource1] }]
                },
                columns: {
                    root: {
                        children: []
                    },
                    levels: []
                },
                valueSources: []
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTreeNodes(matrix.rows.root, segment2.rows.root, false);
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1
                        ]
                    },
                    matrix: matrix
                }],
                operationKind: 1 /* Append */
            });
            var header1 = matrix.rows.root.children[0];
            var header2 = matrix.rows.root.children[1];
            var expectedCells = [
                [rowGroupSource1.displayName, ''],
                [header1.value],
                [header2.value]
            ];
            validateMatrix(expectedCells);
        });
        it('8x3 matrix (column value headers)', function (done) {
            var matrix = matrixThreeColumnGroups;
            v.onDataChanged({
                dataViews: [matrixThreeColumnGroupsDataView]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0].value.toString();
                var header_1_1_2 = header_1_1.children[1].value.toString();
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0].value.toString();
                var header_1_2_2 = header_1_2.children[1].value.toString();
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0].value.toString();
                var header_2_1_2 = header_2_1.children[1].value.toString();
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0].value.toString();
                var header_2_2_2 = header_2_2.children[1].value.toString();
                var expectedCells = [
                    ['', header_1.value, header_2.value, ''],
                    ['', header_1_1.value, header_1_2.value, header_2_1.value, header_2_2.value],
                    ['', header_1_1_1, header_1_1_2, header_1_2_1, header_1_2_2, header_2_1_1, header_2_1_2, header_2_2_1, header_2_2_2]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('6x5 matrix (column value headers and row value headers, multiple group instances, empty cells)', function (done) {
            var matrix = matrixThreeRowGroupsThreeColumnGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            rowGroupSource3formatted,
                            columnGroupSource1,
                            columnGroupSource2,
                            columnGroupSource3formatted
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeaderValue_1_1_1 = formatter(rowHeader_1_1.children[0].value, rowGroupSource3formatted);
                var rowHeaderValue_1_1_2 = formatter(rowHeader_1_1.children[1].value, rowGroupSource3formatted);
                var rowHeader_1_2 = rowHeader_1.children[1];
                var rowHeaderValue_1_2_1 = formatter(rowHeader_1_2.children[0].value, rowGroupSource3formatted);
                var colHeader_1 = matrix.columns.root.children[0];
                var colHeader_1_1 = colHeader_1.children[0];
                var colHeaderValue_1_1_1 = formatter(colHeader_1_1.children[0].value, columnGroupSource3formatted);
                var colHeaderValue_1_1_2 = formatter(colHeader_1_1.children[1].value, columnGroupSource3formatted);
                var colHeader_1_2 = colHeader_1.children[1];
                var colHeaderValue_1_2_1 = formatter(colHeader_1_2.children[0].value, columnGroupSource3formatted);
                var expectedCells = [
                    ['', '', columnGroupSource1.displayName, colHeader_1.value, ''],
                    ['', '', columnGroupSource2.displayName, colHeader_1_1.value, colHeader_1_2.value],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, colHeaderValue_1_1_1, colHeaderValue_1_1_2, colHeaderValue_1_2_1],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeaderValue_1_1_1, '', '', ''],
                    [rowHeaderValue_1_1_2, '', '', ''],
                    [rowHeader_1_2.value, rowHeaderValue_1_2_1, '', '', '']
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x4 matrix (boolean and null group instances)', function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), ''],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with row and column subtotals', function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ''],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1), formatter(rowHeader1.values[2].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1), formatter(rowHeader2.values[2].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1), formatter(rowHeader3.values[2].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4.values[0].value, measureSource1), formatter(rowHeader4.values[1].value, measureSource1), formatter(rowHeader4.values[2].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ''],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with multiple row and column group hierarchy levels, one measure with subtotals', function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            columnGroupSource1,
                            columnGroupSource2,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ['', columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ''],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1)]
                ];
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass, HeaderClass, ColumnHeaderLeafClass + ' ' + TotalClass, ''],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with multiple row and column group hierarchy levels, two measures with subtotals', function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            columnGroupSource1,
                            columnGroupSource2,
                            measureSource1,
                            measureSource2
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ['', columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ''],
                    ['', columnGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1), formatter(rowHeader1_1.values[7].value, measureSource1), formatter(rowHeader1_1.values[8].value, measureSource1), formatter(rowHeader1_1.values[9].value, measureSource1), formatter(rowHeader1_1.values[10].value, measureSource1), formatter(rowHeader1_1.values[11].value, measureSource1), formatter(rowHeader1_1.values[12].value, measureSource1), formatter(rowHeader1_1.values[13].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1), formatter(rowHeader1_2.values[7].value, measureSource1), formatter(rowHeader1_2.values[8].value, measureSource1), formatter(rowHeader1_2.values[9].value, measureSource1), formatter(rowHeader1_2.values[10].value, measureSource1), formatter(rowHeader1_2.values[11].value, measureSource1), formatter(rowHeader1_2.values[12].value, measureSource1), formatter(rowHeader1_2.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1), formatter(rowHeader1_t.values[7].value, measureSource1), formatter(rowHeader1_t.values[8].value, measureSource1), formatter(rowHeader1_t.values[9].value, measureSource1), formatter(rowHeader1_t.values[10].value, measureSource1), formatter(rowHeader1_t.values[11].value, measureSource1), formatter(rowHeader1_t.values[12].value, measureSource1), formatter(rowHeader1_t.values[13].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1), formatter(rowHeader2_1.values[7].value, measureSource1), formatter(rowHeader2_1.values[8].value, measureSource1), formatter(rowHeader2_1.values[9].value, measureSource1), formatter(rowHeader2_1.values[10].value, measureSource1), formatter(rowHeader2_1.values[11].value, measureSource1), formatter(rowHeader2_1.values[12].value, measureSource1), formatter(rowHeader2_1.values[13].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1), formatter(rowHeader2_2.values[7].value, measureSource1), formatter(rowHeader2_2.values[8].value, measureSource1), formatter(rowHeader2_2.values[9].value, measureSource1), formatter(rowHeader2_2.values[10].value, measureSource1), formatter(rowHeader2_2.values[11].value, measureSource1), formatter(rowHeader2_2.values[12].value, measureSource1), formatter(rowHeader2_2.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1), formatter(rowHeader2_t.values[7].value, measureSource1), formatter(rowHeader2_t.values[8].value, measureSource1), formatter(rowHeader2_t.values[9].value, measureSource1), formatter(rowHeader2_t.values[10].value, measureSource1), formatter(rowHeader2_t.values[11].value, measureSource1), formatter(rowHeader2_t.values[12].value, measureSource1), formatter(rowHeader2_t.values[13].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1), formatter(rowHeader3_1.values[7].value, measureSource1), formatter(rowHeader3_1.values[8].value, measureSource1), formatter(rowHeader3_1.values[9].value, measureSource1), formatter(rowHeader3_1.values[10].value, measureSource1), formatter(rowHeader3_1.values[11].value, measureSource1), formatter(rowHeader3_1.values[12].value, measureSource1), formatter(rowHeader3_1.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1), formatter(rowHeader3_t.values[7].value, measureSource1), formatter(rowHeader3_t.values[8].value, measureSource1), formatter(rowHeader3_t.values[9].value, measureSource1), formatter(rowHeader3_t.values[10].value, measureSource1), formatter(rowHeader3_t.values[11].value, measureSource1), formatter(rowHeader3_t.values[12].value, measureSource1), formatter(rowHeader3_t.values[13].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1), formatter(rowHeader4_1.values[7].value, measureSource1), formatter(rowHeader4_1.values[8].value, measureSource1), formatter(rowHeader4_1.values[9].value, measureSource1), formatter(rowHeader4_1.values[10].value, measureSource1), formatter(rowHeader4_1.values[11].value, measureSource1), formatter(rowHeader4_1.values[12].value, measureSource1), formatter(rowHeader4_1.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1), formatter(rowHeader4_t.values[7].value, measureSource1), formatter(rowHeader4_t.values[8].value, measureSource1), formatter(rowHeader4_t.values[9].value, measureSource1), formatter(rowHeader4_t.values[10].value, measureSource1), formatter(rowHeader4_t.values[11].value, measureSource1), formatter(rowHeader4_t.values[12].value, measureSource1), formatter(rowHeader4_t.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1), formatter(rowHeadert.values[7].value, measureSource1), formatter(rowHeadert.values[8].value, measureSource1), formatter(rowHeadert.values[9].value, measureSource1), formatter(rowHeadert.values[10].value, measureSource1), formatter(rowHeadert.values[11].value, measureSource1), formatter(rowHeadert.values[12].value, measureSource1), formatter(rowHeadert.values[13].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass, HeaderClass, HeaderClass + ' ' + TotalClass, ''],
                    [HeaderClass, RowHeaderLeafClass, HeaderClass, HeaderClass, HeaderClass + ' ' + TotalClass, HeaderClass, HeaderClass, HeaderClass + ' ' + TotalClass],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('Verify Interactivity modes', function (done) {
            // Pick a matrix that exceeds the viewport
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: {
                    isInteractiveLegend: false,
                    selection: true
                },
            });
            v.onDataChanged({
                dataViews: [matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView]
            });
            setTimeout(function () {
                var scrollbars = $('.bi-tablix .scroll-bar-div');
                var verticalScrollbar = scrollbars.eq(0);
                var horizontalScrollbar = scrollbars.eq(1);
                // Check Style
                expect(verticalScrollbar.css("width")).toBe("0px");
                expect(horizontalScrollbar.css("height")).toBe("0px");
                // Check Values
                expect(verticalScrollbar.width()).toBe(0);
                expect(horizontalScrollbar.height()).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Matrix.formatStringProp));
        }
    });
    describe('Dashboard matrix DOM validation', function () {
        var v, element, EmptyHeaderCell = '\xa0', NoMarginClass = 'bi-tablix-cellNoMarginStyle', HeaderClass = 'bi-tablix-header', ColumnHeaderLeafClass = 'bi-tablix-column-header-leaf', RowHeaderLeafClass = 'bi-tablix-row-header-leaf', RowHeaderStaticLeafClass = 'bi-tablix-row-header-static-leaf', BodyCellClass = 'bi-matrix-body-cell', TotalClass = 'total', TableTotalLabel = 'TableTotalLabel';
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('700', '700');
            element['visible'] = function () {
                return true;
            };
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('matrix').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true,
                },
                interactivity: {
                    selection: null
                }
            });
        });
        function validateMatrix(expectedValues) {
            powerbitests.tablixHelper.validateMatrix(expectedValues, '.bi-dashboard-tablix tr');
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-dashboard-tablix tr', NoMarginClass);
        }
        it('1x2 matrix (value and static column header)', function (done) {
            var matrix = matrixOneMeasure;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            setTimeout(function () {
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 matrix (value and column header value)', function (done) {
            var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneMeasureOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ['', headerValue],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x2 matrix (values and static column headers)', function (done) {
            var matrix = matrixThreeMeasures;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [measureSource1, measureSource2, measureSource3] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ['', measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x3 matrix (values, static and value column headers)', function (done) {
            var matrix = matrixThreeMeasuresOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ['', headerValue],
                    ['', measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass],
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('6x9 matrix (values, static column headers and row value headers)', function (done) {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrix = matrixThreeMeasuresThreeRowGroups;
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var cellValue1 = formatter(header_1_1_1.values[0].value, measureSource1);
                var cellValue2 = formatter(header_1_1_1.values[1].value, measureSource2);
                var cellValue3 = formatter(header_1_1_1.values[2].value, measureSource3);
                var cellValue4 = formatter(header_1_1_2.values[0].value, measureSource1);
                var cellValue5 = formatter(header_1_1_2.values[1].value, measureSource2);
                var cellValue6 = formatter(header_1_1_2.values[2].value, measureSource3);
                var cellValue7 = formatter(header_1_2_1.values[0].value, measureSource1);
                var cellValue8 = formatter(header_1_2_1.values[1].value, measureSource2);
                var cellValue9 = formatter(header_1_2_1.values[2].value, measureSource3);
                var cellValue10 = formatter(header_1_2_2.values[0].value, measureSource1);
                var cellValue11 = formatter(header_1_2_2.values[1].value, measureSource2);
                var cellValue12 = formatter(header_1_2_2.values[2].value, measureSource3);
                var cellValue13 = formatter(header_2_1_1.values[0].value, measureSource1);
                var cellValue14 = formatter(header_2_1_1.values[1].value, measureSource2);
                var cellValue15 = formatter(header_2_1_1.values[2].value, measureSource3);
                var cellValue16 = formatter(header_2_1_2.values[0].value, measureSource1);
                var cellValue17 = formatter(header_2_1_2.values[1].value, measureSource2);
                var cellValue18 = formatter(header_2_1_2.values[2].value, measureSource3);
                var cellValue19 = formatter(header_2_2_1.values[0].value, measureSource1);
                var cellValue20 = formatter(header_2_2_1.values[1].value, measureSource2);
                var cellValue21 = formatter(header_2_2_1.values[2].value, measureSource3);
                var cellValue22 = formatter(header_2_2_2.values[0].value, measureSource1);
                var cellValue23 = formatter(header_2_2_2.values[1].value, measureSource2);
                var cellValue24 = formatter(header_2_2_2.values[2].value, measureSource3);
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [header_1.value, header_1_1.value, header_1_1_1.value, cellValue1, cellValue2, cellValue3],
                    [header_1_1_2.value, cellValue4, cellValue5, cellValue6],
                    [header_1_2.value, header_1_2_1.value, cellValue7, cellValue8, cellValue9],
                    [header_1_2_2.value, cellValue10, cellValue11, cellValue12],
                    [header_2.value, header_2_1.value, header_2_1_1.value, cellValue13, cellValue14, cellValue15],
                    [header_2_1_2.value, cellValue16, cellValue17, cellValue18],
                    [header_2_2.value, header_2_2_1.value, cellValue19, cellValue20, cellValue21],
                    [header_2_2_2.value, cellValue22, cellValue23, cellValue24]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x2 matrix (value, static column header and row value header)', function (done) {
            var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [rowGroupSource1, measureSource1] },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header = matrix.rows.root.children[0];
                var cellValue = formatter(header.values[0].value, measureSource1);
                var expectedCells = [
                    [rowGroupSource1.displayName, measureSource1.displayName],
                    [header.value, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass],
                    [RowHeaderStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x2 matrix (value, column value header and row value header, empty cell)', function (done) {
            var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var columnHeader = matrix.columns.root.children[0];
                var rowHeader = matrix.rows.root.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, columnHeader.value.toString()],
                    [rowHeader.value.toString(), '']
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x2 matrix (static column headers and row value headers)', function (done) {
            var matrix = matrixThreeRowGroupsOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixThreeRowGroupsOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeader_1_1_1 = rowHeader_1_1.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeader_1_1_1.value.toString()]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass],
                    [HeaderClass, HeaderClass, RowHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x6 matrix (static column headers and row value headers including empty ones)', function (done) {
            var matrix = matrixTwoRowGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName],
                    [header_1.value, EmptyHeaderCell],
                    [header_1_2.value],
                    [header_2.value, header_2_1.value],
                    [EmptyHeaderCell],
                    [EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('5x2 matrix (column value headers including empty ones)', function (done) {
            var matrix = matrixTwoColumnGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            columnGroupSource1,
                            columnGroupSource2
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    ['', header_1.value, header_2.value, EmptyHeaderCell],
                    ['', EmptyHeaderCell, header_1_2.value, header_2_1.value, EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass, HeaderClass, HeaderClass],
                    [HeaderClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('3x9 matrix (static column headers and row value headers)', function (done) {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            rowGroupSource3
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName],
                    [header_1.value, header_1_1.value, header_1_1_1.value.toString()],
                    [header_1_1_2.value.toString()],
                    [header_1_2.value, header_1_2_1.value.toString()],
                    [header_1_2_2.value.toString()],
                    [header_2.value, header_2_1.value, header_2_1_1.value.toString()],
                    [header_2_1_2.value.toString()],
                    [header_2_2.value, header_2_2_1.value.toString()],
                    [header_2_2_2.value.toString()]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('8x3 matrix (column value headers)', function (done) {
            var matrix = matrixThreeColumnGroups;
            v.onDataChanged({
                dataViews: [matrixThreeColumnGroupsDataView]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0].value.toString();
                var header_1_1_2 = header_1_1.children[1].value.toString();
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0].value.toString();
                var header_1_2_2 = header_1_2.children[1].value.toString();
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0].value.toString();
                var header_2_1_2 = header_2_1.children[1].value.toString();
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0].value.toString();
                var header_2_2_2 = header_2_2.children[1].value.toString();
                var expectedCells = [
                    ['', header_1.value, header_2.value],
                    ['', header_1_1.value, header_1_2.value, header_2_1.value, header_2_2.value],
                    ['', header_1_1_1, header_1_1_2, header_1_2_1, header_1_2_2, header_2_1_1, header_2_1_2, header_2_2_1, header_2_2_2]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('6x5 matrix (column value headers and row value headers, multiple group instances, empty cells)', function (done) {
            var matrix = matrixThreeRowGroupsThreeColumnGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            rowGroupSource3formatted,
                            columnGroupSource1,
                            columnGroupSource2,
                            columnGroupSource3formatted
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeaderValue_1_1_1 = formatter(rowHeader_1_1.children[0].value, rowGroupSource3formatted);
                var rowHeaderValue_1_1_2 = formatter(rowHeader_1_1.children[1].value, rowGroupSource3formatted);
                var rowHeader_1_2 = rowHeader_1.children[1];
                var rowHeaderValue_1_2_1 = formatter(rowHeader_1_2.children[0].value, rowGroupSource3formatted);
                var colHeader_1 = matrix.columns.root.children[0];
                var colHeader_1_1 = colHeader_1.children[0];
                var colHeaderValue_1_1_1 = formatter(colHeader_1_1.children[0].value, columnGroupSource3formatted);
                var colHeaderValue_1_1_2 = formatter(colHeader_1_1.children[1].value, columnGroupSource3formatted);
                var colHeader_1_2 = colHeader_1.children[1];
                var colHeaderValue_1_2_1 = formatter(colHeader_1_2.children[0].value, columnGroupSource3formatted);
                var expectedCells = [
                    ['', '', columnGroupSource1.displayName, colHeader_1.value],
                    ['', '', columnGroupSource2.displayName, colHeader_1_1.value, colHeader_1_2.value],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, colHeaderValue_1_1_1, colHeaderValue_1_1_2, colHeaderValue_1_2_1],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeaderValue_1_1_1, '', '', ''],
                    [rowHeaderValue_1_1_2, '', '', ''],
                    [rowHeader_1_2.value, rowHeaderValue_1_2_1, '', '', '']
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x4 matrix (boolean and null group instances)', function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ]
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString()],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with row and column subtotals', function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource4,
                            columnGroupSource4,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1), formatter(rowHeader1.values[2].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1), formatter(rowHeader2.values[2].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1), formatter(rowHeader3.values[2].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4.values[0].value, measureSource1), formatter(rowHeader4.values[1].value, measureSource1), formatter(rowHeader4.values[2].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with multiple row and column group hierarchy levels, one measure with subtotals', function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            columnGroupSource1,
                            columnGroupSource2,
                            measureSource1
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ['', columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString()],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1)]
                ];
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass, HeaderClass],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                validateMatrix(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('Matrix with multiple row and column group hierarchy levels, two measures with subtotals', function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals;
            v.onDataChanged({
                dataViews: [{
                    metadata: {
                        columns: [
                            rowGroupSource1,
                            rowGroupSource2,
                            columnGroupSource1,
                            columnGroupSource2,
                            measureSource1,
                            measureSource2
                        ],
                        objects: {
                            general: {
                                rowSubtotals: true,
                                columnSubtotals: true
                            }
                        }
                    },
                    matrix: matrix
                }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ['', columnGroupSource1.displayName, colHeader1.value.toString()],
                    ['', columnGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass],
                    [HeaderClass, RowHeaderLeafClass, HeaderClass, HeaderClass, HeaderClass + ' ' + TotalClass],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + RowHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + ' ' + TotalClass, ColumnHeaderLeafClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                    [RowHeaderStaticLeafClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass, BodyCellClass + ' ' + TotalClass],
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Matrix.formatStringProp));
        }
    });
    describe("Matrix sort validation", function () {
        var element;
        beforeEach(function (done) {
            powerbitests.helpers.suppressDebugAssertFailure();
            element = powerbitests.helpers.testDom('1800', '1800');
            element['visible'] = function () {
                return true;
            };
            done();
        });
        it('matrix with single measure', function (done) {
            // Clicking on the measure will result in a sort event
            var data = matrixOneMeasureDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Measure1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with one measure and one column group', function (done) {
            // Clicking on a column group (even if there is only a single instance) will not result in a sort event
            var data = matrixOneMeasureOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Group A" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 0, col: 1 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with three measures', function (done) {
            // Clicking on any measure will result in a sort event
            var data = matrixThreeMeasuresDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Measure1" }, { row: 0, col: 2, expectedText: "Measure2" }, { row: 0, col: 3, expectedText: "Measure3" }];
            var clicks = [{ row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with three measures under one column group', function (done) {
            // Clicking on any column group or any measure underneath it will not result in a sort event
            var data = matrixThreeMeasuresOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Group A" }, { row: 1, col: 1, expectedText: "Measure1" }, { row: 1, col: 2, expectedText: "Measure2" }, { row: 1, col: 3, expectedText: "Measure3" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with three measures and three row groups', function (done) {
            // Clicking on any row group or any measure will result in a sort event
            var data = matrixThreeMeasuresThreeRowGroupsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "RowGroup2" },
                { row: 0, col: 2, expectedText: "RowGroup3" },
                { row: 0, col: 3, expectedText: "Measure1" },
                { row: 0, col: 4, expectedText: "Measure2" },
                { row: 0, col: 5, expectedText: "Measure3" }
            ];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }, { row: 0, col: 4 }, { row: 0, col: 5 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }],
                [{ queryName: "RowGroup3" }],
                [{ queryName: "Measure1" }],
                [{ queryName: "Measure2" }],
                [{ queryName: "Measure3" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with one row group and one column group', function (done) {
            // Clicking on the row group will result in a sort event; clicking on the column group will not
            var data = matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "10" }
            ];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 0 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with one row group and one column group', function (done) {
            // Clicking on any row group will result in a sort event
            var data = matrixThreeRowGroupsOneGroupInstanceDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "RowGroup2" },
                { row: 0, col: 2, expectedText: "RowGroup3" }
            ];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }],
                [{ queryName: "RowGroup3" }],
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with three column groups', function (done) {
            // Clicking on any column group will not result in a sort event
            var data = matrixThreeColumnGroupsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "Africa" },
                { row: 0, col: 2, expectedText: "Asia" },
                { row: 1, col: 1, expectedText: "Algeria" },
                { row: 1, col: 2, expectedText: "Angola" },
                { row: 1, col: 3, expectedText: "China" },
                { row: 1, col: 4, expectedText: "India" },
                { row: 2, col: 1, expectedText: "2008" },
                { row: 2, col: 2, expectedText: "2012" },
                { row: 2, col: 3, expectedText: "2008" },
                { row: 2, col: 4, expectedText: "2012" },
                { row: 2, col: 5, expectedText: "2008" },
                { row: 2, col: 6, expectedText: "2012" },
                { row: 2, col: 7, expectedText: "2008" },
                { row: 2, col: 8, expectedText: "2012" },
            ];
            var clicks = [
                { row: 0, col: 1 },
                { row: 0, col: 2 },
                { row: 1, col: 1 },
                { row: 1, col: 2 },
                { row: 1, col: 3 },
                { row: 1, col: 4 },
                { row: 2, col: 1 },
                { row: 2, col: 2 },
                { row: 2, col: 3 },
                { row: 2, col: 4 },
                { row: 2, col: 5 },
                { row: 2, col: 6 },
                { row: 2, col: 7 },
                { row: 2, col: 8 },
            ];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with two row groups, two column groups and two measures', function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event
            var data = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" },
                { row: 0, col: 2, expectedText: "1992" },
                { row: 0, col: 3, expectedText: "1996" },
                { row: 1, col: 1, expectedText: "ColGroup2" },
                { row: 1, col: 2, expectedText: "Bronze" },
                { row: 1, col: 3, expectedText: "Gold" },
                { row: 1, col: 4, expectedText: "Silver" },
                { row: 1, col: 5, expectedText: "Bronze" },
                { row: 1, col: 6, expectedText: "Gold" },
                { row: 1, col: 7, expectedText: "Silver" },
                { row: 2, col: 0, expectedText: "RowGroup1" },
                { row: 2, col: 1, expectedText: "RowGroup2" },
                { row: 2, col: 2, expectedText: "Measure1" },
                { row: 2, col: 3, expectedText: "Measure2" },
                { row: 2, col: 4, expectedText: "Measure1" },
                { row: 2, col: 5, expectedText: "Measure2" },
                { row: 2, col: 6, expectedText: "Measure1" },
                { row: 2, col: 7, expectedText: "Measure2" },
                { row: 2, col: 8, expectedText: "Measure1" },
                { row: 2, col: 9, expectedText: "Measure2" },
                { row: 2, col: 10, expectedText: "Measure1" },
                { row: 2, col: 11, expectedText: "Measure2" },
                { row: 2, col: 12, expectedText: "Measure1" }
            ];
            var clicks = [
                { row: 0, col: 1 },
                { row: 0, col: 2 },
                { row: 0, col: 3 },
                { row: 1, col: 1 },
                { row: 1, col: 2 },
                { row: 1, col: 3 },
                { row: 1, col: 4 },
                { row: 1, col: 5 },
                { row: 1, col: 6 },
                { row: 1, col: 7 },
                { row: 2, col: 0 },
                { row: 2, col: 1 },
                { row: 2, col: 2 },
                { row: 2, col: 3 },
                { row: 2, col: 4 },
                { row: 2, col: 5 },
                { row: 2, col: 6 },
                { row: 2, col: 7 },
                { row: 2, col: 8 },
                { row: 2, col: 9 },
                { row: 2, col: 10 },
                { row: 2, col: 11 },
                { row: 2, col: 12 },
            ];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with two row groups, two column groups and one measure with totals', function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event; clicking on the column grand total will result in a sort (by measure)
            var data = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotalsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" },
                { row: 0, col: 2, expectedText: "1992" },
                { row: 0, col: 3, expectedText: "1996" },
                { row: 0, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 0, expectedText: "RowGroup1" },
                { row: 1, col: 1, expectedText: "RowGroup2" },
                { row: 1, col: 2, expectedText: "Silver" },
                { row: 1, col: 3, expectedText: "Gold" },
                { row: 1, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 5, expectedText: "Silver" },
                { row: 1, col: 6, expectedText: "Gold" },
                { row: 1, col: 7, expectedText: Matrix.TotalLabel },
            ];
            var clicks = [
                { row: 0, col: 1 },
                { row: 0, col: 2 },
                { row: 0, col: 3 },
                { row: 0, col: 4 },
                { row: 1, col: 0 },
                { row: 1, col: 1 },
                { row: 1, col: 2 },
                { row: 1, col: 3 },
                { row: 1, col: 4 },
                { row: 1, col: 5 },
                { row: 1, col: 6 },
                { row: 1, col: 7 },
            ];
            var expectedSorts = [
                [{ queryName: "Measure1" }],
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with two row groups, two column groups and two measures with totals', function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event; clicking on the column grand total will result in a sort (by measure)
            var data = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotalsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" },
                { row: 0, col: 2, expectedText: "1992" },
                { row: 0, col: 3, expectedText: "1996" },
                { row: 0, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 1, expectedText: "ColGroup2" },
                { row: 1, col: 2, expectedText: "Silver" },
                { row: 1, col: 3, expectedText: "Gold" },
                { row: 1, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 5, expectedText: "Silver" },
                { row: 1, col: 6, expectedText: "Gold" },
                { row: 1, col: 7, expectedText: Matrix.TotalLabel },
                { row: 2, col: 0, expectedText: "RowGroup1" },
                { row: 2, col: 1, expectedText: "RowGroup2" },
                { row: 2, col: 2, expectedText: "Measure1" },
                { row: 2, col: 3, expectedText: "Measure2" },
                { row: 2, col: 4, expectedText: "Measure1" },
                { row: 2, col: 5, expectedText: "Measure2" },
                { row: 2, col: 6, expectedText: "Measure1" },
                { row: 2, col: 7, expectedText: "Measure2" },
                { row: 2, col: 8, expectedText: "Measure1" },
                { row: 2, col: 9, expectedText: "Measure2" },
                { row: 2, col: 10, expectedText: "Measure1" },
                { row: 2, col: 11, expectedText: "Measure2" },
                { row: 2, col: 12, expectedText: "Measure1" },
                { row: 2, col: 13, expectedText: "Measure2" },
                { row: 2, col: 14, expectedText: "Measure1" },
                { row: 2, col: 15, expectedText: "Measure2" }
            ];
            var clicks = [
                { row: 0, col: 1 },
                { row: 0, col: 2 },
                { row: 0, col: 3 },
                { row: 0, col: 4 },
                { row: 1, col: 1 },
                { row: 1, col: 2 },
                { row: 1, col: 3 },
                { row: 1, col: 4 },
                { row: 1, col: 5 },
                { row: 1, col: 6 },
                { row: 1, col: 7 },
                { row: 2, col: 0 },
                { row: 2, col: 1 },
                { row: 2, col: 2 },
                { row: 2, col: 3 },
                { row: 2, col: 4 },
                { row: 2, col: 5 },
                { row: 2, col: 6 },
                { row: 2, col: 7 },
                { row: 2, col: 8 },
                { row: 2, col: 9 },
                { row: 2, col: 10 },
                { row: 2, col: 11 },
                { row: 2, col: 12 },
                { row: 2, col: 13 },
                { row: 2, col: 14 },
                { row: 2, col: 15 },
            ];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }],
                [{ queryName: "Measure1" }],
                [{ queryName: "Measure2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('matrix with columnGroup url', function (done) {
            var data = matrixOneMeasureOneColumnGroupWithUrlOneGroupInstanceDataView;
            var renderTablixPromise = powerbitests.tablixHelper.renderNewTablix(element, {
                visualType: 'matrix',
                data: data,
            });
            renderTablixPromise.then(function () {
                var tableBody = $('.tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody');
                expect(tableBody).toBeInDOM();
                var cellInfo = powerbitests.tablixHelper.getTableCell(tableBody, { row: 0, col: 1 });
                var aTag = $('> div > a', cellInfo.clickTarget);
                expect(aTag.length).toBe(1);
                expect(aTag.text()).toBe('http://www.validurl.com');
                expect(aTag.attr('href')).toBe('http://www.validurl.com');
                expect(aTag.attr('title')).toBe('http://www.validurl.com');
                done();
            });
        });
        it('matrix with rowGroup url', function (done) {
            var data = matrixOneMeasureOneRowGroupUrlOneGroupInstanceDataView;
            var renderTablixPromise = powerbitests.tablixHelper.renderNewTablix(element, {
                visualType: 'matrix',
                data: data,
            });
            renderTablixPromise.then(function () {
                var tableBody = $('.tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody');
                expect(tableBody).toBeInDOM();
                var cellInfo = powerbitests.tablixHelper.getTableCell(tableBody, { row: 1, col: 0 });
                var aTag = $('> div > a', cellInfo.clickTarget);
                expect(aTag.length).toBe(1);
                expect(aTag.text()).toBe('http://www.validurl.com');
                expect(aTag.attr('href')).toBe('http://www.validurl.com');
                expect(aTag.attr('title')).toBe('http://www.validurl.com');
                done();
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var MultiRowCard = powerbi.visuals.MultiRowCard;
    var ValueType = powerbi.ValueType;
    describe("MultiRowCard", function () {
        it('MultiRowCard_registered_capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('multiRowCard').capabilities).toBe(MultiRowCard.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(MultiRowCard.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(MultiRowCard.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(MultiRowCard.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(MultiRowCard.capabilities.objects)).toEqual(MultiRowCard.formatStringProp);
        });
    });
    describe("MultiRowCard DOM tests", function () {
        var v, element;
        var defaultTimeout = 30;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadata = {
            columns: [
                { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }) },
                { displayName: 'date', type: ValueType.fromDescriptor({ dateTime: true }) },
                { displayName: 'category', type: ValueType.fromDescriptor({ text: true }) },
            ],
        };
        var data = {
            metadata: dataViewMetadata,
            table: {
                rows: [
                    [123456.789, new Date(1999, 7, 31, 6, 15), 'category1'],
                    [12345, new Date(2014, 7, 1), 'category2']
                ],
                columns: dataViewMetadata.columns
            },
        };
        var dataViewMetadataWithTitle = {
            columns: [
                { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }), isMeasure: true },
                { displayName: 'genre', type: ValueType.fromDescriptor({ text: true }) },
            ],
        };
        var dataWithTitle = {
            metadata: dataViewMetadataWithTitle,
            table: {
                rows: [
                    [123456.789, 'Action'],
                    [12345, 'Adventure']
                ],
                columns: dataViewMetadataWithTitle.columns
            },
        };
        var dataWithNullValue = {
            metadata: dataViewMetadataWithTitle,
            table: {
                rows: [
                    [null, 'Action'],
                    [null, 'Adventure']
                ],
                columns: dataViewMetadataWithTitle.columns
            },
        };
        beforeEach(function () {
            createMultiRowCard();
        });
        function createMultiRowCard() {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('multiRowCard').create();
            var settings;
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
            });
        }
        it('Validate multiRowCard DOM without Title', function (done) {
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .title')).not.toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect($('.card .cardItemContainer .caption')).toBeInDOM();
                expect($('.card .cardItemContainer .details')).toBeInDOM();
                expect($('.card').length).toBe(2);
                expect($('.card')[0].childElementCount).toBe(3);
                expect($('.cardItemContainer')[0].childElementCount).toBe(2);
                expect($('.caption').last().text()).toBe('category2');
                expect($('.details').last().text()).toBe('category');
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard DOM with Title', function (done) {
            v.onDataChanged({ dataViews: [dataWithTitle] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect($('.card .cardItemContainer .caption')).toBeInDOM();
                expect($('.card .cardItemContainer .details')).toBeInDOM();
                expect($('.card .title')).toBeInDOM();
                expect($('.card').length).toBe(2);
                expect($('.card')[0].childElementCount).toBe(2);
                expect($('.cardItemContainer')[0].childElementCount).toBe(2);
                expect($('.title').last().text()).toBe('Adventure');
                expect($('.caption').last().text()).toBe('12,345.00');
                expect($('.details').last().text()).toBe('value');
                done();
            }, defaultTimeout);
        });
        it('Validate that multiRowCard item long caption should be truncated', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Label', type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'Category', type: ValueType.fromDescriptor({ text: true }) }
                ],
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        ['this is the label that never ends, it just goes on and on my friends.Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...', 'Category1']
                    ],
                    columns: dataViewMetadata.columns
                },
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                // Note: the exact text will be different depending on the environment in which the test is run, so we can't do an exact match.
                // Just check that the text is truncated with ellipses.
                var labelText = $('.caption').first().text();
                expect(labelText.substr(labelText.length - 3)).toBe('...');
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard converter without Title', function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(data, data.metadata.columns.length, data.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: undefined, cardItemsData: [{ caption: '123,456.79', details: 'value' }, { caption: '8/31/1999', details: 'date' }, { caption: 'category1', details: 'category' }] },
                    { title: undefined, cardItemsData: [{ caption: '12,345.00', details: 'value' }, { caption: '8/1/2014', details: 'date' }, { caption: 'category2', details: 'category' }] }
                ]);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard converter With Title', function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(dataWithTitle, dataWithTitle.metadata.columns.length, dataWithTitle.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: 'Action', cardItemsData: [{ caption: '123,456.79', details: 'value' }] },
                    { title: 'Adventure', cardItemsData: [{ caption: '12,345.00', details: 'value' }] }
                ]);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard converter null value', function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(dataWithNullValue, dataWithNullValue.metadata.columns.length, dataWithNullValue.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: 'Action', cardItemsData: [{ caption: '(Blank)', details: 'value' }] },
                    { title: 'Adventure', cardItemsData: [{ caption: '(Blank)', details: 'value' }] }
                ]);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard last card styling on dashboard', function (done) {
            element = powerbitests.helpers.testDom('400', '400');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { overflow: 'hidden' }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find('.card').last().css('border-bottom-width'), 10);
                var cardItemBottomPadding = parseInt(element.find('.card').last().css('padding-bottom'), 10);
                var cardItemTopPadding = parseInt(element.find('.card').last().css('padding-top'), 10);
                expect(cardItemBottomBorderWidth).toEqual(0);
                expect(cardItemBottomPadding).toEqual(0);
                expect(cardItemTopPadding).toEqual(5);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard first card styling on canvas', function (done) {
            element = powerbitests.helpers.testDom('100', '100');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            var dataViewMetadata = {
                columns: [
                    { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }) },
                ],
            };
            var singleRowdata = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [123456.789],
                    ],
                    columns: dataViewMetadata.columns
                },
            };
            v.onDataChanged({ dataViews: [singleRowdata] });
            setTimeout(function () {
                var cardBottomMargin = parseInt(element.find('.card').last().css('margin-bottom'), 10);
                expect(cardBottomMargin).toEqual(0);
                v.onDataChanged({ dataViews: [dataWithTitle] });
                cardBottomMargin = parseInt(element.find('.card').last().css('margin-bottom'), 10);
                expect(cardBottomMargin).toEqual(20);
                v.onDataChanged({ dataViews: [data] });
                cardBottomMargin = parseInt(element.find('.card').last().css('margin-bottom'), 10);
                expect(cardBottomMargin).toEqual(20);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard card styling on dashboard', function (done) {
            element = powerbitests.helpers.testDom('400', '400');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { overflow: 'hidden' }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find('.card').first().css('border-bottom-width'), 10);
                var cardItemBottomPadding = parseInt(element.find('.card').first().css('padding-bottom'), 10);
                var cardItemTopPadding = parseInt(element.find('.card').first().css('padding-top'), 10);
                expect($('.card .title')).not.toBeInDOM();
                expect(cardItemBottomBorderWidth).toEqual(1);
                expect(cardItemBottomPadding).toEqual(5);
                expect(cardItemTopPadding).toEqual(5);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard card styling', function (done) {
            element = powerbitests.helpers.testDom('400', '400');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find('.card').first().css('border-bottom-width'), 10);
                var cardItemBottomPadding = parseInt(element.find('.card').first().css('padding-bottom'), 10);
                var cardItemTopPadding = parseInt(element.find('.card').first().css('padding-top'), 10);
                expect(cardItemBottomBorderWidth).toEqual(0);
                expect(cardItemBottomPadding).toEqual(0);
                expect(cardItemTopPadding).toEqual(0);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard styling when there is a single card item', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }) },
                ],
            };
            var singleRowdata = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [123456.789],
                    ],
                    columns: dataViewMetadata.columns
                },
            };
            v.onDataChanged({ dataViews: [singleRowdata] });
            setTimeout(function () {
                var cardItemRightMargin = parseInt(element.find('.cardItemContainer').first().css('margin-right'), 10);
                expect(cardItemRightMargin).toEqual(0);
                done();
            }, defaultTimeout);
        });
        it('Verify number of cards and card items in smallTile ', function (done) {
            element = powerbitests.helpers.testDom('150', '230');
            var data = powerbitests.tableDataViewHelper.getDataWithColumns(10, 10);
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { overflow: 'hidden' }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect($('.card').length).toBe(1);
                expect($('.card')[0].childElementCount).toBe(4);
                done();
            }, defaultTimeout);
        });
        it('Verify number of cards and card items in MediumTile ', function (done) {
            element = powerbitests.helpers.testDom('300', '470');
            var data = powerbitests.tableDataViewHelper.getDataWithColumns(10, 10);
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { overflow: 'hidden' }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect($('.card').length).toBe(3);
                expect($('.card')[0].childElementCount).toBe(6);
                done();
            }, defaultTimeout);
        });
        it('Verify number of cards and card items in LargeTile ', function (done) {
            element = powerbitests.helpers.testDom('450', '750');
            var data = powerbitests.tableDataViewHelper.getDataWithColumns(10, 10);
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { overflow: 'hidden' }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect($('.card').length).toBe(9);
                expect($('.card')[0].childElementCount).toBe(6);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard cardrow column width for default width', function (done) {
            element = powerbitests.helpers.testDom('100', '760');
            var data = powerbitests.tableDataViewHelper.getDataWithColumns(15, 15);
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.card .cardItemContainer')).toBeInDOM();
                expect(element.find('.cardItemContainer').last().innerWidth()).toEqual(86);
                done();
            }, defaultTimeout);
        });
        it('Validate multiRowCard card height', function (done) {
            element = powerbitests.helpers.testDom('400', '400');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemHeight = element.find('.cardItemContainer').height();
                var cardItemBottompadding = parseInt(element.find('.card').css('padding-bottom'), 10);
                var cardItemTopPadding = parseInt(element.find('.card').css('padding-bottom'), 10);
                expect(element.find('.card').first().innerHeight()).toEqual(cardItemHeight + cardItemBottompadding + cardItemTopPadding);
                done();
            }, defaultTimeout);
        });
        it('Card should be cleared when there is a empty dataview ', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }) }
                ],
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [123456.789]
                    ],
                    columns: dataViewMetadata.columns
                },
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card').length).toBe(1);
                dataViewMetadata = {
                    columns: [],
                };
                data = {
                    metadata: dataViewMetadata,
                    table: {
                        rows: [],
                        columns: dataViewMetadata.columns
                    },
                };
                v.onDataChanged({ dataViews: [data] });
                expect($('.card').length).toBe(0);
                done();
            }, defaultTimeout);
        });
        it('Card should format values', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'value', type: ValueType.fromDescriptor({ numeric: true }), objects: { general: { formatString: '0%' } } }
                ],
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [.22]
                    ],
                    columns: dataViewMetadata.columns
                },
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($('.card').length).toBe(1);
                expect($('.card .caption').last().text()).toBe('22%');
                done();
            }, defaultTimeout);
        });
        it('Card should not call loadMoreData ', function () {
            var data = {
                metadata: { columns: [] },
                table: { rows: [[1]], columns: [] }
            };
            v.onDataChanged({ dataViews: [data] });
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).not.toHaveBeenCalled();
        });
        it('Card should call loadMoreData ', function () {
            var data = {
                metadata: { columns: [], segment: {} },
                table: { rows: [[1]], columns: [] }
            };
            v.onDataChanged({ dataViews: [data] });
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).toHaveBeenCalled();
        });
        it('Card already called loadMoreData', function () {
            var data = {
                metadata: { columns: [], segment: {} },
                table: { rows: [[1]], columns: [] }
            };
            v.onDataChanged({ dataViews: [data] });
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            listViewOptions.loadMoreData();
            expect(loadMoreSpy.calls.all().length).toBe(1);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var RichTextbox = powerbi.visuals.RichTextbox;
    describe('Rich Textbox', function () {
        var viewport = {
            height: 500,
            width: 500,
        };
        var style = powerbi.visuals.visualStyles.create();
        describe('capabilities', function () {
            it('should suppress title', function () {
                expect(RichTextbox.capabilities.suppressDefaultTitle).toBeTruthy();
            });
            it('should register capabilities', function () {
                var pluginFactory = powerbi.visuals.visualPluginFactory.create();
                var plugin = pluginFactory.getPlugin('textbox');
                expect(plugin).toBeDefined();
                expect(plugin.capabilities).toBe(RichTextbox.capabilities);
            });
        });
        // Chutzpah is configured to load the quill resources for these tests.
        powerbi.visuals.RichText.QuillWrapper.loadQuillResources = false;
        // ---- Sample data ----
        // 2 paragraphs, no formatting.
        var paragraphs1 = [
            {
                textRuns: [
                    { value: 'foo' },
                    { value: 'bar' },
                ]
            },
            {
                textRuns: [
                    { value: 'baz' }
                ]
            }
        ];
        // 2 paragraphs, with formatting
        var paragraphs2 = [
            {
                textRuns: [
                    { value: 'foo', textStyle: { fontWeight: 'bold' } },
                    { value: 'bar', textStyle: { fontStyle: 'italic' } },
                    { value: 'baz', textStyle: { textDecoration: 'underline' } },
                ]
            },
            {
                textRuns: [
                    { value: 'http://www.powerbi.com', url: 'http://www.powerbi.com' }
                ],
                horizontalTextAlignment: 'center'
            }
        ];
        // 1 paragraph with an unformatted url.
        var paragraphs3 = [
            {
                textRuns: [
                    { value: 'http://www.powerbi.com' },
                ]
            }
        ];
        describe('', function () {
            var host;
            var $element;
            var $toolbar;
            var initOptions;
            var textbox;
            var getViewModeSpy;
            var setToolbarSpy;
            beforeEach(function () {
                host = powerbitests.mocks.createVisualHostServices();
                $element = powerbitests.helpers.testDom('500', '500');
                initOptions = {
                    element: $element,
                    host: host,
                    viewport: viewport,
                    style: style,
                };
                getViewModeSpy = spyOn(host, 'getViewMode');
                setToolbarSpy = spyOn(host, 'setToolbar');
                setToolbarSpy.and.callFake(function (t) { return $toolbar = t; });
            });
            describe('init in view mode', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(0 /* View */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('should not show editor', function () {
                    verifyEditor($element, false);
                });
                it('change to edit-mode should show editor', function () {
                    switchToViewMode(1 /* Edit */);
                    verifyEditor($element, true);
                });
                describe('on data changed', function () {
                    it('with non-empty dataview should set content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        expect($paragraph1.text()).toEqual('foobar');
                        var $paragraph2 = $divs.eq(1);
                        expect($paragraph2.text()).toEqual('baz');
                    });
                    it('with empty dataview should clear content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        // Clear the content.
                        textbox.onDataChanged({ dataViews: [] });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.text()).toEqual('');
                    });
                    it('with formatted text should render correctly', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        var $paragraph1Spans = $paragraph1.children();
                        expect($paragraph1Spans.length).toBe(3);
                        var $fooRun = $paragraph1Spans.eq(0);
                        expect(hasBold($fooRun)).toBeTruthy();
                        var $barRun = $paragraph1Spans.eq(1);
                        expect(hasItalic($barRun)).toBeTruthy();
                        var $bazRun = $paragraph1Spans.eq(2);
                        expect(hasUnderline($bazRun)).toBeTruthy();
                        var $paragraph2 = $divs.eq(1);
                        var $paragraph2Spans = $paragraph2.children();
                        expect($paragraph2Spans.length).toBe(1);
                        var $urlRun = $paragraph2Spans.eq(0);
                        expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                    });
                    describe('theme font', function () {
                        it('"Heading" should render correctly', function () {
                            var paragraphsWithHeading = [
                                {
                                    textRuns: [
                                        { value: 'Some text', textStyle: { fontFamily: 'Heading' } },
                                    ]
                                }
                            ];
                            textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphsWithHeading) });
                            var $divs = getViewModeParagraphDivs($element);
                            var $span = $divs.children('span').eq(0);
                            expect(getFont($span)).toEqual('wf_segoe-ui_light');
                        });
                        it('"Body" should render correctly', function () {
                            var paragraphsWithBody = [
                                {
                                    textRuns: [
                                        { value: 'Some text', textStyle: { fontFamily: 'Body' } },
                                    ]
                                }
                            ];
                            textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphsWithBody) });
                            var $divs = getViewModeParagraphDivs($element);
                            var $span = $divs.children('span').eq(0);
                            expect(getFont($span)).toEqual('wf_segoe-ui_normal');
                        });
                    });
                });
            });
            describe('init in edit mode', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(1 /* Edit */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('should show editor', function () {
                    verifyEditor($element, true);
                });
                it('change to view-mode should not show editor', function () {
                    switchToViewMode(0 /* View */);
                    verifyEditor($element, false);
                });
                it('change to view-mode should format any urls', function () {
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs3) });
                    switchToViewMode(0 /* View */);
                    var $divs = getViewModeParagraphDivs($element);
                    var $urlRun = $divs.children('span').eq(0);
                    expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                });
                it('change to view-mode should save content', function () {
                    var changes = [];
                    spyOn(host, 'persistProperties').and.callFake(function (c) { return changes = c; });
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                    switchToViewMode(0 /* View */);
                    expect(changes).toHaveLength(1);
                    var change = changes[0];
                    expect(change.objectName).toEqual('general');
                    var paragraphs = change.properties.paragraphs;
                    expect(paragraphs.length).toBe(2);
                    expect(paragraphs[0].horizontalTextAlignment).toBeFalsy();
                    expect(paragraphs[0].textRuns.length).toBe(3);
                    expect(paragraphs[0].textRuns[0].value).toBe('foo');
                    expect(paragraphs[0].textRuns[0].textStyle).toEqual({ fontWeight: 'bold' });
                    expect(paragraphs[0].textRuns[0].url).toBeFalsy();
                    expect(paragraphs[0].textRuns[1].value).toBe('bar');
                    expect(paragraphs[0].textRuns[1].textStyle).toEqual({ fontStyle: 'italic' });
                    expect(paragraphs[0].textRuns[1].url).toBeFalsy();
                    expect(paragraphs[0].textRuns[2].value).toBe('baz');
                    expect(paragraphs[0].textRuns[2].textStyle).toEqual({ textDecoration: 'underline' });
                    expect(paragraphs[0].textRuns[2].url).toBeFalsy();
                    expect(paragraphs[1].horizontalTextAlignment).toEqual('center');
                    expect(paragraphs[1].textRuns[0].value).toBe('http://www.powerbi.com');
                    expect(paragraphs[1].textRuns[0].textStyle).toEqual({});
                    expect(paragraphs[1].textRuns[0].url).toEqual('http://www.powerbi.com');
                });
                it('change to view-mode should preserve empty lines', function () {
                    var paragraphs = [
                        {
                            textRuns: [
                                { value: 'line 1' },
                            ]
                        },
                        {
                            textRuns: [
                                { value: '' },
                            ]
                        },
                        {
                            textRuns: [
                                { value: 'line 2' },
                            ]
                        }
                    ];
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs) });
                    switchToViewMode(0 /* View */);
                    var $divs = getViewModeParagraphDivs($element);
                    expect($divs.length).toBe(3);
                    expect($divs.eq(0).text()).toEqual('line 1');
                    expect($divs.eq(1).text()).toEqual('');
                    expect($divs.eq(2).text()).toEqual('line 2');
                });
                describe('on data changed', function () {
                    it('with non-empty dataview should set content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        var $divs = getEditModeParagraphDivs($element);
                        var $paragraph1 = $divs.eq(0);
                        expect($paragraph1.text()).toEqual('foobar');
                        var $paragraph2 = $divs.eq(1);
                        expect($paragraph2.text()).toBe('baz');
                    });
                    it('with empty dataview should clear content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        // Clear the content.
                        textbox.onDataChanged({ dataViews: [] });
                        var $divs = getEditModeParagraphDivs($element);
                        expect($divs.text()).toEqual('');
                    });
                    it('with formatted text should render correctly', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                        var $divs = getEditModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        var $paragraph1Spans = $paragraph1.children();
                        expect($paragraph1Spans.length).toBe(3);
                        var $fooRun = $paragraph1Spans.eq(0);
                        expect(hasBold($fooRun)).toBeTruthy();
                        var $barRun = $paragraph1Spans.eq(1);
                        expect(hasItalic($barRun)).toBeTruthy();
                        var $bazRun = $paragraph1Spans.eq(2);
                        expect(hasUnderline($bazRun)).toBeTruthy();
                        var $paragraph2 = $divs.eq(1);
                        var $urlRun = $paragraph2;
                        expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                    });
                });
            });
            describe('', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(1 /* Edit */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('toolbar should exist with formatting options', function () {
                    var $toolbar = getToolbar();
                    expect($toolbar).toBeDefined();
                    expect(boldButton($toolbar)).toBeDefined();
                    expect(italicButton($toolbar)).toBeDefined();
                    expect(underlineButton($toolbar)).toBeDefined();
                    expect(fontSelect($toolbar)).toBeDefined();
                    expect(fontSizeSelect($toolbar)).toBeDefined();
                    expect(textAlignmentSelect($toolbar)).toBeDefined();
                });
                describe('with selected text', function () {
                    beforeEach(function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        textbox.setSelection(0, 5);
                    });
                    describe('clicking bold', function () {
                        beforeEach(function () {
                            boldButton(getToolbar()).click();
                        });
                        it('should bold selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasBold($spans.eq(0))).toBeTruthy();
                        });
                        it('should bold text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasBold($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('clicking italic', function () {
                        beforeEach(function () {
                            italicButton(getToolbar()).click();
                        });
                        it('should italicize selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasItalic($spans.eq(0))).toBeTruthy();
                        });
                        it('should italicize text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasItalic($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('clicking underline', function () {
                        beforeEach(function () {
                            underlineButton(getToolbar()).click();
                        });
                        it('should underline selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasUnderline($spans.eq(0))).toBeTruthy();
                        });
                        it('should underline text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasUnderline($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('changing font', function () {
                        var fontFace = 'Symbol';
                        beforeEach(function () {
                            setSelectValue(fontSelect(getToolbar()), fontFace);
                        });
                        it('should change font in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                            expect(getSelectText(fontSelect(getToolbar()))).toEqual(fontFace);
                        });
                        it('should change font in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                        });
                    });
                    describe('changing font (embedded)', function () {
                        var fontFace = 'wf_segoe-ui_normal';
                        beforeEach(function () {
                            setSelectValue(fontSelect(getToolbar()), fontFace);
                        });
                        it('should change font in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                            expect(getSelectText(fontSelect(getToolbar()))).toEqual('Segoe UI');
                        });
                        it('should change font in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                        });
                    });
                    describe('changing font size', function () {
                        var fontSize = '24px';
                        beforeEach(function () {
                            setSelectValue(fontSizeSelect(getToolbar()), fontSize);
                        });
                        it('should change font size in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFontSize($spans.eq(0))).toEqual(fontSize);
                            expect(getSelectText(fontSizeSelect(getToolbar()))).toEqual('24');
                        });
                        it('should change font size in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFontSize($spans.eq(0))).toEqual(fontSize);
                        });
                    });
                    describe('changing text alignment', function () {
                        var alignment = 'center';
                        beforeEach(function () {
                            setSelectValue(textAlignmentSelect(getToolbar()), alignment);
                        });
                        it('should change text alignment in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            // NOTE: Changes alignment for the entire paragraph.
                            expect($paragraph1.text()).toEqual('foobar');
                            expect(getTextAlignment($paragraph1)).toEqual(alignment);
                            expect(getSelectText(textAlignmentSelect(getToolbar()))).toEqual('Center');
                        });
                        it('should change text alignment in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            // NOTE: Changes alignment for the entire paragraph.
                            expect($paragraph1.text()).toEqual('foobar');
                            expect(getTextAlignment($paragraph1)).toEqual(alignment);
                        });
                    });
                });
                function getToolbar() {
                    return $toolbar;
                }
                function boldButton($toolbar) {
                    return $toolbar.find('.ql-bold');
                }
                function italicButton($toolbar) {
                    return $toolbar.find('.ql-italic');
                }
                function underlineButton($toolbar) {
                    return $toolbar.find('.ql-underline');
                }
                function fontSelect($toolbar) {
                    return $toolbar.find('.ql-font');
                }
                function fontSizeSelect($toolbar) {
                    return $toolbar.find('.ql-size');
                }
                function textAlignmentSelect($toolbar) {
                    return $toolbar.find('.ql-align');
                }
                function setSelectValue($select, value) {
                    // See powerbi.visuals.RichText.Toolbar.setSelectValue() for description.
                    // NOTE: For unit tests case we have to use document.createEvent() because PhantomJS does
                    // not appear to support new UIEvent (https://github.com/ariya/phantomjs/issues/11289).
                    $select.val(value);
                    var evt = document.createEvent('UIEvent');
                    evt.initUIEvent('change', false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                function getSelectText($select) {
                    return $select.children('option:selected').text();
                }
            });
            function switchToViewMode(viewMode) {
                getViewModeSpy.and.returnValue(viewMode);
                textbox.onViewModeChanged(viewMode);
            }
            function verifyEditor($element, present) {
                expect($element).toHaveClass('richtextbox');
                if (present) {
                    var $container = $element.children('div').eq(0);
                    expect($container).toBeDefined();
                    expect(setToolbarSpy).toHaveBeenCalled();
                    expect($toolbar).toBeDefined();
                    expect($toolbar.hasClass('ql-toolbar')).toBeTruthy();
                    var $editorContainer = $container.find('.ql-container');
                    expect($editorContainer.length).toBe(1);
                    var $editor = $editorContainer.find('.ql-editor');
                    expect($editor.length).toBe(1);
                }
                else {
                    expect($element.find('.ql-editor').length).toBe(0);
                }
            }
        });
        function getTagName($element) {
            return $element.get(0).tagName.toLowerCase();
        }
        function hasBold($element) {
            return getTagName($element) === 'b' || $element.css('font-weight') === 'bold';
        }
        function hasItalic($element) {
            return getTagName($element) === 'i' || $element.css('font-style') === 'italic';
        }
        function hasUnderline($element) {
            return getTagName($element) === 'u' || $element.css('text-decoration') === 'underline';
        }
        function getUrl($element) {
            var $anchor = (getTagName($element) === 'a') ? $element : $element.find('a');
            return $anchor.attr('href');
        }
        function getFont($element) {
            return $element.css('font-family');
        }
        function getFontSize($element) {
            return $element.css('font-size');
        }
        function getTextAlignment($element) {
            return $element.css('text-align');
        }
        function buildParagraphsDataView(paragraphs) {
            return [{ metadata: { columns: [], objects: { general: { paragraphs: paragraphs } } } }];
        }
        function getViewModeParagraphDivs($element) {
            return $element.children('div');
        }
        function getEditModeParagraphDivs($element) {
            var $editor = $element.find('.ql-editor');
            expect($editor.length).toBe(1);
            return $editor.children('div');
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ScatterChart = powerbi.visuals.ScatterChart;
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewPivotCategorical = powerbi.data.DataViewPivotCategorical;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var SemanticType = powerbi.data.SemanticType;
    var ColorUtility = powerbitests.utils.ColorUtility;
    var AxisType = powerbi.axisType;
    var DefaultWaitForRender = 10;
    var axisLabelVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightAxesVisible;
    var axisLabelVisibleGreaterThanMinHeight = axisLabelVisibleMinHeight + 1;
    var axisLabelVisibleSmallerThanMinHeight = axisLabelVisibleMinHeight - 1;
    var axisLabelVisibleGreaterThanMinHeightString = axisLabelVisibleGreaterThanMinHeight.toString();
    var axisLabelVisibleSmallerThanMinHeightString = axisLabelVisibleSmallerThanMinHeight.toString();
    var legendVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightLegendVisible;
    var legendVisibleGreaterThanMinHeight = legendVisibleMinHeight + 1;
    var legendVisibleSmallerThanMinHeight = legendVisibleMinHeight - 1;
    var legendVisibleGreaterThanMinHeightString = legendVisibleGreaterThanMinHeight.toString();
    var legendVisibleSmallerThanMinHeightString = legendVisibleSmallerThanMinHeight.toString();
    describe("ScatterChart", function () {
        var categoryColumn = { displayName: 'year', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
        it('ScatterChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').capabilities).toBe(powerbi.visuals.scatterChartCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.scatterChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.scatterChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.scatterChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.scatterChartCapabilities.objects)).toEqual(powerbi.visuals.scatterChartProps.general.formatString);
        });
        it('preferred capability does not support zero rows', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }
                ],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: categoryColumn,
                        values: []
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: []
                    }]),
                }
            };
            expect(powerbi.DataViewAnalysis.supports(dataView, powerbi.visuals.scatterChartCapabilities.dataViewMappings[0], true)).toBe(false);
        });
        it('preferred capability does not support one row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }
                ],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: categoryColumn,
                        values: [2012, 2013]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [200]
                    }]),
                }
            };
            expect(powerbi.DataViewAnalysis.supports(dataView, powerbi.visuals.scatterChartCapabilities.dataViewMappings[0], true)).toBe(false);
        });
    });
    function scatterChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
            ]
        };
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'col2', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) }
            ],
        };
        var hostServices;
        beforeEach(function () {
            if (interactiveChart)
                powerbitests.helpers.suppressDebugAssertFailure();
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            hostServices = powerbitests.mocks.createVisualHostServices();
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: interactiveChart },
            });
        });
        function getOptionsForValueWarnings(values) {
            var options = {
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: values,
                            subtotal: 2465000
                        }])
                    }
                }]
            };
            return options;
        }
        it('NaN in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, NaN, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Negative Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, Number.NEGATIVE_INFINITY, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Positive Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, Number.POSITIVE_INFINITY, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Out of range value in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, 1e301, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, DefaultWaitForRender);
        });
        it('All okay in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, 480000, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart single measure dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 2465000
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('480K');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart two measure dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, objects: { general: { formatString: '0%' } } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110, 120, 130, 140, 150]
                            },
                            {
                                source: metadata.columns[2],
                                values: [.21, .22, .23, .24, .25]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('110');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('21%');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
                expect($('.scatterChart .mainGraphicsContext .dot')[0].style.fillOpacity).toBe("0");
                expect($('.scatterChart .mainGraphicsContext .dot')[0].style.strokeOpacity).toBe("0.85");
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe('6');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart series dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, objects: { general: { formatString: '0%' } } },
                    { displayName: 'col4', isMeasure: true },
                ]
            };
            v.onDataChanged({
                dataViews: [DataViewPivotCategorical.apply({
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110, 120]
                            },
                            {
                                source: metadata.columns[2],
                                values: [210, 220]
                            },
                            {
                                source: metadata.columns[3],
                                values: [310, 320]
                            }
                        ])
                    }
                })]
            });
            var legendClassSelector = interactiveChart ? ".interactive-legend" : '.legend';
            var itemsNumber = interactiveChart ? 3 : 2;
            setTimeout(function () {
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(2);
                var length = $(legendClassSelector + (interactiveChart ? ' .item' : 'Text')).length;
                expect($(legendClassSelector).length).toBe(1);
                expect(length).toBe(itemsNumber);
                if (!interactiveChart)
                    expect($('.legendTitle').text()).toBe('col1');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart measure and size dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110, 120, 130, 140, 150]
                            },
                            {
                                source: metadata.columns[2],
                                values: [210, 220, 230, 240, 250]
                            },
                            {
                                source: metadata.columns[3],
                                values: [310, 320, 330, 340, 350]
                            }
                        ])
                    }
                }]
            });
            var r = interactiveChart ? 45 : 51.5; // interactive legend is bigger
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('110');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('210');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r, -0.31);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart gridline dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [50000, 49500, 49000, 48000, 50000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis.showLinesOnAxis').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis.showLinesOnAxis').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart single category value dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1', type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a')],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110]
                            },
                            {
                                source: metadata.columns[2],
                                values: [210]
                            },
                            {
                                source: metadata.columns[3],
                                values: [310]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('80');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('140');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('200');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('400');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(1);
                var r = (interactiveChart ? 45 : 51.5).toString();
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe(r);
                expect($('.legendItem').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart no category dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: null,
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[0],
                                values: [110]
                            },
                            {
                                source: metadata.columns[1],
                                values: [210]
                            },
                            {
                                source: metadata.columns[2],
                                values: [310]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(1);
                var r = (interactiveChart ? 45 : 51.5).toString(); // interactive legend is bigger
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe(r);
                expect($('.scatterChart .mainGraphicsContext .dot').find('title').first().text()).toBe('');
                expect($('.legendItem').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('empty scatter chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: []
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: []
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                done();
            }, DefaultWaitForRender);
        });
        it('ensure scatter chart is cleared when an empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [50000, 49500, 49000, 48000, 50000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var scatterCount = $('.scatterChart').find('.dot').length;
                expect(scatterCount).toBe(5);
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: []
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [],
                                subtotal: 0
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    var scatterCount = $('.scatterChart').find('.dot').length;
                    expect(scatterCount).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('scatter chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.5, 2.0, 1.5, 1.0, 2.5]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.5, 2.0, 1.5, 1.0, 2.5]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1.2, 2.3, 1.8, 3.7, 2.6]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('3');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('3');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart nested svg dom validation', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [5, 20, 15, 10, 25]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.5, 2.0, 1.5, 1.0, 2.5]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1.2, 2.3, 1.8, 3.7, 2.6]
                            }
                        ])
                    }
                }]
            });
            expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
            expect($('.scatterChart .mainGraphicsContext').find('svg')).toBeDefined();
        });
        it('scatter chart does not show less ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [32, 45]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [26.125, 26.125]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [3, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('30');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'X-Axis', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'Size', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'Y-Axis', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110, 120, 130, 140, 150]
                            },
                            {
                                source: metadata.columns[2],
                                values: [210, 220, 230, 240, 250]
                            },
                            {
                                source: metadata.columns[3],
                                values: [310, 320, 330, 340, 350]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').text()).toBe('X-Axis');
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').text()).toBe('Y-Axis');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart on small tile shows at least two tick lines dom validation', function (done) {
            v.onResizing({
                height: 101,
                width: 226
            }, 0);
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [3, 5, 7]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.15');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('0.16');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('0.15');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('0.16');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart onResize big tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [3, 15, 27],
                                min: 0,
                                max: 30
                            }
                        ])
                    }
                }]
            });
            v.onResizing({
                height: 500,
                width: 500
            }, 0);
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 42.5;
                r1 = 32.5;
                r2 = 18;
            }
            else {
                r0 = 49;
                r1 = 37.5;
                r2 = 20.5;
            }
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart onResize medium tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [3, 15, 27],
                                min: 0,
                                max: 30
                            }
                        ])
                    }
                }]
            });
            v.onResizing({
                height: 300,
                width: 300
            }, 0);
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 23;
                r1 = 17.5;
                r2 = 9.5;
            }
            else {
                r0 = 29.5;
                r1 = 22.5;
                r2 = 12.5;
            }
            ;
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart onResize small tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [0.1495, 0.15, 0.1633]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [3, 15, 27],
                                min: 0,
                                max: 30
                            }
                        ])
                    }
                }]
            });
            v.onResizing({
                height: 100,
                width: 200
            }, 0);
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 3.5;
                r1 = 2.5;
                r2 = 1.5;
            }
            else {
                r0 = 10;
                r1 = 7.5;
                r2 = 4;
            }
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("scatterChart DOM validation", function () { return scatterChartDomValidation(false); });
    describe("interactive scatterChart DOM validation", function () { return scatterChartDomValidation(true); });
    //Data Labels
    function scatterChartDataLabelsValidation(interactiveChart) {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: DataShapeUtility.describeDataType(2048 /* String */)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: DataShapeUtility.describeDataType(1 /* Number */),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    isMeasure: false,
                    type: DataShapeUtility.describeDataType(4 /* DateTime */),
                    format: 'd'
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataWithLabelsOnObject = powerbi.Prototype.inherit(dataViewMetadata);
        dataViewMetadataWithLabelsOnObject.objects = { categoryLabels: { show: true }, labels: { show: true, labelPrecision: 0 } };
        var dataViewMetadataWithLabelsOffObject = powerbi.Prototype.inherit(dataViewMetadata);
        dataViewMetadataWithLabelsOffObject.objects = { categoryLabels: { show: false } };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: interactiveChart },
            });
        });
        it('scatter chart show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsOnObject.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsOnObject.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('a');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart labels style validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsOnObject.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsOnObject.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var dotFill = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .dot').first().css('fill');
                var labelFill = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().css('fill');
                expect(ColorUtility.convertFromRGBorHexToHex(labelFill).toUpperCase()).toBe(ColorUtility.convertFromRGBorHexToHex(dotFill).toUpperCase());
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart labels custom style validation', function (done) {
            var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
            var dataViewMetadataWithLabelsFillObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsFillObject.objects = { categoryLabels: { show: true, color: color }, labels: { show: true, labelPrecision: 0 } };
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsFillObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataWithLabelsFillObject.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsFillObject.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                var fill = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().css('fill');
                expect(ColorUtility.convertFromRGBorHexToHex(fill).toUpperCase()).toBe('#FF0000');
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart hide labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOffObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsOffObject.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                            subtotal: 246500
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart data labels multi-series', function (done) {
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                objects: {
                    categoryLabels: { show: true },
                    // Force axis ranges to ensure data labels are visible
                    valueAxis: { start: 0, end: 100 },
                    categoryAxis: { start: -100, end: 300 },
                },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }
            ], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: seriesValues,
                            identity: seriesIdentities,
                            identityFields: [seriesIdentityField],
                        }],
                        values: valueColumns
                    }
                }]
            });
            setTimeout(function () {
                var labels = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels');
                var dots = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .dot');
                expect(dots.length).toBe(labels.length);
                for (var i = 0; i < dots.length; i++) {
                    var dotFill = dots.eq(i).css('fill');
                    var labelFill = labels.eq(i).css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(dotFill)).toBe(ColorUtility.convertFromRGBorHexToHex(labelFill));
                }
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart with nulls dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [null, 10, null, 15, null],
                            subtotal: 20
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('change scatter chart dom data label validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsOnObject.columns[1],
                            values: [500000, 495000, 490000, 480000, 500000],
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('a');
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['q', 'w', 'r', 't']
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataWithLabelsOnObject.columns[1],
                                values: [400, 500, 300, 200],
                            }])
                        }
                    }]
                });
                setTimeout(function () {
                    expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                    expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('q');
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        //empty dom
        it('empty scatter chart dom data labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: []
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: []
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        //One point
        it('scatter chart with single point dom data label validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataWithLabelsOnObject,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a']
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [4]
                        }])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').text()).toBe('a');
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("scatterChart Data Labels validation", function () { return scatterChartDataLabelsValidation(false); });
    describe("interactive scatterChart Data Labels validation", function () { return scatterChartDataLabelsValidation(true); });
    describe("scatterChart bubble radius validation", function () {
        it('scatter chart getBubblePixelAreaSizeRange validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var bubblePixelArea = ScatterChart.getBubblePixelAreaSizeRange(viewport, 100, 200);
            expect(bubblePixelArea.minRange).toBe(278);
            expect(bubblePixelArea.maxRange).toBe(556);
            expect(bubblePixelArea.delta).toBe(278);
        });
        it('scatter chart projectSizeToPixel validation', function () {
            var element = powerbitests.helpers.testDom('500', '500');
            var v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: metadata.columns[1],
                                values: [110, 120, 130, 140, 150]
                            },
                            {
                                source: metadata.columns[2],
                                values: [210, 220, 230, 240, 250]
                            },
                            {
                                source: metadata.columns[3],
                                values: [310, 320, 330, 340, 350]
                            }
                        ])
                    }
                }]
            });
            var actualSizeDataRange = {
                minRange: 310,
                maxRange: 350,
                delta: 40
            };
            var bubblePixelAreaSizeRange = {
                minRange: 278,
                maxRange: 556,
                delta: 278
            };
            var projectedSize = ScatterChart.projectSizeToPixels(310, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(19);
            projectedSize = ScatterChart.projectSizeToPixels(320, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(21);
            projectedSize = ScatterChart.projectSizeToPixels(330, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(23);
        });
    });
    describe("scatterChart converter validation", function () {
        it('scatter chart dataView with role validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }
            ], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: seriesValues,
                        identity: seriesIdentities,
                    }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(0);
            expect(dataPoints[0].y).toBe(10);
            expect(dataPoints[0].fill).toBeDefined();
            expect(dataPoints[0].fill).not.toBe(dataPoints[1].fill);
            expect(scatterChartData.xCol).toBe(metadata.columns[1]);
            expect(scatterChartData.size).toBe(metadata.columns[2]);
            expect(scatterChartData.yCol).toBe(metadata.columns[3]);
            // No legend if we don't have a field in legend
            expect(scatterChartData.legendData.dataPoints.map(function (l) { return l.label; })).toEqual(['a', 'b', 'c']);
            var legendColors = scatterChartData.legendData.dataPoints.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            expect(scatterChartData.legendData.title).toBe('series');
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: 'a' }, { displayName: 'value1', value: '0' }, { displayName: 'value3', value: '10' }, { displayName: 'value2', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value3', value: '20' }, { displayName: 'value2', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value3', value: '30' }, { displayName: 'value2', value: '3' }]);
        });
        it('scatter chart null legend', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'value1', groupName: null, isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: null, isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: null, isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = [null, 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }
            ], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var groupedValues = valueColumns.grouped();
            groupedValues[0].objects = { dataPoint: { fill: { solid: { color: '#41BEE1' } } } };
            valueColumns.grouped = function () { return groupedValues; };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: seriesValues,
                        identity: seriesIdentities,
                    }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var legendItems = scatterChartData.legendData.dataPoints;
            expect(legendItems[0].label).toBe(powerbi.visuals.valueFormatter.format(null));
            expect(legendItems[0].color).toBe('#41BEE1');
            var legendColors = legendItems.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            //Tooltips
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: '(Blank)' }, { displayName: 'value1', value: '0' }, { displayName: 'value3', value: '10' }, { displayName: 'value2', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value3', value: '20' }, { displayName: 'value2', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value3', value: '30' }, { displayName: 'value2', value: '3' }]);
        });
        it('scatter chart dataView without role validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "y", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "size", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "y", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "size", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "y", type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "size", type: DataShapeUtility.describeDataType(1 /* Number */) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[2],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[3],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                },
                {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[5],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[6],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                },
                {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[8],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                },
                {
                    source: metadata.columns[9],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }
            ], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: seriesValues,
                        identity: seriesIdentities,
                    }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(0);
            expect(dataPoints[0].y).toBe(10);
            expect(dataPoints[0].fill).toBeDefined();
            expect(dataPoints[0].fill).not.toBe(dataPoints[1].fill);
            var legendItems = scatterChartData.legendData.dataPoints;
            expect(legendItems.map(function (l) { return l.label; })).toEqual(['a', 'b', 'c']);
            var legendColors = legendItems.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: 'a' }, { displayName: 'value1', value: '0' }, { displayName: 'value2', value: '10' }, { displayName: 'value3', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value2', value: '20' }, { displayName: 'value3', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value2', value: '30' }, { displayName: 'value3', value: '3' }]);
        });
        it('scatter chart dataView with min/max', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                            min: 310,
                            max: 350
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
        });
        it('scatter chart dataView with minLocal/maxLocal', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                            minLocal: 310,
                            maxLocal: 350
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
            expect(dataPoints[0].fill).toBeDefined();
        });
        it('scatter chart dataView without min/minLocal/max/maxLocal', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
            expect(dataPoints[0].fill).toBeDefined();
        });
        it('scatterChart multi-series', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var SelectKind = powerbi.data.SelectKind;
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe('2012');
            expect(scatterChartData[0].x).toBe(150);
            expect(scatterChartData[0].y).toBe(30);
            expect(scatterChartData[0].fill).toBeDefined();
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[3].fill);
            //Tooltips
            expect(scatterChartData[0].tooltipInfo).toEqual([{ displayName: '', value: '2012' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '150.00' }, { displayName: '', value: '30' }]);
            expect(scatterChartData[1].tooltipInfo).toEqual([{ displayName: '', value: '2012' }, { displayName: '', value: 'United States' }, { displayName: '', value: '100.00' }, { displayName: '', value: '300' }]);
            expect(scatterChartData[2].tooltipInfo).toEqual([{ displayName: '', value: '2011' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '177.00' }, { displayName: '', value: '25' }]);
            expect(scatterChartData[3].tooltipInfo).toEqual([{ displayName: '', value: '2011' }, { displayName: '', value: 'United States' }, { displayName: '', value: '149.00' }, { displayName: '', value: '250' }]);
            expect(scatterChartData[4].tooltipInfo).toEqual([{ displayName: '', value: '2010' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '157.00' }, { displayName: '', value: '28' }]);
            expect(scatterChartData[5].tooltipInfo).toEqual([{ displayName: '', value: '2010' }, { displayName: '', value: 'United States' }, { displayName: '', value: '144.00' }, { displayName: '', value: '280' }]);
        });
        it('scatterChart multi-series with default color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var SelectKind = powerbi.data.SelectKind;
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            dataView.metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].category).toBe('2012');
            expect(scatterChartData[0].x).toBe(150);
            expect(scatterChartData[0].y).toBe(30);
            expect(scatterChartData[0].fill).toBe(hexDefaultColorRed);
            expect(scatterChartData[0].fill).toBe(scatterChartData[2].fill);
            expect(scatterChartData[0].fill).toBe(scatterChartData[3].fill);
        });
        it('scatterChart multi-series with explicit colors', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var SelectKind = powerbi.data.SelectKind;
            var dsrResult = { "DataShapes": [{ "Id": "DS0", "SecondaryHierarchy": [{ "Id": "DM1", "Instances": [{ "Calculations": [{ "Id": "G1", "Value": "'Canada'" }] }, { "Calculations": [{ "Id": "G1", "Value": "'United States'" }] }] }], "PrimaryHierarchy": [{ "Id": "DM0", "Instances": [{ "Calculations": [{ "Id": "G0", "Value": "2012L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "150D" }, { "Id": "M1", "Value": "30L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "100D" }, { "Id": "M1", "Value": "300L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2011L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "177D" }, { "Id": "M1", "Value": "25L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "149D" }, { "Id": "M1", "Value": "250L" }] }] }, { "Calculations": [{ "Id": "G0", "Value": "2010L" }], "Intersections": [{ "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "157D" }, { "Id": "M1", "Value": "28L" }] }, { "Id": "I0", "Calculations": [{ "Id": "M0", "Value": "144D" }, { "Id": "M1", "Value": "280L" }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "G0", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "M0", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "M1", "Format": "#,0" },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "G1" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 3,
                            }]
                        }]
                    }
                }
            }, dsrResult, 's').dataView;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var groupedValues = dataView.categorical.values.grouped();
            groupedValues[0].objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: 'green' } } } };
            dataView.categorical.values.grouped = function () { return groupedValues; };
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].fill).toBe('red');
            expect(scatterChartData[1].fill).toBe('green');
        });
        it('scatterChart categorical with explicit colors', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var categoryIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'category' });
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: categoryValues,
                        identity: categoryIdentities,
                        identityFields: [categoryIdentityField],
                        objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE1' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE2' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE3' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].fill).toBe('#41BEE0');
            expect(scatterChartData[1].fill).toBe('#41BEE1');
            expect(scatterChartData[2].fill).toBe('#41BEE2');
            expect(scatterChartData[3].fill).toBe('#41BEE3');
            expect(scatterChartData[4].fill).toBe('#41BEE4');
        });
        it('scatterChart multi-series with min/max', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var SelectKind = powerbi.data.SelectKind;
            var dsrResult = { "DataShapes": [{ "Id": "Chart2", "Calculations": [{ "Id": "MinSize", "Value": "1L" }, { "Id": "MaxSize", "Value": "404L" }], "SecondaryHierarchy": [{ "Id": "SeriesMember", "Instances": [{ "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Equipment Failure'", "Key": "2Equipment Failure" }] } }, "Calculations": [{ "Id": "Label2", "Value": "'Equipment Failure'" }] }, { "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Scheduled Outage'", "Key": "2Scheduled Outage" }] } }, "Calculations": [{ "Id": "Label2", "Value": "'Scheduled Outage'" }] }, { "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Trees/Vegetation'", "Key": "2Trees/Vegetation" }] } }, "Calculations": [{ "Id": "Label2", "Value": "'Trees/Vegetation'" }] }, { "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Under Investigation'", "Key": "2Under Investigation" }] } }, "Calculations": [{ "Id": "Label2", "Value": "'Under Investigation'" }] }] }], "PrimaryHierarchy": [{ "Id": "CategoryMember", "Instances": [{ "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Bellevue, WA'", "Key": "2Bellevue, WA" }] } }, "Calculations": [{ "Id": "Label", "Value": "'Bellevue, WA'" }], "Intersections": [{ "Id": "Cell", "Calculations": [{ "Id": "X", "Value": null }, { "Id": "Y", "Value": null }, { "Id": "Size", "Value": null }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": null }, { "Id": "Y", "Value": null }, { "Id": "Size", "Value": null }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": "126439L" }, { "Id": "Y", "Value": "4244.0000000037253D" }, { "Id": "Size", "Value": "1L" }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": "126439L" }, { "Id": "Y", "Value": "239.99999999650754D" }, { "Id": "Size", "Value": "1L" }] }] }, { "Group": { "ScopeId": { "ScopeValues": [{ "Value": "'Deming, WA'", "Key": "2Deming, WA" }] } }, "Calculations": [{ "Id": "Label", "Value": "'Deming, WA'" }], "Intersections": [{ "Id": "Cell", "Calculations": [{ "Id": "X", "Value": null }, { "Id": "Y", "Value": null }, { "Id": "Size", "Value": null }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": "353L" }, { "Id": "Y", "Value": "8078.00000000163D" }, { "Id": "Size", "Value": "4L" }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": null }, { "Id": "Y", "Value": null }, { "Id": "Size", "Value": null }] }, { "Id": "Cell", "Calculations": [{ "Id": "X", "Value": null }, { "Id": "Y", "Value": null }, { "Id": "Size", "Value": null }] }] }] }], "IsComplete": true }] };
            var propertyRef1 = { Entity: 't', Property: 'p1' };
            var propertyRef2 = { Entity: 't', Property: 'p2' };
            var dataView = powerbi.data.dsr.readDsr({
                Select: [
                    { "Kind": 1 /* Group */, "Depth": 0, "Value": "Label", "Format": "0" },
                    { "Kind": 2 /* Measure */, "Value": "X", "Format": "#,0.00" },
                    { "Kind": 2 /* Measure */, "Value": "Y", "Format": "#,0" },
                    { "Kind": 2 /* Measure */, "Value": "Size", "Format": "#,0", "Min": ["MinSize"], "Max": ["MaxSize"] },
                    { "Kind": 1 /* Group */, "SecondaryDepth": 0, "Value": "Label2" }
                ],
                Expressions: {
                    Primary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef1,
                                Select: 0,
                            }]
                        }]
                    },
                    Secondary: {
                        Groupings: [{
                            Keys: [{
                                Source: propertyRef2,
                                Select: 4,
                            }]
                        }]
                    },
                    Aggregates: {
                        Select: 3,
                        Kind: 3
                    }
                }
            }, dsrResult, 's').dataView;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe('Bellevue, WA');
            expect(scatterChartData[0].x).toBe(126439);
            expect(scatterChartData[0].y).toBe(4244.000000003725);
            expect(scatterChartData[0].fill).toBeDefined();
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[2].fill);
        });
        it('scatter chart dataView that should pivot categories', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: '', queryName: '$s1', index: 0 },
                    { displayName: '', queryName: '$s2', isMeasure: true, index: 1 },
                    { displayName: '', queryName: '$s3', isMeasure: true, index: 2 },
                    { displayName: '', queryName: '$s4', isMeasure: true, index: 3 }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220]
                        },
                        {
                            source: metadata.columns[3],
                            values: [310, 320]
                        }
                    ])
                }
            };
            var pivotedDataView = DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: powerbi.visuals.plugins.scatterChart.capabilities.objects,
                dataViewMappings: powerbi.visuals.plugins.scatterChart.capabilities.dataViewMappings,
                transforms: {
                    selects: [
                        { displayName: 'col1', queryName: '$s1', roles: { 'Series': true } },
                        { displayName: 'col2', queryName: '$s2', roles: { 'Y': true } },
                        { displayName: 'col3', queryName: '$s3', roles: { 'Size': true } },
                        { displayName: 'col4', queryName: '$s4', roles: { 'X': true } },
                    ]
                },
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
            })[0];
            expect(pivotedDataView).not.toBe(dataView);
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(pivotedDataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe(null);
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[1].fill);
            //Tooltips
            expect(scatterChartData[0].tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col4', value: '310' }, { displayName: 'col2', value: '110' }, { displayName: 'col3', value: '210' }]);
            expect(scatterChartData[1].tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col4', value: '320' }, { displayName: 'col2', value: '120' }, { displayName: 'col3', value: '220' }]);
        });
        it('scatter chart bubble color category no size', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe(dataPoints[1].fill);
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col3', value: '210' }, { displayName: 'col2', value: '110' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col3', value: '220' }, { displayName: 'col2', value: '120' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'col1', value: 'c' }, { displayName: 'col3', value: '230' }, { displayName: 'col2', value: '130' }]);
            expect(dataPoints[3].tooltipInfo).toEqual([{ displayName: 'col1', value: 'd' }, { displayName: 'col3', value: '240' }, { displayName: 'col2', value: '140' }]);
            expect(dataPoints[4].tooltipInfo).toEqual([{ displayName: 'col1', value: 'e' }, { displayName: 'col3', value: '250' }, { displayName: 'col2', value: '150' }]);
        });
        it('scatter chart bubble color category no size default color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var hexDefaultColorRed = "#FF0000";
            metadata.objects = {
                dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } }
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe(hexDefaultColorRed);
        });
        it('scatter chart null X axes values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                        objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE1' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE2' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE3' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [null, null, null, null, null]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null Y axes values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [null, null, null, null, null]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [110, 120, 130, 140, 150]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null X measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { "Y": true } }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e']
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: null
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null Y measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                        objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE1' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE2' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE3' } } } }, { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [210, 220, 230, 240, 250]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints[0].category).toBe('a');
            expect(scatterChartDataPoints[1].fill).toBe('#41BEE1');
            expect(scatterChartDataPoints[0].x).toBe(210);
            expect(scatterChartDataPoints[0].y).toBe(0);
        });
        it('scatter chart null X and Y measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: null
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart converter data labels default values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a'],
                        identity: categoryIdentities,
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210]
                        }
                    ])
                }
            };
            var dataLabelsSettings = powerbi.visuals.dataLabelUtils.getDefaultPointLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            expect(scatterChartData.dataLabelsSettings).toEqual(dataLabelsSettings);
        });
        it('scatter chart bubble gradient color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col5', isMeasure: true, roles: { "Gradient": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: "#d9f2fb" } } } },
                { dataPoint: { fill: { solid: { color: "#b1eab7" } } } },
                { dataPoint: { fill: { solid: { color: "#cceab7" } } } },
                { dataPoint: { fill: { solid: { color: "#b100b7" } } } },
                { dataPoint: { fill: { solid: { color: "#cceab7" } } } }
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b', 'c', 'd', 'e'],
                        identity: categoryIdentities,
                        objects: objectDefinitions
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        },
                        {
                            source: metadata.columns[3],
                            values: [10, 20, 15, 10, 100]
                        },
                        {
                            source: metadata.columns[4],
                            values: [13, 33, 55, 11, 55]
                        }
                    ])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe('#d9f2fb');
            expect(dataPoints[1].fill).toBe('#b1eab7');
            expect(dataPoints[2].fill).toBe('#cceab7');
            expect(dataPoints[3].fill).toBe('#b100b7');
            expect(dataPoints[4].fill).toBe('#cceab7');
        });
    });
    describe('scatterChart interactivity', function () {
        var v, element;
        var hostServices;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
            ]
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            hostServices = powerbitests.mocks.createVisualHostServices();
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        it('scatter chart single select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart repeated single select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart multi select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[4]);
                var mockEvent = {
                    abc: 'def',
                    ctrlKey: true,
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        },
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger4(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]],
                        },
                        {
                            data: [categoryIdentities[1]]
                        },
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                trigger1(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        },
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                trigger3(mockEvent);
                trigger4(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart single and multi select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[4]);
                var singleEvent = {
                    abc: 'def',
                    stopPropagation: function () {
                    },
                };
                var multiEvent = {
                    abc: 'def',
                    ctrlKey: true,
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(singleEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(multiEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        },
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger1(singleEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                trigger4(multiEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        },
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                trigger3(singleEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart external clear', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                identities[3]
                            ]
                        }
                    ]
                });
                v.onClearSelection();
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart clear on clearCatcher click', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () {
                    },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                identities[3]
                            ]
                        }
                    ]
                });
                ($('.clearCatcher').last()).d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("interactive legend scatterChart validation", function () {
        var v;
        var element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) }
            ]
        };
        var identities = [
            powerbitests.mocks.dataViewScopeIdentity('a'),
            powerbitests.mocks.dataViewScopeIdentity('b'),
            powerbitests.mocks.dataViewScopeIdentity('c'),
            powerbitests.mocks.dataViewScopeIdentity('d'),
            powerbitests.mocks.dataViewScopeIdentity('e'),
        ];
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: identities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [110, 120, 130, 140, 150]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [210, 220, 230, 240, 250]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [310, 320, 330, 340, 350]
                            }
                        ])
                    }
                }]
            });
        });
        it('Interaction scatter chart click validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) {
                return d.category === 'd';
            });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var mouseCordinate = { x: x + 3, y: y + 2 };
            spyOn(scatterChart.interactivityService.behavior, 'getMouseCoordinates').and.returnValue(mouseCordinate);
            scatterChart.interactivityService.behavior.onClick();
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, DefaultWaitForRender);
        });
        it('Scatter chart drag interaction validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) {
                return d.category === 'd';
            });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var mouseCordinate = { x: x, y: y };
            spyOn(scatterChart.interactivityService.behavior, 'getMouseCoordinates').and.returnValue(mouseCordinate);
            scatterChart.interactivityService.behavior.onDrag();
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, DefaultWaitForRender);
        });
        it('Interaction scatter chart dotClick validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) {
                return d.category === 'd';
            });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var selectedDotIndex = scatterChart.interactivityService.behavior.findClosestDotIndex(x, y);
            scatterChart.interactivityService.behavior.selectDotByIndex(selectedDotIndex);
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, DefaultWaitForRender);
        });
    });
    function validateInteraction(x, y, scatterChart) {
        //test crosshair position
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('y1')).toBe(y.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('y2')).toBe(y.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('x1')).toBe(x.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('x2')).toBe(x.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('x1')).toBe('0');
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('x2')).toBe(scatterChart.mainGraphicsContext.attr('width').toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('y1')).toBe(scatterChart.mainGraphicsContext.attr('height').toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('y2')).toBe('0');
        //test style => dot 3 should be selected
        expect(scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) {
            return (d.x !== 140) && (d.y !== 240);
        }).attr('class')).toBe("dot notSelected");
        expect(scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) {
            return (d.x === 140) && (d.y === 240);
        }).attr('class')).toBe("dot selected");
        //test legend
        expect($('.interactive-legend').find('.title').text().trim()).toMatch("d");
        expect($('.interactive-legend').find('.item').find('.itemName')[0].innerText.trim()).toBe('col2');
        expect($('.interactive-legend').find('.item').find('.itemName')[1].innerText.trim()).toBe('col4');
        expect($('.interactive-legend').find('.item').find('.itemName')[2].innerText.trim()).toBe('col3');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[0].innerText.trim()).toBe('140');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[1].innerText.trim()).toBe('340');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[2].innerText.trim()).toBe('240');
    }
    describe("scatterChart axis label existence validation", function () {
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, false, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, true, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, false, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, true, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(0);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, true, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, true, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("scatterChart legends existence validation", function () {
        it('scatter chart legends existence dom validation with viewport height greater than legendVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(legendVisibleGreaterThanMinHeightString, "500", false, false);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height smaller than legendVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(legendVisibleSmallerThanMinHeightString, "500", false, false);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height smaller than legendVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(legendVisibleSmallerThanMinHeightString, legendVisibleSmallerThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.legend .label').length).toBe(0);
                expect($('.legend .item').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height greater than legendVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(legendVisibleGreaterThanMinHeightString, "500", false, true);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: DataShapeUtility.describeDataType(SemanticType.Integer) }
            ]
        };
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities,
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [100, 200, 300, 400, 500]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(5);
                for (var i = 0; i < points.length; i++) {
                    expect(_.contains(categoryValues, points[i].displayName)).toBeTruthy();
                    expect(points[i].properties['fill']).toBeDefined();
                }
                done();
            }, DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify x-axis property card for scatter chart', function () {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataFourColumn.columns[1],
                                values: [1, 2, 3, 4, 5]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[2],
                                values: [200, 400, 600, 800, 1000]
                            },
                            {
                                source: dataViewMetadataFourColumn.columns[3],
                                values: [1, 2, 3, 4, 5]
                            }
                        ])
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
            expect('start' in points[0].properties).toBeTruthy(); //better to check if the index key is found
            expect('end' in points[0].properties).toBeTruthy();
            expect('axisType' in points[0].properties).toBeFalsy();
            expect('show' in points[0].properties).toBeTruthy();
            expect('showAxisTitle' in points[0].properties).toBeTruthy();
            expect('axisStyle' in points[1].properties).toBeTruthy();
        });
        it('X-axis customization: Test forced domain (start and end)', function () {
            dataViewMetadataFourColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 25,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: [1, 2, 3, 4, 5],
                        }]
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            var labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0');
            expect(labels[labels.length - 1].textContent).toBe('25');
        });
        it('Y-axis customization: Test forced domain (start and end)', function () {
            dataViewMetadataFourColumn.objects = {
                valueAxis: {
                    show: true,
                    position: 'Right',
                    start: 0,
                    end: 500,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataFourColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataFourColumn.columns[0],
                            values: [1, 2, 3, 4, 5],
                        }]
                    }
                }]
            };
            v.onDataChanged(dataChangedOptions);
            var labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0');
            expect(labels[labels.length - 1].textContent).toBe('500');
        });
    });
    function testAxisAndLegendExistence(domSizeHeightString, domSizeWidthString, isInteractive, isMobile) {
        var element = powerbitests.helpers.testDom(domSizeHeightString, domSizeWidthString);
        var v;
        if (isMobile) {
            v = powerbi.visuals.visualPluginFactory.createMobile().getPlugin('scatterChart').create();
        }
        else {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
        }
        v.init({
            element: element,
            host: powerbitests.mocks.createVisualHostServices(),
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true },
            interactivity: { isInteractiveLegend: isInteractive },
        });
        // Category and series are the same field
        var metadata = {
            columns: [
                { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            ],
            objects: { categoryLabels: { show: true } },
        };
        var seriesValues = ['a', 'b', 'c'];
        var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
        var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
        var valueColumns = DataViewTransform.createValueColumns([
            {
                source: metadata.columns[1],
                values: [0, null, null],
                identity: seriesIdentities[0],
            },
            {
                source: metadata.columns[2],
                values: [1, null, null],
                identity: seriesIdentities[0],
            },
            {
                source: metadata.columns[3],
                values: [10, null, null],
                identity: seriesIdentities[0],
            },
            {
                source: metadata.columns[4],
                values: [null, 100, null],
                identity: seriesIdentities[1],
            },
            {
                source: metadata.columns[5],
                values: [null, 2, null],
                identity: seriesIdentities[1],
            },
            {
                source: metadata.columns[6],
                values: [null, 20, null],
                identity: seriesIdentities[1],
            },
            {
                source: metadata.columns[7],
                values: [null, null, 200],
                identity: seriesIdentities[2],
            },
            {
                source: metadata.columns[8],
                values: [null, null, 3],
                identity: seriesIdentities[2],
            },
            {
                source: metadata.columns[9],
                values: [null, null, 30],
                identity: seriesIdentities[2],
            }
        ], [seriesIdentityField]);
        valueColumns.source = metadata.columns[0];
        v.onDataChanged({
            dataViews: [{
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: seriesValues,
                        identity: seriesIdentities,
                        identityFields: [seriesIdentityField],
                    }],
                    values: valueColumns
                }
            }]
        });
    }
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var visuals = powerbi.visuals;
    describe('ColorAllocatorFactory', function () {
        it('LinearGradient2: min value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: '#ff0000' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(100)).toBe('#ff0000');
        });
        it('LinearGradient2: max value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: '#ff0000' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(200)).toBe('#0000ff');
        });
        it('LinearGradient2: mid value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: '#ff0000' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(150)).toBe('#800080');
        });
        it('LinearGradient2: intermediate value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: '#ff0000' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(120)).toBe('#cc0033');
        });
        it('LinearGradient3: min value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 150, color: '#ffffff' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(100)).toBe('#ff0000');
        });
        it('LinearGradient3: max value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 150, color: '#ffffff' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(200)).toBe('#0000ff');
        });
        it('LinearGradient3: mid value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 170, color: '#ffffff' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(170)).toBe('#ffffff');
        });
        it('LinearGradient3: intermediate value', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 176, color: '#ffffff' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(178)).toBe('#eaeaff');
        });
        it('LinearGradient3: between min & mid', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 176, color: '#ffffff' },
                max: { value: 200, color: '#0000ff' },
            });
            expect(colorer.color(170)).toBe('#ffebeb');
        });
        it('LinearGradient2 clamping - test values outside the range', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: '#ff0000' },
                max: { value: 200, color: '#008000' },
            });
            expect(colorer.color(90)).toBe('#ff0000');
            expect(colorer.color(220)).toBe('#008000');
        });
        it('LinearGradient3 clamping - test values outside the range', function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: 100, color: '#ff0000' },
                mid: { value: 150, color: '#ffffff' },
                max: { value: 200, color: '#008000' },
            });
            expect(colorer.color(0)).toBe('#ff0000');
            expect(colorer.color(300)).toBe('#008000');
        });
    });
})(powerbitests || (powerbitests = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbitests;
(function (powerbitests) {
    var GeocodeQuery = powerbi.visuals.BI.Services.GeocodingManager.GeocodeQuery;
    describe('General GeocodeCache Tests', function () {
        var cache;
        var createGeocodingCache = powerbi.visuals.BI.Services.createGeocodingCache;
        var maxCacheSize = 3000;
        var maxCacheSizeOverflow = 100;
        beforeEach(function () {
            cache = createGeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            localStorage.clear();
        });
        it('Cache Hit', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            var utahQuery = new GeocodeQuery("Utah", "State");
            var utahCoord = { latitude: 15, longitude: 15 };
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            cache.registerCoordinates(utahQuery, utahCoord);
            expect(cache.getCoordinates(washingtonQuery)).toEqual(washingtonCoord);
            expect(cache.getCoordinates(utahQuery)).toEqual(utahCoord);
        });
        it('Cache Miss', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            var utahQuery = new GeocodeQuery("Utah", "State");
            var utahCoord = { latitude: 15, longitude: 15 };
            var newYorkQuery = new GeocodeQuery("New York", "State");
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            cache.registerCoordinates(utahQuery, utahCoord);
            expect(cache.getCoordinates(newYorkQuery)).toBeFalsy();
        });
        it('Local storage hit', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            var newCache = createGeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            expect(newCache.getCoordinates(washingtonQuery)).toEqual(washingtonCoord);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var SelectionId = powerbi.visuals.SelectionId;
    describe('Web interactivity service', function () {
        var interactivityService;
        var categoryA = powerbitests.mocks.dataViewScopeIdentity("A");
        var categoryB = powerbitests.mocks.dataViewScopeIdentity("B");
        describe('', function () {
            beforeEach(function () {
                var host = powerbitests.mocks.createVisualHostServices();
                interactivityService = new powerbi.visuals.WebInteractivityService(host);
            });
            it('selecting a single data point should set selected state', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                    { selected: true, identity: SelectionId.createWithId(categoryB, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], false);
                expect(dataPoints[0].selected).toBeTruthy();
                expect(dataPoints[1].selected).toBeFalsy();
            });
            it('selecting a highlighted data point should select non-highlight data point with the same id', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, true) },
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], false);
                expect(dataPoints[0].selected).toBeFalsy();
                expect(dataPoints[1].selected).toBeTruthy();
            });
            it('createPropertiesToHost: selecting a dataPoint should result in a VisualObjectInstance', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], true);
                var propertyIdentifier = {
                    objectName: 'general',
                    propertyName: 'property'
                };
                var result = interactivityService.createPropertiesToHost(propertyIdentifier);
                expect(result.length).toBe(1);
                var firstResult = result[0];
                expect(firstResult.objectName).toBe('general');
                expect(firstResult.properties['property']).toBeDefined();
            });
            it('createPropertiesToHost: no selection should result in empty VisualObjectInstance', function () {
                var propertyIdentifier = {
                    objectName: 'general',
                    propertyName: 'property'
                };
                var result = interactivityService.createPropertiesToHost(propertyIdentifier);
                expect(result.length).toBe(1);
                var firstResult = result[0];
                expect(firstResult.objectName).toBe('general');
                expect(firstResult.properties['property']).toBeUndefined();
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var Slicer = powerbi.visuals.Slicer;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var EventType = powerbitests.helpers.ClickEventType;
    var ValueType = powerbi.ValueType;
    var SelectionId = powerbi.visuals.SelectionId;
    var DefaultWaitForRender = 100;
    describe("Slicer", function () {
        it('Slicer_registered_capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('slicer').capabilities).toBe(powerbi.visuals.slicerCapabilities);
        });
        it('Capabilities should include dataViewMapping', function () {
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings).toBeDefined();
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings.length).toBe(1);
        });
        it('Capabilities should have condition', function () {
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings[0].conditions.length).toBe(1);
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings[0].conditions[0][powerbi.visuals.slicerCapabilities.dataRoles[0].name].max).toBe(1);
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.slicerCapabilities.dataRoles).toBeDefined();
            expect(powerbi.visuals.slicerCapabilities.dataRoles.length).toBe(1);
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(powerbi.visuals.slicerCapabilities.suppressDefaultTitle).toBe(true);
        });
        it('Filter property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFilterOutput(powerbi.visuals.slicerCapabilities.objects)).toEqual(powerbi.visuals.slicerProps.filterPropertyIdentifier);
        });
    });
    describe("Slicer DOM tests", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                { displayName: 'Fruit', properties: { "Category": true }, type: ValueType.fromDescriptor({ text: true }) },
                { displayName: 'Price', isMeasure: true }
            ],
        };
        var dataViewCategorical = {
            categories: [{
                source: dataViewMetadata.columns[0],
                values: ['Apple', 'Orange', 'Kiwi', 'Grapes', 'Banana'],
                identity: [
                    powerbitests.mocks.dataViewScopeIdentity('Apple'),
                    powerbitests.mocks.dataViewScopeIdentity('Orange'),
                    powerbitests.mocks.dataViewScopeIdentity('Kiwi'),
                    powerbitests.mocks.dataViewScopeIdentity('Grapes'),
                    powerbitests.mocks.dataViewScopeIdentity('Banana'),
                ]
            }],
            values: DataViewTransform.createValueColumns([{
                source: dataViewMetadata.columns[1],
                values: [20, 10, 30, 15, 12]
            }]),
        };
        var dataView = {
            metadata: dataViewMetadata,
            categorical: dataViewCategorical
        };
        beforeEach(function () {
            createSlicer();
        });
        function createSlicer() {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('slicer').create();
            var settings;
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
            });
        }
        it('Slicer DOM Validation', function (done) {
            spyOn(powerbi.visuals.valueFormatter, 'format').and.callThrough();
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.slicerContainer')).toBeInDOM();
                expect($('.slicerContainer .headerText')).toBeInDOM();
                expect($('.slicerContainer .slicerHeader .clear')).toBeInDOM();
                expect($('.slicerContainer .slicerBody')).toBeInDOM();
                expect($('.slicerContainer .slicerBody .row .slicerText')).toBeInDOM();
                expect($('.slicerText').length).toBe(5);
                expect($('.slicerText').first().text()).toBe('Apple');
                expect($('.slicerText').last().text()).toBe('Banana');
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith('Apple', undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith('Orange', undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith('Kiwi', undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith('Grapes', undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith('Banana', undefined);
                // Subsequent update
                var dataView2 = {
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Strawberry', 'Blueberry', 'Blackberry'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('Strawberry'),
                                powerbitests.mocks.dataViewScopeIdentity('Blueberry'),
                                powerbitests.mocks.dataViewScopeIdentity('Blackberry'),
                            ]
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [40, 25, 22]
                        }]),
                    }
                };
                v.onDataChanged({ dataViews: [dataView2] });
                setTimeout(function () {
                    expect($('.slicerContainer')).toBeInDOM();
                    expect($('.slicerContainer .headerText')).toBeInDOM();
                    expect($('.slicerContainer .slicerHeader .clear')).toBeInDOM();
                    expect($('.slicerContainer .slicerBody')).toBeInDOM();
                    expect($('.slicerContainer .slicerBody .row .slicerText')).toBeInDOM();
                    expect($('.slicerText').length).toBe(3);
                    expect($('.slicerText').first().text()).toBe('Strawberry');
                    expect($('.slicerText').last().text()).toBe('Blackberry');
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('Validate converter', function (done) {
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var slicerData = Slicer.converter(dataView);
                expect(slicerData.slicerDataPoints.length).toBe(5);
                var dataViewIdentities = dataView.categorical.categories[0].identity;
                var selectionIds = [
                    SelectionId.createWithId(dataViewIdentities[0]),
                    SelectionId.createWithId(dataViewIdentities[1]),
                    SelectionId.createWithId(dataViewIdentities[2]),
                    SelectionId.createWithId(dataViewIdentities[3]),
                    SelectionId.createWithId(dataViewIdentities[4]),
                ];
                var dataPoints = [
                    {
                        value: 'Apple',
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[0],
                        selected: false
                    },
                    {
                        value: 'Orange',
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[1],
                        selected: false
                    },
                    {
                        value: 'Kiwi',
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[2],
                        selected: false
                    },
                    {
                        value: 'Grapes',
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[3],
                        selected: false
                    },
                    {
                        value: 'Banana',
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[4],
                        selected: false
                    }
                ];
                expect(slicerData).toEqual({ categorySourceName: 'Fruit', formatString: undefined, slicerDataPoints: dataPoints });
                done();
            }, DefaultWaitForRender);
        });
        it('Null dataView test', function (done) {
            v.onDataChanged({ dataViews: [] });
            setTimeout(function () {
                expect($('.slicerText').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('Slicer resize', function (done) {
            var viewport = {
                height: 200,
                width: 300
            };
            v.onResizing(viewport, 100);
            setTimeout(function () {
                expect($('.slicerContainer .slicerBody').first().css('height')).toBe('160px');
                expect($('.slicerContainer .slicerBody').first().css('width')).toBe('300px');
                expect($('.slicerContainer .headerText').first().css('width')).toBe('271px');
                // Next Resize
                var viewport2 = {
                    height: 150,
                    width: 150
                };
                v.onResizing(viewport2, 100);
                setTimeout(function () {
                    expect($('.slicerContainer .slicerBody').first().css('height')).toBe('110px');
                    expect($('.slicerContainer .slicerBody').first().css('width')).toBe('150px');
                    expect($('.slicerContainer .headerText').first().css('width')).toBe('121px');
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    });
    describe("Slicer Interactivity", function () {
        var v, element, slicers, slicerCheckboxInput;
        var hostServices;
        var dataViewMetadata = {
            columns: [
                { displayName: 'Fruit', properties: { "Category": true }, type: ValueType.fromDescriptor({ text: true }) },
                { displayName: 'Price', isMeasure: true }
            ],
        };
        var dataViewCategorical = {
            categories: [{
                source: dataViewMetadata.columns[0],
                values: ['Apple', 'Orange', 'Kiwi', 'Grapes', 'Banana'],
                identity: [
                    powerbitests.mocks.dataViewScopeIdentity('Apple'),
                    powerbitests.mocks.dataViewScopeIdentity('Orange'),
                    powerbitests.mocks.dataViewScopeIdentity('Kiwi'),
                    powerbitests.mocks.dataViewScopeIdentity('Grapes'),
                    powerbitests.mocks.dataViewScopeIdentity('Banana'),
                ]
            }],
            values: DataViewTransform.createValueColumns([{
                source: dataViewMetadata.columns[1],
                values: [20, 10, 30, 15, 12]
            }]),
        };
        var interactiveDataViewOptions = {
            dataViews: [{
                metadata: dataViewMetadata,
                categorical: dataViewCategorical
            }]
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('slicer').create();
            hostServices = powerbitests.mocks.createVisualHostServices();
            var settings;
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
                interactivity: { selection: true }
            });
            v.onDataChanged(interactiveDataViewOptions);
            slicers = $('.slicerText');
            slicerCheckboxInput = $('label.slicerCheckbox').find('input');
            spyOn(hostServices, 'onSelect').and.callThrough();
        });
        it('slicer item select', function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(true);
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[1]).property('checked')).toBe(false);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0],
                            ]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('slicer item multi-select checkboxes', function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0],
                            ]
                        }
                    ]
                });
                slicers.last().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[4].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(true);
                expect(d3.select(slicerCheckboxInput[1]).property('checked')).toBe(false);
                expect(d3.select(slicerCheckboxInput[4]).property('checked')).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0],
                            ]
                        },
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[4],
                            ]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('slicer item multi-select with control key', function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                slicers.last().d3Click(0, 0, 1 /* CtrlKey */);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[4].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(true);
                expect(d3.select(slicerCheckboxInput[1]).property('checked')).toBe(false);
                expect(d3.select(slicerCheckboxInput[4]).property('checked')).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0],
                            ]
                        },
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[4],
                            ]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        it('slicer item repeated selection', function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                slicers.last().d3Click(0, 0);
                slicers.last().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[4].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(true);
                expect(d3.select(slicerCheckboxInput[4]).property('checked')).toBe(false);
                done();
            }, DefaultWaitForRender);
        });
        it('slicer clear', function (done) {
            setTimeout(function () {
                var clearBtn = $('.clear');
                // Slicer click
                slicers.first().d3Click(0, 0);
                slicers.last().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[4].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                // Slicer clear
                clearBtn.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(102, 102, 102)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(slicers[2].style.color).toBe('rgb(102, 102, 102)');
                expect(slicers[3].style.color).toBe('rgb(102, 102, 102)');
                expect(slicers[4].style.color).toBe('rgb(102, 102, 102)');
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, DefaultWaitForRender);
        });
        it('slicer mouseover', function (done) {
            setTimeout(function () {
                var slicers = $('.slicerText');
                var event = document.createEvent('Event');
                event.initEvent('mouseover', true, true);
                slicers[0].dispatchEvent(event);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                expect(slicers[1].style.color).toBe('rgb(102, 102, 102)');
                expect(d3.select(slicerCheckboxInput[0]).property('checked')).toBe(false);
                done();
            }, DefaultWaitForRender);
        });
        it('slicer mouseout', function (done) {
            setTimeout(function () {
                // mouseover, mouseout
                var mouseOverEvent = document.createEvent('Event');
                mouseOverEvent.initEvent('mouseover', true, true);
                slicers[0].dispatchEvent(mouseOverEvent);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                var mouseOutEvent = document.createEvent('Event');
                mouseOutEvent.initEvent('mouseout', true, true);
                slicers[0].dispatchEvent(mouseOutEvent);
                expect(slicers[0].style.color).toBe('rgb(102, 102, 102)');
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                var mouseOverEvent1 = document.createEvent('Event');
                mouseOverEvent1.initEvent('mouseover', true, true);
                slicers[0].dispatchEvent(mouseOverEvent1);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                var mouseOutEvent1 = document.createEvent('Event');
                mouseOutEvent1.initEvent('mouseout', true, true);
                slicers[0].dispatchEvent(mouseOutEvent1);
                expect(slicers[0].style.color).toBe('rgb(33, 33, 33)');
                done();
            }, DefaultWaitForRender);
        });
        it('slicer loadMoreData noSegment', function () {
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).not.toHaveBeenCalled();
        });
        it('slicer loadMoreData', function () {
            var metadata = {
                columns: [
                    { displayName: 'Fruit', properties: { "Category": true }, type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'Price', isMeasure: true }
                ],
                segment: {},
            };
            var interactiveDataViewOptions = {
                dataViews: [{ metadata: metadata, categorical: dataViewCategorical }]
            };
            v.onDataChanged(interactiveDataViewOptions);
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).toHaveBeenCalled();
        });
        it('slicer loadMoreData already called', function () {
            var metadata = {
                columns: [
                    { displayName: 'Fruit', properties: { "Category": true }, type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'Price', isMeasure: true }
                ],
                segment: {},
            };
            var interactiveDataViewOptions = {
                dataViews: [{ metadata: metadata, categorical: dataViewCategorical }]
            };
            v.onDataChanged(interactiveDataViewOptions);
            var listViewOptions = v['listView']['options'];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            listViewOptions.loadMoreData();
            expect(loadMoreSpy.calls.all().length).toBe(1);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var CompiledSubtotalType = powerbi.data.CompiledSubtotalType;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var Table = powerbi.visuals.Table;
    var TableHierarchyNavigator = powerbi.visuals.TableHierarchyNavigator;
    var valueFormatter = powerbi.visuals.valueFormatter;
    var DefaultWaitForRender = 500;
    var dataTypeNumber = DataShapeUtility.describeDataType(1 /* Number */);
    var dataTypeString = DataShapeUtility.describeDataType(2048 /* String */);
    var dataTypeWebUrl = DataShapeUtility.describeDataType(2048 /* String */, 'WebUrl');
    var groupSource1 = { displayName: 'group1', type: dataTypeString, index: 0 };
    var groupSource2 = { displayName: 'group2', type: dataTypeString, index: 1 };
    var groupSource3 = { displayName: 'group3', type: dataTypeString, index: 2 };
    var groupSourceWebUrl = { displayName: 'groupWebUrl', type: dataTypeWebUrl, index: 0 };
    var measureSource1 = { displayName: 'measure1', type: dataTypeNumber, isMeasure: true, index: 3, objects: { general: { formatString: '#.0' } } };
    var measureSource2 = { displayName: 'measure2', type: dataTypeNumber, isMeasure: true, index: 4, objects: { general: { formatString: '#.00' } } };
    var measureSource3 = { displayName: 'measure3', type: dataTypeNumber, isMeasure: true, index: 5, objects: { general: { formatString: '#' } } };
    var webPluginService = new powerbi.visuals.visualPluginFactory.MinervaVisualPluginService({
        heatMap: false,
    });
    var tableTotals = {
        general: {
            totals: true
        }
    };
    var tableNoTotals = {
        general: {
            totals: false
        }
    };
    var tableOneMeasure = {
        metadata: { columns: [measureSource1] },
        table: {
            columns: [measureSource1],
            rows: [
                [100]
            ]
        }
    };
    var dataViewTableOneGroup = {
        columns: [groupSource1],
        rows: [
            ['A'],
            ['B'],
            ['C']
        ]
    };
    var tableOneGroup = {
        metadata: { columns: [groupSource1] },
        table: dataViewTableOneGroup
    };
    var tableOneGroupNulls = {
        metadata: { columns: [groupSource1] },
        table: {
            columns: [groupSource1],
            rows: [
                [''],
                [null]
            ]
        }
    };
    var dataViewTableTwoGroups = {
        columns: [groupSource1, groupSource2],
        rows: [
            ['A', 'a1'],
            ['A', 'a2'],
            ['A', 'a3'],
            ['B', 'a1'],
            ['B', 'a2'],
            ['C', 'c1'],
            ['C', 'c2']
        ]
    };
    var tableTwoGroups = {
        metadata: { columns: [groupSource1, groupSource2] },
        table: dataViewTableTwoGroups
    };
    var tableTwoGroupsThreeMeasures = {
        metadata: {
            columns: [groupSource1, groupSource2, measureSource1, measureSource2, measureSource3],
            objects: tableTotals
        },
        table: {
            columns: [groupSource1, groupSource2, measureSource1, measureSource2, measureSource3],
            rows: [
                ['A', 'a1', 100, 101, 102],
                ['A', 'a2', 103, 104, 105],
                ['A', 'a3', 106, 107, 108],
                ['B', 'a1', 109, 110, 111],
                ['B', 'a2', 112, 113, 114],
                ['C', 'c1', 115, 116, 117],
                ['C', 'c2', 118, 119, 120]
            ],
            totals: [null, null, 763, 770, 777]
        }
    };
    var tableTwoGroups1MeasureNulls = {
        metadata: {
            columns: [groupSource1, groupSource2, measureSource1],
        },
        table: {
            columns: [groupSource1, groupSource2, measureSource1],
            rows: [
                ['A', 'a1', 100],
                ['', null, 103],
                ['', 'a3', 106],
                ['B', '', 112],
                [null, '', null]
            ]
        }
    };
    var tableThreeGroupsThreeMeasuresInterleaved = {
        metadata: { columns: [groupSource1, measureSource1, groupSource2, measureSource2, groupSource3, measureSource3] },
        table: {
            columns: [groupSource1, measureSource1, groupSource2, measureSource2, groupSource3, measureSource3],
            rows: [
                ['A', 100, 'aa', 101, 'aa1', 102],
                ['A', 103, 'aa', 104, 'aa2', 105],
                ['A', 106, 'ab', 107, 'ab1', 108],
                ['B', 109, 'ba', 110, 'ba1', 111],
                ['B', 112, 'bb', 113, 'bb1', 114],
                ['B', 115, 'bb', 116, 'bb2', 117],
                ['C', 118, 'cc', 119, 'cc1', 120],
            ]
        }
    };
    var tableOneMeasureOneGroupSubtotals = {
        metadata: {
            columns: [measureSource1, groupSource1],
            objects: tableTotals
        },
        table: {
            columns: [measureSource1, groupSource1],
            rows: [
                [1, 'A'],
                [2, 'B'],
                [3, 'C']
            ],
            totals: [6, null]
        }
    };
    var tableOneMeasureOneGroup = {
        metadata: {
            columns: [measureSource1, groupSource1],
            objects: tableNoTotals
        },
        table: {
            columns: [measureSource1, groupSource1],
            rows: [
                [1, 'A'],
                [2, 'B'],
                [3, 'C']
            ]
        }
    };
    var tableWebUrl = {
        metadata: {
            columns: [groupSourceWebUrl],
            objects: tableNoTotals,
        },
        table: {
            columns: [groupSourceWebUrl],
            rows: [
                ['http://www.microsoft.com'],
                ['data:url'],
                ['https://www.microsoft.com/2'],
            ]
        }
    };
    describe('Table', function () {
        it('Table registered capabilities', function () {
            expect(webPluginService.getPlugin('table').capabilities).toEqual(Table.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(Table.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(Table.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(Table.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Table.capabilities.objects)).toEqual(Table.formatStringProp);
        });
        it('CustomizeQuery picks up enabled total', function () {
            var objects = {
                general: {
                    totals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(1 /* Before */);
        });
        it('CustomizeQuery picks up disabled total', function () {
            var objects = {
                general: {
                    totals: false
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            powerbi.visuals.Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(0 /* None */);
        });
        it('CustomizeQuery handles missing settings', function () {
            var dataViewMapping = createCompiledDataViewMapping();
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Total should be enabled by default
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(1 /* Before */);
        });
        it('CustomizeQuery handles missing subtotal settings', function () {
            var objects = {
                general: {
                    totals: undefined
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Total should be enabled by default
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(1 /* Before */);
        });
        function createCompiledDataViewMapping(objects) {
            return {
                metadata: {
                    objects: objects
                },
                table: {
                    rows: {
                        for: {
                            in: { role: 'Values', items: [] }
                        }
                    }
                }
            };
        }
    });
    describe('Table hierarchy navigator tests', function () {
        function createNavigator(dataView) {
            return new TableHierarchyNavigator(dataView.table, valueFormatter.formatRaw);
        }
        describe('getDepth', function () {
            var dataView = tableTwoGroupsThreeMeasures;
            var navigator = createNavigator(dataView);
            it('returns 1 for row dimension', function () {
                expect(navigator.getDepth(dataView.table.rows)).toBe(1);
            });
            it('returns 1 for column dimension', function () {
                expect(navigator.getDepth(dataView.table.columns)).toBe(1);
            });
            it('always returns 1', function () {
                expect(navigator.getDepth(null)).toBe(1);
            });
        });
        describe('getLeafCount', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns the row count for row dimension', function () {
                expect(navigator.getLeafCount(dataView.table.rows)).toBe(7);
            });
            it('returns the column count for column dimension', function () {
                expect(navigator.getLeafCount(dataView.table.columns)).toBe(6);
            });
        });
        describe('getLeafAt', function () {
            it('returns the correct leaf from the row dimension', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getLeafAt(rows, 0)).toBe(rows[0]);
                expect(navigator.getLeafAt(rows, 1)).toBe(rows[1]);
                expect(navigator.getLeafAt(rows, 6)).toBe(rows[6]);
            });
            it('returns the correct leaf from the column dimension', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getLeafAt(columns, 0)).toBe(columns[0]);
                expect(navigator.getLeafAt(columns, 1)).toBe(columns[1]);
                expect(navigator.getLeafAt(columns, 5)).toBe(columns[5]);
            });
            it('returns undefined if index is out of bounds in the row dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getLeafAt(rows, 1)).not.toBeDefined();
            });
            it('returns undefined if index is out of bounds in the column dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getLeafAt(columns, 1)).not.toBeDefined();
            });
        });
        describe('getParent', function () {
            var dataView = tableTwoGroupsThreeMeasures;
            var navigator = createNavigator(dataView);
            it('returns null for column header', function () {
                var columns = dataView.table.columns;
                expect(navigator.getParent(columns[0])).toBeNull();
            });
            it('returns null for row', function () {
                var rows = dataView.table.rows;
                expect(navigator.getParent(rows[0])).toBeNull();
            });
            it('returns null in any other cases', function () {
                expect(navigator.getParent(null)).toBeNull();
            });
        });
        describe('getIndex', function () {
            it('returns the correct index for columns', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                var column1 = columns[0];
                var column2 = columns[1];
                var column3 = columns[2];
                var column4 = columns[3];
                var column5 = columns[4];
                var column6 = columns[5];
                expect(navigator.getIndex(column1)).toBe(0);
                expect(navigator.getIndex(column2)).toBe(1);
                expect(navigator.getIndex(column3)).toBe(2);
                expect(navigator.getIndex(column4)).toBe(3);
                expect(navigator.getIndex(column5)).toBe(4);
                expect(navigator.getIndex(column6)).toBe(5);
            });
            it('returns the correct index for rows', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                var row1 = { index: 0, values: rows[0] };
                var row2 = { index: 1, values: rows[1] };
                expect(navigator.getIndex(row1)).toBe(0);
                expect(navigator.getIndex(row2)).toBe(1);
            });
            it('returns -1 if cannot find column in the collection', function () {
                var dataView = tableTwoGroups;
                var navigator = createNavigator(dataView);
                var columnInAnotherTable = tableThreeGroupsThreeMeasuresInterleaved.table.columns[4];
                expect(navigator.getIndex(columnInAnotherTable)).toBe(-1);
            });
        });
        describe('isLeaf', function () {
            it('returns true for columns', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                var column1 = columns[0];
                var column2 = columns[1];
                var column3 = columns[2];
                var column4 = columns[3];
                var column5 = columns[4];
                var column6 = columns[5];
                expect(navigator.isLeaf(column1)).toBeTruthy();
                expect(navigator.isLeaf(column2)).toBeTruthy();
                expect(navigator.isLeaf(column3)).toBeTruthy();
                expect(navigator.isLeaf(column4)).toBeTruthy();
                expect(navigator.isLeaf(column5)).toBeTruthy();
                expect(navigator.isLeaf(column6)).toBeTruthy();
            });
            it('returns true for rows', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                var row1 = rows[0];
                var row2 = rows[1];
                var row3 = rows[2];
                var row4 = rows[3];
                var row5 = rows[4];
                var row6 = rows[5];
                var row7 = rows[6];
                expect(navigator.isLeaf(row1)).toBeTruthy();
                expect(navigator.isLeaf(row2)).toBeTruthy();
                expect(navigator.isLeaf(row3)).toBeTruthy();
                expect(navigator.isLeaf(row4)).toBeTruthy();
                expect(navigator.isLeaf(row5)).toBeTruthy();
                expect(navigator.isLeaf(row6)).toBeTruthy();
                expect(navigator.isLeaf(row7)).toBeTruthy();
            });
        });
        describe('getChildren', function () {
            it('returns null for column', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var column = dataView.table.columns[3];
                expect(navigator.getChildren(column)).toBeNull();
            });
            it('returns null for row', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var row = dataView.table.rows[4];
                expect(navigator.getChildren(row)).toBeNull();
            });
        });
        describe('getCount', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns the number of the columns for column dimension', function () {
                expect(navigator.getCount(dataView.table.columns)).toBe(dataView.table.columns.length);
            });
            it('returns the number of the rows for row dimension', function () {
                expect(navigator.getCount(dataView.table.rows)).toBe(dataView.table.rows.length);
            });
        });
        describe('getAt', function () {
            it('returns the correct item from the row dimension', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getAt(rows, 0)).toBe(rows[0]);
                expect(navigator.getAt(rows, 1)).toBe(rows[1]);
                expect(navigator.getAt(rows, 6)).toBe(rows[6]);
            });
            it('returns the correct item from the column dimension', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getAt(columns, 0)).toBe(columns[0]);
                expect(navigator.getAt(columns, 1)).toBe(columns[1]);
                expect(navigator.getAt(columns, 5)).toBe(columns[5]);
            });
            it('returns undefined if index is out of bounds in the row dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getAt(rows, 1)).not.toBeDefined();
            });
            it('returns undefined if index is out of bounds in the column dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getAt(columns, 1)).not.toBeDefined();
            });
        });
        describe('getLevel', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns 0 for column', function () {
                var columns = dataView.table.columns;
                expect(navigator.getLevel(columns[1])).toBe(0);
            });
            it('returns 0 for row', function () {
                var rows = dataView.table.rows;
                expect(navigator.getLevel(rows[5])).toBe(0);
            });
        });
        describe('getIntersection', function () {
            it('returns values in the intersection', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var visualTable = powerbi.visuals.Table.converter(dataView.table);
                var rows = visualTable.visualRows;
                var columns = dataView.table.columns;
                var expectedValues = [
                    ['A', '100.0', 'aa', '101.00', 'aa1', '102'],
                    ['A', '103.0', 'aa', '104.00', 'aa2', '105'],
                    ['A', '106.0', 'ab', '107.00', 'ab1', '108'],
                    ['B', '109.0', 'ba', '110.00', 'ba1', '111'],
                    ['B', '112.0', 'bb', '113.00', 'bb1', '114'],
                    ['B', '115.0', 'bb', '116.00', 'bb2', '117'],
                    ['C', '118.0', 'cc', '119.00', 'cc1', '120']
                ];
                var navigator = new TableHierarchyNavigator(visualTable, valueFormatter.formatRaw);
                validateIntersections(navigator, rows, columns, expectedValues);
            });
            it('returns weburl values', function () {
                var dataView = tableWebUrl;
                var visualTable = powerbi.visuals.Table.converter(dataView.table);
                var rows = visualTable.visualRows;
                var columns = dataView.table.columns;
                var navigator = new TableHierarchyNavigator(visualTable, valueFormatter.formatRaw);
                var result = [];
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columns.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rows[i], columns[j]).showUrl;
                }
                var expectedValues = [
                    [true],
                    [false],
                    [true],
                ];
                expect(result).toEqual(expectedValues);
            });
            function validateIntersections(navigator, rows, columns, expectedValues) {
                var result = [];
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columns.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rows[i], columns[j]).value;
                }
                expect(result).toEqual(expectedValues);
            }
        });
        describe('getCorner', function () {
            it('always returns null', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                expect(navigator.getCorner(0, 0)).toBeNull();
                expect(navigator.getCorner(10, 0)).toBeNull();
                expect(navigator.getCorner(0, 10)).toBeNull();
                expect(navigator.getCorner(10, 10)).toBeNull();
            });
        });
        describe('headerItemEquals', function () {
            it('returns true if the two items are the same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var row = dataView.table.rows[0];
                var column = dataView.table.columns[0];
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals(row, row)).toBeTruthy();
                expect(navigator.headerItemEquals(column, column)).toBeTruthy();
            });
            it('returns false if the two items are not same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var row = dataView.table.rows[0];
                var column = dataView.table.columns[0];
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals(row, column)).toBeFalsy();
                expect(navigator.headerItemEquals(column, row)).toBeFalsy();
            });
        });
        describe('bodyCellItemEquals', function () {
            it('returns true if the two items are the same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var cell1 = dataView.table.rows[0][3];
                var navigator = createNavigator(dataView);
                expect(navigator.bodyCellItemEquals(cell1, cell1)).toBeTruthy();
            });
            it('returns false if the two items are not same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var cell1 = dataView.table.rows[1][3];
                var cell2 = dataView.table.rows[2][3];
                var navigator = createNavigator(dataView);
                expect(navigator.bodyCellItemEquals(cell1, cell2)).toBeFalsy();
            });
        });
    });
    describe('Table logic', function () {
        var v, element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () {
                return true;
            };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: true
                }
            });
        });
        it('loadMoreData calls control refresh', function () {
            var nav = { update: function () {
            } };
            var control = { refresh: function () {
            }, rowDimension: {}, updateModels: function (resetScrollOffsets, rowModel, columnModel) {
            } };
            var navSpy = spyOn(nav, "update");
            var controlSpy = spyOn(control, "refresh");
            v['hierarchyNavigator'] = nav;
            v['tablixControl'] = control;
            v.onDataChanged({
                dataViews: [tableOneGroup],
                operationKind: 1 /* Append */
            });
            expect(navSpy).toHaveBeenCalled();
            expect(controlSpy).toHaveBeenCalled();
        });
        it('needsMoreData waitingForData', function () {
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [groupSource1], segment: {} },
                    table: dataViewTableOneGroup
                }]
            });
            v['waitingForData'] = true;
            var tableVisual = v;
            var lastRow = dataViewTableOneGroup.rows[2];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData segmentComplete', function () {
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [groupSource1] },
                    table: dataViewTableOneGroup
                }]
            });
            var tableVisual = v;
            var lastRow = dataViewTableOneGroup.rows[2];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData belowThreshold', function () {
            var table = dataViewTableTwoGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [groupSource1, groupSource2], segment: {} },
                    table: table
                }]
            });
            var tableVisual = v;
            var lastRow = table.rows[3];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData aboveThreshold', function () {
            var table = dataViewTableTwoGroups;
            v.onDataChanged({
                dataViews: [{
                    metadata: { columns: [groupSource1, groupSource2], segment: {} },
                    table: table
                }]
            });
            var tableVisual = v;
            var lastRow = { index: 6, values: table.rows[6] };
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(true);
        });
        it('bindRowHeader callback', function () {
            var callBackCalled = false;
            var binderOptions = {
                onBindRowHeader: function (item) {
                    callBackCalled = true;
                },
                layoutKind: 0 /* Canvas */,
            };
            var binder = new powerbi.visuals.TableBinder(binderOptions);
            binder.bindRowHeader({ name: null }, {
                type: null,
                item: null,
                colSpan: 0,
                rowSpan: 0,
                textAlign: '',
                extension: { setContainerStyle: function () {
                } }
            });
            expect(callBackCalled).toBe(true);
        });
        it('enumerateObjectInstances empty data view', function () {
            v.onDataChanged({ dataViews: [] });
            // Note: this must not throw an exception
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([]);
        });
        it('enumerateObjectInstances general totals on', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroupSubtotals] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    totals: true
                }
            }]);
        });
        it('enumerateObjectInstances general totals off', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroup] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    totals: false
                }
            }]);
        });
        it('enumerateObjectInstances general no objects', function () {
            var dataView = {
                metadata: {
                    columns: [measureSource1, groupSource1]
                },
                table: {
                    columns: [measureSource1, groupSource1],
                    rows: [
                        [1, 'A'],
                        [2, 'B'],
                        [3, 'C']
                    ],
                    totals: [6, null]
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                selector: null,
                objectName: 'general',
                properties: {
                    totals: true
                }
            }]);
        });
        it('enumerateObjectInstances some other object', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroup] });
            var objects = v.enumerateObjectInstances({ objectName: 'some other object' });
            expect(objects).toEqual([]);
        });
        it('RefreshControl invisible parent', function () {
            var control = { refresh: function () {
            } };
            var controlSpy = spyOn(control, "refresh");
            v['shouldAllowHeaderResize'] = function () {
                return true;
            };
            v['hierarchyNavigator'] = { update: function () {
            } };
            v['tablixControl'] = control;
            v['element']['visible'] = function () {
                return false;
            };
            v.onResizing({ width: 100, height: 100 }, 0);
            expect(controlSpy).not.toHaveBeenCalled();
        });
        it('RefreshControl invisible parent but dashboard layout', function () {
            var control = { refresh: function () {
            } };
            var controlSpy = spyOn(control, "refresh");
            v['shouldAllowHeaderResize'] = function () {
                return true;
            };
            v['hierarchyNavigator'] = { update: function () {
            } };
            v['tablixControl'] = control;
            v['element']['visible'] = function () {
                return false;
            };
            v['isInteractive'] = false;
            v.onResizing({ width: 100, height: 100 }, 0);
            expect(controlSpy).toHaveBeenCalled();
        });
    });
    describe('Table DOM validation', function () {
        var v, element, NoMarginClass = 'bi-tablix-cellNoMarginStyle', ColumnHeaderClassName = 'bi-table-column-header', RowClassName = 'bi-table-row', LastRowClassName = 'bi-table-last-row', FooterClassName = 'bi-table-footer', NumericCellClassName = ' bi-table-cell-numeric', EmptyHeaderCell = '\xa0';
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            groupSource1.index = 0;
            groupSource2.index = 1;
            groupSource3.index = 2;
            measureSource1.index = 3;
            measureSource2.index = 4;
            measureSource3.index = 5;
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () {
                return true;
            };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: true
                }
            });
        });
        function validateTable(expectedValues) {
            powerbitests.tablixHelper.validateTable(expectedValues, '.bi-tablix tr');
        }
        function validateChildTag(expectedChildTag) {
            var rows = $('.bi-tablix tr');
            var result = [];
            for (var i = 0, ilen = rows.length; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                for (var j = 0, jlen = cells.length; j < jlen; j++) {
                    var childTag = expectedChildTag[i][j];
                    if (childTag) {
                        var child = cells.eq(j).find(childTag);
                        if (child.length > 0)
                            result[i][j] = childTag;
                        else
                            result[i][j] = undefined;
                    }
                    else
                        result[i][j] = undefined;
                }
            }
            expect(result).toEqual(expectedChildTag);
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-tablix tr', NoMarginClass);
        }
        it('1x2 table (one measure)', function (done) {
            var dataView = tableOneMeasure;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue = formatter(dataView.table.rows[0][0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, ''],
                    ['', cellValue]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ''],
                    ['', LastRowClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 table (one group null)', function (done) {
            var dataView = tableOneGroupNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    [EmptyHeaderCell, ''],
                    [EmptyHeaderCell, '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x5 table (2 groups 1 measure nulls)', function (done) {
            var dataView = tableTwoGroups1MeasureNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, ''],
                    ['', 'A', 'a1', '100.0'],
                    ['', '', '', '103.0'],
                    ['', '', 'a3', '106.0'],
                    ['', 'B', '', '112.0'],
                    [EmptyHeaderCell, '', '', '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances)', function (done) {
            var dataView = tableOneGroup;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ''],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x8 table (group instances)', function (done) {
            var dataView = tableTwoGroups;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var cellValue6 = formatter(dataView.table.rows[5][0], groupSource1);
                var cellValue7 = formatter(dataView.table.rows[6][0], groupSource1);
                var cellValue8 = formatter(dataView.table.rows[0][1], groupSource2);
                var cellValue9 = formatter(dataView.table.rows[1][1], groupSource2);
                var cellValue10 = formatter(dataView.table.rows[2][1], groupSource2);
                var cellValue11 = formatter(dataView.table.rows[3][1], groupSource2);
                var cellValue12 = formatter(dataView.table.rows[4][1], groupSource2);
                var cellValue13 = formatter(dataView.table.rows[5][1], groupSource2);
                var cellValue14 = formatter(dataView.table.rows[6][1], groupSource2);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, ''],
                    ['', cellValue1, cellValue8],
                    ['', cellValue2, cellValue9],
                    ['', cellValue3, cellValue10],
                    ['', cellValue4, cellValue11],
                    ['', cellValue5, cellValue12],
                    ['', cellValue6, cellValue13],
                    ['', cellValue7, cellValue14]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('5x9 table (group instances and measure values) with totals', function (done) {
            var dataView = tableTwoGroupsThreeMeasures;
            measureSource1.index = 2;
            measureSource2.index = 3;
            measureSource3.index = 4;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][2], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][2], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][2], measureSource1);
                var cellValue4 = formatter(dataView.table.rows[3][2], measureSource1);
                var cellValue5 = formatter(dataView.table.rows[4][2], measureSource1);
                var cellValue6 = formatter(dataView.table.rows[5][2], measureSource1);
                var cellValue7 = formatter(dataView.table.rows[6][2], measureSource1);
                var cellValue8 = formatter(dataView.table.rows[0][3], measureSource2);
                var cellValue9 = formatter(dataView.table.rows[1][3], measureSource2);
                var cellValue10 = formatter(dataView.table.rows[2][3], measureSource2);
                var cellValue11 = formatter(dataView.table.rows[3][3], measureSource2);
                var cellValue12 = formatter(dataView.table.rows[4][3], measureSource2);
                var cellValue13 = formatter(dataView.table.rows[5][3], measureSource2);
                var cellValue14 = formatter(dataView.table.rows[6][3], measureSource2);
                var cellValue15 = formatter(dataView.table.rows[0][4], measureSource3);
                var cellValue16 = formatter(dataView.table.rows[1][4], measureSource3);
                var cellValue17 = formatter(dataView.table.rows[2][4], measureSource3);
                var cellValue18 = formatter(dataView.table.rows[3][4], measureSource3);
                var cellValue19 = formatter(dataView.table.rows[4][4], measureSource3);
                var cellValue20 = formatter(dataView.table.rows[5][4], measureSource3);
                var cellValue21 = formatter(dataView.table.rows[6][4], measureSource3);
                var total1 = formatter(dataView.table.totals[2], measureSource1);
                var total2 = formatter(dataView.table.totals[3], measureSource2);
                var total3 = formatter(dataView.table.totals[4], measureSource3);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ''],
                    ['', dataView.table.rows[0][0], dataView.table.rows[0][1], cellValue1, cellValue8, cellValue15],
                    ['', dataView.table.rows[1][0], dataView.table.rows[1][1], cellValue2, cellValue9, cellValue16],
                    ['', dataView.table.rows[2][0], dataView.table.rows[2][1], cellValue3, cellValue10, cellValue17],
                    ['', dataView.table.rows[3][0], dataView.table.rows[3][1], cellValue4, cellValue11, cellValue18],
                    ['', dataView.table.rows[4][0], dataView.table.rows[4][1], cellValue5, cellValue12, cellValue19],
                    ['', dataView.table.rows[5][0], dataView.table.rows[5][1], cellValue6, cellValue13, cellValue20],
                    ['', dataView.table.rows[6][0], dataView.table.rows[6][1], cellValue7, cellValue14, cellValue21],
                    ['', 'TableTotalLabel', '', total1, total2, total3, '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName, ''],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', LastRowClassName, LastRowClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName],
                    ['', FooterClassName, FooterClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName, '']
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) with totals, total value comes first', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName, ''],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '', '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName, ''],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', LastRowClassName + NumericCellClassName, LastRowClassName],
                    ['', FooterClassName + NumericCellClassName, FooterClassName, '']
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) totals on then off', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName, ''],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '', '']
                ];
                validateTable(expectedCells);
                // Now update with totals off
                var dataViewNoTotal = tableOneMeasureOneGroup;
                v.onDataChanged({ dataViews: [dataViewNoTotal] });
                setTimeout(function () {
                    var expectedCellsNoTotal = [
                        ['', measureSource1.displayName, groupSource1.displayName, ''],
                        ['', cellValue1, dataViewNoTotal.table.rows[0][1]],
                        ['', cellValue2, dataViewNoTotal.table.rows[1][1]],
                        ['', cellValue3, dataViewNoTotal.table.rows[2][1]]
                    ];
                    validateTable(expectedCellsNoTotal);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances with WebUrl)', function (done) {
            var dataView = tableWebUrl;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSourceWebUrl);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSourceWebUrl);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSourceWebUrl);
                var expectedCells = [
                    ['', groupSourceWebUrl.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ''],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                var expectedChildTags = [
                    [, , ,],
                    [, 'A'],
                    [, ,],
                    [, 'A']
                ];
                validateChildTag(expectedChildTags);
                done();
            }, DefaultWaitForRender);
        });
        it('1x1 table loadMoreData', function (done) {
            var dataView = {
                metadata: { columns: [groupSource1], segment: {} },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['A'],
                        ['B'],
                        ['C']
                    ]
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            var segment2 = {
                metadata: { columns: [groupSource1] },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['D'],
                        ['E']
                    ]
                }
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTables(dataView.table, segment2.table);
            v.onDataChanged({
                dataViews: [dataView],
                operationKind: 1 /* Append */
            });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3],
                    ['', cellValue4],
                    ['', cellValue5]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table reorder loadMoreData', function (done) {
            var dataView = {
                metadata: { columns: [groupSource1, groupSource2], segment: {} },
                table: {
                    columns: [groupSource1, groupSource2],
                    rows: [
                        ['A', '1'],
                        ['B', '2'],
                        ['C', '3']
                    ]
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            // Simulate column reordering
            var transformedDataView = applyTransform(dataView);
            v.onDataChanged({ dataViews: [transformedDataView] });
            var segment2 = {
                metadata: { columns: [groupSource1] },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['D', '4'],
                        ['E', '5']
                    ]
                }
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTables(dataView.table, segment2.table);
            var transformedDataView = applyTransform(dataView);
            v.onDataChanged({
                dataViews: [transformedDataView],
                operationKind: 1 /* Append */
            });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource2.displayName, groupSource1.displayName, ''],
                    ['', '1', 'A'],
                    ['', '2', 'B'],
                    ['', '3', 'C'],
                    ['', '4', 'D'],
                    ['', '5', 'E']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        function applyTransform(dataView) {
            var transforms = {
                selects: [
                    {
                        displayName: groupSource1.displayName,
                        type: powerbi.ValueType.fromDescriptor({ text: true }),
                    },
                    {
                        displayName: groupSource2.displayName,
                        type: powerbi.ValueType.fromDescriptor({ text: true }),
                    }
                ],
                projectionOrdering: {
                    Values: [1, 0]
                }
            };
            var transformedDataView = powerbi.data.DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: null,
                transforms: transforms,
                dataViewMappings: powerbi.visuals.Table.capabilities.dataViewMappings,
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory()
            })[0];
            return transformedDataView;
        }
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Table.formatStringProp, false));
        }
    });
    describe('Dashboard table DOM validation', function () {
        var v, element, NoMarginClass = 'bi-tablix-cellNoMarginStyle', ColumnHeaderClassName = 'bi-table-column-header', RowClassName = 'bi-table-row', LastRowClassName = 'bi-table-last-row', FooterClassName = 'bi-table-footer', NumericCellClassName = ' bi-table-cell-numeric', EmptyHeaderCell = '\xa0';
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            groupSource1.index = 0;
            groupSource2.index = 1;
            groupSource3.index = 2;
            measureSource1.index = 3;
            measureSource2.index = 4;
            measureSource3.index = 5;
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () {
                return false;
            };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: null
                }
            });
        });
        function validateTable(expectedValues) {
            powerbitests.tablixHelper.validateTable(expectedValues, '.bi-dashboard-tablix tr');
        }
        function validateChildTag(expectedChildTag) {
            var rows = $('.bi-dashboard-tablix tr');
            var result = [];
            for (var i = 0, ilen = rows.length; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                for (var j = 0, jlen = cells.length; j < jlen; j++) {
                    var childTag = expectedChildTag[i][j];
                    if (childTag) {
                        var child = cells.eq(j).find(childTag);
                        if (child.length > 0)
                            result[i][j] = childTag;
                        else
                            result[i][j] = undefined;
                    }
                    else
                        result[i][j] = undefined;
                }
            }
            expect(result).toEqual(expectedChildTag);
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-dashboard-tablix tr', NoMarginClass);
        }
        it('1x2 table (one measure)', function (done) {
            var dataView = tableOneMeasure;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue = formatter(dataView.table.rows[0][0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName],
                    ['', cellValue]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName],
                    ['', LastRowClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 table (one group null)', function (done) {
            var dataView = tableOneGroupNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName],
                    [EmptyHeaderCell, ''],
                    [EmptyHeaderCell, '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x5 table (2 groups 1 measure nulls)', function (done) {
            var dataView = tableTwoGroups1MeasureNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName],
                    ['', 'A', 'a1', '100.0'],
                    ['', '', '', '103.0'],
                    ['', '', 'a3', '106.0'],
                    ['', 'B', '', '112.0'],
                    [EmptyHeaderCell, '', '', '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances)', function (done) {
            var dataView = tableOneGroup;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x8 table (group instances)', function (done) {
            var dataView = tableTwoGroups;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var cellValue6 = formatter(dataView.table.rows[5][0], groupSource1);
                var cellValue7 = formatter(dataView.table.rows[6][0], groupSource1);
                var cellValue8 = formatter(dataView.table.rows[0][1], groupSource2);
                var cellValue9 = formatter(dataView.table.rows[1][1], groupSource2);
                var cellValue10 = formatter(dataView.table.rows[2][1], groupSource2);
                var cellValue11 = formatter(dataView.table.rows[3][1], groupSource2);
                var cellValue12 = formatter(dataView.table.rows[4][1], groupSource2);
                var cellValue13 = formatter(dataView.table.rows[5][1], groupSource2);
                var cellValue14 = formatter(dataView.table.rows[6][1], groupSource2);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName],
                    ['', cellValue1, cellValue8],
                    ['', cellValue2, cellValue9],
                    ['', cellValue3, cellValue10],
                    ['', cellValue4, cellValue11],
                    ['', cellValue5, cellValue12],
                    ['', cellValue6, cellValue13],
                    ['', cellValue7, cellValue14]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('5x9 table (group instances and measure values) with totals', function (done) {
            var dataView = tableTwoGroupsThreeMeasures;
            measureSource1.index = 2;
            measureSource2.index = 3;
            measureSource3.index = 4;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][2], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][2], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][2], measureSource1);
                var cellValue4 = formatter(dataView.table.rows[3][2], measureSource1);
                var cellValue5 = formatter(dataView.table.rows[4][2], measureSource1);
                var cellValue6 = formatter(dataView.table.rows[5][2], measureSource1);
                var cellValue7 = formatter(dataView.table.rows[6][2], measureSource1);
                var cellValue8 = formatter(dataView.table.rows[0][3], measureSource2);
                var cellValue9 = formatter(dataView.table.rows[1][3], measureSource2);
                var cellValue10 = formatter(dataView.table.rows[2][3], measureSource2);
                var cellValue11 = formatter(dataView.table.rows[3][3], measureSource2);
                var cellValue12 = formatter(dataView.table.rows[4][3], measureSource2);
                var cellValue13 = formatter(dataView.table.rows[5][3], measureSource2);
                var cellValue14 = formatter(dataView.table.rows[6][3], measureSource2);
                var total1 = formatter(dataView.table.totals[2], measureSource1);
                var total2 = formatter(dataView.table.totals[3], measureSource2);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, measureSource2.displayName],
                    ['', dataView.table.rows[0][0], dataView.table.rows[0][1], cellValue1, cellValue8],
                    ['', dataView.table.rows[1][0], dataView.table.rows[1][1], cellValue2, cellValue9],
                    ['', dataView.table.rows[2][0], dataView.table.rows[2][1], cellValue3, cellValue10],
                    ['', dataView.table.rows[3][0], dataView.table.rows[3][1], cellValue4, cellValue11],
                    ['', dataView.table.rows[4][0], dataView.table.rows[4][1], cellValue5, cellValue12],
                    ['', dataView.table.rows[5][0], dataView.table.rows[5][1], cellValue6, cellValue13],
                    ['', dataView.table.rows[6][0], dataView.table.rows[6][1], cellValue7, cellValue14],
                    ['', 'TableTotalLabel', '', total1, total2]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', LastRowClassName, LastRowClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName],
                    ['', FooterClassName, FooterClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) with totals, total value comes first', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', LastRowClassName + NumericCellClassName, LastRowClassName],
                    ['', FooterClassName + NumericCellClassName, FooterClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) totals on then off', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '']
                ];
                validateTable(expectedCells);
                // Now update with totals off
                var dataViewNoTotal = tableOneMeasureOneGroup;
                v.onDataChanged({ dataViews: [dataViewNoTotal] });
                setTimeout(function () {
                    var expectedCellsNoTotal = [
                        ['', measureSource1.displayName, groupSource1.displayName],
                        ['', cellValue1, dataViewNoTotal.table.rows[0][1]],
                        ['', cellValue2, dataViewNoTotal.table.rows[1][1]],
                        ['', cellValue3, dataViewNoTotal.table.rows[2][1]]
                    ];
                    validateTable(expectedCellsNoTotal);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances with WebUrl)', function (done) {
            var dataView = tableWebUrl;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSourceWebUrl);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSourceWebUrl);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSourceWebUrl);
                var expectedCells = [
                    ['', groupSourceWebUrl.displayName],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                var expectedChildTags = [
                    [, ,],
                    [, 'A'],
                    [, ,],
                    [, 'A']
                ];
                validateChildTag(expectedChildTags);
                done();
            }, DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Table.formatStringProp, false));
        }
    });
    describe("Table sort validation", function () {
        var element;
        beforeEach(function (done) {
            powerbitests.helpers.suppressDebugAssertFailure();
            element = powerbitests.helpers.testDom('800', '800');
            element['visible'] = function () {
                return true;
            };
            done();
        });
        it('table with single measure', function (done) {
            // Clicking on the measure will result in a sort event
            var data = tableOneMeasure;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "measure1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }];
            var expectedSorts = [
                [{ queryName: "measure1" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with single group', function (done) {
            // Clicking on the group header multiple times will result in multiple sort events.
            // Clicking on non-header cells will not result in sort events.
            var data = tableOneGroup;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 2, col: 1 }, { row: 0, col: 1 }];
            var expectedSorts = [
                [{ queryName: "group1" }],
                [{ queryName: "group1" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with two groups', function (done) {
            // Clicking on different group headers multiple times results in a sort event for each click
            var data = tableTwoGroups;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }, { row: 0, col: 2, expectedText: "group2" }];
            var clicks = [{ row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 1 }, { row: 0, col: 2 }];
            var expectedSorts = [
                [{ queryName: "group1" }],
                [{ queryName: "group2" }],
                [{ queryName: "group1" }],
                [{ queryName: "group2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with two groups and three measures', function (done) {
            // Clicking on different group headers multiple times results in a sort event for each click
            var data = tableTwoGroupsThreeMeasures;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }, { row: 0, col: 2, expectedText: "group2" }, { row: 0, col: 3, expectedText: "measure1" }, { row: 0, col: 4, expectedText: "measure2" }, { row: 0, col: 5, expectedText: "measure3" }];
            var clicks = [{ row: 0, col: 5 }, { row: 0, col: 2 }, { row: 0, col: 4 }, { row: 0, col: 1 }, { row: 0, col: 3 }, { row: 0, col: 1 }, { row: 0, col: 5 }];
            var expectedSorts = [
                [{ queryName: "measure3" }],
                [{ queryName: "group2" }],
                [{ queryName: "measure2" }],
                [{ queryName: "group1" }],
                [{ queryName: "measure1" }],
                [{ queryName: "group1" }],
                [{ queryName: "measure3" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var Textbox = powerbi.visuals.Textbox;
    describe("Textbox", function () {
        it('Textbox no visual configuration', function () {
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            };
            var textbox = new Textbox();
            textbox.init(options);
            expect(element.children().length).toBe(0);
        });
        it('Textbox basic text', function () {
            var content = {
                paragraphs: [{
                    textRuns: [{
                        value: "Text"
                    }]
                }]
            };
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            };
            var textbox = new Textbox();
            textbox.init(options);
            textbox.onDataChanged({ dataViews: [dataView(content)] });
            expect($('.textbox span').length).toBe(1);
            expect($('.textbox span')[0].innerText).toBe('Text');
        });
        it('Textbox all styles', function () {
            var content = {
                paragraphs: [{
                    horizontalTextAlignment: "center",
                    textRuns: [{
                        value: "Text",
                        textStyle: {
                            fontFamily: "Heading",
                            fontSize: "12px",
                            textDecoration: "underline",
                            fontWeight: "300",
                            fontStyle: "italic"
                        }
                    }]
                }]
            };
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            };
            var textbox = new Textbox();
            textbox.init(options);
            textbox.onDataChanged({ dataViews: [dataView(content)] });
            expect($('.textbox div').length).toBe(1);
            expect($('.textbox div')[0].style.textAlign).toBe('center');
            var spans = $('.textbox span');
            expect(spans.length).toBe(1);
            var firstSpan = spans[0];
            expect(firstSpan.innerText).toBe('Text');
            var firstSpanStyle = firstSpan.style;
            expect(firstSpanStyle.fontFamily).toBe("'Segoe UI Light'");
            expect(firstSpanStyle.fontSize).toBe('12px');
            expect(firstSpanStyle.fontStyle).toBe('italic');
            expect(firstSpanStyle.fontWeight).toBe('300');
            expect(firstSpanStyle.textDecoration).toBe('underline');
        });
        it('Textbox all styles', function () {
            var content = {
                paragraphs: [{
                    textRuns: [{
                        value: "Text",
                        textStyle: {
                            fontFamily: "Arial",
                        }
                    }]
                }]
            };
            var element = powerbitests.helpers.testDom('200', '300');
            var options = {
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            };
            var textbox = new Textbox();
            textbox.init(options);
            textbox.onDataChanged({ dataViews: [dataView(content)] });
            expect($('.textbox span')[0].style.fontFamily).toBe("Arial");
        });
        function dataView(content) {
            return {
                metadata: {
                    columns: [],
                    objects: { general: content },
                }
            };
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var TooltipBuilder = powerbi.visuals.TooltipBuilder;
    var TooltipManager = powerbi.visuals.TooltipManager;
    var ValueType = powerbi.ValueType;
    var SVGUtil = powerbi.visuals.SVGUtil;
    describe("Tooltip", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('Tooltip instance created', function () {
            expect(TooltipManager.ToolTipInstance).toBeDefined();
        });
        it('Tooltip has localization options defined', function () {
            expect(powerbi.visuals.ToolTipComponent.localizationOptions).toBeDefined();
        });
    });
    describe("Tooltip DOM tests", function () {
        var element;
        var d3Element;
        var tooltipInfo;
        //var timerCallback: jasmine.Spy;
        beforeEach(function () {
            var localizationService = powerbi.common.createLocalizationService();
            powerbi.common.localize = localizationService;
            powerbitests.mocks.setLocale(localizationService);
            //timerCallback = jasmine.createSpy("timerCallback");
            //jasmine.clock().install();
            createDomElement();
        });
        afterEach(function () {
            //jasmine.clock().uninstall();
        });
        it('DOM container exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer.length).toBe(1);
        });
        it('Has single instance of DOM container', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer.length).toBe(1);
        });
        it('DOM two rows exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipRow = $('.tooltip-row');
            expect(tooltipRow.length).toBe(2);
        });
        it('DOM two title cells exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipTitle = $('.tooltip-title-cell');
            expect(tooltipTitle.length).toBe(2);
        });
        it('DOM two value cells exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipValue = $('.tooltip-value-cell');
            expect(tooltipValue.length).toBe(2);
        });
        it('DOM content container exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContentContainer = $('.tooltip-content-container');
            expect(tooltipContentContainer.length).toBe(1);
        });
        it('DOM container visible', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer).toBeVisible();
        });
        it('DOM container is visible - Show ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainerVisibility = $('.tooltip-container');
            expect(tooltipContainerVisibility).toBeVisible();
        });
        it('DOM container style Opacity is 1 - Show ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            var tooltipContainerOpacity = $('.tooltip-container').css('opacity');
            expect(tooltipContainerOpacity).toBeCloseTo(1, 2);
        });
        it('DOM container hiden - Hide ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            var tooltipContainer = $('.tooltip-container');
            var visibility = tooltipContainer.css("visibility");
            expect("hidden").toBe(visibility);
        });
        it('DOM container style Opacity is 1 - Hide ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            var tooltipContainerOpacity = $('.tooltip-container').css('opacity');
            expect(tooltipContainerOpacity).toBe('0');
        });
        it('DOM arrow exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            var arrow = tooltipContainer.find('.arrow');
            expect(arrow.length).toBe(1);
        });
        it('DOM arrow position test', function () {
            var clickedArea;
            // Set test screen size
            TooltipManager.ToolTipInstance.setTestScreenSize(1000, 700);
            // Show tooltip at top left of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var arrowClass;
            var tooltipContainer = $('.tooltip-container');
            var arrow = tooltipContainer.find('.arrow');
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow top left');
            // Hide
            hideTooltip();
            // Show tooltip at top right of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(600, 100, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow top right');
            // Hide
            hideTooltip();
            // Show tooltip at bottom left of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(300, 500, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow bottom left');
            // Hide
            hideTooltip();
            // Show tooltip at bottom right of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(700, 800, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow bottom right');
            // Hide
            hideTooltip();
            // Reset test screen size
            TooltipManager.ToolTipInstance.setTestScreenSize(null, null);
        });
        it("Should invoke mouseover event.", function () {
            var spyEvent = spyOnEvent('#item', 'mouseover');
            hideTooltip();
            emulateShowTooltip();
            expect('mouseover').toHaveBeenTriggeredOn('#item');
            expect(spyEvent).toHaveBeenTriggered();
        });
        it('tooltip is visible after 200ms', function (done) {
            hideTooltip();
            var tooltipEvent = getMockTooltipEvent();
            TooltipManager.showDelayedTooltip(tooltipEvent, getMockTooltipData, 500);
            setTimeout(function () {
                var visibility = getTooltipVisibility();
                expect(visibility).toEqual('hidden');
                done();
            }, 200);
        });
        it('tooltip is visible after 500ms', function (done) {
            hideTooltip();
            var tooltipEvent = getMockTooltipEvent();
            TooltipManager.showDelayedTooltip(tooltipEvent, getMockTooltipData, 500);
            setTimeout(function () {
                var visibility = getTooltipVisibility();
                expect(visibility).toEqual('visible');
                done();
            }, 513);
        });
        function getMockTooltipEvent() {
            return {
                data: null,
                index: 0,
                coordinates: [10, 10],
                elementCoordinates: [2, 2],
                context: this,
                isTouchEvent: false
            };
        }
        function getMockTooltipData(tooltipEvent) {
            return [
                { displayName: "test 1", value: "111" },
                { displayName: "test 2", value: "222" }
            ];
        }
        function emulateShowTooltip() {
            // Fire mouseover event
            var evt = document.createEvent("MouseEvents");
            evt.initMouseEvent("mouseover", true, true, window, 1, 2, 2, 2, 2, false, false, false, false, 0, null);
            d3Element.node().dispatchEvent(evt);
        }
        function getTooltipVisibility() {
            var tooltipContainer = $('.tooltip-container');
            return tooltipContainer.length > 0 ? tooltipContainer.css("visibility") : "hidden";
        }
        function hideTooltip() {
            TooltipManager.ToolTipInstance.hide();
            SVGUtil.flushAllD3Transitions();
        }
        function createDomElement() {
            if (element) {
                // remove existing one
                element.remove();
            }
            element = powerbitests.helpers.testDom('500', '500');
            d3Element = d3.select("#" + element.attr("id"));
            tooltipInfo = [
                { displayName: "test 1", value: "111" },
                { displayName: "test 2", value: "222" }
            ];
            TooltipManager.addTooltip(d3Element, getMockTooltipData);
        }
    });
    describe("Tooltip Builder tests", function () {
        it('createTooltipInfo: category & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                },
                {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true })
                },
            ];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
                powerbitests.mocks.dataViewScopeIdentity("ghi")
            ];
            var dataView = {
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                        source: columns[0],
                        values: ['abc', 'def', 'ghi'],
                        identity: categoryIdentities,
                        identityFields: [],
                    }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[1],
                            values: [123.321, 234.789, 456.001],
                        }
                    ])
                }
            };
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321, [{ value: 123.321, metadata: dataView.categorical.values[0] }], 0);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'val', value: '123.321' }
            ]);
        });
        it('createTooltipInfo: category, series & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                },
                {
                    displayName: 'ser',
                    type: ValueType.fromDescriptor({ text: true }),
                },
                {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true }),
                    groupName: 'ser1',
                },
            ];
            var dataView = {
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                        source: columns[0],
                        values: ['abc', 'def'],
                        identity: [powerbitests.mocks.dataViewScopeIdentity("abc"), powerbitests.mocks.dataViewScopeIdentity("def")],
                    }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[2],
                            values: [123, 234],
                            identity: powerbitests.mocks.dataViewScopeIdentity("ABC"),
                        },
                        {
                            source: columns[2],
                            values: [345, 456],
                            identity: powerbitests.mocks.dataViewScopeIdentity("DEF"),
                        }
                    ])
                }
            };
            dataView.categorical.values.source = columns[1];
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321, [{ value: 123.321, metadata: dataView.categorical.values[0] }], 0);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'ser', value: 'ser1' },
                { displayName: 'val', value: '123.321' }
            ]);
        });
        it('createTooltipInfo: self cross-joined category & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                },
                {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true })
                },
            ];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
                powerbitests.mocks.dataViewScopeIdentity("ghi")
            ];
            var dataView = powerbi.data.DataViewSelfCrossJoin.apply({
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                        source: columns[0],
                        values: ['abc', 'def', 'ghi'],
                        identity: categoryIdentities,
                        identityFields: [],
                    }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[1],
                            values: [123.321, 234.789, 456.001],
                        }
                    ])
                }
            });
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'val', value: '123.321' }
            ]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var CssConstants = jsCommon.CssConstants;
    var data = powerbi.data;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var DataViewAnalysis = powerbi.DataViewAnalysis;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var SemanticType = powerbi.data.SemanticType;
    var SQExprBuilder = powerbi.data.SQExprBuilder;
    var Treemap = powerbi.visuals.Treemap;
    var SelectionId = powerbi.visuals.SelectionId;
    var DefaultWaitForRender = 500;
    var dataViewMetadataCategorySeriesColumns = {
        columns: [
            { displayName: 'Squad', queryName: 'select0', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
            { displayName: 'Period', queryName: 'select1', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            { displayName: null, queryName: 'select2', groupName: '201501', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            { displayName: null, queryName: 'select2', groupName: '201502', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            { displayName: null, queryName: 'select2', groupName: '201503', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
        ]
    };
    var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Squad' });
    var seriesColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Period' });
    var dataViewMetadataCategoryColumn = {
        columns: [
            { displayName: 'Genre', queryName: 'select0', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
            { displayName: 'TotalSales', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
        ]
    };
    var dataViewMetadataCategoryColumnAndLongText = {
        columns: [
            { displayName: 'Category group', queryName: 'select0', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
            { displayName: 'Measure with long name', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            { displayName: 'Measure', queryName: 'select2', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
        ]
    };
    var dataViewMetadataCategoryAndMeasures = {
        columns: [
            { displayName: 'Area', queryName: 'select0', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
            { displayName: 'BugsFiled', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
            { displayName: 'BugsFixed', queryName: 'select2', isMeasure: true, properties: { "Values": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
        ]
    };
    describe("Treemap", function () {
        var categoryColumn = { displayName: 'year', queryName: 'select0', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', queryName: 'select1', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer) };
        it('Treemap registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').capabilities).toBe(powerbi.visuals.treemapCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.treemapCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.treemapCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should include objects', function () {
            expect(powerbi.visuals.treemapCapabilities.objects).toBeDefined();
        });
        it('Capabilities should include implicitSort', function () {
            expect(powerbi.visuals.treemapCapabilities.sorting.implicit).toBeDefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.treemapCapabilities.objects)).toEqual(powerbi.visuals.treemapProps.general.formatString);
        });
        it('preferred capability does not support zero rows', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }
                ],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: categoryColumn,
                        values: []
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: []
                    }]),
                }
            };
            expect(DataViewAnalysis.supports(dataView, powerbi.visuals.treemapCapabilities.dataViewMappings[0], true)).toBe(false);
        });
        it('preferred capability does not support one row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }
                ],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                        source: categoryColumn,
                        values: [2012, 2013]
                    }],
                    values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [200]
                    }]),
                }
            };
            expect(DataViewAnalysis.supports(dataView, powerbi.visuals.treemapCapabilities.dataViewMappings[0], true)).toBe(false);
        });
        it('Capabilities should only allow one measure if there are group and detail', function () {
            var allowedProjections = {
                'Group': [{ queryRef: '0' }],
                'Details': [{ queryRef: '1' }],
                'Values': [{ queryRef: '2' }]
            };
            var disallowedProjections1 = {
                'Group': [{ queryRef: '0' }],
                'Details': [{ queryRef: '1' }],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '3' }
                ]
            };
            var disallowedProjections2 = {
                'Group': [{ queryRef: '0' }],
                'Details': [{ queryRef: '1' }],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '3' },
                    { queryRef: '4' }
                ]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
        });
        it('Capabilities should only allow one measure if is a detail group', function () {
            var allowedProjections = {
                'Details': [{ queryRef: '1' }],
                'Values': [{ queryRef: '0' }]
            };
            var disallowedProjections = {
                'Details': [{ queryRef: '1' }],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '0' }
                ]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections, dataViewMappings)).toBe(null);
        });
        it('Capabilities should allow multiple measures if there is no detail group', function () {
            var allowedProjections1 = {
                'Group': [{ queryRef: '2' }],
                'Values': [
                    { queryRef: '1' },
                    { queryRef: '0' }
                ]
            };
            var allowedProjections2 = {
                'Group': [{ queryRef: '1' }],
                'Values': [
                    { queryRef: '2' },
                    { queryRef: '0' },
                    { queryRef: '3' }
                ]
            };
            var allowedProjections3 = {
                'Group': [{ queryRef: '1' }],
                'Values': [{ queryRef: '0' }]
            };
            var allowedProjections4 = {
                'Values': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should not allow multiple category groups', function () {
            var disallowedProjections1 = {
                'Group': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var disallowedProjections2 = {
                'Group': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ],
                'Values': [{ queryRef: '2' }]
            };
            var disallowedProjections3 = {
                'Group': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ],
                'Details': [{ queryRef: '2' }],
                'Values': [{ queryRef: '3' }]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections3, dataViewMappings)).toBe(null);
        });
        it('Capabilities should not allow multiple detail groups', function () {
            var disallowedProjections1 = {
                'Details': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]
            };
            var disallowedProjections2 = {
                'Details': [
                    { queryRef: '0' },
                    { queryRef: '1' }
                ],
                'Values': [{ queryRef: '2' }]
            };
            var disallowedProjections3 = {
                'Group': [{ queryRef: '0' }],
                'Details': [
                    { queryRef: '1' },
                    { queryRef: '2' }
                ],
                'Values': [{ queryRef: '3' }]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections3, dataViewMappings)).toBe(null);
        });
        it('Capabilities should allow one category and/or one detail groups', function () {
            var allowedProjections1 = {
                'Group': [{ queryRef: '0' }]
            };
            var allowedProjections2 = {
                'Detail': [{ queryRef: '0' }]
            };
            var allowedProjections3 = {
                'Group': [{ queryRef: '0' }],
                'Detail': [{ queryRef: '1' }]
            };
            var allowedProjections4 = {
                'Values': [{ queryRef: '0' }]
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
    });
    describe("treemap data labels validation", function () {
        var v, element;
        var hostServices;
        beforeEach(function () {
            hostServices = powerbitests.mocks.createVisualHostServices();
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('NaN in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([NaN, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Negative Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([Number.NEGATIVE_INFINITY, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Positive Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([Number.POSITIVE_INFINITY, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Out of range value in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([1e301, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, DefaultWaitForRender);
        });
        it('All okay in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([300, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, DefaultWaitForRender);
        });
        function getOptionsForValueWarnings(values) {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef]
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: values,
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            }
                        ], [seriesColumnRef])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            return dataChangedOptions;
        }
        it('labels should be visible by default', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef]
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ], [seriesColumnRef])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').css('opacity')).toBe('1');
                expect($('.treemap .labels .majorLabel').css('opacity')).toBe('1');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should be visible', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = { labels: { show: true } };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').css('opacity')).toBe('1');
                expect($('.treemap .labels .majorLabel').css('opacity')).toBe('1');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should be hidden', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = { labels: { show: false } };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').length).toEqual(0);
                expect($('.treemap .labels .majorLabel').length).toEqual(0);
                done();
            }, DefaultWaitForRender);
        });
        it('hidden labels with highlights dom validation', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = { labels: { show: false } };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("Drama"),
                powerbitests.mocks.dataViewScopeIdentity("Comedy"),
                powerbitests.mocks.dataViewScopeIdentity("Documentary"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['Drama', 'Comedy', 'Documentary'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[1],
                                values: [110, 120, 130],
                                highlights: [60, 80, 20]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.treemap .labels .majorLabel').length).toBe(0);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('labels color should changed from settings', function (done) {
            var colorRgb = 'rgb(120,110,100)';
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: {
                    color: { solid: { color: colorRgb } },
                    show: true,
                }
            };
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var minorActualColor = $('.treemap .labels .minorLabel').css('fill').replace(/\ /g, "");
                var majorActualColor = $('.treemap .labels .majorLabel').css('fill').replace(/\ /g, "");
                //convert the actual color to rgb format if target browser returns hex format
                minorActualColor = (minorActualColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(minorActualColor)) : minorActualColor;
                majorActualColor = (majorActualColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(majorActualColor)) : majorActualColor;
                expect(minorActualColor).toBe(colorRgb);
                expect(majorActualColor).toBe(colorRgb);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toEqual('The Nuthatches');
                expect(points[0].properties['fill']).toBeDefined();
                expect(points[1].displayName).toEqual('Skylarks');
                expect(points[1].properties['fill']).toBeDefined();
                done();
            }, DefaultWaitForRender);
        });
    });
    function treemapDomValidation(hasLegendObject) {
        var v, element;
        if (hasLegendObject) {
            dataViewMetadataCategorySeriesColumns.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadataCategorySeriesColumns.objects = undefined;
        }
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('treemap categories and series dom validation', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            dataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(dataChangedOptions);
            var renderLegend = dataViewMetadataCategorySeriesColumns.objects && dataViewMetadataCategorySeriesColumns.objects['legend'];
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Skylarks');
                expect($('.treemap .labels .minorLabel').length).toBe(6);
                expect($('.treemap .labels .minorLabel').last().text()).toBe('201503');
                if (renderLegend) {
                    expect($('.legend .item').length).toBe(2);
                    expect($('.legend .item').first().text()).toBe('The Nuthatches');
                    expect($('.legend .title').text()).toBe('Squad');
                }
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and series onDataChanged dom validation', function (done) {
            var initialDataViews = [{
                metadata: dataViewMetadataCategorySeriesColumns,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategorySeriesColumns.columns[0],
                        values: ['The Nuthatches', 'Skylarks'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[2],
                            values: [110, 120],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                        },
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[3],
                            values: [210, 220],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                        },
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[4],
                            values: [310, 320],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                        }
                    ])
                }
            }];
            initialDataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            var updatedMetadata = {
                columns: [
                    { displayName: 'Squad', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'Period', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '201503', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '201504', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var updatedDataViews = [{
                metadata: updatedMetadata,
                categorical: {
                    categories: [{
                        source: updatedMetadata.columns[0],
                        values: ['The Nuthatches', 'OddOneOut'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: updatedMetadata.columns[2],
                            values: [210, 220],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                        },
                        {
                            source: updatedMetadata.columns[3],
                            values: [310, 320],
                            identity: powerbitests.mocks.dataViewScopeIdentity('201504'),
                        }
                    ])
                }
            }];
            updatedDataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged({ dataViews: initialDataViews });
            var renderLegend = dataViewMetadataCategorySeriesColumns.objects && dataViewMetadataCategorySeriesColumns.objects['legend'];
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Skylarks');
                expect($('.treemap .labels .minorLabel').length).toBe(6);
                expect($('.treemap .labels .minorLabel').last().text()).toBe('201503');
                if (renderLegend) {
                    expect($('.legend .item').length).toBe(2);
                    expect($('.legend .item').first().text()).toBe('The Nuthatches');
                    expect($('.legend .item').last().text()).toBe('Skylarks');
                    expect($('.legend .title').text()).toBe('Squad');
                }
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(4);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').last().text()).toBe('OddOneOut');
                    expect($('.treemap .labels .minorLabel').length).toBe(4);
                    expect($('.treemap .labels .minorLabel').last().text()).toBe('201504');
                    if (renderLegend) {
                        expect($('.legend .item').first().text()).toBe('The Nuthatches');
                        expect($('.legend .item').last().text()).toBe('OddOneOut');
                        expect($('.legend .title').text()).toBe('Squad');
                    }
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and series onResize from small to medium tile dom validation', function (done) {
            var onDataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                            }
                        ])
                    }
                }]
            };
            onDataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(onDataChangedOptions);
            v.onResizing({
                height: 100,
                width: 200
            }, 0);
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .minorLabel').length).toBe(4);
                v.onResizing({ height: 300, width: 300 }, 0);
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .minorLabel').length).toBe(6);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryColumn.columns[0],
                            values: ['Drama', 'Comedy', 'Documentary'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [110, 120, 130]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure with highlights dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("Drama"),
                powerbitests.mocks.dataViewScopeIdentity("Comedy"),
                powerbitests.mocks.dataViewScopeIdentity("Documentary"),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryColumn.columns[0],
                            values: ['Drama', 'Comedy', 'Documentary'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [110, 120, 130],
                                highlights: [60, 80, 20]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(6);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure with overflowing highlights dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryColumn.columns[0],
                            values: ['Drama', 'Comedy', 'Documentary'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [110, 120, 130],
                                highlights: [140, 160, 135]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measures with highlights dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryAndMeasures,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryAndMeasures.columns[0],
                            values: ['Front end', 'Back end'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('f'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryAndMeasures.columns[1],
                                values: [110, 120],
                                highlights: [60, 60]
                            },
                            {
                                source: dataViewMetadataCategoryAndMeasures.columns[2],
                                values: [210, 220],
                                highlights: [140, 200]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(8);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(4);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Back end');
                expect($('.treemap .labels .minorLabel').length).toBe(4);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure onDataChanged dom validation', function (done) {
            var initialDataViews = [{
                metadata: dataViewMetadataCategoryColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategoryColumn.columns[0],
                        values: ['Drama', 'Comedy', 'Documentary'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                            powerbitests.mocks.dataViewScopeIdentity('c'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategoryColumn.columns[1],
                            values: [110, 120, 130]
                        }
                    ])
                }
            }];
            var updatedDataViews = [{
                metadata: dataViewMetadataCategoryColumn,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategoryColumn.columns[0],
                        values: ['Comedy', 'Documentary'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                            powerbitests.mocks.dataViewScopeIdentity('c'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategoryColumn.columns[1],
                            values: [120, 130]
                        }
                    ])
                }
            }];
            v.onDataChanged({ dataViews: initialDataViews });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').first().text()).toBe('Drama');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').first().text()).toBe('Comedy');
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure onResize from small to medium tile dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryColumn.columns[0],
                            values: ['Drama', 'Comedy', 'Documentary'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                                powerbitests.mocks.dataViewScopeIdentity('c'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [110, 120, 130]
                            }
                        ])
                    }
                }]
            });
            v.onResizing({
                height: 100,
                width: 200
            }, 0);
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onResizing({ height: 300, width: 300 }, 0);
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(3);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').length).toBe(3);
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap category and measure labeling validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryColumnAndLongText,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryColumnAndLongText.columns[0],
                            values: ['Very very long value'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumnAndLongText.columns[1],
                                values: [100]
                            },
                            {
                                source: dataViewMetadataCategoryColumnAndLongText.columns[2],
                                values: [100]
                            }
                        ])
                    }
                }]
            });
            v.onResizing({
                height: 12,
                width: 100
            }, 0);
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(1);
                expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                expect($('.treemap .labels .majorLabel').length).toBe(0);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onResizing({ height: 24, width: 100 }, 0);
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(1);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').length).toBe(1);
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                    v.onResizing({ height: 32, width: 200 }, 0);
                    setTimeout(function () {
                        expect($('.treemap .shapes .rootNode').length).toBe(1);
                        expect($('.treemap .shapes .parentGroup').length).toBe(1);
                        expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                        expect($('.treemap .labels .majorLabel').length).toBe(1);
                        expect($('.treemap .labels .minorLabel').length).toBe(0);
                        expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                        v.onResizing({ height: 64, width: 200 }, 0);
                        setTimeout(function () {
                            expect($('.treemap .shapes .rootNode').length).toBe(1);
                            expect($('.treemap .shapes .parentGroup').length).toBe(1);
                            expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                            expect($('.treemap .labels .majorLabel').length).toBe(1);
                            expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                            expect($('.treemap .labels .minorLabel').length).toBe(2);
                            expect($('.treemap .labels .minorLabel').first().text().length).toBeGreaterThan(0);
                            expect($('.treemap .labels .minorLabel').last().text().length).toBeGreaterThan(0);
                            done();
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        if (hasLegendObject) {
            it('legend formatting', function (done) {
                var dataView = {
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                };
                dataView.categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
                // Check legend should show, if show is undefined
                dataView.metadata.objects = { legend: {} };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.legendItem')).toBeInDOM();
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.legendItem')).toBeInDOM();
                        //change legend position
                        dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.legendItem')).toBeInDOM();
                            //set title
                            var testTitle = 'Test Title';
                            dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.legendItem')).toBeInDOM();
                                expect($('.legendTitle').text()).toBe(testTitle);
                                //hide legend
                                dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                                v.onDataChanged({
                                    dataViews: [dataView]
                                });
                                setTimeout(function () {
                                    expect($('.legendItem')).not.toBeInDOM();
                                    done();
                                }, DefaultWaitForRender);
                            }, DefaultWaitForRender);
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
        }
    }
    ;
    describe("Treemap DOM validation", function () { return treemapDomValidation(false); });
    describe("Treemap DOM validation - with legend", function () { return treemapDomValidation(true); });
    describe("treemap web animation", function () {
        var v, element;
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                heatMap: false,
            }).getPlugin('treemap').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('treemap highlight animation', function (done) {
            var noHighlightsDataViews = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            noHighlightsDataViews.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            var highlightsDataViewsA = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                highlights: [60, 70],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                highlights: [160, 170],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                highlights: [260, 270],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            highlightsDataViewsA.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            var highlightsDataViewsB = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['The Nuthatches', 'Skylarks'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                highlights: [20, 10],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                highlights: [120, 110],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                highlights: [220, 210],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }
                        ])
                    }
                }]
            };
            highlightsDataViewsB.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(noHighlightsDataViews);
            setTimeout(function () {
                var svgInit = $('.treemap');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(highlightsDataViewsA);
                v.onDataChanged(highlightsDataViewsB);
                v.onDataChanged(noHighlightsDataViews);
                expect(animator).toBeTruthy();
                expect(animator.animate).toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.treemap');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    });
    describe("treemap interactivity", function () {
        var v, element;
        var hostServices;
        var defaultOpacity = '';
        var dimmedOpacity = Treemap.DimmedShapeOpacity.toString();
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            hostServices = powerbitests.mocks.createVisualHostServices();
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        it('treemap categories and series - single select', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['A', 'B'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: seriesIdentities[0],
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: seriesIdentities[1],
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: seriesIdentities[2],
                            }
                        ])
                    }
                }]
            };
            onDataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select a major label
                $('.majorLabel').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                $('.majorLabel').first().d3Click(0, 0);
                // Select the first nested shape
                $('.nodeGroup').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0], seriesIdentities[0]]
                        }
                    ]
                });
                // Select the last minor label
                $('.minorLabel').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1], seriesIdentities[2]]
                        }
                    ]
                });
                $('.minorLabel').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({ data: [] });
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measures - single click on category node (parent shape must be selectable)', function (done) {
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('f'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            v.onDataChanged({
                dataViews: [{
                    metadata: dataViewMetadataCategoryAndMeasures,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategoryAndMeasures.columns[0],
                            values: ['Front end', 'Back end'],
                            identity: identities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryAndMeasures.columns[1],
                                values: [110, 120]
                            },
                            {
                                source: dataViewMetadataCategoryAndMeasures.columns[2],
                                values: [210, 220]
                            }
                        ])
                    }
                }]
            });
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                expect(shapes[0].style.fill).toBe(CssConstants.noneValue);
                expect(shapes[1].style.fill).toBe(CssConstants.noneValue);
                expect(nestedShapes[0].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[1].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[2].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[3].style.fill).not.toBe(CssConstants.noneValue);
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select the shape for the second category instance
                $('.parentGroup').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [identities[1]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        // Disabling due to changes in how we handle selection breaking the preservation of selection across data view changes.  Bug filed as #4904881
        /*it('treemap categories and series onDataChanged - single click on old and new shapes', (done) => {
            var categoryIdentities: powerbi.DataViewScopeIdentity[] = [
                mocks.dataViewScopeIdentity('a'),
                mocks.dataViewScopeIdentity('b'),
            ];

            var initialDataViews: DataView[] = [{
                metadata: dataViewMetadataCategorySeriesColumns,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategorySeriesColumns.columns[0],
                        values: ['A', 'B'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[2],
                            values: [110, 120],
                            identity: mocks.dataViewScopeIdentity('201501'),
                        }, {
                            source: dataViewMetadataCategorySeriesColumns.columns[3],
                            values: [210, 220],
                            identity: mocks.dataViewScopeIdentity('201502'),
                        }, {
                            source: dataViewMetadataCategorySeriesColumns.columns[4],
                            values: [310, 320],
                            identity: mocks.dataViewScopeIdentity('201503'),
                        }])
                }
            }];
            initialDataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            var updatedMetadata: powerbi.DataViewMetadata = {
                columns: [
                    { displayName: 'Squad', properties: { "Category": true }, type: DataShapeUtility.describeDataType(SemanticType.String) },
                    { displayName: 'Period', properties: { "Series": true }, type: DataShapeUtility.describeDataType(SemanticType.Number) },
                    { displayName: '201503', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(SemanticType.Number) },
                    { displayName: '201504', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(SemanticType.Number) }
                ]
            };
            var updatedDataViewsSeriesIdentities: powerbi.DataViewScopeIdentity[] = [
                mocks.dataViewScopeIdentity('201503'),
                mocks.dataViewScopeIdentity('201504'),
            ];
            var updatedDataViews: DataView[] = [{
                metadata: updatedMetadata,
                categorical: {
                    categories: [{
                        source: updatedMetadata.columns[0],
                        values: ['A', 'B'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: updatedMetadata.columns[2],
                            values: [210, 220],
                            identity: updatedDataViewsSeriesIdentities[0],
                        }, {
                            source: updatedMetadata.columns[3],
                            values: [310, 320],
                            identity: updatedDataViewsSeriesIdentities[1],
                        }])
                }
            }];
            updatedDataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];

            v.onDataChanged({ dataViews: initialDataViews });

            setTimeout(() => {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');

                spyOn(hostServices, 'onSelect').and.callThrough();

                // Make a selection
                (<any>$('.majorLabel')).first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);

                // Change data
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(() => {
                    shapes = $('.treemap .shapes .parentGroup');
                    nestedShapes = $('.treemap .shapes .nodeGroup');

                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);

                    // Select a new shape
                    (<any>$('.nodeGroup')).last().d3Click(0, 0);
                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                    expect(hostServices.onSelect).toHaveBeenCalledWith(
                        {
                            data: [categoryIdentities[1]]
                        });

                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        }); */
        it('treemap categories and series - selection across resize', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['A', 'B'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: seriesIdentities[0],
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: seriesIdentities[1],
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: seriesIdentities[2],
                            }
                        ])
                    }
                }]
            };
            onDataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select a major label
                $('.majorLabel').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                v.onResizing({ width: 300, height: 300 }, 0);
                setTimeout(function () {
                    // Select a major label
                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap external clear selection ', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataCategorySeriesColumns.columns[0],
                            values: ['A', 'B'],
                            identity: [
                                categoryIdentities[0],
                                categoryIdentities[1],
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: seriesIdentities[0]
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: seriesIdentities[1]
                            },
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: seriesIdentities[2]
                            }
                        ])
                    }
                }]
            };
            onDataChangedOptions.dataViews[0].categorical.values.source = dataViewMetadataCategorySeriesColumns.columns[1];
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                $('.nodeGroup').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0], seriesIdentities[0]]
                        }
                    ]
                });
                v.onClearSelection();
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("treemap converter validation", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
        });
        it('treemap dataView multi measure', function () {
            var metadata = {
                columns: [
                    {
                        displayName: 'EventCount',
                        queryName: 'EventCount',
                        isMeasure: true,
                        properties: { "Y": true },
                        type: DataShapeUtility.describeDataType(1 /* Number */),
                        objects: { dataPoint: { fill: { solid: { color: 'red' } } } }
                    },
                    {
                        displayName: 'MedalCount',
                        queryName: 'MedalCount',
                        isMeasure: true,
                        properties: { "Y": true },
                        type: DataShapeUtility.describeDataType(1 /* Number */)
                    }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        },
                        {
                            source: metadata.columns[1],
                            values: [210]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithMeasure("EventCount"),
                SelectionId.createWithMeasure("MedalCount"),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(2);
            expect(nodes[0].name).toBe('EventCount');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            expect(nodes[1].name).toBe('MedalCount');
            expect(nodes[1].size).toBe(210);
            expect(nodes[1].children).not.toBeDefined();
            expect(nodes[1].key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            expect(shapeColors[0]).toEqual('red');
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it('treemap dataView multi measure with null values', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'EventCount', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'MedalCount', queryName: 'MedalCount', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        },
                        {
                            source: metadata.columns[1],
                            values: [null]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithMeasure("EventCount"),
                SelectionId.createWithMeasure("MedalCount"),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(1);
            expect(nodes[0].name).toBe('EventCount');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it('treemap dataView multi category multi measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', queryName: 'select0', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'MedalCount', queryName: 'select2', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['Africa', 'Asia', 'Australia', 'Europe', 'North America'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(5);
            var node = nodes[0];
            expect(node.name).toBe('Africa');
            expect(node.size).toBe(320);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[0].getKey());
            node = nodes[1];
            expect(node.name).toBe('Asia');
            expect(node.size).toBe(340);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[1].getKey());
            node = nodes[2];
            expect(node.name).toBe('Australia');
            expect(node.size).toBe(360);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[2].getKey());
            node = nodes[3];
            expect(node.name).toBe('Europe');
            expect(node.size).toBe(380);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[3].getKey());
            node = nodes[4];
            expect(node.name).toBe('North America');
            expect(node.size).toBe(400);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[4].getKey());
            var childIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[4], 'select1'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[4], 'select2'),
            ];
            var childNode = node.children[0];
            expect(childNode.name).toBe('EventCount');
            expect(childNode.size).toBe(150);
            expect(childNode.children).not.toBeDefined();
            expect(childNode.key).toBe(childIds[0].getKey());
            expect(childNode.color).toBe(node.color);
            childNode = node.children[1];
            expect(childNode.name).toBe('MedalCount');
            expect(childNode.size).toBe(250);
            expect(childNode.children).not.toBeDefined();
            expect(childNode.key).toBe(childIds[1].getKey());
            expect(childNode.color).toBe(node.color);
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('Africa');
        });
        it('treemap dataView multi series one measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'Year', properties: { "Series": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'MedalCount', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['2004', '2008', '2012'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithId(categoryIdentities[0]),
                SelectionId.createWithId(categoryIdentities[2]),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(3);
            expect(nodes[0].name).toBe('2004');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            expect(nodes[2].name).toBe('2012');
            expect(nodes[2].size).toBe(130);
            expect(nodes[2].children).not.toBeDefined();
            expect(nodes[2].key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Year');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('2004');
        });
        it('treemap dataView multi category/series', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'Year', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: ['Africa', 'Asia', 'Australia', 'Europe', 'North America'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [110, 120, 130, 140, 150],
                            identity: seriesIdentities[0],
                        },
                        {
                            source: metadata.columns[3],
                            values: [210, 220, 230, 240, 250],
                            identity: seriesIdentities[1],
                        },
                        {
                            source: metadata.columns[4],
                            values: [310, 320, 330, 340, 350],
                            identity: seriesIdentities[2],
                        }
                    ])
                }
            };
            dataView.categorical.values.source = metadata.columns[1];
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithId(categoryIdentities[0]),
                SelectionId.createWithId(categoryIdentities[4]),
                SelectionId.createWithIds(categoryIdentities[4], seriesIdentities[2]),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(5);
            expect(nodes[0].name).toBe('Africa');
            expect(nodes[0].size).toBe(630);
            expect(nodes[0].children).toBeDefined();
            expect(nodes[0].children.length).toBe(3);
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            var lastNode = nodes[4];
            expect(lastNode.name).toBe('North America');
            expect(lastNode.size).toBe(750);
            expect(lastNode.children).toBeDefined();
            expect(lastNode.children.length).toBe(3);
            expect(lastNode.key).toBe(selectionIds[1].getKey());
            var childNodes = lastNode.children;
            expect(childNodes[2].name).toBe('2012');
            expect(childNodes[2].size).toBe(350);
            expect(childNodes[2].children).not.toBeDefined();
            expect(childNodes[2].key).toBe(selectionIds[2].getKey());
            childNodes.forEach(function (n) { return expect(n.color).toBe(lastNode.color); });
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('Africa');
        });
        it('treemap dataView multi category/series with null values', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'Year', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: [null, 'Asia', 'Australia', 'Europe', 'North America'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [null, 120, 130, 140, null],
                            identity: seriesIdentities[0],
                        },
                        {
                            source: metadata.columns[3],
                            values: [210, 220, null, 240, null],
                            identity: seriesIdentities[1],
                        },
                        {
                            source: metadata.columns[4],
                            values: [null, 320, 330, 340, null],
                            identity: seriesIdentities[2],
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var nodes = rootNode.children;
            expect(nodes.length).toBe(4);
            expect(nodes[0].name).toBe('(Blank)');
            expect(nodes[0].size).toBe(210);
            expect(nodes[0].children).toBeDefined();
            expect(nodes[0].children.length).toBe(1);
            expect(nodes[0].key).toBe(SelectionId.createWithId(categoryIdentities[0]).getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('(Blank)');
            expect(treeMapData.legendData.dataPoints[1].label).toBe('Asia');
        });
        it('treemap dataView multi category/series with null values tooltip data test', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: DataShapeUtility.describeDataType(2048 /* String */) },
                    { displayName: 'Year', properties: { "Series": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                        source: metadata.columns[0],
                        values: [null, 'Asia', 'Australia', 'Europe', 'North America'],
                        identity: categoryIdentities,
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [null, 120, 130, 140, null],
                            identity: seriesIdentities[0],
                        },
                        {
                            source: metadata.columns[3],
                            values: [210, 220, null, 240, null],
                            identity: seriesIdentities[1],
                        },
                        {
                            source: metadata.columns[4],
                            values: [null, 320, 330, 340, null],
                            identity: seriesIdentities[2],
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null).root;
            var node1 = rootNode.children[0];
            var node11 = rootNode.children[0].children[0];
            var node2 = rootNode.children[1];
            var node3 = rootNode.children[2];
            var node4 = rootNode.children[3];
            expect(node1.tooltipInfo).toEqual([{ displayName: "Continent", value: "(Blank)" }]);
            expect(node11.tooltipInfo).toEqual([{ displayName: "Continent", value: "(Blank)" }, { displayName: null, value: "210" }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: "Continent", value: "Asia" }, { displayName: null, value: "120" }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: "Continent", value: "Australia" }, { displayName: null, value: "130" }]);
            expect(node4.tooltipInfo).toEqual([{ displayName: "Continent", value: "Europe" }, { displayName: null, value: "140" }]);
        });
        it('treemap non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', isMeasure: true },
                    { displayName: 'b', isMeasure: true },
                    { displayName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3],
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null).root;
            var node1 = rootNode.children[0];
            var node2 = rootNode.children[1];
            var node3 = rootNode.children[2];
            expect(node1.tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
        it('treemap dataView multi measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) },
                    { displayName: 'MedalCount', queryName: 'select2', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        },
                        {
                            source: metadata.columns[1],
                            values: [210]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = metadata.columns.map(function (measure) { return SelectionId.createWithMeasure(measure.queryName); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(2);
            var node = nodes[0];
            expect(node.name).toBe('EventCount');
            expect(node.size).toBe(110);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[0].getKey());
            node = nodes[1];
            expect(node.name).toBe('MedalCount');
            expect(node.size).toBe(210);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
            expect(treeMapData.legendData.dataPoints[1].label).toBe('MedalCount');
        });
        it('treemap dataView single measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: DataShapeUtility.describeDataType(1 /* Number */) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110],
                        }
                    ]),
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null);
            var rootNode = treeMapData.root;
            var selectionIds = metadata.columns.map(function (measure) { return SelectionId.createWithMeasure(measure.queryName); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(1);
            var node = nodes[0];
            expect(node.name).toBe('EventCount');
            expect(node.size).toBe(110);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[0].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it("treemap categories and measures with highlights tooltip data test", function () {
            var dataView = {
                metadata: dataViewMetadataCategoryAndMeasures,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategoryAndMeasures.columns[0],
                        values: ['Front end', 'Back end'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('f'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ],
                        identityFields: [categoryColumnRef],
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategoryAndMeasures.columns[1],
                            values: [110, 120],
                            highlights: [60, 60]
                        },
                        {
                            source: dataViewMetadataCategoryAndMeasures.columns[2],
                            values: [210, 220],
                            highlights: [140, 200]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null).root;
            var node1 = rootNode.children[0].children[0];
            var node2 = rootNode.children[0].children[1];
            var node3 = rootNode.children[1].children[0];
            var node4 = rootNode.children[1].children[1];
            expect(node1.tooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFiled", value: "110" }]);
            expect(node1.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFiled", value: "110" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "60" }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFixed", value: "210" }]);
            expect(node2.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFixed", value: "210" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFiled", value: "120" }]);
            expect(node3.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFiled", value: "120" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "60" }]);
            expect(node4.tooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFixed", value: "220" }]);
            expect(node4.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFixed", value: "220" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "200" }]);
        });
        it("treemap gradient color test", function () {
            var dataPointColors = ["#d9f2fb", "#ff557f", "#b1eab7"];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: dataPointColors[0] } } } },
                { dataPoint: { fill: { solid: { color: dataPointColors[1] } } } },
                { dataPoint: { fill: { solid: { color: dataPointColors[2] } } } }
            ];
            var dataViewGradientMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var dataView = {
                metadata: dataViewGradientMetadata,
                categorical: {
                    categories: [{
                        source: dataViewGradientMetadata.columns[0],
                        values: ['Front end', 'Back end'],
                        objects: objectDefinitions,
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('f'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ]
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewGradientMetadata.columns[1],
                            values: [110, 120],
                            highlights: [60, 60]
                        },
                        {
                            source: dataViewGradientMetadata.columns[2],
                            values: [210, 220],
                            highlights: [140, 200]
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null, null).root;
            var node1 = rootNode.children[0];
            var node2 = rootNode.children[1];
            expect(node1.color).toEqual(dataPointColors[0]);
            expect(node2.color).toEqual(dataPointColors[1]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
describe("VisualFactory", function () {
    var mockVisualKey = 'mock';
    var mockFactoryMethod;
    beforeEach(function () {
        mockFactoryMethod = function () {
            return {};
        };
        var plugin = {
            name: mockVisualKey,
            capabilities: {},
            create: mockFactoryMethod
        };
        powerbi.visuals.plugins[mockVisualKey] = plugin;
    });
    afterEach(function () {
        delete powerbi.visuals.plugins[mockVisualKey];
    });
    it('getPlugin finds mock', function () {
        var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin(mockVisualKey);
        expect(plugin).toBe(powerbi.visuals.plugins[mockVisualKey]);
    });
    it('getRegisteredVisuals includes test', function () {
        var registered = powerbi.visuals.visualPluginFactory.create().getVisuals().filter(function (v) { return v.name === mockVisualKey; });
        expect(registered).toEqual([powerbi.visuals.plugins[mockVisualKey]]);
    });
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbitests;
(function (powerbitests) {
    var WaterfallChart = powerbi.visuals.WaterfallChart;
    var DataShapeUtility = powerbi.data.dsr.DataShapeUtility;
    var SemanticType = powerbi.data.SemanticType;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var DefaultWaitForRender = 10;
    describe('WaterfallChart', function () {
        var localizationService = powerbi.common.createLocalizationService();
        powerbi.common.localize = localizationService;
        powerbitests.mocks.setLocale(localizationService);
        var viewport = {
            height: 500,
            width: 500,
        };
        var cartesianHost = {
            updateLegend: function (data) { return dummyDrawLegend(data, viewport); },
        };
        var svg = d3.select($('<svg/>').get(0));
        var style = powerbi.visuals.visualStyles.create();
        var initOptions = {
            element: powerbitests.helpers.testDom('500', '500'),
            host: powerbitests.mocks.createVisualHostServices(),
            style: style,
            viewport: viewport,
            //settings:,
            //animation:,
            //interactivity:,
            svg: svg,
            cartesianHost: cartesianHost,
        };
        var categoryColumn = { displayName: 'year', type: DataShapeUtility.describeDataType(2048 /* String */) };
        var measureColumn = { displayName: 'sales', isMeasure: true, type: DataShapeUtility.describeDataType(SemanticType.Integer), objects: { general: { formatString: '$0' } } };
        var colors = style.colorPalette.dataColors;
        describe('axes', function () {
            var hostServices;
            var v;
            beforeEach(function () {
                var element = powerbitests.helpers.testDom('500', '500');
                hostServices = powerbitests.mocks.createVisualHostServices();
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    interactivity: { isInteractiveLegend: false },
                    animation: { transitionImmediate: true },
                });
            });
            function getDataViewFromValues(values) {
                var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
                var dataViewMetadataOneColumn = {
                    columns: [
                        {
                            displayName: 'AxesTitleTest',
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        }
                    ],
                    objects: {
                        categoryAxis: {
                            showAxisTitle: true
                        },
                        valueAxis: {
                            showAxisTitle: true
                        }
                    }
                };
                var dataView = {
                    metadata: dataViewMetadataOneColumn,
                    categorical: {
                        categories: [{
                            source: dataViewMetadataOneColumn.columns[0],
                            values: [500, 2000, 5000, 10000],
                            identity: categoryIdentities
                        }],
                        values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataOneColumn.columns[0],
                            values: values,
                            subtotal: 1020
                        }])
                    }
                };
                return dataView;
            }
            it('NaN in values shows a warning', function () {
                var dataView = getDataViewFromValues([200, NaN]);
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
            });
            it('Negative Infinity in values shows a warning', function () {
                var dataView = getDataViewFromValues([200, Number.NEGATIVE_INFINITY]);
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
            });
            it('Postive Infinity in values shows a warning', function () {
                var dataView = getDataViewFromValues([200, Number.POSITIVE_INFINITY]);
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
            });
            it('Value out of range in values shows a warning', function () {
                var dataView = getDataViewFromValues([200, -1e301]);
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
            });
            it('All okay in values shows a warning', function () {
                var dataView = getDataViewFromValues([200, 300]);
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).not.toHaveBeenCalled();
            });
            it('Waterfall Chart X and Y-axis show/hide Title ', function () {
                var element = powerbitests.helpers.testDom('500', '500');
                var hostServices = powerbitests.mocks.createVisualHostServices();
                var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
                var v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    interactivity: { isInteractiveLegend: false },
                    animation: { transitionImmediate: true },
                });
                var dataViewMetadataOneColumn = {
                    columns: [
                        {
                            displayName: 'AxesTitleTest',
                            type: DataShapeUtility.describeDataType(1 /* Number */)
                        }
                    ],
                    objects: {
                        categoryAxis: {
                            showAxisTitle: true
                        },
                        valueAxis: {
                            showAxisTitle: true
                        }
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataOneColumn,
                        categorical: {
                            categories: [{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [500, 2000, 5000, 10000],
                                identity: categoryIdentities
                            }],
                            values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [20, 1000],
                                subtotal: 1020
                            }])
                        }
                    }]
                });
                expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
                expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
                dataViewMetadataOneColumn.objects = {
                    categoryAxis: {
                        showAxisTitle: false
                    },
                    valueAxis: {
                        showAxisTitle: false
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                        metadata: dataViewMetadataOneColumn,
                    }]
                });
                expect($('.xAxisLabel').length).toBe(0);
                expect($('.yAxisLabel').length).toBe(0);
            });
        });
        describe('capabilities', function () {
            it('should include dataViewMappings', function () {
                expect(powerbi.visuals.waterfallChartCapabilities.dataViewMappings).toBeDefined();
            });
            it('should include dataRoles', function () {
                expect(powerbi.visuals.waterfallChartCapabilities.dataRoles).toBeDefined();
            });
            it('should not support highlight', function () {
                expect(powerbi.visuals.waterfallChartCapabilities.supportsHighlight).toBeUndefined();
            });
            it('FormatString property should match calculated', function () {
                expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.waterfallChartCapabilities.objects)).toEqual(WaterfallChart.formatStringProp);
            });
            it('should register capabilities', function () {
                var pluginFactory = powerbi.visuals.visualPluginFactory.create();
                var plugin = pluginFactory.getPlugin('waterfallChart');
                expect(plugin).toBeDefined();
                expect(plugin.capabilities).toBe(powerbi.visuals.waterfallChartCapabilities);
            });
        });
        describe('data converter', function () {
            var colors = style.colorPalette.dataColors;
            var values = [100, -200, 250];
            var positions = [0, 100, -100, 0]; // The last position represents the total and is always 0.
            var categories = [2010, 2011, 2012];
            var posMax = 150;
            var posMin = -100;
            var total = 150;
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: categories,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }])
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var sentimentColors = {
                increaseFill: {
                    solid: { color: "#FF0000" }
                },
                decreaseFill: {
                    solid: { color: "#00FF00" }
                },
                totalFill: {
                    solid: { color: "#0000FF" }
                },
            };
            var data = WaterfallChart.converter(dataView, colors, initOptions.host, dataLabelSettings, sentimentColors, null, null);
            var dataPoints = data.series[0].data;
            it('legend should have 3 items', function () {
                expect(data.legend.dataPoints.length).toBe(3); // Gain, Loss, Total
            });
            it('has correct positions', function () {
                expect(dataPoints.map(function (d) { return d.position; })).toEqual(positions);
                expect(data.positionMin).toBe(posMin);
                expect(data.positionMax).toBe(posMax);
            });
            it('has correct values', function () {
                expect(dataPoints.map(function (d) { return d.value; })).toEqual(values.concat(total));
                expect(data.positionMin).toBe(posMin);
                expect(data.positionMax).toBe(posMax);
            });
            it('gain/loss colors match legend', function () {
                var gainLegend = data.legend.dataPoints[0];
                var lossLegend = data.legend.dataPoints[1];
                expect(dataPoints[0].color).toBe(gainLegend.color); // first value is a gain
                expect(dataPoints[1].color).toBe(lossLegend.color); // second value is a loss
            });
            it('should have no highlights', function () {
                expect(dataPoints.some(function (d) { return d.highlight; })).toBe(false);
                expect(data.hasHighlights).toBe(false);
            });
            it('should have no selected data points', function () {
                expect(dataPoints.some(function (d) { return d.selected; })).toBe(false);
            });
            it('tooltip data', function () {
                expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'year', value: '2010' }, { displayName: 'sales', value: '$100' }]);
                expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'year', value: '2011' }, { displayName: 'sales', value: '-$200' }]);
                expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'year', value: '2012' }, { displayName: 'sales', value: '$250' }]);
                expect(dataPoints[3].tooltipInfo).toEqual([{ displayName: 'year', value: 'Waterfall_TotalLabel' }, { displayName: 'sales', value: '$150' }]);
            });
        });
        describe('setData', function () {
            var values = [100, -200, 250];
            var categories = [2010, 2011, 2012];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: categories,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }]),
            };
            var sentimentColors = colors.getSentimentColors();
            var gainFillHex = sentimentColors[2].value;
            var lossFillHex = sentimentColors[0].value;
            var metadata = {
                columns: [categoryColumn, measureColumn]
            };
            var data = {
                categorical: dataView,
                metadata: metadata,
            };
            var chart;
            beforeEach(function () {
                chart = new WaterfallChart({ isScrollable: false });
                chart.init(initOptions);
            });
            it('sentiment colors should be set from data object', function () {
                data.metadata.objects = {
                    sentimentColors: {
                        increseFill: { solid: { color: gainFillHex } },
                        decreaseFill: { solid: { color: lossFillHex } }
                    }
                };
                chart.setData([data]);
                var legendData = chart.calculateLegend();
                expect(legendData.dataPoints[0].color).toBe(gainFillHex);
                expect(legendData.dataPoints[1].color).toBe(lossFillHex);
            });
            it('should clear data if passed empty array', function () {
                chart.setData([data]);
                expect(chart.calculateLegend().dataPoints.length).not.toBe(0);
                chart.setData([]);
                expect(chart.calculateLegend().dataPoints.length).toBe(0);
            });
        });
        describe("Scrollbar", function () {
            var v, element;
            var values = [500000, 495000, 490000, 480000, 500000, 500000, 500000, 500000, 500000];
            var categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: categories,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }]),
            };
            var metadata = {
                columns: [categoryColumn, measureColumn]
            };
            var data = {
                categorical: dataView,
                metadata: metadata,
            };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('150', '50');
                v = powerbi.visuals.visualPluginFactory.createMinerva({
                    heatMap: false,
                    scrollableVisuals: true,
                }).getPlugin('waterfallChart').create();
                v.init({
                    element: element,
                    host: powerbitests.mocks.createVisualHostServices(),
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    svg: svg,
                    cartesianHost: cartesianHost,
                });
                v.onDataChanged({
                    dataViews: [data]
                });
            });
            it('DOM Validation', function (done) {
                setTimeout(function () {
                    expect($('.waterfallChart')).toBeInDOM();
                    expect($('rect.extent').length).toBe(1);
                    var transform = $('.waterfallChart .axisGraphicsContext .x.axis .tick').last().attr('transform');
                    var xTranslate = SVGUtil.parseTranslateTransform(transform).x;
                    var brushTransform = SVGUtil.parseTranslateTransform($('.brush').first().attr('transform'));
                    expect(xTranslate).toBeLessThan(element.width());
                    expect(brushTransform.x).toBe('19');
                    expect(brushTransform.y).toBe('116');
                    expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(1);
                    expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                    done();
                }, DefaultWaitForRender);
            });
            it('Tooltip Data Validation', function () {
                var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
                var gainFillHex = "#FF0000";
                var lossFillHex = "#00FF00";
                var totalFillHex = "#0000FF";
                var sentimentColors = {
                    increaseFill: { solid: { color: gainFillHex } },
                    decreaseFill: { solid: { color: lossFillHex } },
                    totalFill: { solid: { color: totalFillHex } }
                };
                var data = WaterfallChart.converter(dataView, colors, initOptions.host, dataLabelSettings, sentimentColors, null, null);
                var dataPoints = data.series[0].data;
                expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'year', value: 'a' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'year', value: 'b' }, { displayName: 'sales', value: '$495000' }]);
                expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'year', value: 'c' }, { displayName: 'sales', value: '$490000' }]);
                expect(dataPoints[3].tooltipInfo).toEqual([{ displayName: 'year', value: 'd' }, { displayName: 'sales', value: '$480000' }]);
                expect(dataPoints[4].tooltipInfo).toEqual([{ displayName: 'year', value: 'e' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[5].tooltipInfo).toEqual([{ displayName: 'year', value: 'f' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[6].tooltipInfo).toEqual([{ displayName: 'year', value: 'g' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[7].tooltipInfo).toEqual([{ displayName: 'year', value: 'h' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[8].tooltipInfo).toEqual([{ displayName: 'year', value: 'i' }, { displayName: 'sales', value: '$500000' }]);
                expect(dataPoints[9].tooltipInfo).toEqual([{ displayName: 'year', value: 'Waterfall_TotalLabel' }, { displayName: 'sales', value: '$4465000' }]);
            });
        });
        describe("data labels validation", function () {
            var v, element;
            ;
            var values = [100, -200, 250];
            var categories = [2010, 2011, 2012];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2010"),
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: categories,
                    identity: categoryIdentities,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }]),
            };
            var metadata = {
                columns: [categoryColumn, measureColumn],
            };
            var data = {
                categorical: dataView,
                metadata: metadata,
            };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
                v.init({
                    element: element,
                    host: powerbitests.mocks.createVisualHostServices(),
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
            });
            it('verify labels in DOM', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: true,
                        labelPrecision: 0,
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    expect($('.dataLabelsSVG text')).toBeInDOM();
                    expect($('.dataLabelsSVG text').first().text()).toBe(values[0].toString());
                    // Two last labels are hidden due to collision detection
                    expect($('.dataLabelsSVG text').last().text()).toBe(values[1].toString());
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should be visible', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: true,
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    // Two last labels are hidden due to collision detection
                    expect($('.dataLabelsSVG text').length).toBe(2);
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should be hidden', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: false,
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    expect($('.dataLabelsSVG text').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should support display units with no precision', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: true,
                        labelDisplayUnits: 1000,
                        labelPrecision: 0
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    expect($('.dataLabelsSVG text').first().text()).toBe('0K');
                    done();
                }, DefaultWaitForRender);
            });
            it('labels should support display units with precision', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: true,
                        labelDisplayUnits: 1000,
                        labelPrecision: 1
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    expect($('.dataLabelsSVG text').first().text()).toBe('0.1K');
                    done();
                }, DefaultWaitForRender);
            });
            it('label color should be overriden', function (done) {
                var expectedColor = 'rgb(80,90,100)';
                data.metadata.objects = {
                    labels: {
                        show: true,
                        color: { solid: { color: expectedColor } }
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    var actualColor = $('.dataLabelsSVG text').css('fill').replace(/\ /g, "");
                    actualColor = (actualColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(actualColor)) : actualColor;
                    expect(actualColor).toBe(expectedColor);
                    done();
                }, DefaultWaitForRender);
            });
            it('label color should be same as rect color', function (done) {
                data.metadata.objects = {
                    labels: {
                        show: true,
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    var rects = $('rect.column');
                    var texts = $('.mainGraphicsContext text');
                    for (var i = 0, len = texts.length; i < len; i++) {
                        var rectColor = $(rects[i]).css('fill').replace(/\ /g, "");
                        var textColor = $(texts[i]).css('fill').replace(/\ /g, "");
                        expect(rectColor).toBe(textColor);
                    }
                    done();
                }, DefaultWaitForRender);
            });
            it('labels color should be same as sentiments color', function (done) {
                var totalSentimentColor = 'rgb(1,2,3)';
                var increaseSentimentColors = 'rgb(4,5,6)';
                var decreaseSentimentColors = 'rgb(7,8,9)';
                data.metadata.objects = {
                    labels: {
                        show: true,
                    },
                    sentimentColors: {
                        totalFill: { solid: { color: totalSentimentColor } },
                        increaseFill: { solid: { color: increaseSentimentColors } },
                        decreaseFill: { solid: { color: decreaseSentimentColors } },
                    }
                };
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                setTimeout(function () {
                    var texts = $('.dataLabelsSVG text');
                    var increaseTextColor = texts.first().css('fill').replace(/\ /g, "");
                    var decreaseTextColor = $(texts[1]).css('fill').replace(/\ /g, "");
                    var rgbIncreaseTextColor = (increaseTextColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(increaseTextColor)) : increaseTextColor;
                    var rgbDecreaseTextColor = (decreaseTextColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(decreaseTextColor)) : decreaseTextColor;
                    expect(rgbIncreaseTextColor).toBe(increaseSentimentColors);
                    expect(rgbDecreaseTextColor).toBe(decreaseSentimentColors);
                    done();
                }, DefaultWaitForRender);
            });
        });
        describe("Enumerate Objects", function () {
            var v, element;
            ;
            var values = [100, -200, 250];
            var categories = [2010, 2011, 2012];
            var dataView = {
                categories: [{
                    source: categoryColumn,
                    values: categories,
                }],
                values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }]),
            };
            var metadata = {
                columns: [categoryColumn, measureColumn],
            };
            var data = {
                categorical: dataView,
                metadata: metadata,
            };
            beforeEach(function () {
                powerbitests.mocks.setLocale(powerbi.common.createLocalizationService());
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
                v.init({
                    element: element,
                    host: powerbitests.mocks.createVisualHostServices(),
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
            });
            it('enumerateObjectInstances should include labels with empty data', function () {
                v.onDataChanged({ dataViews: [] });
                verifyLabels();
            });
            it('enumerateObjectInstances should include labels', function () {
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                verifyLabels();
            });
            it('enumerateObjectInstances should include sentiment colors with empty data', function () {
                v.onDataChanged({ dataViews: [] });
                verifyColors();
            });
            it('enumerateObjectInstances should include sentiment colors', function () {
                var dataChangedOptions = {
                    dataViews: [data]
                };
                v.onDataChanged(dataChangedOptions);
                verifyColors();
            });
            function verifyColors() {
                var points = v.enumerateObjectInstances({ objectName: 'sentimentColors' });
                expect(points.length).toBe(1);
                expect(points[0].properties['increaseFill']).toBeDefined();
                expect(points[0].properties['decreaseFill']).toBeDefined();
                expect(points[0].properties['totalFill']).toBeDefined();
            }
            ;
            function verifyLabels() {
                var points = v.enumerateObjectInstances({ objectName: 'labels' });
                var defaultLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
                expect(points.length).toBe(1);
                expect(points[0].properties).toBeDefined();
                var properties = points[0].properties;
                expect(properties['color']).toBe(defaultLabelSettings.labelColor);
                expect(properties['show']).toBe(false);
                expect(properties['labelPrecision']).toBe(defaultLabelSettings.precision);
                expect(properties['labelDisplayUnits']).toBe(defaultLabelSettings.displayUnits);
            }
        });
        // TODO: add DOM tests when the visual matches the spec.
    });
    function dummyDrawLegend(data, viewport) {
    }
})(powerbitests || (powerbitests = {}));
//# sourceMappingURL=PowerBIVisualsTests.js.map